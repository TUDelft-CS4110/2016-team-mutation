<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>NetUtils.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">cloud-core (18-mrt-2016 13:14:54)</a> &gt; <a href="../../index.html" class="el_group">cloud-utils</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">com.cloud.utils.net</a> &gt; <span class="el_source">NetUtils.java</span></div><h1>NetUtils.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">//</span>
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// &quot;License&quot;); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//

package com.cloud.utils.net;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.InterfaceAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.URI;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Formatter;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.SortedSet;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.SystemUtils;
import org.apache.commons.net.util.SubnetUtils;
import org.apache.commons.validator.routines.InetAddressValidator;
import org.apache.log4j.Logger;

import com.cloud.utils.IteratorUtil;
import com.cloud.utils.Pair;
import com.cloud.utils.exception.CloudRuntimeException;
import com.cloud.utils.script.Script;
import com.googlecode.ipv6.IPv6Address;
import com.googlecode.ipv6.IPv6AddressRange;
import com.googlecode.ipv6.IPv6Network;

<span class="pc bpc" id="L57" title="1 of 2 branches missed.">public class NetUtils {</span>
<span class="fc" id="L58">    protected final static Logger s_logger = Logger.getLogger(NetUtils.class);</span>

    private static final int MAX_CIDR = 32;
    private static final int RFC_3021_31_BIT_CIDR = 31;

    public final static String HTTP_PORT = &quot;80&quot;;
    public final static String HTTPS_PORT = &quot;443&quot;;
    public final static int VPN_PORT = 500;
    public final static int VPN_NATT_PORT = 4500;
    public final static int VPN_L2TP_PORT = 1701;
    public final static int HAPROXY_STATS_PORT = 8081;

    public final static String UDP_PROTO = &quot;udp&quot;;
    public final static String TCP_PROTO = &quot;tcp&quot;;
    public final static String ANY_PROTO = &quot;any&quot;;
    public final static String ICMP_PROTO = &quot;icmp&quot;;
    public final static String ALL_PROTO = &quot;all&quot;;
    public final static String HTTP_PROTO = &quot;http&quot;;
    public final static String SSL_PROTO = &quot;ssl&quot;;

    public final static String ALL_CIDRS = &quot;0.0.0.0/0&quot;;
    public final static int PORT_RANGE_MIN = 0;
    public final static int PORT_RANGE_MAX = 65535;

    public final static int DEFAULT_AUTOSCALE_VM_DESTROY_TIME = 2 * 60; // Grace period before Vm is destroyed
    public final static int DEFAULT_AUTOSCALE_POLICY_INTERVAL_TIME = 30;
    public final static int DEFAULT_AUTOSCALE_POLICY_QUIET_TIME = 5 * 60;
<span class="fc" id="L85">    private final static Random s_rand = new Random(System.currentTimeMillis());</span>

    public static long createSequenceBasedMacAddress(final long macAddress) {
<span class="nc" id="L88">        return macAddress | 0x060000000000l | (long)s_rand.nextInt(32768) &lt;&lt; 25 &amp; 0x00fffe000000l;</span>
    }

    public static String getHostName() {
        try {
<span class="nc" id="L93">            final InetAddress localAddr = InetAddress.getLocalHost();</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">            if (localAddr != null) {</span>
<span class="nc" id="L95">                return localAddr.getHostName();</span>
            }
<span class="nc" id="L97">        } catch (final UnknownHostException e) {</span>
<span class="nc" id="L98">            s_logger.warn(&quot;UnknownHostException when trying to get host name. &quot;, e);</span>
        }
<span class="nc" id="L100">        return &quot;localhost&quot;;</span>
    }

    public static InetAddress getLocalInetAddress() {
        try {
<span class="nc" id="L105">            return InetAddress.getLocalHost();</span>
<span class="nc" id="L106">        } catch (final UnknownHostException e) {</span>
<span class="nc" id="L107">            s_logger.warn(&quot;UnknownHostException in getLocalInetAddress().&quot;, e);</span>
<span class="nc" id="L108">            return null;</span>
        }
    }

    public static String resolveToIp(final String host) {
        try {
<span class="nc" id="L114">            final InetAddress addr = InetAddress.getByName(host);</span>
<span class="nc" id="L115">            return ipFromInetAddress(addr);</span>
<span class="nc" id="L116">        } catch (final UnknownHostException e) {</span>
<span class="nc" id="L117">            s_logger.warn(&quot;Unable to resolve &quot; + host + &quot; to IP due to UnknownHostException&quot;);</span>
<span class="nc" id="L118">            return null;</span>
        }
    }

    public static InetAddress[] getAllLocalInetAddresses() {
<span class="nc" id="L123">        final List&lt;InetAddress&gt; addrList = new ArrayList&lt;InetAddress&gt;();</span>
        try {
<span class="nc bnc" id="L125" title="All 2 branches missed.">            for (final NetworkInterface ifc : IteratorUtil.enumerationAsIterable(NetworkInterface.getNetworkInterfaces())) {</span>
<span class="nc bnc" id="L126" title="All 4 branches missed.">                if (ifc.isUp() &amp;&amp; !ifc.isVirtual()) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                    for (final InetAddress addr : IteratorUtil.enumerationAsIterable(ifc.getInetAddresses())) {</span>
<span class="nc" id="L128">                        addrList.add(addr);</span>
                    }
                }
            }
<span class="nc" id="L132">        } catch (final SocketException e) {</span>
<span class="nc" id="L133">            s_logger.warn(&quot;SocketException in getAllLocalInetAddresses().&quot;, e);</span>
        }

<span class="nc" id="L136">        final InetAddress[] addrs = new InetAddress[addrList.size()];</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (addrList.size() &gt; 0) {</span>
<span class="nc" id="L138">            System.arraycopy(addrList.toArray(), 0, addrs, 0, addrList.size());</span>
        }
<span class="nc" id="L140">        return addrs;</span>
    }

    public static String[] getLocalCidrs() {
<span class="nc" id="L144">        final String defaultHostIp = getDefaultHostIp();</span>

<span class="nc" id="L146">        final List&lt;String&gt; cidrList = new ArrayList&lt;String&gt;();</span>
        try {
<span class="nc bnc" id="L148" title="All 2 branches missed.">            for (final NetworkInterface ifc : IteratorUtil.enumerationAsIterable(NetworkInterface.getNetworkInterfaces())) {</span>
<span class="nc bnc" id="L149" title="All 6 branches missed.">                if (ifc.isUp() &amp;&amp; !ifc.isVirtual() &amp;&amp; !ifc.isLoopback()) {</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">                    for (final InterfaceAddress address : ifc.getInterfaceAddresses()) {</span>
<span class="nc" id="L151">                        final InetAddress addr = address.getAddress();</span>
<span class="nc" id="L152">                        final int prefixLength = address.getNetworkPrefixLength();</span>
<span class="nc bnc" id="L153" title="All 4 branches missed.">                        if (prefixLength &lt; MAX_CIDR &amp;&amp; prefixLength &gt; 0) {</span>
<span class="nc" id="L154">                            final String ip = ipFromInetAddress(addr);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                            if (ip.equalsIgnoreCase(defaultHostIp)) {</span>
<span class="nc" id="L156">                                cidrList.add(ipAndNetMaskToCidr(ip, getCidrNetmask(prefixLength)));</span>
                            }
                        }
                    }
                }
            }
<span class="nc" id="L162">        } catch (final SocketException e) {</span>
<span class="nc" id="L163">            s_logger.warn(&quot;UnknownHostException in getLocalCidrs().&quot;, e);</span>
        }

<span class="nc" id="L166">        return cidrList.toArray(new String[0]);</span>
    }

    public static String getDefaultHostIp() {
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (SystemUtils.IS_OS_WINDOWS) {</span>
<span class="nc" id="L171">            final Pattern pattern = Pattern.compile(&quot;\\s*0.0.0.0\\s*0.0.0.0\\s*(\\S*)\\s*(\\S*)\\s*&quot;);</span>
            try {
<span class="nc" id="L173">                final Process result = Runtime.getRuntime().exec(&quot;route print -4&quot;);</span>
<span class="nc" id="L174">                final BufferedReader output = new BufferedReader(new InputStreamReader(result.getInputStream()));</span>

<span class="nc" id="L176">                String line = output.readLine();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                while (line != null) {</span>
<span class="nc" id="L178">                    final Matcher matcher = pattern.matcher(line);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                    if (matcher.find()) {</span>
<span class="nc" id="L180">                        return matcher.group(2);</span>
                    }
<span class="nc" id="L182">                    line = output.readLine();</span>
                }
<span class="nc" id="L184">            } catch (final IOException e) {</span>
<span class="nc" id="L185">                s_logger.debug(&quot;Caught IOException&quot;, e);</span>
            }
<span class="nc" id="L187">            return null;</span>
        } else {
<span class="nc" id="L189">            NetworkInterface nic = null;</span>
<span class="nc" id="L190">            final String pubNic = getDefaultEthDevice();</span>

<span class="nc bnc" id="L192" title="All 2 branches missed.">            if (pubNic == null) {</span>
<span class="nc" id="L193">                return null;</span>
            }

            try {
<span class="nc" id="L197">                nic = NetworkInterface.getByName(pubNic);</span>
<span class="nc" id="L198">            } catch (final SocketException e) {</span>
<span class="nc" id="L199">                return null;</span>
            }

<span class="nc" id="L202">            String[] info = null;</span>
            try {
<span class="nc" id="L204">                info = NetUtils.getNetworkParams(nic);</span>
<span class="nc" id="L205">            } catch (final NullPointerException ignored) {</span>
<span class="nc" id="L206">                s_logger.debug(&quot;Caught NullPointerException when trying to getDefaultHostIp&quot;);</span>
            }
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if (info != null) {</span>
<span class="nc" id="L209">                return info[0];</span>
            }
<span class="nc" id="L211">            return null;</span>
        }
    }

    public static String getDefaultEthDevice() {
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (SystemUtils.IS_OS_MAC) {</span>
<span class="nc" id="L217">            final String defDev = Script.runSimpleBashScript(&quot;/sbin/route -n get default 2&gt; /dev/null | grep interface | awk '{print $2}'&quot;);</span>
<span class="nc" id="L218">            return defDev;</span>
        }
<span class="nc" id="L220">        final String defaultRoute = Script.runSimpleBashScript(&quot;/sbin/route | grep default&quot;);</span>

<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (defaultRoute == null) {</span>
<span class="nc" id="L223">            return null;</span>
        }

<span class="nc" id="L226">        final String[] defaultRouteList = defaultRoute.split(&quot;\\s+&quot;);</span>

<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (defaultRouteList.length != 8) {</span>
<span class="nc" id="L229">            return null;</span>
        }

<span class="nc" id="L232">        return defaultRouteList[7];</span>
    }

    public static InetAddress getFirstNonLoopbackLocalInetAddress() {
<span class="nc" id="L236">        final InetAddress[] addrs = getAllLocalInetAddresses();</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (addrs != null) {</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            for (final InetAddress addr : addrs) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                if (s_logger.isInfoEnabled()) {</span>
<span class="nc" id="L240">                    s_logger.info(&quot;Check local InetAddress : &quot; + addr.toString() + &quot;, total count :&quot; + addrs.length);</span>
                }

<span class="nc bnc" id="L243" title="All 2 branches missed.">                if (!addr.isLoopbackAddress()) {</span>
<span class="nc" id="L244">                    return addr;</span>
                }
            }
        }

<span class="nc" id="L249">        s_logger.warn(&quot;Unable to determine a non-loopback address, local inet address count :&quot; + addrs.length);</span>
<span class="nc" id="L250">        return null;</span>
    }

    public static InetAddress[] getInterfaceInetAddresses(final String ifName) {
<span class="nc" id="L254">        final List&lt;InetAddress&gt; addrList = new ArrayList&lt;InetAddress&gt;();</span>
        try {
<span class="nc bnc" id="L256" title="All 2 branches missed.">            for (final NetworkInterface ifc : IteratorUtil.enumerationAsIterable(NetworkInterface.getNetworkInterfaces())) {</span>
<span class="nc bnc" id="L257" title="All 6 branches missed.">                if (ifc.isUp() &amp;&amp; !ifc.isVirtual() &amp;&amp; ifc.getName().equals(ifName)) {</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">                    for (final InetAddress addr : IteratorUtil.enumerationAsIterable(ifc.getInetAddresses())) {</span>
<span class="nc" id="L259">                        addrList.add(addr);</span>
                    }
                }
            }
<span class="nc" id="L263">        } catch (final SocketException e) {</span>
<span class="nc" id="L264">            s_logger.warn(&quot;SocketException in getAllLocalInetAddresses().&quot;, e);</span>
        }

<span class="nc" id="L267">        final InetAddress[] addrs = new InetAddress[addrList.size()];</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (addrList.size() &gt; 0) {</span>
<span class="nc" id="L269">            System.arraycopy(addrList.toArray(), 0, addrs, 0, addrList.size());</span>
        }
<span class="nc" id="L271">        return addrs;</span>
    }

    public static String getLocalIPString() {
<span class="nc" id="L275">        final InetAddress addr = getLocalInetAddress();</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (addr != null) {</span>
<span class="nc" id="L277">            return ipFromInetAddress(addr);</span>
        }

<span class="nc" id="L280">        return &quot;127.0.0.1&quot;;</span>
    }

    public static String ipFromInetAddress(final InetAddress addr) {
<span class="nc bnc" id="L284" title="All 4 branches missed.">        assert addr != null;</span>

<span class="nc" id="L286">        final byte[] ipBytes = addr.getAddress();</span>
<span class="nc" id="L287">        final StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L288">        sb.append(ipBytes[0] &amp; 0xff).append(&quot;.&quot;);</span>
<span class="nc" id="L289">        sb.append(ipBytes[1] &amp; 0xff).append(&quot;.&quot;);</span>
<span class="nc" id="L290">        sb.append(ipBytes[2] &amp; 0xff).append(&quot;.&quot;);</span>
<span class="nc" id="L291">        sb.append(ipBytes[3] &amp; 0xff);</span>

<span class="nc" id="L293">        return sb.toString();</span>
    }

    public static boolean isLocalAddress(final InetAddress addr) {
<span class="nc" id="L297">        final InetAddress[] addrs = getAllLocalInetAddresses();</span>

<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (addrs != null) {</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">            for (final InetAddress self : addrs) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                if (self.equals(addr)) {</span>
<span class="nc" id="L302">                    return true;</span>
                }
            }
        }
<span class="nc" id="L306">        return false;</span>
    }

    public static boolean isLocalAddress(final String strAddress) {

        InetAddress addr;
        try {
<span class="nc" id="L313">            addr = InetAddress.getByName(strAddress);</span>
<span class="nc" id="L314">            return isLocalAddress(addr);</span>
<span class="nc" id="L315">        } catch (final UnknownHostException e) {</span>
        }
<span class="nc" id="L317">        return false;</span>
    }

    public static String getMacAddress(final InetAddress address) {
<span class="nc" id="L321">        final StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L322">        final Formatter formatter = new Formatter(sb);</span>
        try {
<span class="nc" id="L324">            final NetworkInterface ni = NetworkInterface.getByInetAddress(address);</span>
<span class="nc" id="L325">            final byte[] mac = ni.getHardwareAddress();</span>

<span class="nc bnc" id="L327" title="All 2 branches missed.">            for (int i = 0; i &lt; mac.length; i++) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">                formatter.format(&quot;%02X%s&quot;, mac[i], i &lt; mac.length - 1 ? &quot;:&quot; : &quot;&quot;);</span>
            }
<span class="nc" id="L330">        } catch (final SocketException e) {</span>
<span class="nc" id="L331">            s_logger.error(&quot;SocketException when trying to retrieve MAC address&quot;, e);</span>
<span class="nc" id="L332">        } finally {</span>
<span class="nc" id="L333">            formatter.close();</span>
<span class="nc" id="L334">        }</span>
<span class="nc" id="L335">        return sb.toString();</span>
    }

    public static long getMacAddressAsLong(final InetAddress address) {
<span class="nc" id="L339">        long macAddressAsLong = 0;</span>
        try {
<span class="nc" id="L341">            final NetworkInterface ni = NetworkInterface.getByInetAddress(address);</span>
<span class="nc" id="L342">            final byte[] mac = ni.getHardwareAddress();</span>

<span class="nc bnc" id="L344" title="All 2 branches missed.">            for (int i = 0; i &lt; mac.length; i++) {</span>
<span class="nc" id="L345">                macAddressAsLong |= (long)(mac[i] &amp; 0xff) &lt;&lt; (mac.length - i - 1) * 8;</span>
            }

<span class="nc" id="L348">        } catch (final SocketException e) {</span>
<span class="nc" id="L349">            s_logger.error(&quot;SocketException when trying to retrieve MAC address&quot;, e);</span>
        }

<span class="nc" id="L352">        return macAddressAsLong;</span>
    }

    /**
     * This method will fail in case we have a 31 Bit prefix network
     * See RFC 3021.
     *
     * In order to avoid calling this method, please check the &lt;code&gt;NetUtils.is31PrefixCidr(cidr)&lt;/code&gt; first.
     */
    public static boolean ipRangesOverlap(final String startIp1, final String endIp1, final String startIp2, final String endIp2) {
<span class="nc" id="L362">        final long startIp1Long = ip2Long(startIp1);</span>
<span class="nc" id="L363">        long endIp1Long = startIp1Long;</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (endIp1 != null) {</span>
<span class="nc" id="L365">            endIp1Long = ip2Long(endIp1);</span>
        }
<span class="nc" id="L367">        final long startIp2Long = ip2Long(startIp2);</span>
<span class="nc" id="L368">        long endIp2Long = startIp2Long;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (endIp2 != null) {</span>
<span class="nc" id="L370">            endIp2Long = ip2Long(endIp2);</span>
        }

<span class="nc bnc" id="L373" title="All 8 branches missed.">        if (startIp1Long == startIp2Long || startIp1Long == endIp2Long || endIp1Long == startIp2Long || endIp1Long == endIp2Long) {</span>
<span class="nc" id="L374">            return true;</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">        } else if (startIp1Long &gt; startIp2Long &amp;&amp; startIp1Long &lt; endIp2Long) {</span>
<span class="nc" id="L376">            return true;</span>
<span class="nc bnc" id="L377" title="All 4 branches missed.">        } else if (endIp1Long &gt; startIp2Long &amp;&amp; endIp1Long &lt; endIp2Long) {</span>
<span class="nc" id="L378">            return true;</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">        } else if (startIp2Long &gt; startIp1Long &amp;&amp; startIp2Long &lt; endIp1Long) {</span>
<span class="nc" id="L380">            return true;</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">        } else if (endIp2Long &gt; startIp1Long &amp;&amp; endIp2Long &lt; endIp1Long) {</span>
<span class="nc" id="L382">            return true;</span>
        } else {
<span class="nc" id="L384">            return false;</span>
        }
    }

    public static long ip2Long(final String ip) {
<span class="nc" id="L389">        final String[] tokens = ip.split(&quot;[.]&quot;);</span>
<span class="nc bnc" id="L390" title="All 4 branches missed.">        assert tokens.length == 4;</span>
<span class="nc" id="L391">        long result = 0;</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        for (int i = 0; i &lt; tokens.length; i++) {</span>
            try {
<span class="nc" id="L394">                result = result &lt;&lt; 8 | Integer.parseInt(tokens[i]);</span>
<span class="nc" id="L395">            } catch (final NumberFormatException e) {</span>
<span class="nc" id="L396">                throw new RuntimeException(&quot;Incorrect number&quot;, e);</span>
            }
        }

<span class="nc" id="L400">        return result;</span>
    }

    public static String long2Ip(final long ip) {
<span class="nc" id="L404">        final StringBuilder result = new StringBuilder(15);</span>
<span class="nc" id="L405">        result.append(ip &gt;&gt; 24 &amp; 0xff).append(&quot;.&quot;);</span>
<span class="nc" id="L406">        result.append(ip &gt;&gt; 16 &amp; 0xff).append(&quot;.&quot;);</span>
<span class="nc" id="L407">        result.append(ip &gt;&gt; 8 &amp; 0xff).append(&quot;.&quot;);</span>
<span class="nc" id="L408">        result.append(ip &amp; 0xff);</span>

<span class="nc" id="L410">        return result.toString();</span>
    }

    public static long mac2Long(final String macAddress) {
<span class="nc" id="L414">        final String[] tokens = macAddress.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L415" title="All 4 branches missed.">        assert tokens.length == 6;</span>
<span class="nc" id="L416">        long result = 0;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">        for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="nc" id="L418">            result = result &lt;&lt; 8;</span>
<span class="nc" id="L419">            result |= Integer.parseInt(tokens[i], 16);</span>
        }
<span class="nc" id="L421">        return result;</span>
    }

    public static String[] getNicParams(final String nicName) {
        try {
<span class="nc" id="L426">            final NetworkInterface nic = NetworkInterface.getByName(nicName);</span>
<span class="nc" id="L427">            return getNetworkParams(nic);</span>
<span class="nc" id="L428">        } catch (final SocketException e) {</span>
<span class="nc" id="L429">            return null;</span>
        }
    }

    public static String[] getNetworkParams(final NetworkInterface nic) {
<span class="nc" id="L434">        final List&lt;InterfaceAddress&gt; addrs = nic.getInterfaceAddresses();</span>
<span class="nc bnc" id="L435" title="All 4 branches missed.">        if (addrs == null || addrs.size() == 0) {</span>
<span class="nc" id="L436">            return null;</span>
        }
<span class="nc" id="L438">        InterfaceAddress addr = null;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">        for (final InterfaceAddress iaddr : addrs) {</span>
<span class="nc" id="L440">            final InetAddress inet = iaddr.getAddress();</span>
<span class="nc bnc" id="L441" title="All 8 branches missed.">            if (!inet.isLinkLocalAddress() &amp;&amp; !inet.isLoopbackAddress() &amp;&amp; !inet.isMulticastAddress() &amp;&amp; inet.getAddress().length == 4) {</span>
<span class="nc" id="L442">                addr = iaddr;</span>
<span class="nc" id="L443">                break;</span>
            }
        }
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (addr == null) {</span>
<span class="nc" id="L447">            return null;</span>
        }
<span class="nc" id="L449">        final String[] result = new String[3];</span>
<span class="nc" id="L450">        result[0] = addr.getAddress().getHostAddress();</span>
        try {
<span class="nc" id="L452">            final byte[] mac = nic.getHardwareAddress();</span>
<span class="nc" id="L453">            result[1] = byte2Mac(mac);</span>
<span class="nc" id="L454">        } catch (final SocketException e) {</span>
<span class="nc" id="L455">            s_logger.debug(&quot;Caught exception when trying to get the mac address &quot;, e);</span>
        }

<span class="nc" id="L458">        result[2] = prefix2Netmask(addr.getNetworkPrefixLength());</span>
<span class="nc" id="L459">        return result;</span>
    }

    public static String prefix2Netmask(final short prefix) {
<span class="nc" id="L463">        long addr = 0;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        for (int i = 0; i &lt; prefix; i++) {</span>
<span class="nc" id="L465">            addr = addr | 1 &lt;&lt; 31 - i;</span>
        }

<span class="nc" id="L468">        return long2Ip(addr);</span>
    }

    public static String byte2Mac(final byte[] m) {
<span class="nc" id="L472">        final StringBuilder result = new StringBuilder(17);</span>
<span class="nc" id="L473">        final Formatter formatter = new Formatter(result);</span>
<span class="nc" id="L474">        formatter.format(&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;, m[0], m[1], m[2], m[3], m[4], m[5]);</span>
<span class="nc" id="L475">        formatter.close();</span>
<span class="nc" id="L476">        return result.toString();</span>
    }

    public static String long2Mac(final long macAddress) {
<span class="nc" id="L480">        final StringBuilder result = new StringBuilder(17);</span>
<span class="nc" id="L481">        try (Formatter formatter = new Formatter(result)) {</span>
<span class="nc" id="L482">            formatter.format(&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,</span>
<span class="nc" id="L483">                    macAddress &gt;&gt; 40 &amp; 0xff, macAddress &gt;&gt; 32 &amp; 0xff,</span>
<span class="nc" id="L484">                    macAddress &gt;&gt; 24 &amp; 0xff, macAddress &gt;&gt; 16 &amp; 0xff,</span>
<span class="nc" id="L485">                    macAddress &gt;&gt; 8 &amp; 0xff, macAddress &amp; 0xff);</span>
<span class="nc bnc" id="L486" title="All 8 branches missed.">        }</span>
<span class="nc" id="L487">        return result.toString();</span>
    }

    public static boolean isValidPrivateIp(final String ipAddress, final String guestIPAddress) {

<span class="nc" id="L492">        final InetAddress privIp = parseIpAddress(ipAddress);</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (privIp == null) {</span>
<span class="nc" id="L494">            return false;</span>
        }
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (!privIp.isSiteLocalAddress()) {</span>
<span class="nc" id="L497">            return false;</span>
        }

<span class="nc" id="L500">        String firstGuestOctet = &quot;10&quot;;</span>
<span class="nc bnc" id="L501" title="All 4 branches missed.">        if (guestIPAddress != null &amp;&amp; !guestIPAddress.isEmpty()) {</span>
<span class="nc" id="L502">            final String[] guestIPList = guestIPAddress.split(&quot;\\.&quot;);</span>
<span class="nc" id="L503">            firstGuestOctet = guestIPList[0];</span>
        }

<span class="nc" id="L506">        final String[] ipList = ipAddress.split(&quot;\\.&quot;);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (!ipList[0].equals(firstGuestOctet)) {</span>
<span class="nc" id="L508">            return false;</span>
        }

<span class="nc" id="L511">        return true;</span>
    }

    public static boolean isSiteLocalAddress(final String ipAddress) {
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (ipAddress == null) {</span>
<span class="nc" id="L516">            return false;</span>
        } else {
<span class="nc" id="L518">            final InetAddress ip = parseIpAddress(ipAddress);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if(ip != null) {</span>
<span class="nc" id="L520">                return ip.isSiteLocalAddress();</span>
            }
<span class="nc" id="L522">            return false;</span>
        }
    }

    public static boolean validIpRange(final String startIP, final String endIP) {
<span class="nc bnc" id="L527" title="All 4 branches missed.">        if (endIP == null || endIP.isEmpty()) {</span>
<span class="nc" id="L528">            return true;</span>
        }

<span class="nc" id="L531">        final long startIPLong = NetUtils.ip2Long(startIP);</span>
<span class="nc" id="L532">        final long endIPLong = NetUtils.ip2Long(endIP);</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        return startIPLong &lt;= endIPLong;</span>
    }

    public static boolean isValidIp(final String ip) {
<span class="nc" id="L537">        final InetAddressValidator validator = InetAddressValidator.getInstance();</span>

<span class="nc" id="L539">        return validator.isValidInet4Address(ip);</span>
    }

    public static boolean is31PrefixCidr(final String cidr) {
<span class="nc" id="L543">        final boolean isValidCird = isValidCIDR(cidr);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">        if (isValidCird){</span>
<span class="nc" id="L545">            final String[] cidrPair = cidr.split(&quot;\\/&quot;);</span>
<span class="nc" id="L546">            final String cidrSize = cidrPair[1];</span>

<span class="nc" id="L548">            final int cidrSizeNum = Integer.parseInt(cidrSize);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            if (cidrSizeNum == RFC_3021_31_BIT_CIDR) {</span>
<span class="nc" id="L550">                return true;</span>
            }
        }
<span class="nc" id="L553">        return false;</span>
    }

    public static boolean isValidCIDR(final String cidr) {
<span class="nc bnc" id="L557" title="All 4 branches missed.">        if (cidr == null || cidr.isEmpty()) {</span>
<span class="nc" id="L558">            return false;</span>
        }
<span class="nc" id="L560">        final String[] cidrPair = cidr.split(&quot;\\/&quot;);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (cidrPair.length != 2) {</span>
<span class="nc" id="L562">            return false;</span>
        }
<span class="nc" id="L564">        final String cidrAddress = cidrPair[0];</span>
<span class="nc" id="L565">        final String cidrSize = cidrPair[1];</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">        if (!isValidIp(cidrAddress)) {</span>
<span class="nc" id="L567">            return false;</span>
        }
<span class="nc" id="L569">        int cidrSizeNum = -1;</span>

        try {
<span class="nc" id="L572">            cidrSizeNum = Integer.parseInt(cidrSize);</span>
<span class="nc" id="L573">        } catch (final Exception e) {</span>
<span class="nc" id="L574">            return false;</span>
        }

<span class="nc bnc" id="L577" title="All 4 branches missed.">        if (cidrSizeNum &lt; 0 || cidrSizeNum &gt; MAX_CIDR) {</span>
<span class="nc" id="L578">            return false;</span>
        }

<span class="nc" id="L581">        return true;</span>
    }

    public static boolean isValidNetmask(final String netmask) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (!isValidIp(netmask)) {</span>
<span class="nc" id="L586">            return false;</span>
        }

<span class="nc" id="L589">        final long ip = ip2Long(netmask);</span>
<span class="nc" id="L590">        int count = 0;</span>
<span class="nc" id="L591">        boolean finished = false;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        for (int i = 31; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">            if ((ip &gt;&gt; i &amp; 0x1) == 0) {</span>
<span class="nc" id="L594">                finished = true;</span>
<span class="nc" id="L595">            } else {</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                if (finished) {</span>
<span class="nc" id="L597">                    return false;</span>
                }
<span class="nc" id="L599">                count += 1;</span>
            }
        }

<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L604">            return false;</span>
        }

<span class="nc" id="L607">        return true;</span>
    }

    private static InetAddress parseIpAddress(final String address) {
<span class="nc" id="L611">        final StringTokenizer st = new StringTokenizer(address, &quot;.&quot;);</span>
<span class="nc" id="L612">        final byte[] bytes = new byte[4];</span>

<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (st.countTokens() == 4) {</span>
            try {
<span class="nc bnc" id="L616" title="All 2 branches missed.">                for (int i = 0; i &lt; 4; i++) {</span>
<span class="nc" id="L617">                    bytes[i] = (byte)Integer.parseInt(st.nextToken());</span>
                }
<span class="nc" id="L619">                return InetAddress.getByAddress(address, bytes);</span>
<span class="nc" id="L620">            } catch (final NumberFormatException nfe) {</span>
<span class="nc" id="L621">                return null;</span>
<span class="nc" id="L622">            } catch (final UnknownHostException uhe) {</span>
<span class="nc" id="L623">                return null;</span>
            }
        }
<span class="nc" id="L626">        return null;</span>
    }

    public static String getCidrFromGatewayAndNetmask(final String gatewayStr, final String netmaskStr) {
<span class="nc" id="L630">        final long netmask = ip2Long(netmaskStr);</span>
<span class="nc" id="L631">        final long gateway = ip2Long(gatewayStr);</span>
<span class="nc" id="L632">        final long firstPart = gateway &amp; netmask;</span>
<span class="nc" id="L633">        final long size = getCidrSize(netmaskStr);</span>
<span class="nc" id="L634">        return long2Ip(firstPart) + &quot;/&quot; + size;</span>
    }

    public static String[] getIpRangeFromCidr(final String cidr, final long size) {
<span class="nc bnc" id="L638" title="All 4 branches missed.">        assert size &lt; MAX_CIDR : &quot;You do know this is not for ipv6 right?  Keep it smaller than 32 but you have &quot; + size;</span>
<span class="nc" id="L639">        final String[] result = new String[2];</span>
<span class="nc" id="L640">        final long ip = ip2Long(cidr);</span>
<span class="nc" id="L641">        final long startNetMask = ip2Long(getCidrNetmask(size));</span>
<span class="nc" id="L642">        final long start = (ip &amp; startNetMask) + 1;</span>
<span class="nc" id="L643">        long end = start;</span>

<span class="nc" id="L645">        end = end &gt;&gt; MAX_CIDR - size;</span>

<span class="nc" id="L647">        end++;</span>
<span class="nc" id="L648">        end = (end &lt;&lt; MAX_CIDR - size) - 2;</span>

<span class="nc" id="L650">        result[0] = long2Ip(start);</span>
<span class="nc" id="L651">        result[1] = long2Ip(end);</span>

<span class="nc" id="L653">        return result;</span>
    }

    public static Set&lt;Long&gt; getAllIpsFromCidr(final String cidr, final long size, final Set&lt;Long&gt; usedIps) {
<span class="nc bnc" id="L657" title="All 4 branches missed.">        assert size &lt; MAX_CIDR : &quot;You do know this is not for ipv6 right?  Keep it smaller than 32 but you have &quot; + size;</span>
<span class="nc" id="L658">        final Set&lt;Long&gt; result = new TreeSet&lt;Long&gt;();</span>
<span class="nc" id="L659">        final long ip = ip2Long(cidr);</span>
<span class="nc" id="L660">        final long startNetMask = ip2Long(getCidrNetmask(size));</span>
<span class="nc" id="L661">        long start = (ip &amp; startNetMask) + 1;</span>
<span class="nc" id="L662">        long end = start;</span>

<span class="nc" id="L664">        end = end &gt;&gt; MAX_CIDR - size;</span>

<span class="nc" id="L666">        end++;</span>
<span class="nc" id="L667">        end = (end &lt;&lt; MAX_CIDR - size) - 2;</span>
<span class="nc" id="L668">        int maxIps = 255; // get 255 ips as maximum</span>
<span class="nc bnc" id="L669" title="All 4 branches missed.">        while (start &lt;= end &amp;&amp; maxIps &gt; 0) {</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            if (!usedIps.contains(start)) {</span>
<span class="nc" id="L671">                result.add(start);</span>
<span class="nc" id="L672">                maxIps--;</span>
            }
<span class="nc" id="L674">            start++;</span>
        }

<span class="nc" id="L677">        return result;</span>
    }

    /**
     * Given a cidr, this method returns an ip address within the range but
     * is not in the avoid list.
     *
     * @param startIp ip that the cidr starts with
     * @param size size of the cidr
     * @param avoid set of ips to avoid
     * @return ip that is within the cidr range but not in the avoid set.  -1 if unable to find one.
     */
    public static long getRandomIpFromCidr(final String startIp, final int size, final SortedSet&lt;Long&gt; avoid) {
<span class="nc" id="L690">        return getRandomIpFromCidr(ip2Long(startIp), size, avoid);</span>

    }

    /**
     * Given a cidr, this method returns an ip address within the range but
     * is not in the avoid list.
     * Note: the gateway address has to be specified in the avoid list
     *
     * @param cidr ip that the cidr starts with
     * @param size size of the cidr
     * @param avoid set of ips to avoid
     * @return ip that is within the cidr range but not in the avoid set.  -1 if unable to find one.
     */
    public static long getRandomIpFromCidr(final long cidr, final int size, final SortedSet&lt;Long&gt; avoid) {
<span class="nc bnc" id="L705" title="All 4 branches missed.">        assert size &lt; MAX_CIDR : &quot;You do know this is not for ipv6 right?  Keep it smaller than 32 but you have &quot; + size;</span>

<span class="nc" id="L707">        final long startNetMask = ip2Long(getCidrNetmask(size));</span>
<span class="nc" id="L708">        final long startIp = (cidr &amp; startNetMask) + 1; //exclude the first ip since it isnt valid, e.g., 192.168.10.0</span>
<span class="nc" id="L709">        int range = 1 &lt;&lt; MAX_CIDR - size; //e.g., /24 = 2^8 = 256</span>
<span class="nc" id="L710">        range = range - 1; //exclude end of the range since that is the broadcast address, e.g., 192.168.10.255</span>

<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (avoid.size() &gt;= range) {</span>
<span class="nc" id="L713">            return -1;</span>
        }

        //Reduce the range by the size of the avoid set
        //e.g., cidr = 192.168.10.0, size = /24, avoid = 192.168.10.1, 192.168.10.20, 192.168.10.254
        // range = 2^8 - 1 - 3 = 252
<span class="nc" id="L719">        range = range - avoid.size();</span>
<span class="nc" id="L720">        final int next = s_rand.nextInt(range); //note: nextInt excludes last value</span>
<span class="nc" id="L721">        long ip = startIp + next;</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">        for (final Long avoidable : avoid) {</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (ip &gt;= avoidable) {</span>
<span class="nc" id="L724">                ip++;</span>
            } else {
                break;
            }
        }

<span class="nc" id="L730">        return ip;</span>
    }

    public static String getIpRangeStartIpFromCidr(final String cidr, final long size) {
<span class="nc" id="L734">        final long ip = ip2Long(cidr);</span>
<span class="nc" id="L735">        final long startNetMask = ip2Long(getCidrNetmask(size));</span>
<span class="nc" id="L736">        final long start = (ip &amp; startNetMask) + 1;</span>
<span class="nc" id="L737">        return long2Ip(start);</span>
    }

    public static String getIpRangeEndIpFromCidr(final String cidr, final long size) {
<span class="nc" id="L741">        final long ip = ip2Long(cidr);</span>
<span class="nc" id="L742">        final long startNetMask = ip2Long(getCidrNetmask(size));</span>
<span class="nc" id="L743">        final long start = (ip &amp; startNetMask) + 1;</span>
<span class="nc" id="L744">        long end = start;</span>
<span class="nc" id="L745">        end = end &gt;&gt; MAX_CIDR - size;</span>

<span class="nc" id="L747">        end++;</span>
<span class="nc" id="L748">        end = (end &lt;&lt; MAX_CIDR - size) - 2;</span>
<span class="nc" id="L749">        return long2Ip(end);</span>
    }

    public static boolean sameSubnet(final String ip1, final String ip2, final String netmask) {
<span class="nc bnc" id="L753" title="All 8 branches missed.">        if (ip1 == null || ip1.isEmpty() || ip2 == null || ip2.isEmpty()) {</span>
<span class="nc" id="L754">            return true;</span>
        }
<span class="nc" id="L756">        final String subnet1 = NetUtils.getSubNet(ip1, netmask);</span>
<span class="nc" id="L757">        final String subnet2 = NetUtils.getSubNet(ip2, netmask);</span>

<span class="nc" id="L759">        return subnet1.equals(subnet2);</span>
    }

    public static boolean sameSubnetCIDR(final String ip1, final String ip2, final long cidrSize) {
<span class="nc bnc" id="L763" title="All 8 branches missed.">        if (ip1 == null || ip1.isEmpty() || ip2 == null || ip2.isEmpty()) {</span>
<span class="nc" id="L764">            return true;</span>
        }
<span class="nc" id="L766">        final String subnet1 = NetUtils.getCidrSubNet(ip1, cidrSize);</span>
<span class="nc" id="L767">        final String subnet2 = NetUtils.getCidrSubNet(ip2, cidrSize);</span>

<span class="nc" id="L769">        return subnet1.equals(subnet2);</span>
    }

    public static String getSubNet(final String ip, final String netmask) {
<span class="nc" id="L773">        final long ipAddr = ip2Long(ip);</span>
<span class="nc" id="L774">        final long subnet = ip2Long(netmask);</span>
<span class="nc" id="L775">        final long result = ipAddr &amp; subnet;</span>
<span class="nc" id="L776">        return long2Ip(result);</span>
    }

    public static String getCidrSubNet(final String ip, final long cidrSize) {
<span class="nc" id="L780">        final long numericNetmask = netMaskFromCidr(cidrSize);</span>
<span class="nc" id="L781">        final String netmask = NetUtils.long2Ip(numericNetmask);</span>
<span class="nc" id="L782">        return getSubNet(ip, netmask);</span>
    }

    /**
     * @param cidrSize
     * @return
     */
    static long netMaskFromCidr(final long cidrSize) {
<span class="nc" id="L790">        return ((long)0xffffffff) &gt;&gt; MAX_CIDR - cidrSize &lt;&lt; MAX_CIDR - cidrSize;</span>
    }

    public static String ipAndNetMaskToCidr(final String ip, final String netmask) {
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (!isValidIp(ip)) {</span>
<span class="nc" id="L795">            return null;</span>
        }

<span class="nc bnc" id="L798" title="All 2 branches missed.">        if (!isValidNetmask(netmask)) {</span>
<span class="nc" id="L799">            return null;</span>
        }

<span class="nc" id="L802">        final long ipAddr = ip2Long(ip);</span>
<span class="nc" id="L803">        final long subnet = ip2Long(netmask);</span>
<span class="nc" id="L804">        final long result = ipAddr &amp; subnet;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">        int bits = subnet == 0 ? 0 : 1;</span>
<span class="nc" id="L806">        long subnet2 = subnet;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">        while ((subnet2 = subnet2 &gt;&gt; 1 &amp; subnet) != 0) {</span>
<span class="nc" id="L808">            bits++;</span>
        }

<span class="nc" id="L811">        return long2Ip(result) + &quot;/&quot; + Integer.toString(bits);</span>
    }

    public static String[] ipAndNetMaskToRange(final String ip, final String netmask) {
<span class="nc" id="L815">        final long ipAddr = ip2Long(ip);</span>
<span class="nc" id="L816">        long subnet = ip2Long(netmask);</span>
<span class="nc" id="L817">        final long start = (ipAddr &amp; subnet) + 1;</span>
<span class="nc" id="L818">        long end = start;</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">        int bits = subnet == 0 ? 0 : 1;</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">        while ((subnet = subnet &gt;&gt; 1 &amp; subnet) != 0) {</span>
<span class="nc" id="L821">            bits++;</span>
        }
<span class="nc" id="L823">        end = end &gt;&gt; MAX_CIDR - bits;</span>

<span class="nc" id="L825">        end++;</span>
<span class="nc" id="L826">        end = (end &lt;&lt; MAX_CIDR - bits) - 2;</span>

<span class="nc" id="L828">        return new String[] {long2Ip(start), long2Ip(end)};</span>

    }

    public static Pair&lt;String, Integer&gt; getCidr(final String cidr) {
<span class="nc" id="L833">        final String[] tokens = cidr.split(&quot;/&quot;);</span>
<span class="nc" id="L834">        return new Pair&lt;String, Integer&gt;(tokens[0], Integer.parseInt(tokens[1]));</span>
    }

<span class="nc" id="L837">    public static enum SupersetOrSubset {</span>
<span class="nc" id="L838">        isSuperset, isSubset, neitherSubetNorSuperset, sameSubnet, errorInCidrFormat</span>
    }

    public static SupersetOrSubset isNetowrkASubsetOrSupersetOfNetworkB(final String cidrA, final String cidrB) {
<span class="nc bnc" id="L842" title="All 2 branches missed.">        if (!areCidrsNotEmpty(cidrA, cidrB)) {</span>
<span class="nc" id="L843">            return SupersetOrSubset.errorInCidrFormat;</span>
        }
<span class="nc" id="L845">        final Long[] cidrALong = cidrToLong(cidrA);</span>
<span class="nc" id="L846">        final Long[] cidrBLong = cidrToLong(cidrB);</span>
<span class="nc" id="L847">        long shift = 0;</span>

<span class="nc bnc" id="L849" title="All 2 branches missed.">        if (cidrALong[1] &gt;= cidrBLong[1]) {</span>
<span class="nc" id="L850">            shift = MAX_CIDR - cidrBLong[1];</span>
<span class="nc" id="L851">        } else {</span>
<span class="nc" id="L852">            shift = MAX_CIDR - cidrALong[1];</span>
        }
<span class="nc" id="L854">        final long result = (cidrALong[0] &gt;&gt; shift) - (cidrBLong[0] &gt;&gt; shift);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">        if (result == 0) {</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">            if (cidrALong[1] &lt; cidrBLong[1]) {</span>
                //this implies cidrA is super set of cidrB
<span class="nc" id="L858">                return SupersetOrSubset.isSuperset;</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            } else if (cidrALong[1].equals(cidrBLong[1])) {</span>
                //this implies both the cidrs are equal
<span class="nc" id="L861">                return SupersetOrSubset.sameSubnet;</span>
            }
            // implies cidrA is subset of cidrB
<span class="nc" id="L864">            return SupersetOrSubset.isSubset;</span>
        }
        //this implies no overlap.
<span class="nc" id="L867">        return SupersetOrSubset.neitherSubetNorSuperset;</span>
    }

    public static boolean isNetworkAWithinNetworkB(final String cidrA, final String cidrB) {
<span class="nc bnc" id="L871" title="All 2 branches missed.">        if (!areCidrsNotEmpty(cidrA, cidrB)) {</span>
<span class="nc" id="L872">            return false;</span>
        }
<span class="nc" id="L874">        Long[] cidrALong = cidrToLong(cidrA);</span>
<span class="nc" id="L875">        Long[] cidrBLong = cidrToLong(cidrB);</span>

<span class="nc" id="L877">        long shift = MAX_CIDR - cidrBLong[1];</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">        return cidrALong[0] &gt;&gt; shift == cidrBLong[0] &gt;&gt; shift;</span>
    }

    static boolean areCidrsNotEmpty(String cidrA, String cidrB) {
<span class="nc bnc" id="L882" title="All 4 branches missed.">        return StringUtils.isNotEmpty(cidrA) &amp;&amp; StringUtils.isNotEmpty(cidrB);</span>
    }

    public static Long[] cidrToLong(final String cidr) {
<span class="nc bnc" id="L886" title="All 4 branches missed.">        if (cidr == null || cidr.isEmpty()) {</span>
<span class="nc" id="L887">            throw new CloudRuntimeException(&quot;empty cidr can not be converted to longs&quot;);</span>
        }
<span class="nc" id="L889">        final String[] cidrPair = cidr.split(&quot;\\/&quot;);</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">        if (cidrPair.length != 2) {</span>
<span class="nc" id="L891">            throw new CloudRuntimeException(&quot;cidr is not formatted correctly: &quot;+ cidr);</span>
        }
<span class="nc" id="L893">        final String cidrAddress = cidrPair[0];</span>
<span class="nc" id="L894">        final String cidrSize = cidrPair[1];</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">        if (!isValidIp(cidrAddress)) {</span>
<span class="nc" id="L896">            throw new CloudRuntimeException(&quot;cidr is not valid in ip space&quot; + cidr);</span>
        }
<span class="nc" id="L898">        long cidrSizeNum = getCidrSizeFromString(cidrSize);</span>
<span class="nc" id="L899">        final long numericNetmask = netMaskFromCidr(cidrSizeNum);</span>
<span class="nc" id="L900">        final long ipAddr = ip2Long(cidrAddress);</span>
<span class="nc" id="L901">        final Long[] cidrlong = {ipAddr &amp; numericNetmask, cidrSizeNum};</span>
<span class="nc" id="L902">        return cidrlong;</span>

    }

    /**
     * @param cidrSize
     * @return
     * @throws CloudRuntimeException
     */
    static long getCidrSizeFromString(final String cidrSize) throws CloudRuntimeException {
<span class="nc" id="L912">        long cidrSizeNum = -1;</span>

        try {
<span class="nc" id="L915">            cidrSizeNum = Integer.parseInt(cidrSize);</span>
<span class="nc" id="L916">        } catch (final NumberFormatException e) {</span>
<span class="nc" id="L917">            throw new CloudRuntimeException(&quot;cidrsize is not a valid int: &quot; + cidrSize, e);</span>
        }
<span class="nc bnc" id="L919" title="All 4 branches missed.">        if(cidrSizeNum &gt; 32 || cidrSizeNum &lt; 0) {// assuming IPv4</span>
<span class="nc" id="L920">            throw new CloudRuntimeException(&quot;cidr size out of range: &quot; + cidrSizeNum);</span>
        }
<span class="nc" id="L922">        return cidrSizeNum;</span>
    }

    public static String getCidrSubNet(final String cidr) {
<span class="nc bnc" id="L926" title="All 4 branches missed.">        if (cidr == null || cidr.isEmpty()) {</span>
<span class="nc" id="L927">            return null;</span>
        }
<span class="nc" id="L929">        final String[] cidrPair = cidr.split(&quot;\\/&quot;);</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if (cidrPair.length != 2) {</span>
<span class="nc" id="L931">            return null;</span>
        }
<span class="nc" id="L933">        final String cidrAddress = cidrPair[0];</span>
<span class="nc" id="L934">        final String cidrSize = cidrPair[1];</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">        if (!isValidIp(cidrAddress)) {</span>
<span class="nc" id="L936">            return null;</span>
        }
<span class="nc" id="L938">        long cidrSizeNum = getCidrSizeFromString(cidrSize);</span>
<span class="nc" id="L939">        final long numericNetmask = netMaskFromCidr(cidrSizeNum);</span>
<span class="nc" id="L940">        final String netmask = NetUtils.long2Ip(numericNetmask);</span>
<span class="nc" id="L941">        return getSubNet(cidrAddress, netmask);</span>
    }

    public static String getCidrNetmask(final long cidrSize) {
<span class="nc" id="L945">        final long numericNetmask = netMaskFromCidr(cidrSize);</span>
<span class="nc" id="L946">        return long2Ip(numericNetmask);</span>
    }

    public static String getCidrNetmask(final String cidr) {
<span class="nc" id="L950">        final String[] cidrPair = cidr.split(&quot;\\/&quot;);</span>
<span class="nc" id="L951">        final long guestCidrSize = Long.parseLong(cidrPair[1]);</span>
<span class="nc" id="L952">        return getCidrNetmask(guestCidrSize);</span>
    }

    public static String cidr2Netmask(final String cidr) {
<span class="nc" id="L956">        final String[] tokens = cidr.split(&quot;\\/&quot;);</span>
<span class="nc" id="L957">        return getCidrNetmask(Integer.parseInt(tokens[1]));</span>
    }

    public static long getCidrSize(final String netmask) {
<span class="nc" id="L961">        final long ip = ip2Long(netmask);</span>
<span class="nc" id="L962">        int count = 0;</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">        for (int i = 0; i &lt; MAX_CIDR; i++) {</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">            if ((ip &gt;&gt; i &amp; 0x1) == 0) {</span>
<span class="nc" id="L965">                count++;</span>
            } else {
                break;
            }
        }

<span class="nc" id="L971">        return MAX_CIDR - count;</span>
    }

    public static boolean isValidPort(final String p) {
        try {
<span class="nc" id="L976">            final int port = Integer.parseInt(p);</span>
<span class="nc bnc" id="L977" title="All 4 branches missed.">            return !(port &gt; 65535 || port &lt; 1);</span>
<span class="nc" id="L978">        } catch (final NumberFormatException e) {</span>
<span class="nc" id="L979">            return false;</span>
        }
    }

    public static boolean isValidPort(final int p) {
<span class="nc bnc" id="L984" title="All 4 branches missed.">        return !(p &gt; 65535 || p &lt; 1);</span>
    }

    public static boolean isValidLBPort(final String p) {
        try {
<span class="nc" id="L989">            final int port = Integer.parseInt(p);</span>
<span class="nc bnc" id="L990" title="All 4 branches missed.">            return !(port &gt; 65535 || port &lt; 1);</span>
<span class="nc" id="L991">        } catch (final NumberFormatException e) {</span>
<span class="nc" id="L992">            return false;</span>
        }
    }

    public static boolean isValidProto(final String p) {
<span class="nc" id="L997">        final String proto = p.toLowerCase();</span>
<span class="nc bnc" id="L998" title="All 6 branches missed.">        return proto.equals(TCP_PROTO) || proto.equals(UDP_PROTO) || proto.equals(ICMP_PROTO);</span>
    }

    public static boolean isValidSecurityGroupProto(final String p) {
<span class="nc" id="L1002">        final String proto = p.toLowerCase();</span>
<span class="nc bnc" id="L1003" title="All 8 branches missed.">        return proto.equals(TCP_PROTO) || proto.equals(UDP_PROTO) || proto.equals(ICMP_PROTO) || proto.equals(ALL_PROTO);</span>
    }

    public static boolean isValidAlgorithm(final String p) {
<span class="nc" id="L1007">        final String algo = p.toLowerCase();</span>
<span class="nc bnc" id="L1008" title="All 6 branches missed.">        return algo.equals(&quot;roundrobin&quot;) || algo.equals(&quot;leastconn&quot;) || algo.equals(&quot;source&quot;);</span>
    }

    public static boolean isValidAutoScaleAction(final String p) {
<span class="nc" id="L1012">        final String action = p.toLowerCase();</span>
<span class="nc bnc" id="L1013" title="All 4 branches missed.">        return action.equals(&quot;scaleup&quot;) || action.equals(&quot;scaledown&quot;);</span>
    }

    public static String getLinkLocalNetMask() {
<span class="nc" id="L1017">        return &quot;255.255.0.0&quot;;</span>
    }

    public static String getLinkLocalGateway() {
<span class="nc" id="L1021">        return &quot;169.254.0.1&quot;;</span>
    }

    public static String getLinkLocalCIDR() {
<span class="nc" id="L1025">        return &quot;169.254.0.0/16&quot;;</span>
    }

    public static String[] getLinkLocalIPRange(final int size) {
<span class="nc bnc" id="L1029" title="All 4 branches missed.">        if (size &gt; 16 || size &lt;= 0) {</span>
<span class="nc" id="L1030">            return null;</span>
        }
        /* reserve gateway */
<span class="nc" id="L1033">        final String[] range = getIpRangeFromCidr(getLinkLocalGateway(), MAX_CIDR - size);</span>

<span class="nc bnc" id="L1035" title="All 2 branches missed.">        if (range[0].equalsIgnoreCase(getLinkLocalGateway())) {</span>
            /* remove the gateway */
<span class="nc" id="L1037">            long ip = ip2Long(range[0]);</span>
<span class="nc" id="L1038">            ip += 1;</span>
<span class="nc" id="L1039">            range[0] = long2Ip(ip);</span>
        }
<span class="nc" id="L1041">        return range;</span>
    }

    public static String getLinkLocalIpEnd() {
<span class="nc" id="L1045">        final String[] cidrPair = getLinkLocalCIDR().split(&quot;\\/&quot;);</span>
<span class="nc" id="L1046">        final String cidr = cidrPair[0];</span>

<span class="nc" id="L1048">        return getIpRangeEndIpFromCidr(cidr, MAX_CIDR - Long.parseLong(cidrPair[1]));</span>
    }

    public static String portRangeToString(final int portRange[]) {
<span class="fc" id="L1052">        return Integer.toString(portRange[0]) + &quot;:&quot; + Integer.toString(portRange[1]);</span>
    }

    public static boolean verifyDomainNameLabel(final String hostName, final boolean isHostName) {
        // must be between 1 and 63 characters long and may contain only the ASCII letters 'a' through 'z' (in a
        // case-insensitive manner),
        // the digits '0' through '9', and the hyphen ('-').
        // Can not start with a hyphen and digit, and must not end with a hyphen
        // If it's a host name, don't allow to start with digit

<span class="nc bnc" id="L1062" title="All 4 branches missed.">        if (hostName.length() &gt; 63 || hostName.length() &lt; 1) {</span>
<span class="nc" id="L1063">            s_logger.warn(&quot;Domain name label must be between 1 and 63 characters long&quot;);</span>
<span class="nc" id="L1064">            return false;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        } else if (!hostName.toLowerCase().matches(&quot;[a-z0-9-]*&quot;)) {</span>
<span class="nc" id="L1066">            s_logger.warn(&quot;Domain name label may contain only the ASCII letters 'a' through 'z' (in a case-insensitive manner)&quot;);</span>
<span class="nc" id="L1067">            return false;</span>
<span class="nc bnc" id="L1068" title="All 4 branches missed.">        } else if (hostName.startsWith(&quot;-&quot;) || hostName.endsWith(&quot;-&quot;)) {</span>
<span class="nc" id="L1069">            s_logger.warn(&quot;Domain name label can not start  with a hyphen and digit, and must not end with a hyphen&quot;);</span>
<span class="nc" id="L1070">            return false;</span>
<span class="nc bnc" id="L1071" title="All 4 branches missed.">        } else if (isHostName &amp;&amp; hostName.matches(&quot;^[0-9-].*&quot;)) {</span>
<span class="nc" id="L1072">            s_logger.warn(&quot;Host name can't start with digit&quot;);</span>
<span class="nc" id="L1073">            return false;</span>
        }

<span class="nc" id="L1076">        return true;</span>
    }

    public static boolean verifyDomainName(final String domainName) {
        // don't allow domain name length to exceed 190 chars (190 + 63 (max host name length) = 253 = max domainName length
<span class="nc bnc" id="L1081" title="All 4 branches missed.">        if (domainName.length() &lt; 1 || domainName.length() &gt; 190) {</span>
<span class="nc" id="L1082">            s_logger.trace(&quot;Domain name must be between 1 and 190 characters long&quot;);</span>
<span class="nc" id="L1083">            return false;</span>
        }

<span class="nc bnc" id="L1086" title="All 4 branches missed.">        if (domainName.startsWith(&quot;.&quot;) || domainName.endsWith(&quot;.&quot;)) {</span>
<span class="nc" id="L1087">            s_logger.trace(&quot;Domain name can't start or end with .&quot;);</span>
<span class="nc" id="L1088">            return false;</span>
        }

<span class="nc" id="L1091">        final String[] domainNameLabels = domainName.split(&quot;\\.&quot;);</span>

<span class="nc bnc" id="L1093" title="All 2 branches missed.">        for (int i = 0; i &lt; domainNameLabels.length; i++) {</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">            if (!verifyDomainNameLabel(domainNameLabels[i], false)) {</span>
<span class="nc" id="L1095">                s_logger.warn(&quot;Domain name label &quot; + domainNameLabels[i] + &quot; is incorrect&quot;);</span>
<span class="nc" id="L1096">                return false;</span>
            }
        }

<span class="nc" id="L1100">        return true;</span>
    }

    public static String getDhcpRange(final String cidr) {
<span class="nc" id="L1104">        final String[] splitResult = cidr.split(&quot;\\/&quot;);</span>
<span class="nc" id="L1105">        final long size = Long.parseLong(splitResult[1]);</span>
<span class="nc" id="L1106">        return NetUtils.getIpRangeStartIpFromCidr(splitResult[0], size);</span>
    }

    // Check if 2 CIDRs have exactly same IP Range
    public static boolean isSameIpRange(final String cidrA, final String cidrB) {

<span class="nc bnc" id="L1112" title="All 2 branches missed.">        if (!NetUtils.isValidCIDR(cidrA)) {</span>
<span class="nc" id="L1113">            s_logger.info(&quot;Invalid value of cidr &quot; + cidrA);</span>
<span class="nc" id="L1114">            return false;</span>
        }
<span class="nc bnc" id="L1116" title="All 2 branches missed.">        if (!NetUtils.isValidCIDR(cidrB)) {</span>
<span class="nc" id="L1117">            s_logger.info(&quot;Invalid value of cidr &quot; + cidrB);</span>
<span class="nc" id="L1118">            return false;</span>
        }
<span class="nc" id="L1120">        final String[] cidrPairFirst = cidrA.split(&quot;\\/&quot;);</span>
<span class="nc" id="L1121">        final String[] cidrPairSecond = cidrB.split(&quot;\\/&quot;);</span>

<span class="nc" id="L1123">        final Long networkSizeFirst = Long.valueOf(cidrPairFirst[1]);</span>
<span class="nc" id="L1124">        final Long networkSizeSecond = Long.valueOf(cidrPairSecond[1]);</span>
<span class="nc" id="L1125">        final String ipRangeFirst[] = NetUtils.getIpRangeFromCidr(cidrPairFirst[0], networkSizeFirst);</span>
<span class="nc" id="L1126">        final String ipRangeSecond[] = NetUtils.getIpRangeFromCidr(cidrPairFirst[0], networkSizeSecond);</span>

<span class="nc" id="L1128">        final long startIpFirst = NetUtils.ip2Long(ipRangeFirst[0]);</span>
<span class="nc" id="L1129">        final long endIpFirst = NetUtils.ip2Long(ipRangeFirst[1]);</span>
<span class="nc" id="L1130">        final long startIpSecond = NetUtils.ip2Long(ipRangeSecond[0]);</span>
<span class="nc" id="L1131">        final long endIpSecond = NetUtils.ip2Long(ipRangeSecond[1]);</span>
<span class="nc bnc" id="L1132" title="All 4 branches missed.">        if (startIpFirst == startIpSecond &amp;&amp; endIpFirst == endIpSecond) {</span>
<span class="nc" id="L1133">            return true;</span>
        }
<span class="nc" id="L1135">        return false;</span>
    }

    public static boolean validateGuestCidr(final String cidr) {
        // RFC 1918 - The Internet Assigned Numbers Authority (IANA) has reserved the
        // following three blocks of the IP address space for private internets:
        // 10.0.0.0 - 10.255.255.255 (10/8 prefix)
        // 172.16.0.0 - 172.31.255.255 (172.16/12 prefix)
        // 192.168.0.0 - 192.168.255.255 (192.168/16 prefix)

<span class="nc" id="L1145">        final String cidr1 = &quot;10.0.0.0/8&quot;;</span>
<span class="nc" id="L1146">        final String cidr2 = &quot;172.16.0.0/12&quot;;</span>
<span class="nc" id="L1147">        final String cidr3 = &quot;192.168.0.0/16&quot;;</span>

<span class="nc bnc" id="L1149" title="All 2 branches missed.">        if (!isValidCIDR(cidr)) {</span>
<span class="nc" id="L1150">            s_logger.warn(&quot;Cidr &quot; + cidr + &quot; is not valid&quot;);</span>
<span class="nc" id="L1151">            return false;</span>
        }

<span class="nc bnc" id="L1154" title="All 6 branches missed.">        if (isNetworkAWithinNetworkB(cidr, cidr1) || isNetworkAWithinNetworkB(cidr, cidr2) || isNetworkAWithinNetworkB(cidr, cidr3)) {</span>
<span class="nc" id="L1155">            return true;</span>
        } else {
<span class="nc" id="L1157">            s_logger.warn(&quot;cidr &quot; + cidr + &quot; is not RFC 1918 compliant&quot;);</span>
<span class="nc" id="L1158">            return false;</span>
        }
    }

    public static boolean verifyInstanceName(final String instanceName) {
        //instance name for cloudstack vms shouldn't contain - and spaces
<span class="nc bnc" id="L1164" title="All 6 branches missed.">        if (instanceName.contains(&quot;-&quot;) || instanceName.contains(&quot; &quot;) || instanceName.contains(&quot;+&quot;)) {</span>
<span class="nc" id="L1165">            s_logger.warn(&quot;Instance name can not contain hyphen, spaces and \&quot;+\&quot; char&quot;);</span>
<span class="nc" id="L1166">            return false;</span>
        }

<span class="nc" id="L1169">        return true;</span>
    }

    public static boolean isNetworksOverlap(final String cidrA, final String cidrB) {
        try {
<span class="nc" id="L1174">            Long[] cidrALong = cidrToLong(cidrA);</span>
<span class="nc" id="L1175">            Long[] cidrBLong = cidrToLong(cidrB);</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">            final long shift = MAX_CIDR - (cidrALong[1] &gt; cidrBLong[1] ? cidrBLong[1] : cidrALong[1]);</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">            return cidrALong[0] &gt;&gt; shift == cidrBLong[0] &gt;&gt; shift;</span>
<span class="nc" id="L1178">        } catch (CloudRuntimeException e) {</span>
<span class="nc" id="L1179">            s_logger.error(e.getLocalizedMessage(),e);</span>
        }
<span class="nc" id="L1181">        return false;</span>
    }

    public static boolean isValidS2SVpnPolicy(final String policys) {
<span class="nc bnc" id="L1185" title="All 4 branches missed.">        if (policys == null || policys.isEmpty()) {</span>
<span class="nc" id="L1186">            return false;</span>
        }
<span class="nc bnc" id="L1188" title="All 2 branches missed.">        for (final String policy : policys.split(&quot;,&quot;)) {</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">            if (policy.isEmpty()) {</span>
<span class="nc" id="L1190">                return false;</span>
            }
<span class="nc" id="L1192">            final String cipherHash = policy.split(&quot;;&quot;)[0];</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            if (cipherHash.isEmpty()) {</span>
<span class="nc" id="L1194">                return false;</span>
            }
<span class="nc" id="L1196">            final String[] list = cipherHash.split(&quot;-&quot;);</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">            if (list.length != 2) {</span>
<span class="nc" id="L1198">                return false;</span>
            }
<span class="nc" id="L1200">            final String cipher = list[0];</span>
<span class="nc" id="L1201">            final String hash = list[1];</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">            if (!cipher.matches(&quot;3des|aes128|aes192|aes256&quot;)) {</span>
<span class="nc" id="L1203">                return false;</span>
            }
<span class="nc bnc" id="L1205" title="All 2 branches missed.">            if (!hash.matches(&quot;md5|sha1&quot;)) {</span>
<span class="nc" id="L1206">                return false;</span>
            }
<span class="nc" id="L1208">            String pfsGroup = null;</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">            if (!policy.equals(cipherHash)) {</span>
<span class="nc" id="L1210">                pfsGroup = policy.split(&quot;;&quot;)[1];</span>
            }
<span class="nc bnc" id="L1212" title="All 4 branches missed.">            if (pfsGroup != null &amp;&amp; !pfsGroup.matches(&quot;modp1024|modp1536&quot;)) {</span>
<span class="nc" id="L1213">                return false;</span>
            }
        }
<span class="nc" id="L1216">        return true;</span>
    }

    public static boolean isValidCidrList(final String cidrList) {
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        for (final String guestCidr : cidrList.split(&quot;,&quot;)) {</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">            if (!isValidCIDR(guestCidr)) {</span>
<span class="nc" id="L1222">                return false;</span>
            }
        }
<span class="nc" id="L1225">        return true;</span>
    }

    public static boolean validateGuestCidrList(final String guestCidrList) {
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        for (final String guestCidr : guestCidrList.split(&quot;,&quot;)) {</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">            if (!validateGuestCidr(guestCidr)) {</span>
<span class="nc" id="L1231">                return false;</span>
            }
        }
<span class="nc" id="L1234">        return true;</span>
    }

    public static boolean validateIcmpType(final long icmpType) {
        //Source - http://www.erg.abdn.ac.uk/~gorry/course/inet-pages/icmp-code.html
<span class="nc bnc" id="L1239" title="All 4 branches missed.">        if (!(icmpType &gt;= 0 &amp;&amp; icmpType &lt;= 255)) {</span>
<span class="nc" id="L1240">            s_logger.warn(&quot;impcType is not within 0-255 range&quot;);</span>
<span class="nc" id="L1241">            return false;</span>
        }
<span class="nc" id="L1243">        return true;</span>
    }

    public static boolean validateIcmpCode(final long icmpCode) {

        //Source - http://www.erg.abdn.ac.uk/~gorry/course/inet-pages/icmp-code.html
<span class="nc bnc" id="L1249" title="All 4 branches missed.">        if (!(icmpCode &gt;= 0 &amp;&amp; icmpCode &lt;= 15)) {</span>
<span class="nc" id="L1250">            s_logger.warn(&quot;Icmp code should be within 0-15 range&quot;);</span>
<span class="nc" id="L1251">            return false;</span>
        }

<span class="nc" id="L1254">        return true;</span>
    }

    public static boolean isValidIpv6(final String ip) {
        try {
<span class="nc" id="L1259">            IPv6Address.fromString(ip);</span>
<span class="nc" id="L1260">        } catch (final IllegalArgumentException ex) {</span>
<span class="nc" id="L1261">            return false;</span>
        }
<span class="nc" id="L1263">        return true;</span>
    }

    public static boolean isValidIp6Cidr(final String ip6Cidr) {
        try {
<span class="nc" id="L1268">            IPv6Network.fromString(ip6Cidr);</span>
<span class="nc" id="L1269">        } catch (final IllegalArgumentException ex) {</span>
<span class="nc" id="L1270">            return false;</span>
        }
<span class="nc" id="L1272">        return true;</span>
    }

    public static int getIp6CidrSize(final String ip6Cidr) {
<span class="nc" id="L1276">        IPv6Network network = null;</span>
        try {
<span class="nc" id="L1278">            network = IPv6Network.fromString(ip6Cidr);</span>
<span class="nc" id="L1279">        } catch (final IllegalArgumentException ex) {</span>
<span class="nc" id="L1280">            return 0;</span>
        }
<span class="nc" id="L1282">        return network.getNetmask().asPrefixLength();</span>
    }

    // Can cover 127 bits
    public static String getIp6FromRange(final String ip6Range) {
<span class="nc" id="L1287">        final String[] ips = ip6Range.split(&quot;-&quot;);</span>
<span class="nc" id="L1288">        final String startIp = ips[0];</span>
<span class="nc" id="L1289">        final IPv6Address start = IPv6Address.fromString(startIp);</span>
<span class="nc" id="L1290">        final BigInteger gap = countIp6InRange(ip6Range);</span>
<span class="nc" id="L1291">        BigInteger next = new BigInteger(gap.bitLength(), s_rand);</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">        while (next.compareTo(gap) &gt;= 0) {</span>
<span class="nc" id="L1293">            next = new BigInteger(gap.bitLength(), s_rand);</span>
        }
<span class="nc" id="L1295">        InetAddress resultAddr = null;</span>
<span class="nc" id="L1296">        final BigInteger startInt = convertIPv6AddressToBigInteger(start);</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">        if (startInt != null) {</span>
<span class="nc" id="L1298">            final BigInteger resultInt = startInt.add(next);</span>
            try {
<span class="nc" id="L1300">                resultAddr = InetAddress.getByAddress(resultInt.toByteArray());</span>
<span class="nc" id="L1301">            } catch (final UnknownHostException e) {</span>
<span class="nc" id="L1302">                return null;</span>
            }
        }
<span class="nc bnc" id="L1305" title="All 2 branches missed.">        if( resultAddr != null) {</span>
<span class="nc" id="L1306">            final IPv6Address ip = IPv6Address.fromInetAddress(resultAddr);</span>
<span class="nc" id="L1307">            return ip.toString();</span>
        }
<span class="nc" id="L1309">        return null;</span>
    }

    //RFC3315, section 9.4
    public static String getDuidLL(final String macAddress) {
<span class="nc" id="L1314">        final String duid = &quot;00:03:00:01:&quot; + macAddress;</span>
<span class="nc" id="L1315">        return duid;</span>
    }

    private static BigInteger convertIPv6AddressToBigInteger(final IPv6Address addr) {
        InetAddress inetAddr;
        try {
<span class="nc" id="L1321">            inetAddr = addr.toInetAddress();</span>
<span class="nc" id="L1322">        } catch (final UnknownHostException e) {</span>
<span class="nc" id="L1323">            return null;</span>
        }
<span class="nc" id="L1325">        return new BigInteger(inetAddr.getAddress());</span>
    }

    // Can cover 127 bits
    public static BigInteger countIp6InRange(final String ip6Range) {
<span class="nc bnc" id="L1330" title="All 2 branches missed.">        if (ip6Range == null) {</span>
<span class="nc" id="L1331">            return null;</span>
        }
<span class="nc" id="L1333">        final String[] ips = ip6Range.split(&quot;-&quot;);</span>
<span class="nc" id="L1334">        final String startIp = ips[0];</span>
<span class="nc" id="L1335">        String endIp = ips[0];</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">        if (ips.length &gt; 1) {</span>
<span class="nc" id="L1337">            endIp = ips[1];</span>
        }
        try {
<span class="nc" id="L1340">            final BigInteger startInt = convertIPv6AddressToBigInteger(IPv6Address.fromString(startIp));</span>
<span class="nc" id="L1341">            final BigInteger endInt = convertIPv6AddressToBigInteger(IPv6Address.fromString(endIp));</span>
<span class="nc bnc" id="L1342" title="All 6 branches missed.">            if (endInt != null &amp;&amp; startInt != null &amp;&amp; startInt.compareTo(endInt) &lt;= 0) {</span>
<span class="nc" id="L1343">                return endInt.subtract(startInt).add(BigInteger.ONE);</span>
            }
<span class="nc" id="L1345">        } catch (final IllegalArgumentException ex) {</span>
<span class="nc" id="L1346">            s_logger.error(&quot;Failed to convert a string to an IPv6 address&quot;, ex);</span>
        }
<span class="nc" id="L1348">        return null;</span>
    }

    public static boolean isIp6InRange(final String ip6, final String ip6Range) {
<span class="nc bnc" id="L1352" title="All 2 branches missed.">        if (ip6Range == null) {</span>
<span class="nc" id="L1353">            return false;</span>
        }
<span class="nc" id="L1355">        final String[] ips = ip6Range.split(&quot;-&quot;);</span>
<span class="nc" id="L1356">        final String startIp = ips[0];</span>
<span class="nc" id="L1357">        String endIp = null;</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">        if (ips.length &gt; 1) {</span>
<span class="nc" id="L1359">            endIp = ips[1];</span>
        }
<span class="nc" id="L1361">        final IPv6Address start = IPv6Address.fromString(startIp);</span>
<span class="nc" id="L1362">        final IPv6Address end = IPv6Address.fromString(endIp);</span>
<span class="nc" id="L1363">        final IPv6Address ip = IPv6Address.fromString(ip6);</span>
<span class="nc bnc" id="L1364" title="All 4 branches missed.">        if (start.compareTo(ip) &lt;= 0 &amp;&amp; end.compareTo(ip) &gt;= 0) {</span>
<span class="nc" id="L1365">            return true;</span>
        }
<span class="nc" id="L1367">        return false;</span>
    }

    public static boolean isIp6InNetwork(final String ip6, final String ip6Cidr) {
<span class="nc" id="L1371">        IPv6Network network = null;</span>
        try {
<span class="nc" id="L1373">            network = IPv6Network.fromString(ip6Cidr);</span>
<span class="nc" id="L1374">        } catch (final IllegalArgumentException ex) {</span>
<span class="nc" id="L1375">            return false;</span>
        }
<span class="nc" id="L1377">        final IPv6Address ip = IPv6Address.fromString(ip6);</span>
<span class="nc" id="L1378">        return network.contains(ip);</span>
    }

    public static boolean isIp6RangeOverlap(final String ipRange1, final String ipRange2) {
<span class="nc" id="L1382">        String[] ips = ipRange1.split(&quot;-&quot;);</span>
<span class="nc" id="L1383">        final String startIp1 = ips[0];</span>
<span class="nc" id="L1384">        String endIp1 = null;</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">        if (ips.length &gt; 1) {</span>
<span class="nc" id="L1386">            endIp1 = ips[1];</span>
        }
<span class="nc" id="L1388">        final IPv6Address start1 = IPv6Address.fromString(startIp1);</span>
<span class="nc" id="L1389">        final IPv6Address end1 = IPv6Address.fromString(endIp1);</span>
<span class="nc" id="L1390">        final IPv6AddressRange range1 = IPv6AddressRange.fromFirstAndLast(start1, end1);</span>
<span class="nc" id="L1391">        ips = ipRange2.split(&quot;-&quot;);</span>
<span class="nc" id="L1392">        final String startIp2 = ips[0];</span>
<span class="nc" id="L1393">        String endIp2 = null;</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">        if (ips.length &gt; 1) {</span>
<span class="nc" id="L1395">            endIp2 = ips[1];</span>
        }
<span class="nc" id="L1397">        final IPv6Address start2 = IPv6Address.fromString(startIp2);</span>
<span class="nc" id="L1398">        final IPv6Address end2 = IPv6Address.fromString(endIp2);</span>
<span class="nc" id="L1399">        final IPv6AddressRange range2 = IPv6AddressRange.fromFirstAndLast(start2, end2);</span>
<span class="nc" id="L1400">        return range1.overlaps(range2);</span>
    }

    public static String getNextIp6InRange(final String currentIp, final String ipRange) {
<span class="nc" id="L1404">        final String[] ips = ipRange.split(&quot;-&quot;);</span>
<span class="nc" id="L1405">        final String startIp = ips[0];</span>
<span class="nc" id="L1406">        String endIp = null;</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">        if (ips.length &gt; 1) {</span>
<span class="nc" id="L1408">            endIp = ips[1];</span>
        }
<span class="nc" id="L1410">        final IPv6Address start = IPv6Address.fromString(startIp);</span>
<span class="nc" id="L1411">        final IPv6Address end = IPv6Address.fromString(endIp);</span>
<span class="nc" id="L1412">        final IPv6Address current = IPv6Address.fromString(currentIp);</span>
<span class="nc" id="L1413">        IPv6Address result = null;</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">        if (current.equals(end)) {</span>
<span class="nc" id="L1415">            result = start;</span>
<span class="nc" id="L1416">        } else {</span>
<span class="nc" id="L1417">            result = current.add(1);</span>
        }
<span class="nc" id="L1419">        String resultIp = null;</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L1421">            resultIp = result.toString();</span>
        }
<span class="nc" id="L1423">        return resultIp;</span>
    }

    public static String standardizeIp6Address(final String ip6Addr) {
        try {
<span class="nc" id="L1428">            return IPv6Address.fromString(ip6Addr).toString();</span>
<span class="nc" id="L1429">        } catch (final IllegalArgumentException ex) {</span>
<span class="nc" id="L1430">            throw new IllegalArgumentException(&quot;Invalid IPv6 address: &quot; + ex.getMessage());</span>
        }
    }

    public static String standardizeIp6Cidr(final String ip6Cidr){
        try {
<span class="nc" id="L1436">            return IPv6Network.fromString(ip6Cidr).toString();</span>
<span class="nc" id="L1437">        } catch (final IllegalArgumentException ex) {</span>
<span class="nc" id="L1438">            throw new IllegalArgumentException(&quot;Invalid IPv6 CIDR: &quot; + ex.getMessage());</span>
        }
    }

    static final String VLAN_PREFIX = &quot;vlan://&quot;;
<span class="fc" id="L1443">    static final int VLAN_PREFIX_LENGTH = VLAN_PREFIX.length();</span>

    public static boolean isValidVlan(String vlan) {
<span class="nc bnc" id="L1446" title="All 4 branches missed.">        if (null == vlan || &quot;&quot;.equals(vlan)) {</span>
<span class="nc" id="L1447">            return false;</span>
        }
<span class="nc bnc" id="L1449" title="All 2 branches missed.">        if (vlan.startsWith(VLAN_PREFIX)) {</span>
<span class="nc" id="L1450">            vlan = vlan.substring(VLAN_PREFIX_LENGTH);</span>
        }
        try {
<span class="nc" id="L1453">            final int vnet = Integer.parseInt(vlan);</span>
<span class="nc bnc" id="L1454" title="All 4 branches missed.">            if (vnet &lt;= 0 || vnet &gt;= 4095) { // the valid range is 1- 4094</span>
<span class="nc" id="L1455">                return false;</span>
            }
<span class="nc" id="L1457">            return true;</span>
<span class="nc" id="L1458">        } catch (final NumberFormatException e) {</span>
<span class="nc" id="L1459">            return false;</span>
        }
    }

<span class="fc" id="L1463">    static final String VLAN_UNTAGGED = &quot;untagged&quot;;</span>

    public static boolean isSameIsolationId(String one, String other) {
        // check nulls
        // check empty strings
<span class="nc bnc" id="L1468" title="All 8 branches missed.">        if ((one == null || one.isEmpty()) &amp;&amp; (other == null || other.isEmpty())) {</span>
<span class="nc" id="L1469">            return true;</span>
        }
<span class="nc bnc" id="L1471" title="All 4 branches missed.">        if (one == null || other == null) {</span>
<span class="nc" id="L1472">            return false;</span>
        }
        // check 'untagged'
<span class="nc bnc" id="L1475" title="All 4 branches missed.">        if (one.contains(VLAN_UNTAGGED) &amp;&amp; other.contains(VLAN_UNTAGGED)) {</span>
<span class="nc" id="L1476">            return true;</span>
        }
        // if one is a number check the other as number and as 'vlan://' + number
<span class="nc bnc" id="L1479" title="All 2 branches missed.">        if (one.startsWith(VLAN_PREFIX)) {</span>
<span class="nc" id="L1480">            one = one.substring(VLAN_PREFIX_LENGTH);</span>
        }
<span class="nc bnc" id="L1482" title="All 2 branches missed.">        if (other.startsWith(VLAN_PREFIX)) {</span>
<span class="nc" id="L1483">            other = other.substring(VLAN_PREFIX_LENGTH);</span>
        }
        // check valid uris or numbers
<span class="nc bnc" id="L1486" title="All 2 branches missed.">        if (one.equalsIgnoreCase(other)) {</span>
<span class="nc" id="L1487">            return true;</span>
        }

<span class="nc" id="L1490">        return false;</span>
    }

    // Attention maintainers: these pvlan functions should take into account code
    // in Networks.BroadcastDomainType, where URI construction is done for other
    // types of BroadcastDomainTypes
    public static URI generateUriForPvlan(final String primaryVlan, final String isolatedPvlan) {
<span class="nc" id="L1497">        return URI.create(&quot;pvlan://&quot; + primaryVlan + &quot;-i&quot; + isolatedPvlan);</span>
    }

    public static String getPrimaryPvlanFromUri(final URI uri) {
<span class="nc" id="L1501">        final String[] vlans = uri.getHost().split(&quot;-&quot;);</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">        if (vlans.length &lt; 1) {</span>
<span class="nc" id="L1503">            return null;</span>
        }
<span class="nc" id="L1505">        return vlans[0];</span>
    }

    public static String getIsolatedPvlanFromUri(final URI uri) {
<span class="nc" id="L1509">        final String[] vlans = uri.getHost().split(&quot;-&quot;);</span>
<span class="nc bnc" id="L1510" title="All 2 branches missed.">        if (vlans.length &lt; 2) {</span>
<span class="nc" id="L1511">            return null;</span>
        }
<span class="nc bnc" id="L1513" title="All 2 branches missed.">        for (final String vlan : vlans) {</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">            if (vlan.startsWith(&quot;i&quot;)) {</span>
<span class="nc" id="L1515">                return vlan.replace(&quot;i&quot;, &quot; &quot;).trim();</span>
            }
        }
<span class="nc" id="L1518">        return null;</span>
    }

    public static String generateMacOnIncrease(final String baseMac, final long l) {
<span class="nc" id="L1522">        long mac = mac2Long(baseMac);</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">        if (l &gt; 0xFFFFl) {</span>
<span class="nc" id="L1524">            return null;</span>
        }
<span class="nc" id="L1526">        mac = mac + (l &lt;&lt; 24);</span>
<span class="nc" id="L1527">        mac = mac &amp; 0x06FFFFFFFFFFl;</span>
<span class="nc" id="L1528">        return long2Mac(mac);</span>
    }

    public static boolean isIpWithtInCidrRange(final String ipAddress, final String cidr) {
<span class="nc bnc" id="L1532" title="All 2 branches missed.">        if (!isValidIp(ipAddress)) {</span>
<span class="nc" id="L1533">            return false;</span>
        }
<span class="nc bnc" id="L1535" title="All 2 branches missed.">        if (!isValidCIDR(cidr)) {</span>
<span class="nc" id="L1536">            return false;</span>
        }

        // check if the gatewayip is the part of the ip range being added.
        // RFC 3021 - 31-Bit Prefixes on IPv4 Point-to-Point Links
        //     GW              Netmask         Stat IP        End IP
        // 192.168.24.0 - 255.255.255.254 - 192.168.24.0 - 192.168.24.1
        // https://tools.ietf.org/html/rfc3021
        // Added by Wilder Rodrigues
<span class="nc" id="L1545">        final SubnetUtils subnetUtils = new SubnetUtils(cidr);</span>
<span class="nc" id="L1546">        subnetUtils.setInclusiveHostCount(true);</span>

<span class="nc" id="L1548">        final boolean isInRange = subnetUtils.getInfo().isInRange(ipAddress);</span>

<span class="nc" id="L1550">        return isInRange;</span>
    }

    public static Boolean IsIpEqualToNetworkOrBroadCastIp(final String requestedIp, final String cidr, final long size) {
<span class="nc bnc" id="L1554" title="All 4 branches missed.">        assert size &lt; MAX_CIDR : &quot;You do know this is not for ipv6 right?  Keep it smaller than 32 but you have &quot; + size;</span>

<span class="nc" id="L1556">        final long ip = ip2Long(cidr);</span>
<span class="nc" id="L1557">        final long startNetMask = ip2Long(getCidrNetmask(size));</span>

<span class="nc" id="L1559">        final long start = ip &amp; startNetMask;</span>
<span class="nc" id="L1560">        long end = start;</span>

<span class="nc" id="L1562">        end = end &gt;&gt; MAX_CIDR - size;</span>

<span class="nc" id="L1564">        end++;</span>
<span class="nc" id="L1565">        end = (end &lt;&lt; MAX_CIDR - size) - 1;</span>

<span class="nc" id="L1567">        final long reqIp = ip2Long(requestedIp);</span>
<span class="nc bnc" id="L1568" title="All 4 branches missed.">        if (reqIp == start || reqIp == end) {</span>
<span class="nc" id="L1569">            return true;</span>
        }
<span class="nc" id="L1571">        return false;</span>
    }
    public static boolean isNetworkorBroadcastIP(String ip, String netmask){
<span class="nc" id="L1574">        String cidr = getCidrFromGatewayAndNetmask(ip,netmask);</span>
<span class="nc" id="L1575">        final SubnetUtils subnetUtils = new SubnetUtils(cidr);</span>
<span class="nc" id="L1576">        subnetUtils.setInclusiveHostCount(false);</span>
<span class="nc" id="L1577">        final boolean isInRange = subnetUtils.getInfo().isInRange(ip);</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">        return !isInRange;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>cloud-core (18-mrt-2016 13:14:54)</div></body></html>