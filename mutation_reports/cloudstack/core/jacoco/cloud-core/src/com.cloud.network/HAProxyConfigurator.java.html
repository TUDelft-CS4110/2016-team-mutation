<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>HAProxyConfigurator.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">cloud-core (18-mrt-2016 13:14:54)</a> &gt; <a href="../../index.html" class="el_group">cloud-core</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">com.cloud.network</a> &gt; <span class="el_source">HAProxyConfigurator.java</span></div><h1>HAProxyConfigurator.java</h1><pre class="source lang-java linenums">//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// &quot;License&quot;); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//

package com.cloud.network;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;

import com.cloud.agent.api.routing.LoadBalancerConfigCommand;
import com.cloud.agent.api.to.LoadBalancerTO;
import com.cloud.agent.api.to.LoadBalancerTO.DestinationTO;
import com.cloud.agent.api.to.LoadBalancerTO.StickinessPolicyTO;
import com.cloud.agent.api.to.PortForwardingRuleTO;
import com.cloud.network.rules.LbStickinessMethod.StickinessMethodType;
import com.cloud.utils.Pair;
import com.cloud.utils.net.NetUtils;

<span class="fc" id="L41">public class HAProxyConfigurator implements LoadBalancerConfigurator {</span>

<span class="fc" id="L43">    private static final Logger s_logger = Logger.getLogger(HAProxyConfigurator.class);</span>
    private static final String blankLine = &quot;\t &quot;;
<span class="fc" id="L45">    private static String[] globalSection = {&quot;global&quot;, &quot;\tlog 127.0.0.1:3914   local0 warning&quot;, &quot;\tmaxconn 4096&quot;, &quot;\tmaxpipes 1024&quot;, &quot;\tchroot /var/lib/haproxy&quot;,</span>
<span class="fc" id="L46">        &quot;\tuser haproxy&quot;, &quot;\tgroup haproxy&quot;, &quot;\tdaemon&quot;};</span>

<span class="fc" id="L48">    private static String[] defaultsSection = {&quot;defaults&quot;, &quot;\tlog     global&quot;, &quot;\tmode    tcp&quot;, &quot;\toption  dontlognull&quot;, &quot;\tretries 3&quot;, &quot;\toption redispatch&quot;,</span>
<span class="fc" id="L49">        &quot;\toption forwardfor&quot;, &quot;\toption forceclose&quot;, &quot;\ttimeout connect    5000&quot;, &quot;\ttimeout client     50000&quot;, &quot;\ttimeout server     50000&quot;};</span>

<span class="fc" id="L51">    private static String[] defaultListen = {&quot;listen  vmops 0.0.0.0:9&quot;, &quot;\toption transparent&quot;};</span>

    @Override
    public String[] generateConfiguration(final List&lt;PortForwardingRuleTO&gt; fwRules) {
        // Group the rules by publicip:publicport
<span class="nc" id="L56">        final Map&lt;String, List&lt;PortForwardingRuleTO&gt;&gt; pools = new HashMap&lt;String, List&lt;PortForwardingRuleTO&gt;&gt;();</span>

<span class="nc bnc" id="L58" title="All 2 branches missed.">        for (final PortForwardingRuleTO rule : fwRules) {</span>
<span class="nc" id="L59">            final StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L60">            final String poolName = sb.append(rule.getSrcIp().replace(&quot;.&quot;, &quot;_&quot;)).append('-').append(rule.getSrcPortRange()[0]).toString();</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">            if (!rule.revoked()) {</span>
<span class="nc" id="L62">                List&lt;PortForwardingRuleTO&gt; fwList = pools.get(poolName);</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">                if (fwList == null) {</span>
<span class="nc" id="L64">                    fwList = new ArrayList&lt;PortForwardingRuleTO&gt;();</span>
<span class="nc" id="L65">                    pools.put(poolName, fwList);</span>
                }
<span class="nc" id="L67">                fwList.add(rule);</span>
            }
        }

<span class="nc" id="L71">        final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>

<span class="nc" id="L73">        result.addAll(Arrays.asList(globalSection));</span>
<span class="nc" id="L74">        result.add(blankLine);</span>
<span class="nc" id="L75">        result.addAll(Arrays.asList(defaultsSection));</span>
<span class="nc" id="L76">        result.add(blankLine);</span>

<span class="nc bnc" id="L78" title="All 2 branches missed.">        if (pools.isEmpty()) {</span>
            // haproxy cannot handle empty listen / frontend or backend, so add
            // a dummy listener
            // on port 9
<span class="nc" id="L82">            result.addAll(Arrays.asList(defaultListen));</span>
        }
<span class="nc" id="L84">        result.add(blankLine);</span>

<span class="nc bnc" id="L86" title="All 2 branches missed.">        for (final Map.Entry&lt;String, List&lt;PortForwardingRuleTO&gt;&gt; e : pools.entrySet()) {</span>
<span class="nc" id="L87">            final List&lt;String&gt; poolRules = getRulesForPool(e.getKey(), e.getValue());</span>
<span class="nc" id="L88">            result.addAll(poolRules);</span>
        }

<span class="nc" id="L91">        return result.toArray(new String[result.size()]);</span>
    }

    private List&lt;String&gt; getRulesForPool(final String poolName, final List&lt;PortForwardingRuleTO&gt; fwRules) {
<span class="nc" id="L95">        final PortForwardingRuleTO firstRule = fwRules.get(0);</span>
<span class="nc" id="L96">        final String publicIP = firstRule.getSrcIp();</span>
<span class="nc" id="L97">        final String publicPort = Integer.toString(firstRule.getSrcPortRange()[0]);</span>
        // FIXEME: String algorithm = firstRule.getAlgorithm();

<span class="nc" id="L100">        final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
        // add line like this: &quot;listen  65_37_141_30-80 65.37.141.30:80&quot;
<span class="nc" id="L102">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L103">        sb.append(&quot;listen &quot;).append(poolName).append(&quot; &quot;).append(publicIP).append(&quot;:&quot;).append(publicPort);</span>
<span class="nc" id="L104">        result.add(sb.toString());</span>
<span class="nc" id="L105">        sb = new StringBuilder();</span>
        // FIXME sb.append(&quot;\t&quot;).append(&quot;balance &quot;).append(algorithm);
<span class="nc" id="L107">        result.add(sb.toString());</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (publicPort.equals(NetUtils.HTTP_PORT)</span>
                // &amp;&amp; global option httpclose set (or maybe not in this spot???)
                ) {
<span class="nc" id="L111">            sb = new StringBuilder();</span>
<span class="nc" id="L112">            sb.append(&quot;\t&quot;).append(&quot;mode http&quot;);</span>
<span class="nc" id="L113">            result.add(sb.toString());</span>
<span class="nc" id="L114">            sb = new StringBuilder();</span>
<span class="nc" id="L115">            sb.append(&quot;\t&quot;).append(&quot;option httpclose&quot;);</span>
<span class="nc" id="L116">            result.add(sb.toString());</span>
        }
<span class="nc" id="L118">        int i = 0;</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        for (final PortForwardingRuleTO rule : fwRules) {</span>
            // add line like this: &quot;server  65_37_141_30-80_3 10.1.1.4:80 check&quot;
<span class="nc bnc" id="L121" title="All 2 branches missed.">            if (rule.revoked()) {</span>
<span class="nc" id="L122">                continue;</span>
            }
<span class="nc" id="L124">            sb = new StringBuilder();</span>
<span class="nc" id="L125">            sb.append(&quot;\t&quot;)</span>
<span class="nc" id="L126">            .append(&quot;server &quot;)</span>
<span class="nc" id="L127">            .append(poolName)</span>
<span class="nc" id="L128">            .append(&quot;_&quot;)</span>
<span class="nc" id="L129">            .append(Integer.toString(i++))</span>
<span class="nc" id="L130">            .append(&quot; &quot;)</span>
<span class="nc" id="L131">            .append(rule.getDstIp())</span>
<span class="nc" id="L132">            .append(&quot;:&quot;)</span>
<span class="nc" id="L133">            .append(rule.getDstPortRange()[0])</span>
<span class="nc" id="L134">            .append(&quot; check&quot;);</span>
<span class="nc" id="L135">            result.add(sb.toString());</span>
        }
<span class="nc" id="L137">        result.add(blankLine);</span>
<span class="nc" id="L138">        return result;</span>
    }

    /*
    cookie &lt;name&gt; [ rewrite | insert | prefix ] [ indirect ] [ nocache ]
                [ postonly ] [ domain &lt;domain&gt; ]*
    Enable cookie-based persistence in a backend.
    May be used in sections :   defaults | frontend | listen | backend
                                   yes   |    no    |   yes  |   yes
    Arguments :
      &lt;name&gt;    is the name of the cookie which will be monitored, modified or
                inserted in order to bring persistence. This cookie is sent to
                the client via a &quot;Set-Cookie&quot; header in the response, and is
                brought back by the client in a &quot;Cookie&quot; header in all requests.
                Special care should be taken to choose a name which does not
                conflict with any likely application cookie. Also, if the same
                backends are subject to be used by the same clients (eg:
                HTTP/HTTPS), care should be taken to use different cookie names
                between all backends if persistence between them is not desired.

      rewrite   This keyword indicates that the cookie will be provided by the
                server and that haproxy will have to modify its value to set the
                server's identifier in it. This mode is handy when the management
                of complex combinations of &quot;Set-cookie&quot; and &quot;Cache-control&quot;
                headers is left to the application. The application can then
                decide whether or not it is appropriate to emit a persistence
                cookie. Since all responses should be monitored, this mode only
                works in HTTP close mode. Unless the application behaviour is
                very complex and/or broken, it is advised not to start with this
                mode for new deployments. This keyword is incompatible with
                &quot;insert&quot; and &quot;prefix&quot;.

      insert    This keyword indicates that the persistence cookie will have to
                be inserted by haproxy in the responses. If the server emits a
                cookie with the same name, it will be replaced anyway. For this
                reason, this mode can be used to upgrade existing configurations
                running in the &quot;rewrite&quot; mode. The cookie will only be a session
                cookie and will not be stored on the client's disk. Due to
                caching effects, it is generally wise to add the &quot;indirect&quot; and
                &quot;nocache&quot; or &quot;postonly&quot; keywords (see below). The &quot;insert&quot;
                keyword is not compatible with &quot;rewrite&quot; and &quot;prefix&quot;.

      prefix    This keyword indicates that instead of relying on a dedicated
                cookie for the persistence, an existing one will be completed.
                This may be needed in some specific environments where the client
                does not support more than one single cookie and the application
                already needs it. In this case, whenever the server sets a cookie
                named &lt;name&gt;, it will be prefixed with the server's identifier
                and a delimiter. The prefix will be removed from all client
                requests so that the server still finds the cookie it emitted.
                Since all requests and responses are subject to being modified,
                this mode requires the HTTP close mode. The &quot;prefix&quot; keyword is
                not compatible with &quot;rewrite&quot; and &quot;insert&quot;.

      indirect  When this option is specified in insert mode, cookies will only
                be added when the server was not reached after a direct access,
                which means that only when a server is elected after applying a
                load-balancing algorithm, or after a redispatch, then the cookie
                will be inserted. If the client has all the required information
                to connect to the same server next time, no further cookie will
                be inserted. In all cases, when the &quot;indirect&quot; option is used in
                insert mode, the cookie is always removed from the requests
                transmitted to the server. The persistence mechanism then becomes
                totally transparent from the application point of view.

      nocache   This option is recommended in conjunction with the insert mode
                when there is a cache between the client and HAProxy, as it
                ensures that a cacheable response will be tagged non-cacheable if
                a cookie needs to be inserted. This is important because if all
                persistence cookies are added on a cacheable home page for
                instance, then all customers will then fetch the page from an
                outer cache and will all share the same persistence cookie,
                leading to one server receiving much more traffic than others.
                See also the &quot;insert&quot; and &quot;postonly&quot; options.

      postonly  This option ensures that cookie insertion will only be performed
                on responses to POST requests. It is an alternative to the
                &quot;nocache&quot; option, because POST responses are not cacheable, so
                this ensures that the persistence cookie will never get cached.
                Since most sites do not need any sort of persistence before the
                first POST which generally is a login request, this is a very
                efficient method to optimize caching without risking to find a
                persistence cookie in the cache.
                See also the &quot;insert&quot; and &quot;nocache&quot; options.

      domain    This option allows to specify the domain at which a cookie is
                inserted. It requires exactly one parameter: a valid domain
                name. If the domain begins with a dot, the browser is allowed to
                use it for any host ending with that name. It is also possible to
                specify several domain names by invoking this option multiple
                times. Some browsers might have small limits on the number of
                domains, so be careful when doing that. For the record, sending
                10 domains to MSIE 6 or Firefox 2 works as expected.

    There can be only one persistence cookie per HTTP backend, and it can be
    declared in a defaults section. The value of the cookie will be the value
    indicated after the &quot;cookie&quot; keyword in a &quot;server&quot; statement. If no cookie
    is declared for a given server, the cookie is not set.

    Examples :
          cookie JSESSIONID prefix
          cookie SRV insert indirect nocache
          cookie SRV insert postonly indirect


    appsession &lt;cookie&gt; len &lt;length&gt; timeout &lt;holdtime&gt;
             [request-learn] [prefix] [mode &lt;path-parameters|query-string&gt;]
    Define session stickiness on an existing application cookie.
    May be used in sections :   defaults | frontend | listen | backend
                                   no    |    no    |   yes  |   yes
    Arguments :
      &lt;cookie&gt;   this is the name of the cookie used by the application and which
                 HAProxy will have to learn for each new session.

      &lt;length&gt;   this is the max number of characters that will be memorized and
                 checked in each cookie value.

      &lt;holdtime&gt; this is the time after which the cookie will be removed from
                 memory if unused. If no unit is specified, this time is in
                 milliseconds.

      request-learn
                 If this option is specified, then haproxy will be able to learn
                 the cookie found in the request in case the server does not
                 specify any in response. This is typically what happens with
                 PHPSESSID cookies, or when haproxy's session expires before
                 the application's session and the correct server is selected.
                 It is recommended to specify this option to improve reliability.

      prefix     When this option is specified, haproxy will match on the cookie
                 prefix (or URL parameter prefix). The appsession value is the
                 data following this prefix.

                 Example :
                 appsession ASPSESSIONID len 64 timeout 3h prefix

                 This will match the cookie ASPSESSIONIDXXXX=XXXXX,
                 the appsession value will be XXXX=XXXXX.

      mode       This option allows to change the URL parser mode.
                 2 modes are currently supported :
                 - path-parameters :
                   The parser looks for the appsession in the path parameters
                   part (each parameter is separated by a semi-colon), which is
                   convenient for JSESSIONID for example.
                   This is the default mode if the option is not set.
                 - query-string :
                   In this mode, the parser will look for the appsession in the
                   query string.

    When an application cookie is defined in a backend, HAProxy will check when
    the server sets such a cookie, and will store its value in a table, and
    associate it with the server's identifier. Up to &lt;length&gt; characters from
    the value will be retained. On each connection, haproxy will look for this
    cookie both in the &quot;Cookie:&quot; headers, and as a URL parameter (depending on
    the mode used). If a known value is found, the client will be directed to the
    server associated with this value. Otherwise, the load balancing algorithm is
    applied. Cookies are automatically removed from memory when they have been
    unused for a duration longer than &lt;holdtime&gt;.

    The definition of an application cookie is limited to one per backend.
    Example :
          appsession JSESSIONID len 52 timeout 3h
     */
    private String getLbSubRuleForStickiness(final LoadBalancerTO lbTO) {
<span class="fc" id="L303">        int i = 0;</span>

<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (lbTO.getStickinessPolicies() == null) {</span>
<span class="fc" id="L306">            return null;</span>
        }

<span class="nc" id="L309">        final StringBuilder sb = new StringBuilder();</span>

<span class="nc bnc" id="L311" title="All 2 branches missed.">        for (final StickinessPolicyTO stickinessPolicy : lbTO.getStickinessPolicies()) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (stickinessPolicy == null) {</span>
<span class="nc" id="L313">                continue;</span>
            }
<span class="nc" id="L315">            final List&lt;Pair&lt;String, String&gt;&gt; paramsList = stickinessPolicy.getParams();</span>
<span class="nc" id="L316">            i++;</span>

            /*
             * cookie &lt;name&gt; [ rewrite | insert | prefix ] [ indirect ] [ nocache ]
              [ postonly ] [ domain &lt;domain&gt; ]*

             */
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (StickinessMethodType.LBCookieBased.getName().equalsIgnoreCase(stickinessPolicy.getMethodName())) {</span>
                /* Default Values */
<span class="nc" id="L325">                String cookieName = null; // optional</span>
<span class="nc" id="L326">                String mode = &quot;insert &quot;; // optional</span>
<span class="nc" id="L327">                Boolean indirect = false; // optional</span>
<span class="nc" id="L328">                Boolean nocache = false; // optional</span>
<span class="nc" id="L329">                Boolean postonly = false; // optional</span>
<span class="nc" id="L330">                StringBuilder domainSb = null; // optional</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">                for (final Pair&lt;String, String&gt; paramKV : paramsList) {</span>
<span class="nc" id="L333">                    final String key = paramKV.first();</span>
<span class="nc" id="L334">                    final String value = paramKV.second();</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                    if (&quot;cookie-name&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L336">                        cookieName = value;</span>
                    }
<span class="nc bnc" id="L338" title="All 2 branches missed.">                    if (&quot;mode&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L339">                        mode = value;</span>
                    }
<span class="nc bnc" id="L341" title="All 2 branches missed.">                    if (&quot;domain&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                        if (domainSb == null) {</span>
<span class="nc" id="L343">                            domainSb = new StringBuilder();</span>
                        }
<span class="nc" id="L345">                        domainSb = domainSb.append(&quot;domain &quot;);</span>
<span class="nc" id="L346">                        domainSb.append(value).append(&quot; &quot;);</span>
                    }
<span class="nc bnc" id="L348" title="All 2 branches missed.">                    if (&quot;indirect&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L349">                        indirect = true;</span>
                    }
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (&quot;nocache&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L352">                        nocache = true;</span>
                    }
<span class="nc bnc" id="L354" title="All 2 branches missed.">                    if (&quot;postonly&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L355">                        postonly = true;</span>
                    }
                }
<span class="nc bnc" id="L358" title="All 2 branches missed.">                if (cookieName == null) {// re-check all haproxy mandatory params</span>
<span class="nc" id="L359">                    final StringBuilder tempSb = new StringBuilder();</span>
<span class="nc" id="L360">                    String srcip = lbTO.getSrcIp();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">                    if (srcip == null) {</span>
<span class="nc" id="L362">                        srcip = &quot;TESTCOOKIE&quot;;</span>
                    }
<span class="nc" id="L364">                    tempSb.append(&quot;lbcooki_&quot;).append(srcip.hashCode()).append(&quot;_&quot;).append(lbTO.getSrcPort());</span>
<span class="nc" id="L365">                    cookieName = tempSb.toString();</span>
                }
<span class="nc" id="L367">                sb.append(&quot;\t&quot;).append(&quot;cookie &quot;).append(cookieName).append(&quot; &quot;).append(mode).append(&quot; &quot;);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                if (indirect) {</span>
<span class="nc" id="L369">                    sb.append(&quot;indirect &quot;);</span>
                }
<span class="nc bnc" id="L371" title="All 2 branches missed.">                if (nocache) {</span>
<span class="nc" id="L372">                    sb.append(&quot;nocache &quot;);</span>
                }
<span class="nc bnc" id="L374" title="All 2 branches missed.">                if (postonly) {</span>
<span class="nc" id="L375">                    sb.append(&quot;postonly &quot;);</span>
                }
<span class="nc bnc" id="L377" title="All 2 branches missed.">                if (domainSb != null) {</span>
<span class="nc" id="L378">                    sb.append(domainSb).append(&quot; &quot;);</span>
                }
<span class="nc bnc" id="L380" title="All 2 branches missed.">            } else if (StickinessMethodType.SourceBased.getName().equalsIgnoreCase(stickinessPolicy.getMethodName())) {</span>
                /* Default Values */
<span class="nc" id="L382">                String tablesize = &quot;200k&quot;; // optional</span>
<span class="nc" id="L383">                String expire = &quot;30m&quot;; // optional</span>

                /* overwrite default values with the stick parameters */
<span class="nc bnc" id="L386" title="All 2 branches missed.">                for (final Pair&lt;String, String&gt; paramKV : paramsList) {</span>
<span class="nc" id="L387">                    final String key = paramKV.first();</span>
<span class="nc" id="L388">                    final String value = paramKV.second();</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                    if (&quot;tablesize&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L390">                        tablesize = value;</span>
                    }
<span class="nc bnc" id="L392" title="All 2 branches missed.">                    if (&quot;expire&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L393">                        expire = value;</span>
                    }
                }
<span class="nc" id="L396">                sb.append(&quot;\t&quot;).append(&quot;stick-table type ip size &quot;).append(tablesize).append(&quot; expire &quot;).append(expire);</span>
<span class="nc" id="L397">                sb.append(&quot;\n\t&quot;).append(&quot;stick on src&quot;);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            } else if (StickinessMethodType.AppCookieBased.getName().equalsIgnoreCase(stickinessPolicy.getMethodName())) {</span>
                /*
                 * FORMAT : appsession &lt;cookie&gt; len &lt;length&gt; timeout &lt;holdtime&gt;
                 * [request-learn] [prefix] [mode
                 * &lt;path-parameters|query-string&gt;]
                 */
                /* example: appsession JSESSIONID len 52 timeout 3h */
<span class="nc" id="L405">                String cookieName = null; // optional</span>
<span class="nc" id="L406">                String length = &quot;52&quot;; // optional</span>
<span class="nc" id="L407">                String holdtime = &quot;3h&quot;; // optional</span>
<span class="nc" id="L408">                String mode = null; // optional</span>
<span class="nc" id="L409">                Boolean requestlearn = false; // optional</span>
<span class="nc" id="L410">                Boolean prefix = false; // optional</span>

<span class="nc bnc" id="L412" title="All 2 branches missed.">                for (final Pair&lt;String, String&gt; paramKV : paramsList) {</span>
<span class="nc" id="L413">                    final String key = paramKV.first();</span>
<span class="nc" id="L414">                    final String value = paramKV.second();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                    if (&quot;cookie-name&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L416">                        cookieName = value;</span>
                    }
<span class="nc bnc" id="L418" title="All 2 branches missed.">                    if (&quot;length&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L419">                        length = value;</span>
                    }
<span class="nc bnc" id="L421" title="All 2 branches missed.">                    if (&quot;holdtime&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L422">                        holdtime = value;</span>
                    }
<span class="nc bnc" id="L424" title="All 2 branches missed.">                    if (&quot;mode&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L425">                        mode = value;</span>
                    }
<span class="nc bnc" id="L427" title="All 2 branches missed.">                    if (&quot;request-learn&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L428">                        requestlearn = true;</span>
                    }
<span class="nc bnc" id="L430" title="All 2 branches missed.">                    if (&quot;prefix&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L431">                        prefix = true;</span>
                    }
                }
<span class="nc bnc" id="L434" title="All 2 branches missed.">                if (cookieName == null) {// re-check all haproxy mandatory params</span>
<span class="nc" id="L435">                    final StringBuilder tempSb = new StringBuilder();</span>
<span class="nc" id="L436">                    String srcip = lbTO.getSrcIp();</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                    if (srcip == null) {</span>
<span class="nc" id="L438">                        srcip = &quot;TESTCOOKIE&quot;;</span>
                    }
<span class="nc" id="L440">                    tempSb.append(&quot;appcookie_&quot;).append(srcip.hashCode()).append(&quot;_&quot;).append(lbTO.getSrcPort());</span>
<span class="nc" id="L441">                    cookieName = tempSb.toString();</span>
                }
<span class="nc" id="L443">                sb.append(&quot;\t&quot;).append(&quot;appsession &quot;).append(cookieName).append(&quot; len &quot;).append(length).append(&quot; timeout &quot;).append(holdtime).append(&quot; &quot;);</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                if (prefix) {</span>
<span class="nc" id="L445">                    sb.append(&quot;prefix &quot;);</span>
                }
<span class="nc bnc" id="L447" title="All 2 branches missed.">                if (requestlearn) {</span>
<span class="nc" id="L448">                    sb.append(&quot;request-learn&quot;).append(&quot; &quot;);</span>
                }
<span class="nc bnc" id="L450" title="All 2 branches missed.">                if (mode != null) {</span>
<span class="nc" id="L451">                    sb.append(&quot;mode &quot;).append(mode).append(&quot; &quot;);</span>
                }
<span class="nc" id="L453">            } else {</span>
                /*
                 * Error is silently swallowed.
                 * Not supposed to reach here, validation of methods are
                 * done at the higher layer
                 */
<span class="nc" id="L459">                s_logger.warn(&quot;Haproxy stickiness policy for lb rule: &quot; + lbTO.getSrcIp() + &quot;:&quot; + lbTO.getSrcPort() + &quot;: Not Applied, cause:invalid method &quot;);</span>
<span class="nc" id="L460">                return null;</span>
            }
        }
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (i == 0) {</span>
<span class="nc" id="L464">            return null;</span>
        }
<span class="nc" id="L466">        return sb.toString();</span>
    }

    private List&lt;String&gt; getRulesForPool(final LoadBalancerTO lbTO, final boolean keepAliveEnabled) {
<span class="fc" id="L470">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L471">        final String poolName = sb.append(lbTO.getSrcIp().replace(&quot;.&quot;, &quot;_&quot;)).append('-').append(lbTO.getSrcPort()).toString();</span>
<span class="fc" id="L472">        final String publicIP = lbTO.getSrcIp();</span>
<span class="fc" id="L473">        final String publicPort = Integer.toString(lbTO.getSrcPort());</span>
<span class="fc" id="L474">        final String algorithm = lbTO.getAlgorithm();</span>

<span class="fc" id="L476">        final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
        // add line like this: &quot;listen  65_37_141_30-80 65.37.141.30:80&quot;
<span class="fc" id="L478">        sb = new StringBuilder();</span>
<span class="fc" id="L479">        sb.append(&quot;listen &quot;).append(poolName).append(&quot; &quot;).append(publicIP).append(&quot;:&quot;).append(publicPort);</span>
<span class="fc" id="L480">        result.add(sb.toString());</span>
<span class="fc" id="L481">        sb = new StringBuilder();</span>
<span class="fc" id="L482">        sb.append(&quot;\t&quot;).append(&quot;balance &quot;).append(algorithm);</span>
<span class="fc" id="L483">        result.add(sb.toString());</span>

<span class="fc" id="L485">        int i = 0;</span>
<span class="fc" id="L486">        Boolean destsAvailable = false;</span>
<span class="fc" id="L487">        final String stickinessSubRule = getLbSubRuleForStickiness(lbTO);</span>
<span class="fc" id="L488">        final List&lt;String&gt; dstSubRule = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L489">        final List&lt;String&gt; dstWithCookieSubRule = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">        for (final DestinationTO dest : lbTO.getDestinations()) {</span>
            // add line like this: &quot;server  65_37_141_30-80_3 10.1.1.4:80 check&quot;
<span class="fc bfc" id="L492" title="All 2 branches covered.">            if (dest.isRevoked()) {</span>
<span class="fc" id="L493">                continue;</span>
            }
<span class="fc" id="L495">            sb = new StringBuilder();</span>
<span class="fc" id="L496">            sb.append(&quot;\t&quot;)</span>
<span class="fc" id="L497">            .append(&quot;server &quot;)</span>
<span class="fc" id="L498">            .append(poolName)</span>
<span class="fc" id="L499">            .append(&quot;_&quot;)</span>
<span class="fc" id="L500">            .append(Integer.toString(i++))</span>
<span class="fc" id="L501">            .append(&quot; &quot;)</span>
<span class="fc" id="L502">            .append(dest.getDestIp())</span>
<span class="fc" id="L503">            .append(&quot;:&quot;)</span>
<span class="fc" id="L504">            .append(dest.getDestPort())</span>
<span class="fc" id="L505">            .append(&quot; check&quot;);</span>
<span class="pc bpc" id="L506" title="1 of 4 branches missed.">            if(lbTO.getLbProtocol() != null &amp;&amp; lbTO.getLbProtocol().equals(&quot;tcp-proxy&quot;)) {</span>
<span class="fc" id="L507">                sb.append(&quot; send-proxy&quot;);</span>
            }
<span class="fc" id="L509">            dstSubRule.add(sb.toString());</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">            if (stickinessSubRule != null) {</span>
<span class="nc" id="L511">                sb.append(&quot; cookie &quot;).append(dest.getDestIp().replace(&quot;.&quot;, &quot;_&quot;)).append('-').append(dest.getDestPort()).toString();</span>
<span class="nc" id="L512">                dstWithCookieSubRule.add(sb.toString());</span>
            }
<span class="fc" id="L514">            destsAvailable = true;</span>
        }

<span class="fc" id="L517">        Boolean httpbasedStickiness = false;</span>
        /* attach stickiness sub rule only if the destinations are available */
<span class="pc bpc" id="L519" title="3 of 4 branches missed.">        if (stickinessSubRule != null &amp;&amp; destsAvailable == true) {</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">            for (final StickinessPolicyTO stickinessPolicy : lbTO.getStickinessPolicies()) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                if (stickinessPolicy == null) {</span>
<span class="nc" id="L522">                    continue;</span>
                }
<span class="nc bnc" id="L524" title="All 2 branches missed.">                if (StickinessMethodType.LBCookieBased.getName().equalsIgnoreCase(stickinessPolicy.getMethodName()) ||</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                        StickinessMethodType.AppCookieBased.getName().equalsIgnoreCase(stickinessPolicy.getMethodName())) {</span>
<span class="nc" id="L526">                    httpbasedStickiness = true;</span>
                }
            }
<span class="nc bnc" id="L529" title="All 2 branches missed.">            if (httpbasedStickiness) {</span>
<span class="nc" id="L530">                result.addAll(dstWithCookieSubRule);</span>
<span class="nc" id="L531">            } else {</span>
<span class="nc" id="L532">                result.addAll(dstSubRule);</span>
            }
<span class="nc" id="L534">            result.add(stickinessSubRule);</span>
<span class="nc" id="L535">        } else {</span>
<span class="fc" id="L536">            result.addAll(dstSubRule);</span>
        }
<span class="pc bpc" id="L538" title="3 of 4 branches missed.">        if (stickinessSubRule != null &amp;&amp; !destsAvailable) {</span>
<span class="nc" id="L539">            s_logger.warn(&quot;Haproxy stickiness policy for lb rule: &quot; + lbTO.getSrcIp() + &quot;:&quot; + lbTO.getSrcPort() + &quot;: Not Applied, cause:  backends are unavailable&quot;);</span>
        }
<span class="pc bpc" id="L541" title="1 of 6 branches missed.">        if (publicPort.equals(NetUtils.HTTP_PORT) &amp;&amp; !keepAliveEnabled || httpbasedStickiness) {</span>
<span class="fc" id="L542">            sb = new StringBuilder();</span>
<span class="fc" id="L543">            sb.append(&quot;\t&quot;).append(&quot;mode http&quot;);</span>
<span class="fc" id="L544">            result.add(sb.toString());</span>
<span class="fc" id="L545">            sb = new StringBuilder();</span>
<span class="fc" id="L546">            sb.append(&quot;\t&quot;).append(&quot;option httpclose&quot;);</span>
<span class="fc" id="L547">            result.add(sb.toString());</span>
        }

<span class="fc" id="L550">        result.add(blankLine);</span>
<span class="fc" id="L551">        return result;</span>
    }

    private String generateStatsRule(final LoadBalancerConfigCommand lbCmd, final String ruleName, final String statsIp) {
<span class="fc" id="L555">        final StringBuilder rule = new StringBuilder(&quot;\nlisten &quot;).append(ruleName).append(&quot; &quot;).append(statsIp).append(&quot;:&quot;).append(lbCmd.lbStatsPort);</span>
        // TODO DH: write test for this in both cases
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if (!lbCmd.keepAliveEnabled) {</span>
<span class="fc" id="L558">            s_logger.info(&quot;Haproxy mode http enabled&quot;);</span>
<span class="fc" id="L559">            rule.append(&quot;\n\tmode http\n\toption httpclose&quot;);</span>
        }
<span class="fc" id="L561">        rule.append(&quot;\n\tstats enable\n\tstats uri     &quot;)</span>
<span class="fc" id="L562">        .append(lbCmd.lbStatsUri)</span>
<span class="fc" id="L563">        .append(&quot;\n\tstats realm   Haproxy\\ Statistics\n\tstats auth    &quot;)</span>
<span class="fc" id="L564">        .append(lbCmd.lbStatsAuth);</span>
<span class="fc" id="L565">        rule.append(&quot;\n&quot;);</span>
<span class="fc" id="L566">        final String result = rule.toString();</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (s_logger.isDebugEnabled()) {</span>
<span class="fc" id="L568">            s_logger.debug(&quot;Haproxystats rule: &quot; + result);</span>
        }
<span class="fc" id="L570">        return result;</span>
    }

    @Override
    public String[] generateConfiguration(final LoadBalancerConfigCommand lbCmd) {
<span class="fc" id="L575">        final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L576">        final List&lt;String&gt; gSection = Arrays.asList(globalSection);</span>
        //        note that this is overwritten on the String in the static ArrayList&lt;String&gt;
<span class="fc" id="L578">        gSection.set(2, &quot;\tmaxconn &quot; + lbCmd.maxconn);</span>
        // TODO DH: write test for this function
<span class="fc" id="L580">        final String pipesLine = &quot;\tmaxpipes &quot; + Long.toString(Long.parseLong(lbCmd.maxconn) / 4);</span>
<span class="fc" id="L581">        gSection.set(3, pipesLine);</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">        if (s_logger.isDebugEnabled()) {</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">            for (final String s : gSection) {</span>
<span class="fc" id="L584">                s_logger.debug(&quot;global section: &quot; + s);</span>
            }
        }
<span class="fc" id="L587">        result.addAll(gSection);</span>
        // TODO decide under what circumstances these options are needed
        //        result.add(&quot;\tnokqueue&quot;);
        //        result.add(&quot;\tnopoll&quot;);

<span class="fc" id="L592">        result.add(blankLine);</span>
<span class="fc" id="L593">        final List&lt;String&gt; dSection = Arrays.asList(defaultsSection);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">        if (lbCmd.keepAliveEnabled) {</span>
<span class="fc" id="L595">            dSection.set(7, &quot;\tno option forceclose&quot;);</span>
        }

<span class="pc bpc" id="L598" title="1 of 2 branches missed.">        if (s_logger.isDebugEnabled()) {</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">            for (final String s : dSection) {</span>
<span class="fc" id="L600">                s_logger.debug(&quot;default section: &quot; + s);</span>
            }
        }
<span class="fc" id="L603">        result.addAll(dSection);</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        if (!lbCmd.lbStatsVisibility.equals(&quot;disabled&quot;)) {</span>
            /* new rule : listen admin_page guestip/link-local:8081 */
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">            if (lbCmd.lbStatsVisibility.equals(&quot;global&quot;)) {</span>
<span class="nc" id="L607">                result.add(generateStatsRule(lbCmd, &quot;stats_on_public&quot;, lbCmd.lbStatsPublicIP));</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">            } else if (lbCmd.lbStatsVisibility.equals(&quot;guest-network&quot;)) {</span>
<span class="fc" id="L609">                result.add(generateStatsRule(lbCmd, &quot;stats_on_guest&quot;, lbCmd.lbStatsGuestIP));</span>
<span class="pc bnc" id="L610" title="All 2 branches missed.">            } else if (lbCmd.lbStatsVisibility.equals(&quot;link-local&quot;)) {</span>
<span class="nc" id="L611">                result.add(generateStatsRule(lbCmd, &quot;stats_on_private&quot;, lbCmd.lbStatsPrivateIP));</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">            } else if (lbCmd.lbStatsVisibility.equals(&quot;all&quot;)) {</span>
<span class="nc" id="L613">                result.add(generateStatsRule(lbCmd, &quot;stats_on_public&quot;, lbCmd.lbStatsPublicIP));</span>
<span class="nc" id="L614">                result.add(generateStatsRule(lbCmd, &quot;stats_on_guest&quot;, lbCmd.lbStatsGuestIP));</span>
<span class="nc" id="L615">                result.add(generateStatsRule(lbCmd, &quot;stats_on_private&quot;, lbCmd.lbStatsPrivateIP));</span>
<span class="nc" id="L616">            } else {</span>
                /*
                 * stats will be available on the default http serving port, no
                 * special stats port
                 */
<span class="nc" id="L621">                final StringBuilder subRule =</span>
<span class="nc" id="L622">                        new StringBuilder(&quot;\tstats enable\n\tstats uri     &quot;).append(lbCmd.lbStatsUri)</span>
<span class="nc" id="L623">                        .append(&quot;\n\tstats realm   Haproxy\\ Statistics\n\tstats auth    &quot;)</span>
<span class="nc" id="L624">                        .append(lbCmd.lbStatsAuth);</span>
<span class="nc" id="L625">                result.add(subRule.toString());</span>
            }

        }
<span class="fc" id="L629">        result.add(blankLine);</span>
<span class="fc" id="L630">        boolean has_listener = false;</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">        for (final LoadBalancerTO lbTO : lbCmd.getLoadBalancers()) {</span>
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">            if (lbTO.isRevoked()) {</span>
<span class="nc" id="L633">                continue;</span>
            }
<span class="fc" id="L635">            final List&lt;String&gt; poolRules = getRulesForPool(lbTO, lbCmd.keepAliveEnabled);</span>
<span class="fc" id="L636">            result.addAll(poolRules);</span>
<span class="fc" id="L637">            has_listener = true;</span>
        }
<span class="fc" id="L639">        result.add(blankLine);</span>
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">        if (!has_listener) {</span>
            // haproxy cannot handle empty listen / frontend or backend, so add
            // a dummy listener
            // on port 9
<span class="nc" id="L644">            result.addAll(Arrays.asList(defaultListen));</span>
        }
<span class="fc" id="L646">        return result.toArray(new String[result.size()]);</span>
    }

    @Override
    public String[][] generateFwRules(final LoadBalancerConfigCommand lbCmd) {
<span class="fc" id="L651">        final String[][] result = new String[3][];</span>
<span class="fc" id="L652">        final Set&lt;String&gt; toAdd = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L653">        final Set&lt;String&gt; toRemove = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L654">        final Set&lt;String&gt; toStats = new HashSet&lt;String&gt;();</span>

<span class="fc bfc" id="L656" title="All 2 branches covered.">        for (final LoadBalancerTO lbTO : lbCmd.getLoadBalancers()) {</span>

<span class="fc" id="L658">            final StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L659">            sb.append(lbTO.getSrcIp()).append(&quot;:&quot;);</span>
<span class="fc" id="L660">            sb.append(lbTO.getSrcPort()).append(&quot;:&quot;);</span>
<span class="fc" id="L661">            final String lbRuleEntry = sb.toString();</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">            if (!lbTO.isRevoked()) {</span>
<span class="fc" id="L663">                toAdd.add(lbRuleEntry);</span>
<span class="fc" id="L664">            } else {</span>
<span class="nc" id="L665">                toRemove.add(lbRuleEntry);</span>
            }
        }
<span class="fc" id="L668">        StringBuilder sb = new StringBuilder(&quot;&quot;);</span>
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        if (lbCmd.lbStatsVisibility.equals(&quot;guest-network&quot;)) {</span>
<span class="fc" id="L670">            sb = new StringBuilder(lbCmd.lbStatsGuestIP).append(&quot;:&quot;).append(lbCmd.lbStatsPort).append(&quot;:&quot;).append(lbCmd.lbStatsSrcCidrs).append(&quot;:,&quot;);</span>
<span class="pc bnc" id="L671" title="All 2 branches missed.">        } else if (lbCmd.lbStatsVisibility.equals(&quot;link-local&quot;)) {</span>
<span class="nc" id="L672">            sb = new StringBuilder(lbCmd.lbStatsPrivateIP).append(&quot;:&quot;).append(lbCmd.lbStatsPort).append(&quot;:&quot;).append(lbCmd.lbStatsSrcCidrs).append(&quot;:,&quot;);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">        } else if (lbCmd.lbStatsVisibility.equals(&quot;global&quot;)) {</span>
<span class="nc" id="L674">            sb = new StringBuilder(lbCmd.lbStatsPublicIP).append(&quot;:&quot;).append(lbCmd.lbStatsPort).append(&quot;:&quot;).append(lbCmd.lbStatsSrcCidrs).append(&quot;:,&quot;);</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        } else if (lbCmd.lbStatsVisibility.equals(&quot;all&quot;)) {</span>
<span class="nc" id="L676">            sb = new StringBuilder(&quot;0.0.0.0/0&quot;).append(&quot;:&quot;).append(lbCmd.lbStatsPort).append(&quot;:&quot;).append(lbCmd.lbStatsSrcCidrs).append(&quot;:,&quot;);</span>
        }
<span class="fc" id="L678">        toStats.add(sb.toString());</span>

<span class="fc" id="L680">        toRemove.removeAll(toAdd);</span>
<span class="fc" id="L681">        result[ADD] = toAdd.toArray(new String[toAdd.size()]);</span>
<span class="fc" id="L682">        result[REMOVE] = toRemove.toArray(new String[toRemove.size()]);</span>
<span class="fc" id="L683">        result[STATS] = toStats.toArray(new String[toStats.size()]);</span>

<span class="fc" id="L685">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>cloud-core (18-mrt-2016 13:14:54)</div></body></html>