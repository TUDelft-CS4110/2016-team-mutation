<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>AbstractBuild.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">jenkins-core (22-mrt-2016 21:51:03)</a> &gt; <a href="../../index.html" class="el_group">jenkins-core</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">hudson.model</a> &gt; <span class="el_source">AbstractBuild.java</span></div><h1>AbstractBuild.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/*</span>
 * The MIT License
 *
 * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi, Yahoo! Inc., CloudBees, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package hudson.model;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSortedSet;
import hudson.AbortException;
import hudson.EnvVars;
import hudson.FilePath;
import hudson.Functions;
import hudson.Launcher;
import hudson.console.ModelHyperlinkNote;
import hudson.model.Fingerprint.BuildPtr;
import hudson.model.Fingerprint.RangeSet;
import hudson.model.labels.LabelAtom;
import hudson.model.listeners.RunListener;
import hudson.model.listeners.SCMListener;
import hudson.remoting.ChannelClosedException;
import hudson.remoting.RequestAbortedException;
import hudson.scm.ChangeLogParser;
import hudson.scm.ChangeLogSet;
import hudson.scm.ChangeLogSet.Entry;
import hudson.scm.NullChangeLogParser;
import hudson.scm.SCM;
import hudson.scm.SCMRevisionState;
import hudson.slaves.NodeProperty;
import hudson.slaves.WorkspaceList;
import hudson.slaves.WorkspaceList.Lease;
import hudson.slaves.OfflineCause;
import hudson.tasks.BuildStep;
import hudson.tasks.BuildStepMonitor;
import hudson.tasks.BuildTrigger;
import hudson.tasks.BuildWrapper;
import hudson.tasks.Builder;
import hudson.tasks.Fingerprinter.FingerprintAction;
import hudson.tasks.Publisher;
import hudson.util.*;
import jenkins.model.Jenkins;
import org.kohsuke.stapler.HttpResponse;
import org.kohsuke.stapler.Stapler;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import org.kohsuke.stapler.export.Exported;
import org.xml.sax.SAXException;

import javax.servlet.ServletException;
import java.io.File;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.lang.ref.WeakReference;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import org.kohsuke.stapler.interceptor.RequirePOST;

import static java.util.logging.Level.WARNING;

import jenkins.model.lazy.BuildReference;
import jenkins.model.lazy.LazyBuildMixIn;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.DoNotUse;

/**
 * Base implementation of {@link Run}s that build software.
 *
 * For now this is primarily the common part of {@link Build} and MavenBuild.
 *
 * @author Kohsuke Kawaguchi
 * @see AbstractProject
 */
public abstract class AbstractBuild&lt;P extends AbstractProject&lt;P,R&gt;,R extends AbstractBuild&lt;P,R&gt;&gt; extends Run&lt;P,R&gt; implements Queue.Executable, LazyBuildMixIn.LazyLoadingRun&lt;P,R&gt; {

    /**
     * Set if we want the blame information to flow from upstream to downstream build.
     */
<span class="fc" id="L109">    private static final boolean upstreamCulprits = Boolean.getBoolean(&quot;hudson.upstreamCulprits&quot;);</span>

    /**
     * Name of the slave this project was built on.
     * Null or &quot;&quot; if built by the master. (null happens when we read old record that didn't have this information.)
     */
    private String builtOn;

    /**
     * The file path on the node that performed a build. Kept as a string since {@link FilePath} is not serializable into XML.
     * @since 1.319
     */
    private String workspace;

    /**
     * Version of Hudson that built this.
     */
    private String hudsonVersion;

    /**
     * SCM used for this build.
     * Maybe null, for historical reason, in which case CVS is assumed.
     */
    private ChangeLogParser scm;

    /**
     * Changes in this build.
     */
    private volatile transient WeakReference&lt;ChangeLogSet&lt;? extends Entry&gt;&gt; changeSet;

    /**
     * Cumulative list of people who contributed to the build problem.
     *
     * &lt;p&gt;
     * This is a list of {@link User#getId() user ids} who made a change
     * since the last non-broken build. Can be null (which should be
     * treated like empty set), because of the compatibility.
     *
     * &lt;p&gt;
     * This field is semi-final --- once set the value will never be modified.
     *
     * @since 1.137
     */
    private volatile Set&lt;String&gt; culprits;

    /**
     * During the build this field remembers {@link hudson.tasks.BuildWrapper.Environment}s created by
     * {@link BuildWrapper}. This design is bit ugly but forced due to compatibility.
     */
    protected transient List&lt;Environment&gt; buildEnvironments;

<span class="nc" id="L160">    private transient final LazyBuildMixIn.RunMixIn&lt;P,R&gt; runMixIn = new LazyBuildMixIn.RunMixIn&lt;P,R&gt;() {</span>
        @Override protected R asRun() {
<span class="nc" id="L162">            return _this();</span>
        }
    };

    protected AbstractBuild(P job) throws IOException {
<span class="nc" id="L167">        super(job);</span>
<span class="nc" id="L168">    }</span>

    protected AbstractBuild(P job, Calendar timestamp) {
<span class="nc" id="L171">        super(job, timestamp);</span>
<span class="nc" id="L172">    }</span>

    protected AbstractBuild(P project, File buildDir) throws IOException {
<span class="nc" id="L175">        super(project, buildDir);</span>
<span class="nc" id="L176">    }</span>

    public final P getProject() {
<span class="fc" id="L179">        return getParent();</span>
    }

    @Override public final LazyBuildMixIn.RunMixIn&lt;P,R&gt; getRunMixIn() {
<span class="nc" id="L183">        return runMixIn;</span>
    }

    @Override protected final BuildReference&lt;R&gt; createReference() {
<span class="nc" id="L187">        return getRunMixIn().createReference();</span>
    }

    @Override protected final void dropLinks() {
<span class="nc" id="L191">        getRunMixIn().dropLinks();</span>
<span class="nc" id="L192">    }</span>

    @Override
    public R getPreviousBuild() {
<span class="nc" id="L196">        return getRunMixIn().getPreviousBuild();</span>
    }

    @Override
    public R getNextBuild() {
<span class="nc" id="L201">        return getRunMixIn().getNextBuild();</span>
    }

    /**
     * Returns a {@link Slave} on which this build was done.
     *
     * @return
     *      null, for example if the slave that this build run no longer exists.
     */
    public @CheckForNull Node getBuiltOn() {
<span class="nc bnc" id="L211" title="All 4 branches missed.">        if (builtOn==null || builtOn.equals(&quot;&quot;))</span>
<span class="nc" id="L212">            return Jenkins.getInstance();</span>
        else
<span class="nc" id="L214">            return Jenkins.getInstance().getNode(builtOn);</span>
    }

    /**
     * Returns the name of the slave it was built on; null or &quot;&quot; if built by the master.
     * (null happens when we read old record that didn't have this information.)
     */
    @Exported(name=&quot;builtOn&quot;)
    public String getBuiltOnStr() {
<span class="nc" id="L223">        return builtOn;</span>
    }

    /**
     * Allows subtypes to set the value of {@link #builtOn}.
     * This is used for those implementations where an {@link AbstractBuild} is made 'built' without
     * actually running its {@link #run()} method.
     *
     * @since 1.429
     */
    protected void setBuiltOnStr( String builtOn ) {
<span class="nc" id="L234">        this.builtOn = builtOn;</span>
<span class="nc" id="L235">    }</span>

    /**
     * Gets the nearest ancestor {@link AbstractBuild} that belongs to
     * {@linkplain AbstractProject#getRootProject() the root project of getProject()} that
     * dominates/governs/encompasses this build.
     *
     * &lt;p&gt;
     * Some projects (such as matrix projects, Maven projects, or promotion processes) form a tree of jobs,
     * and still in some of them, builds of child projects are related/tied to that of the parent project.
     * In such a case, this method returns the governing build.
     *
     * @return never null. In the worst case the build dominates itself.
     * @since 1.421
     * @see AbstractProject#getRootProject()
     */
    public AbstractBuild&lt;?,?&gt; getRootBuild() {
<span class="nc" id="L252">        return this;</span>
    }

    /**
     * Used to render the side panel &quot;Back to project&quot; link.
     *
     * &lt;p&gt;
     * In a rare situation where a build can be reached from multiple paths,
     * returning different URLs from this method based on situations might
     * be desirable.
     *
     * &lt;p&gt;
     * If you override this method, you'll most likely also want to override
     * {@link #getDisplayName()}.
     */
    public String getUpUrl() {
<span class="nc" id="L268">        return Functions.getNearestAncestorUrl(Stapler.getCurrentRequest(),getParent())+'/';</span>
    }

    /**
     * Gets the directory where this build is being built.
     *
     * &lt;p&gt;
     * Note to implementors: to control where the workspace is created, override
     * {@link AbstractBuildExecution#decideWorkspace(Node,WorkspaceList)}.
     *
     * @return
     *      null if the workspace is on a slave that's not connected. Note that once the build is completed,
     *      the workspace may be used to build something else, so the value returned from this method may
     *      no longer show a workspace as it was used for this build.
     * @since 1.319
     */
    public final @CheckForNull FilePath getWorkspace() {
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (workspace==null) return null;</span>
<span class="nc" id="L286">        Node n = getBuiltOn();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (n==null) return null;</span>
<span class="nc" id="L288">        return n.createPath(workspace);</span>
    }

    /**
     * Normally, a workspace is assigned by {@link hudson.model.Run.RunExecution}, but this lets you set the workspace in case
     * {@link AbstractBuild} is created without a build.
     */
    protected void setWorkspace(@Nonnull FilePath ws) {
<span class="nc" id="L296">        this.workspace = ws.getRemote();</span>
<span class="nc" id="L297">    }</span>

    /**
     * Returns the root directory of the checked-out module.
     * &lt;p&gt;
     * This is usually where &lt;tt&gt;pom.xml&lt;/tt&gt;, &lt;tt&gt;build.xml&lt;/tt&gt;
     * and so on exists.
     */
    public final FilePath getModuleRoot() {
<span class="nc" id="L306">        FilePath ws = getWorkspace();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (ws==null)    return null;</span>
<span class="nc" id="L308">        return getParent().getScm().getModuleRoot(ws, this);</span>
    }

    /**
     * Returns the root directories of all checked-out modules.
     * &lt;p&gt;
     * Some SCMs support checking out multiple modules into the same workspace.
     * In these cases, the returned array will have a length greater than one.
     * @return The roots of all modules checked out from the SCM.
     */
    public FilePath[] getModuleRoots() {
<span class="nc" id="L319">        FilePath ws = getWorkspace();</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (ws==null)    return null;</span>
<span class="nc" id="L321">        return getParent().getScm().getModuleRoots(ws, this);</span>
    }

    /**
     * List of users who committed a change since the last non-broken build till now.
     *
     * &lt;p&gt;
     * This list at least always include people who made changes in this build, but
     * if the previous build was a failure it also includes the culprit list from there.
     *
     * @return
     *      can be empty but never null.
     */
    @Exported
    public Set&lt;User&gt; getCulprits() {
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (culprits==null) {</span>
<span class="nc" id="L337">            Set&lt;User&gt; r = new HashSet&lt;User&gt;();</span>
<span class="nc" id="L338">            R p = getPreviousCompletedBuild();</span>
<span class="nc bnc" id="L339" title="All 4 branches missed.">            if (p !=null &amp;&amp; isBuilding()) {</span>
<span class="nc" id="L340">                Result pr = p.getResult();</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">                if (pr!=null &amp;&amp; pr.isWorseThan(Result.SUCCESS)) {</span>
                    // we are still building, so this is just the current latest information,
                    // but we seems to be failing so far, so inherit culprits from the previous build.
                    // isBuilding() check is to avoid recursion when loading data from old Hudson, which doesn't record
                    // this information
<span class="nc" id="L346">                    r.addAll(p.getCulprits());</span>
                }
            }
<span class="nc bnc" id="L349" title="All 2 branches missed.">            for (Entry e : getChangeSet())</span>
<span class="nc" id="L350">                r.add(e.getAuthor());</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">            if (upstreamCulprits) {</span>
                // If we have dependencies since the last successful build, add their authors to our list
<span class="nc bnc" id="L354" title="All 2 branches missed.">                if (getPreviousNotFailedBuild() != null) {</span>
<span class="nc" id="L355">                    Map &lt;AbstractProject,DependencyChange&gt; depmap = getDependencyChanges(getPreviousSuccessfulBuild());</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                    for (DependencyChange dep : depmap.values()) {</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">                        for (AbstractBuild&lt;?,?&gt; b : dep.getBuilds()) {</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">                            for (Entry entry : b.getChangeSet()) {</span>
<span class="nc" id="L359">                                r.add(entry.getAuthor());</span>
                            }
                        }
                    }
                }
            }

<span class="nc" id="L366">            return r;</span>
        }

<span class="nc" id="L369">        return new AbstractSet&lt;User&gt;() {</span>
            public Iterator&lt;User&gt; iterator() {
<span class="nc" id="L371">                return new AdaptedIterator&lt;String,User&gt;(culprits.iterator()) {</span>
                    protected User adapt(String id) {
<span class="nc" id="L373">                        return User.get(id);</span>
                    }
                };
            }

            public int size() {
<span class="nc" id="L379">                return culprits.size();</span>
            }
        };
    }

    /**
     * Returns true if this user has made a commit to this build.
     *
     * @since 1.191
     */
    public boolean hasParticipant(User user) {
<span class="nc bnc" id="L390" title="All 2 branches missed.">        for (ChangeLogSet.Entry e : getChangeSet())</span>
            try{
<span class="nc bnc" id="L392" title="All 2 branches missed.">                if (e.getAuthor()==user)</span>
<span class="nc" id="L393">                    return true;</span>
<span class="nc" id="L394">            } catch (RuntimeException re) { </span>
<span class="nc" id="L395">                LOGGER.log(Level.INFO, &quot;Failed to determine author of changelog &quot; + e.getCommitId() + &quot;for &quot; + getParent().getDisplayName() + &quot;, &quot; + getDisplayName(), re);</span>
            }
<span class="nc" id="L397">        return false;</span>
    }

    /**
     * Gets the version of Hudson that was used to build this job.
     *
     * @since 1.246
     */
    public String getHudsonVersion() {
<span class="nc" id="L406">        return hudsonVersion;</span>
    }

    /**
     * @deprecated as of 1.467
     *      Please use {@link hudson.model.Run.RunExecution}
     */
    @Deprecated
<span class="nc" id="L414">    public abstract class AbstractRunner extends AbstractBuildExecution {</span>

    }

<span class="nc bnc" id="L418" title="All 2 branches missed.">    public abstract class AbstractBuildExecution extends Runner {</span>
        /*
            Some plugins might depend on this instance castable to Runner, so we need to use
            deprecated class here.
         */

        /**
         * Since configuration can be changed while a build is in progress,
         * create a launcher once and stick to it for the entire build duration.
         */
        protected Launcher launcher;

        /**
         * Output/progress of this build goes here.
         */
        protected BuildListener listener;

        /**
         * Lease of the workspace.
         */
        private Lease lease;

        /**
         * Returns the current {@link Node} on which we are building.
         * @return Returns the current {@link Node}
         * @throws IllegalStateException if that cannot be determined
         */
        protected final @Nonnull Node getCurrentNode() throws IllegalStateException {
<span class="nc" id="L446">            Executor exec = Executor.currentExecutor();</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            if (exec == null) {</span>
<span class="nc" id="L448">                throw new IllegalStateException(&quot;not being called from an executor thread&quot;);</span>
            }
<span class="nc" id="L450">            Computer c = exec.getOwner();</span>
<span class="nc" id="L451">            Node node = c.getNode();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (node == null) {</span>
<span class="nc" id="L453">                throw new IllegalStateException(&quot;no longer a configured node for &quot; + c.getName());</span>
            }
<span class="nc" id="L455">            return node;</span>
        }

        public Launcher getLauncher() {
<span class="nc" id="L459">            return launcher;</span>
        }

        public BuildListener getListener() {
<span class="nc" id="L463">            return listener;</span>
        }

        /**
         * Allocates the workspace from {@link WorkspaceList}.
         *
         * @param n
         *      Passed in for the convenience. The node where the build is running.
         * @param wsl
         *      Passed in for the convenience. The returned path must be registered to this object.
         */
        protected Lease decideWorkspace(@Nonnull Node n, WorkspaceList wsl) throws InterruptedException, IOException {
<span class="nc" id="L475">            String customWorkspace = getProject().getCustomWorkspace();</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">            if (customWorkspace != null) {</span>
                // we allow custom workspaces to be concurrently used between jobs.
<span class="nc" id="L478">                return Lease.createDummyLease(n.getRootPath().child(getEnvironment(listener).expand(customWorkspace)));</span>
            }
            // TODO: this cast is indicative of abstraction problem
<span class="nc" id="L481">            return wsl.allocate(n.getWorkspaceFor((TopLevelItem)getProject()), getBuild());</span>
        }

        public Result run(@Nonnull BuildListener listener) throws Exception {
<span class="nc" id="L485">            final Node node = getCurrentNode();</span>
            
<span class="nc bnc" id="L487" title="All 4 branches missed.">            assert builtOn==null;</span>
<span class="nc" id="L488">            builtOn = node.getNodeName();</span>
<span class="nc" id="L489">            hudsonVersion = Jenkins.VERSION;</span>
<span class="nc" id="L490">            this.listener = listener;</span>

<span class="nc" id="L492">            launcher = createLauncher(listener);</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            if (!Jenkins.getInstance().getNodes().isEmpty()) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                if (node instanceof Jenkins) {</span>
<span class="nc" id="L495">                    listener.getLogger().print(Messages.AbstractBuild_BuildingOnMaster());</span>
<span class="nc" id="L496">                } else {</span>
<span class="nc" id="L497">                    listener.getLogger().print(Messages.AbstractBuild_BuildingRemotely(ModelHyperlinkNote.encodeTo(&quot;/computer/&quot; + builtOn, builtOn)));</span>
<span class="nc" id="L498">                    Set&lt;LabelAtom&gt; assignedLabels = new HashSet&lt;LabelAtom&gt;(node.getAssignedLabels());</span>
<span class="nc" id="L499">                    assignedLabels.remove(node.getSelfLabel());</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                    if (!assignedLabels.isEmpty()) {</span>
<span class="nc" id="L501">                        boolean first = true;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                        for (LabelAtom label : assignedLabels) {</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">                            if (first) {</span>
<span class="nc" id="L504">                                listener.getLogger().print(&quot; (&quot;);</span>
<span class="nc" id="L505">                                first = false;</span>
<span class="nc" id="L506">                            } else {</span>
<span class="nc" id="L507">                                listener.getLogger().print(' ');</span>
                            }
<span class="nc" id="L509">                            listener.getLogger().print(label.getName());</span>
                        }
<span class="nc" id="L511">                        listener.getLogger().print(')');</span>
                    }
                }
<span class="nc" id="L514">            } else {</span>
<span class="nc" id="L515">                listener.getLogger().print(Messages.AbstractBuild_Building());</span>
            }
            
<span class="nc" id="L518">            lease = decideWorkspace(node, Computer.currentComputer().getWorkspaceList());</span>

<span class="nc" id="L520">            workspace = lease.path.getRemote();</span>
<span class="nc" id="L521">            listener.getLogger().println(Messages.AbstractBuild_BuildingInWorkspace(workspace));</span>
<span class="nc" id="L522">            node.getFileSystemProvisioner().prepareWorkspace(AbstractBuild.this,lease.path,listener);</span>

<span class="nc bnc" id="L524" title="All 2 branches missed.">            for (WorkspaceListener wl : WorkspaceListener.all()) {</span>
<span class="nc" id="L525">                wl.beforeUse(AbstractBuild.this, lease.path, listener);</span>
            }

<span class="nc" id="L528">            getProject().getScmCheckoutStrategy().preCheckout(AbstractBuild.this, launcher, this.listener);</span>
<span class="nc" id="L529">            getProject().getScmCheckoutStrategy().checkout(this);</span>

<span class="nc bnc" id="L531" title="All 2 branches missed.">            if (!preBuild(listener,project.getProperties()))</span>
<span class="nc" id="L532">                return Result.FAILURE;</span>

<span class="nc" id="L534">            Result result = doRun(listener);</span>

<span class="nc bnc" id="L536" title="All 2 branches missed.">            if (node.getChannel() != null) {</span>
                // kill run-away processes that are left
                // use multiple environment variables so that people can escape this massacre by overriding an environment
                // variable for some processes
<span class="nc" id="L540">                launcher.kill(getCharacteristicEnvVars());</span>
            }

            // this is ugly, but for historical reason, if non-null value is returned
            // it should become the final result.
<span class="nc bnc" id="L545" title="All 2 branches missed.">            if (result==null)    result = getResult();</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            if (result==null)    result = Result.SUCCESS;</span>

<span class="nc" id="L548">            return result;</span>
        }

        /**
         * Creates a {@link Launcher} that this build will use. This can be overridden by derived types
         * to decorate the resulting {@link Launcher}.
         *
         * @param listener
         *      Always non-null. Connected to the main build output.
         */
        @Nonnull
        protected Launcher createLauncher(@Nonnull BuildListener listener) throws IOException, InterruptedException {
<span class="nc" id="L560">            final Node currentNode = getCurrentNode();</span>
<span class="nc" id="L561">            Launcher l = currentNode.createLauncher(listener);</span>

<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (project instanceof BuildableItemWithBuildWrappers) {</span>
<span class="nc" id="L564">                BuildableItemWithBuildWrappers biwbw = (BuildableItemWithBuildWrappers) project;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                for (BuildWrapper bw : biwbw.getBuildWrappersList())</span>
<span class="nc" id="L566">                    l = bw.decorateLauncher(AbstractBuild.this,l,listener);</span>
            }

<span class="nc" id="L569">            buildEnvironments = new ArrayList&lt;Environment&gt;();</span>

<span class="nc bnc" id="L571" title="All 2 branches missed.">            for (RunListener rl: RunListener.all()) {</span>
<span class="nc" id="L572">                Environment environment = rl.setUpEnvironment(AbstractBuild.this, l, listener);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">                if (environment != null) {</span>
<span class="nc" id="L574">                    buildEnvironments.add(environment);</span>
                }
            }

<span class="nc bnc" id="L578" title="All 2 branches missed.">            for (NodeProperty nodeProperty: Jenkins.getInstance().getGlobalNodeProperties()) {</span>
<span class="nc" id="L579">                Environment environment = nodeProperty.setUp(AbstractBuild.this, l, listener);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                if (environment != null) {</span>
<span class="nc" id="L581">                    buildEnvironments.add(environment);</span>
                }
            }

<span class="nc bnc" id="L585" title="All 2 branches missed.">            for (NodeProperty nodeProperty: currentNode.getNodeProperties()) {</span>
<span class="nc" id="L586">                Environment environment = nodeProperty.setUp(AbstractBuild.this, l, listener);</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                if (environment != null) {</span>
<span class="nc" id="L588">                    buildEnvironments.add(environment);</span>
                }
            }

<span class="nc" id="L592">            return l;</span>
        }

        public void defaultCheckout() throws IOException, InterruptedException {
<span class="nc" id="L596">            AbstractBuild&lt;?,?&gt; build = AbstractBuild.this;</span>
<span class="nc" id="L597">            AbstractProject&lt;?, ?&gt; project = build.getProject();</span>

<span class="nc" id="L599">            for (int retryCount=project.getScmCheckoutRetryCount(); ; retryCount--) {</span>
                // for historical reasons, null in the scm field means CVS, so we need to explicitly set this to something
                // in case check out fails and leaves a broken changelog.xml behind.
                // see http://www.nabble.com/CVSChangeLogSet.parse-yields-SAXParseExceptions-when-parsing-bad-*AccuRev*-changelog.xml-files-td22213663.html
<span class="nc" id="L603">                build.scm = NullChangeLogParser.INSTANCE;</span>

                try {
<span class="nc" id="L606">                    File changeLogFile = new File(build.getRootDir(), &quot;changelog.xml&quot;);</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">                    if (project.checkout(build, launcher,listener, changeLogFile)) {</span>
                        // check out succeeded
<span class="nc" id="L609">                        SCM scm = project.getScm();</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">                        for (SCMListener l : SCMListener.all()) {</span>
                            try {
<span class="nc" id="L612">                                l.onCheckout(build, scm, build.getWorkspace(), listener, changeLogFile, build.getAction(SCMRevisionState.class));</span>
<span class="nc" id="L613">                            } catch (Exception e) {</span>
<span class="nc" id="L614">                                throw new IOException(e);</span>
                            }
                        }

<span class="nc" id="L618">                        build.scm = scm.createChangeLogParser();</span>
<span class="nc" id="L619">                        build.changeSet = new WeakReference&lt;ChangeLogSet&lt;? extends Entry&gt;&gt;(build.calcChangeSet());</span>

<span class="nc bnc" id="L621" title="All 2 branches missed.">                        for (SCMListener l : SCMListener.all())</span>
                            try {
<span class="nc" id="L623">                                l.onChangeLogParsed(build,listener,build.getChangeSet());</span>
<span class="nc" id="L624">                            } catch (Exception e) {</span>
<span class="nc" id="L625">                                throw new IOException(&quot;Failed to parse changelog&quot;,e);</span>
                            }

                        // Get a chance to do something after checkout and changelog is done
<span class="nc" id="L629">                        scm.postCheckout( build, launcher, build.getWorkspace(), listener );</span>

<span class="nc" id="L631">                        return;</span>
                    }
<span class="nc" id="L633">                } catch (AbortException e) {</span>
<span class="nc" id="L634">                    listener.error(e.getMessage());</span>
<span class="nc" id="L635">                } catch (InterruptedIOException e) {</span>
<span class="nc" id="L636">                    throw (InterruptedException)new InterruptedException().initCause(e);</span>
<span class="nc" id="L637">                } catch (IOException e) {</span>
                    // checkout error not yet reported
<span class="nc" id="L639">                    e.printStackTrace(listener.getLogger());</span>
                }

<span class="nc bnc" id="L642" title="All 2 branches missed.">                if (retryCount == 0)   // all attempts failed</span>
<span class="nc" id="L643">                    throw new RunnerAbortedException();</span>

<span class="nc" id="L645">                listener.getLogger().println(&quot;Retrying after 10 seconds&quot;);</span>
<span class="nc" id="L646">                Thread.sleep(10000);</span>
            }
        }

        /**
         * The portion of a build that is specific to a subclass of {@link AbstractBuild}
         * goes here.
         *
         * @return
         *      null to continue the build normally (that means the doRun method
         *      itself run successfully)
         *      Return a non-null value to abort the build right there with the specified result code.
         */
        protected abstract Result doRun(BuildListener listener) throws Exception, RunnerAbortedException;

        /**
         * @see #post(BuildListener)
         */
        protected abstract void post2(BuildListener listener) throws Exception;

        public final void post(BuildListener listener) throws Exception {
            try {
<span class="nc" id="L668">                post2(listener);</span>
<span class="nc" id="L669">            } finally {</span>
                // update the culprit list
<span class="nc" id="L671">                HashSet&lt;String&gt; r = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L672" title="All 4 branches missed.">                for (User u : getCulprits())</span>
<span class="nc" id="L673">                    r.add(u.getId());</span>
<span class="nc" id="L674">                culprits = ImmutableSortedSet.copyOf(r);</span>
<span class="nc" id="L675">                CheckPoint.CULPRITS_DETERMINED.report();</span>
<span class="nc" id="L676">            }</span>
<span class="nc" id="L677">        }</span>

        public void cleanUp(BuildListener listener) throws Exception {
<span class="nc bnc" id="L680" title="All 2 branches missed.">            if (lease!=null) {</span>
<span class="nc" id="L681">                lease.release();</span>
<span class="nc" id="L682">                lease = null;</span>
            }
<span class="nc" id="L684">            BuildTrigger.execute(AbstractBuild.this, listener);</span>
<span class="nc" id="L685">            buildEnvironments = null;</span>
<span class="nc" id="L686">        }</span>

        /**
         * @deprecated as of 1.356
         *      Use {@link #performAllBuildSteps(BuildListener, Map, boolean)}
         */
       @Deprecated
        protected final void performAllBuildStep(BuildListener listener, Map&lt;?,? extends BuildStep&gt; buildSteps, boolean phase) throws InterruptedException, IOException {
<span class="nc" id="L694">            performAllBuildSteps(listener,buildSteps.values(),phase);</span>
<span class="nc" id="L695">        }</span>

        protected final boolean performAllBuildSteps(BuildListener listener, Map&lt;?,? extends BuildStep&gt; buildSteps, boolean phase) throws InterruptedException, IOException {
<span class="nc" id="L698">            return performAllBuildSteps(listener,buildSteps.values(),phase);</span>
        }

        /**
         * @deprecated as of 1.356
         *      Use {@link #performAllBuildSteps(BuildListener, Iterable, boolean)}
         */
        @Deprecated
        protected final void performAllBuildStep(BuildListener listener, Iterable&lt;? extends BuildStep&gt; buildSteps, boolean phase) throws InterruptedException, IOException {
<span class="nc" id="L707">            performAllBuildSteps(listener,buildSteps,phase);</span>
<span class="nc" id="L708">        }</span>

        /**
         * Runs all the given build steps, even if one of them fail.
         *
         * @param phase
         *      true for the post build processing, and false for the final &quot;run after finished&quot; execution.
         *
         * @return false if any build step failed
         */
        protected final boolean performAllBuildSteps(BuildListener listener, Iterable&lt;? extends BuildStep&gt; buildSteps, boolean phase) throws InterruptedException, IOException {
<span class="nc" id="L719">            boolean r = true;</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">            for (BuildStep bs : buildSteps) {</span>
<span class="nc bnc" id="L721" title="All 6 branches missed.">                if ((bs instanceof Publisher &amp;&amp; ((Publisher)bs).needsToRunAfterFinalized()) ^ phase)</span>
                    try {
<span class="nc bnc" id="L723" title="All 2 branches missed.">                        if (!perform(bs,listener)) {</span>
<span class="nc" id="L724">                            LOGGER.log(Level.FINE, &quot;{0} : {1} failed&quot;, new Object[] {AbstractBuild.this, bs});</span>
<span class="nc" id="L725">                            r = false;</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                            if (phase) {</span>
<span class="nc" id="L727">                                setResult(Result.FAILURE);</span>
                            }
                        }
<span class="nc" id="L730">                    } catch (Exception e) {</span>
<span class="nc" id="L731">                        reportError(bs, e, listener, phase);</span>
<span class="nc" id="L732">                        r = false;</span>
<span class="nc" id="L733">                    } catch (LinkageError e) {</span>
<span class="nc" id="L734">                        reportError(bs, e, listener, phase);</span>
<span class="nc" id="L735">                        r = false;</span>
                    }
            }
<span class="nc" id="L738">            return r;</span>
        }

        private void reportError(BuildStep bs, Throwable e, BuildListener listener, boolean phase) {
            final String buildStep;

<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (bs instanceof Describable) {</span>
<span class="nc" id="L745">                buildStep = ((Describable) bs).getDescriptor().getDisplayName();</span>
<span class="nc" id="L746">            } else {</span>
<span class="nc" id="L747">                buildStep = bs.getClass().getName();</span>
            }

<span class="nc bnc" id="L750" title="All 2 branches missed.">            if (e instanceof AbortException) {</span>
<span class="nc" id="L751">                LOGGER.log(Level.FINE, &quot;{0} : {1} failed&quot;, new Object[] {AbstractBuild.this, buildStep});</span>
<span class="nc" id="L752">                listener.error(&quot;Step ‘&quot; + buildStep + &quot;’ failed: &quot; + e.getMessage());</span>
<span class="nc" id="L753">            } else {</span>
<span class="nc" id="L754">                String msg = &quot;Step ‘&quot; + buildStep + &quot;’ aborted due to exception: &quot;;</span>
<span class="nc" id="L755">                e.printStackTrace(listener.error(msg));</span>
<span class="nc" id="L756">                LOGGER.log(WARNING, msg, e);</span>
            }

<span class="nc bnc" id="L759" title="All 2 branches missed.">            if (phase) {</span>
<span class="nc" id="L760">                setResult(Result.FAILURE);</span>
            }
<span class="nc" id="L762">        }</span>

        /**
         * Calls a build step.
         */
        protected final boolean perform(BuildStep bs, BuildListener listener) throws InterruptedException, IOException {
            BuildStepMonitor mon;
            try {
<span class="nc" id="L770">                mon = bs.getRequiredMonitorService();</span>
<span class="nc" id="L771">            } catch (AbstractMethodError e) {</span>
<span class="nc" id="L772">                mon = BuildStepMonitor.BUILD;</span>
            }
<span class="nc" id="L774">            Result oldResult = AbstractBuild.this.getResult();</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">            for (BuildStepListener bsl : BuildStepListener.all()) {</span>
<span class="nc" id="L776">                bsl.started(AbstractBuild.this, bs, listener);</span>
            }

<span class="nc" id="L779">            boolean canContinue = false;</span>
            try {

<span class="nc" id="L782">                canContinue = mon.perform(bs, AbstractBuild.this, launcher, listener);</span>
<span class="nc" id="L783">            } catch (RequestAbortedException ex) {</span>
                // Channel is closed, do not continue
<span class="nc" id="L785">                reportBrokenChannel(listener);</span>
<span class="nc" id="L786">            } catch (ChannelClosedException ex) {</span>
                // Channel is closed, do not continue
<span class="nc" id="L788">                reportBrokenChannel(listener);</span>
<span class="nc" id="L789">            } catch (RuntimeException ex) {</span>

<span class="nc" id="L791">                ex.printStackTrace(listener.error(&quot;Build step failed with exception&quot;));</span>
            }

<span class="nc bnc" id="L794" title="All 2 branches missed.">            for (BuildStepListener bsl : BuildStepListener.all()) {</span>
<span class="nc" id="L795">                bsl.finished(AbstractBuild.this, bs, listener, canContinue);</span>
            }
<span class="nc" id="L797">            Result newResult = AbstractBuild.this.getResult();</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">            if (newResult != oldResult) {</span>
<span class="nc" id="L799">                String buildStepName = getBuildStepName(bs);</span>
<span class="nc" id="L800">                listener.getLogger().format(&quot;Build step '%s' changed build result to %s%n&quot;, buildStepName, newResult);</span>
            }
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if (!canContinue) {</span>
<span class="nc" id="L803">                String buildStepName = getBuildStepName(bs);</span>
<span class="nc" id="L804">                listener.getLogger().format(&quot;Build step '%s' marked build as failure%n&quot;, buildStepName);</span>
            }
<span class="nc" id="L806">            return canContinue;</span>
        }

        private void reportBrokenChannel(BuildListener listener) throws IOException {
<span class="nc" id="L810">            final Node node = getCurrentNode();</span>
<span class="nc" id="L811">            listener.hyperlink(&quot;/&quot; + node.toComputer().getUrl() + &quot;log&quot;, &quot;Slave went offline during the build&quot;);</span>
<span class="nc" id="L812">            listener.getLogger().println();</span>
<span class="nc" id="L813">            final OfflineCause offlineCause = node.toComputer().getOfflineCause();</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">            if (offlineCause != null) {</span>
<span class="nc" id="L815">                listener.error(offlineCause.toString());</span>
            }
<span class="nc" id="L817">        }</span>

        private String getBuildStepName(BuildStep bs) {
<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (bs instanceof Describable&lt;?&gt;) {</span>
<span class="nc" id="L821">                return ((Describable&lt;?&gt;) bs).getDescriptor().getDisplayName();</span>
            } else {
<span class="nc" id="L823">                return bs.getClass().getSimpleName();</span>
            }
        }

        protected final boolean preBuild(BuildListener listener,Map&lt;?,? extends BuildStep&gt; steps) {
<span class="nc" id="L828">            return preBuild(listener,steps.values());</span>
        }

        protected final boolean preBuild(BuildListener listener,Collection&lt;? extends BuildStep&gt; steps) {
<span class="nc" id="L832">            return preBuild(listener,(Iterable&lt;? extends BuildStep&gt;)steps);</span>
        }

        protected final boolean preBuild(BuildListener listener,Iterable&lt;? extends BuildStep&gt; steps) {
<span class="nc bnc" id="L836" title="All 2 branches missed.">            for (BuildStep bs : steps)</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">                if (!bs.prebuild(AbstractBuild.this,listener)) {</span>
<span class="nc" id="L838">                    LOGGER.log(Level.FINE, &quot;{0} : {1} failed&quot;, new Object[] {AbstractBuild.this, bs});</span>
<span class="nc" id="L839">                    return false;</span>
                }
<span class="nc" id="L841">            return true;</span>
        }
    }

    /**
     * get the fingerprints associated with this build
     *
     * @return never null
     */
    @Exported(name = &quot;fingerprint&quot;, inline = true, visibility = -1)
    public Collection&lt;Fingerprint&gt; getBuildFingerprints() {
<span class="nc" id="L852">        FingerprintAction fingerprintAction = getAction(FingerprintAction.class);</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">        if (fingerprintAction != null) {</span>
<span class="nc" id="L854">            return fingerprintAction.getFingerprints().values();</span>
        }
<span class="nc" id="L856">        return Collections.&lt;Fingerprint&gt;emptyList();</span>
    }

	/*
     * No need to to lock the entire AbstractBuild on change set calculcation
     */
<span class="nc" id="L862">    private transient Object changeSetLock = new Object();</span>
    
    /**
     * Gets the changes incorporated into this build.
     *
     * @return never null.
     */
    @Exported
    public ChangeLogSet&lt;? extends Entry&gt; getChangeSet() {
<span class="nc" id="L871">        synchronized (changeSetLock) {</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">            if (scm==null) {</span>
                // for historical reason, null means CVS.
                try {
<span class="nc" id="L875">                    Class&lt;?&gt; c = Jenkins.getInstance().getPluginManager().uberClassLoader.loadClass(&quot;hudson.scm.CVSChangeLogParser&quot;);</span>
<span class="nc" id="L876">                    scm = (ChangeLogParser)c.newInstance();</span>
<span class="nc" id="L877">                } catch (ClassNotFoundException e) {</span>
                    // if CVS isn't available, fall back to something non-null.
<span class="nc" id="L879">                    scm = NullChangeLogParser.INSTANCE;</span>
<span class="nc" id="L880">                } catch (InstantiationException e) {</span>
<span class="nc" id="L881">                    scm = NullChangeLogParser.INSTANCE;</span>
<span class="nc" id="L882">                    throw (Error)new InstantiationError().initCause(e);</span>
<span class="nc" id="L883">                } catch (IllegalAccessException e) {</span>
<span class="nc" id="L884">                    scm = NullChangeLogParser.INSTANCE;</span>
<span class="nc" id="L885">                    throw (Error)new IllegalAccessError().initCause(e);</span>
                }
            }
        }

<span class="nc" id="L890">        ChangeLogSet&lt;? extends Entry&gt; cs = null;</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (changeSet!=null)</span>
<span class="nc" id="L892">            cs = changeSet.get();</span>

<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (cs==null)</span>
<span class="nc" id="L895">            cs = calcChangeSet();</span>

        // defensive check. if the calculation fails (such as through an exception),
        // set a dummy value so that it'll work the next time. the exception will
        // be still reported, giving the plugin developer an opportunity to fix it.
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (cs==null)</span>
<span class="nc" id="L901">            cs = ChangeLogSet.createEmpty(this);</span>

<span class="nc" id="L903">        changeSet = new WeakReference&lt;ChangeLogSet&lt;? extends Entry&gt;&gt;(cs);</span>
<span class="nc" id="L904">        return cs;</span>
    }

    @Restricted(DoNotUse.class) // for project-changes.jelly
    public List&lt;ChangeLogSet&lt;? extends ChangeLogSet.Entry&gt;&gt; getChangeSets() {
<span class="nc" id="L909">        ChangeLogSet&lt;? extends Entry&gt; cs = getChangeSet();</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">        return cs.isEmptySet() ? Collections.&lt;ChangeLogSet&lt;? extends ChangeLogSet.Entry&gt;&gt;emptyList() : Collections.&lt;ChangeLogSet&lt;? extends ChangeLogSet.Entry&gt;&gt;singletonList(cs);</span>
    }

    /**
     * Returns true if the changelog is already computed.
     */
    public boolean hasChangeSetComputed() {
<span class="nc" id="L917">        File changelogFile = new File(getRootDir(), &quot;changelog.xml&quot;);</span>
<span class="nc" id="L918">        return changelogFile.exists();</span>
    }

    private ChangeLogSet&lt;? extends Entry&gt; calcChangeSet() {
<span class="nc" id="L922">        File changelogFile = new File(getRootDir(), &quot;changelog.xml&quot;);</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">        if (!changelogFile.exists())</span>
<span class="nc" id="L924">            return ChangeLogSet.createEmpty(this);</span>

        try {
<span class="nc" id="L927">            return scm.parse(this,changelogFile);</span>
<span class="nc" id="L928">        } catch (IOException e) {</span>
<span class="nc" id="L929">            LOGGER.log(WARNING, &quot;Failed to parse &quot;+changelogFile,e);</span>
<span class="nc" id="L930">        } catch (SAXException e) {</span>
<span class="nc" id="L931">            LOGGER.log(WARNING, &quot;Failed to parse &quot;+changelogFile,e);</span>
        }
<span class="nc" id="L933">        return ChangeLogSet.createEmpty(this);</span>
    }

    @Override
    public EnvVars getEnvironment(TaskListener log) throws IOException, InterruptedException {
<span class="nc" id="L938">        EnvVars env = super.getEnvironment(log);</span>
<span class="nc" id="L939">        FilePath ws = getWorkspace();</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">        if (ws!=null)   // if this is done very early on in the build, workspace may not be decided yet. see HUDSON-3997</span>
<span class="nc" id="L941">            env.put(&quot;WORKSPACE&quot;, ws.getRemote());</span>

<span class="nc" id="L943">        project.getScm().buildEnvVars(this,env);</span>

<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (buildEnvironments!=null)</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">            for (Environment e : buildEnvironments)</span>
<span class="nc" id="L947">                e.buildEnvVars(env);</span>

<span class="nc bnc" id="L949" title="All 2 branches missed.">        for (EnvironmentContributingAction a : getActions(EnvironmentContributingAction.class))</span>
<span class="nc" id="L950">            a.buildEnvVars(this,env);</span>

<span class="nc" id="L952">        EnvVars.resolve(env);</span>

<span class="nc" id="L954">        return env;</span>
    }

    /**
     * During the build, expose the environments contributed by {@link BuildWrapper}s and others.
     * 
     * &lt;p&gt;
     * Since 1.444, executor thread that's doing the build can access mutable underlying list,
     * which allows the caller to add/remove environments. The recommended way of adding
     * environment is through {@link BuildWrapper}, but this might be handy for build steps
     * who wants to expose additional environment variables to the rest of the build.
     * 
     * @return can be empty list, but never null. Immutable.
     * @since 1.437
     */
    public EnvironmentList getEnvironments() {
<span class="nc" id="L970">        Executor e = Executor.currentExecutor();</span>
<span class="nc bnc" id="L971" title="All 4 branches missed.">        if (e!=null &amp;&amp; e.getCurrentExecutable()==this) {</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">            if (buildEnvironments==null)    buildEnvironments = new ArrayList&lt;Environment&gt;();</span>
<span class="nc" id="L973">            return new EnvironmentList(buildEnvironments); </span>
        }
        
<span class="nc bnc" id="L976" title="All 2 branches missed.">        return new EnvironmentList(buildEnvironments==null ? Collections.&lt;Environment&gt;emptyList() : ImmutableList.copyOf(buildEnvironments));</span>
    }

    public Calendar due() {
<span class="nc" id="L980">        return getTimestamp();</span>
    }

    /**
     * {@inheritDoc}
     * The action may have a {@code summary.jelly} view containing a {@code &lt;t:summary&gt;} or other {@code &lt;tr&gt;}.
     */
    @Override public void addAction(Action a) {
<span class="nc" id="L988">        super.addAction(a);</span>
<span class="nc" id="L989">    }</span>
      
    @SuppressWarnings(&quot;deprecation&quot;)
    public List&lt;Action&gt; getPersistentActions(){
<span class="nc" id="L993">        return super.getActions();</span>
    }

    /**
     * Builds up a set of variable names that contain sensitive values that
     * should not be exposed. The expectation is that this set is populated with
     * keys returned by {@link #getBuildVariables()} that should have their
     * values masked for display purposes.
     *
     * @since 1.378
     */
    public Set&lt;String&gt; getSensitiveBuildVariables() {
<span class="nc" id="L1005">        Set&lt;String&gt; s = new HashSet&lt;String&gt;();</span>

<span class="nc" id="L1007">        ParametersAction parameters = getAction(ParametersAction.class);</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (parameters != null) {</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            for (ParameterValue p : parameters) {</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">                if (p.isSensitive()) {</span>
<span class="nc" id="L1011">                    s.add(p.getName());</span>
                }
            }
        }

        // Allow BuildWrappers to determine if any of their data is sensitive
<span class="nc bnc" id="L1017" title="All 2 branches missed.">        if (project instanceof BuildableItemWithBuildWrappers) {</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            for (BuildWrapper bw : ((BuildableItemWithBuildWrappers) project).getBuildWrappersList()) {</span>
<span class="nc" id="L1019">                bw.makeSensitiveBuildVariables(this, s);</span>
            }
        }
        
<span class="nc" id="L1023">        return s;</span>
    }

    /**
     * Provides additional variables and their values to {@link Builder}s.
     *
     * &lt;p&gt;
     * This mechanism is used by {@code MatrixConfiguration} to pass
     * the configuration values to the current build. It is up to
     * {@link Builder}s to decide whether they want to recognize the values
     * or how to use them.
     *
     * &lt;p&gt;
     * This also includes build parameters if a build is parameterized.
     *
     * @return
     *      The returned map is mutable so that subtypes can put more values.
     */
    public Map&lt;String,String&gt; getBuildVariables() {
<span class="nc" id="L1042">        Map&lt;String,String&gt; r = new HashMap&lt;String, String&gt;();</span>

<span class="nc" id="L1044">        ParametersAction parameters = getAction(ParametersAction.class);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">        if (parameters!=null) {</span>
            // this is a rather round about way of doing this...
<span class="nc bnc" id="L1047" title="All 2 branches missed.">            for (ParameterValue p : parameters) {</span>
<span class="nc" id="L1048">                String v = p.createVariableResolver(this).resolve(p.getName());</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                if (v!=null) r.put(p.getName(),v);</span>
            }
        }

        // allow the BuildWrappers to contribute additional build variables
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        if (project instanceof BuildableItemWithBuildWrappers) {</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">            for (BuildWrapper bw : ((BuildableItemWithBuildWrappers) project).getBuildWrappersList())</span>
<span class="nc" id="L1056">                bw.makeBuildVariables(this,r);</span>
        }

<span class="nc bnc" id="L1059" title="All 2 branches missed.">        for (BuildVariableContributor bvc : BuildVariableContributor.all())</span>
<span class="nc" id="L1060">            bvc.buildVariablesFor(this,r);</span>

<span class="nc" id="L1062">        return r;</span>
    }

    /**
     * Creates {@link VariableResolver} backed by {@link #getBuildVariables()}.
     */
    public final VariableResolver&lt;String&gt; getBuildVariableResolver() {
<span class="nc" id="L1069">        return new VariableResolver.ByMap&lt;String&gt;(getBuildVariables());</span>
    }

    /**
     * @deprecated Use {@link #getAction(Class)} on {@link AbstractTestResultAction}.
     */
    @Deprecated
    public Action getTestResultAction() {
        try {
<span class="nc" id="L1078">            return getAction(Jenkins.getInstance().getPluginManager().uberClassLoader.loadClass(&quot;hudson.tasks.test.AbstractTestResultAction&quot;).asSubclass(Action.class));</span>
<span class="nc" id="L1079">        } catch (ClassNotFoundException x) {</span>
<span class="nc" id="L1080">            return null;</span>
        }
    }

    /**
     * @deprecated Use {@link #getAction(Class)} on {@link AggregatedTestResultAction}.
     */
    @Deprecated
    public Action getAggregatedTestResultAction() {
        try {
<span class="nc" id="L1090">            return getAction(Jenkins.getInstance().getPluginManager().uberClassLoader.loadClass(&quot;hudson.tasks.test.AggregatedTestResultAction&quot;).asSubclass(Action.class));</span>
<span class="nc" id="L1091">        } catch (ClassNotFoundException x) {</span>
<span class="nc" id="L1092">            return null;</span>
        }
    }

    /**
     * Invoked by {@link Executor} to performs a build.
     */
    public abstract void run();

//
//
// fingerprint related stuff
//
//

    @Override
    public String getWhyKeepLog() {
        // if any of the downstream project is configured with 'keep dependency component',
        // we need to keep this log
        OUTER:
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        for (AbstractProject&lt;?,?&gt; p : getParent().getDownstreamProjects()) {</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">            if (!p.isKeepDependencies()) continue;</span>

<span class="nc" id="L1115">            AbstractBuild&lt;?,?&gt; fb = p.getFirstBuild();</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">            if (fb==null)        continue; // no active record</span>

            // is there any active build that depends on us?
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            for (int i : getDownstreamRelationship(p).listNumbersReverse()) {</span>
                // TODO: this is essentially a &quot;find intersection between two sparse sequences&quot;
                // and we should be able to do much better.

<span class="nc bnc" id="L1123" title="All 2 branches missed.">                if (i&lt;fb.getNumber())</span>
<span class="nc" id="L1124">                    continue OUTER; // all the other records are younger than the first record, so pointless to search.</span>

<span class="nc" id="L1126">                AbstractBuild&lt;?,?&gt; b = p.getBuildByNumber(i);</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">                if (b!=null)</span>
<span class="nc" id="L1128">                    return Messages.AbstractBuild_KeptBecause(b);</span>
            }
        }

<span class="nc" id="L1132">        return super.getWhyKeepLog();</span>
    }

    /**
     * Gets the dependency relationship from this build (as the source)
     * and that project (as the sink.)
     *
     * @return
     *      range of build numbers that represent which downstream builds are using this build.
     *      The range will be empty if no build of that project matches this (or there is no {@link FingerprintAction}), but it'll never be null.
     */
    public RangeSet getDownstreamRelationship(AbstractProject that) {
<span class="nc" id="L1144">        RangeSet rs = new RangeSet();</span>

<span class="nc" id="L1146">        FingerprintAction f = getAction(FingerprintAction.class);</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        if (f==null)     return rs;</span>

        // look for fingerprints that point to this build as the source, and merge them all
<span class="nc bnc" id="L1150" title="All 2 branches missed.">        for (Fingerprint e : f.getFingerprints().values()) {</span>

<span class="nc bnc" id="L1152" title="All 2 branches missed.">            if (upstreamCulprits) {</span>
                // With upstreamCulprits, we allow downstream relationships
                // from intermediate jobs
<span class="nc" id="L1155">                rs.add(e.getRangeSet(that));</span>
<span class="nc" id="L1156">            } else {</span>
<span class="nc" id="L1157">                BuildPtr o = e.getOriginal();</span>
<span class="nc bnc" id="L1158" title="All 4 branches missed.">                if (o!=null &amp;&amp; o.is(this))</span>
<span class="nc" id="L1159">                    rs.add(e.getRangeSet(that));</span>
            }
        }

<span class="nc" id="L1163">        return rs;</span>
    }

    /**
     * Works like {@link #getDownstreamRelationship(AbstractProject)} but returns
     * the actual build objects, in ascending order.
     * @since 1.150
     */
    public Iterable&lt;AbstractBuild&lt;?,?&gt;&gt; getDownstreamBuilds(final AbstractProject&lt;?,?&gt; that) {
<span class="nc" id="L1172">        final Iterable&lt;Integer&gt; nums = getDownstreamRelationship(that).listNumbers();</span>

<span class="nc" id="L1174">        return new Iterable&lt;AbstractBuild&lt;?, ?&gt;&gt;() {</span>
            public Iterator&lt;AbstractBuild&lt;?, ?&gt;&gt; iterator() {
<span class="nc" id="L1176">                return Iterators.removeNull(</span>
<span class="nc" id="L1177">                    new AdaptedIterator&lt;Integer,AbstractBuild&lt;?,?&gt;&gt;(nums) {</span>
                        protected AbstractBuild&lt;?, ?&gt; adapt(Integer item) {
<span class="nc" id="L1179">                            return that.getBuildByNumber(item);</span>
                        }
                    });
            }
        };
    }

    /**
     * Gets the dependency relationship from this build (as the sink)
     * and that project (as the source.)
     *
     * @return
     *      Build number of the upstream build that feed into this build,
     *      or -1 if no record is available (for example if there is no {@link FingerprintAction}, even if there is an {@link Cause.UpstreamCause}).
     */
    public int getUpstreamRelationship(AbstractProject that) {
<span class="nc" id="L1195">        FingerprintAction f = getAction(FingerprintAction.class);</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">        if (f==null)     return -1;</span>

<span class="nc" id="L1198">        int n = -1;</span>

        // look for fingerprints that point to the given project as the source, and merge them all
<span class="nc bnc" id="L1201" title="All 2 branches missed.">        for (Fingerprint e : f.getFingerprints().values()) {</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">            if (upstreamCulprits) {</span>
                // With upstreamCulprits, we allow upstream relationships
                // from intermediate jobs
<span class="nc" id="L1205">                Fingerprint.RangeSet rangeset = e.getRangeSet(that);</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">                if (!rangeset.isEmpty()) {</span>
<span class="nc" id="L1207">                    n = Math.max(n, rangeset.listNumbersReverse().iterator().next());</span>
                }
<span class="nc" id="L1209">            } else {</span>
<span class="nc" id="L1210">                BuildPtr o = e.getOriginal();</span>
<span class="nc bnc" id="L1211" title="All 4 branches missed.">                if (o!=null &amp;&amp; o.belongsTo(that))</span>
<span class="nc" id="L1212">                    n = Math.max(n,o.getNumber());</span>
            }
        }

<span class="nc" id="L1216">        return n;</span>
    }

    /**
     * Works like {@link #getUpstreamRelationship(AbstractProject)} but returns the
     * actual build object.
     *
     * @return
     *      null if no such upstream build was found, or it was found but the
     *      build record is already lost.
     */
    public AbstractBuild&lt;?,?&gt; getUpstreamRelationshipBuild(AbstractProject&lt;?,?&gt; that) {
<span class="nc" id="L1228">        int n = getUpstreamRelationship(that);</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if (n==-1)   return null;</span>
<span class="nc" id="L1230">        return that.getBuildByNumber(n);</span>
    }

    /**
     * Gets the downstream builds of this build, which are the builds of the
     * downstream projects that use artifacts of this build.
     *
     * @return
     *      For each project with fingerprinting enabled, returns the range
     *      of builds (which can be empty if no build uses the artifact from this build or downstream is not {@link AbstractProject#isFingerprintConfigured}.)
     */
    public Map&lt;AbstractProject,RangeSet&gt; getDownstreamBuilds() {
<span class="nc" id="L1242">        Map&lt;AbstractProject,RangeSet&gt; r = new HashMap&lt;AbstractProject,RangeSet&gt;();</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">        for (AbstractProject p : getParent().getDownstreamProjects()) {</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">            if (p.isFingerprintConfigured())</span>
<span class="nc" id="L1245">                r.put(p,getDownstreamRelationship(p));</span>
        }
<span class="nc" id="L1247">        return r;</span>
    }

    /**
     * Gets the upstream builds of this build, which are the builds of the
     * upstream projects whose artifacts feed into this build.
     * @return empty if there is no {@link FingerprintAction} (even if there is an {@link Cause.UpstreamCause})
     * @see #getTransitiveUpstreamBuilds()
     */
    public Map&lt;AbstractProject,Integer&gt; getUpstreamBuilds() {
<span class="nc" id="L1257">        return _getUpstreamBuilds(getParent().getUpstreamProjects());</span>
    }

    /**
     * Works like {@link #getUpstreamBuilds()}  but also includes all the transitive
     * dependencies as well.
     */
    public Map&lt;AbstractProject,Integer&gt; getTransitiveUpstreamBuilds() {
<span class="nc" id="L1265">        return _getUpstreamBuilds(getParent().getTransitiveUpstreamProjects());</span>
    }

    private Map&lt;AbstractProject, Integer&gt; _getUpstreamBuilds(Collection&lt;AbstractProject&gt; projects) {
<span class="nc" id="L1269">        Map&lt;AbstractProject,Integer&gt; r = new HashMap&lt;AbstractProject,Integer&gt;();</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">        for (AbstractProject p : projects) {</span>
<span class="nc" id="L1271">            int n = getUpstreamRelationship(p);</span>
<span class="nc bnc" id="L1272" title="All 2 branches missed.">            if (n&gt;=0)</span>
<span class="nc" id="L1273">                r.put(p,n);</span>
        }
<span class="nc" id="L1275">        return r;</span>
    }

    /**
     * Gets the changes in the dependency between the given build and this build.
     * @return empty if there is no {@link FingerprintAction}
     */
    public Map&lt;AbstractProject,DependencyChange&gt; getDependencyChanges(AbstractBuild from) {
<span class="nc bnc" id="L1283" title="All 2 branches missed.">        if (from==null)             return Collections.emptyMap(); // make it easy to call this from views</span>
<span class="nc" id="L1284">        FingerprintAction n = this.getAction(FingerprintAction.class);</span>
<span class="nc" id="L1285">        FingerprintAction o = from.getAction(FingerprintAction.class);</span>
<span class="nc bnc" id="L1286" title="All 4 branches missed.">        if (n==null || o==null)     return Collections.emptyMap();</span>

<span class="nc" id="L1288">        Map&lt;AbstractProject,Integer&gt; ndep = n.getDependencies(true);</span>
<span class="nc" id="L1289">        Map&lt;AbstractProject,Integer&gt; odep = o.getDependencies(true);</span>

<span class="nc" id="L1291">        Map&lt;AbstractProject,DependencyChange&gt; r = new HashMap&lt;AbstractProject,DependencyChange&gt;();</span>

<span class="nc bnc" id="L1293" title="All 2 branches missed.">        for (Map.Entry&lt;AbstractProject,Integer&gt; entry : odep.entrySet()) {</span>
<span class="nc" id="L1294">            AbstractProject p = entry.getKey();</span>
<span class="nc" id="L1295">            Integer oldNumber = entry.getValue();</span>
<span class="nc" id="L1296">            Integer newNumber = ndep.get(p);</span>
<span class="nc bnc" id="L1297" title="All 4 branches missed.">            if (newNumber!=null &amp;&amp; oldNumber.compareTo(newNumber)&lt;0) {</span>
<span class="nc" id="L1298">                r.put(p,new DependencyChange(p,oldNumber,newNumber));</span>
            }
        }

<span class="nc" id="L1302">        return r;</span>
    }

    /**
     * Represents a change in the dependency.
     */
    public static final class DependencyChange {
        /**
         * The dependency project.
         */
        public final AbstractProject project;
        /**
         * Version of the dependency project used in the previous build.
         */
        public final int fromId;
        /**
         * {@link Build} object for {@link #fromId}. Can be null if the log is gone.
         */
        public final AbstractBuild from;
        /**
         * Version of the dependency project used in this build.
         */
        public final int toId;

        public final AbstractBuild to;

<span class="nc" id="L1328">        public DependencyChange(AbstractProject&lt;?,?&gt; project, int fromId, int toId) {</span>
<span class="nc" id="L1329">            this.project = project;</span>
<span class="nc" id="L1330">            this.fromId = fromId;</span>
<span class="nc" id="L1331">            this.toId = toId;</span>
<span class="nc" id="L1332">            this.from = project.getBuildByNumber(fromId);</span>
<span class="nc" id="L1333">            this.to = project.getBuildByNumber(toId);</span>
<span class="nc" id="L1334">        }</span>

        /**
         * Gets the {@link AbstractBuild} objects (fromId,toId].
         * &lt;p&gt;
         * This method returns all such available builds in the ascending order
         * of IDs, but due to log rotations, some builds may be already unavailable.
         */
        public List&lt;AbstractBuild&gt; getBuilds() {
<span class="nc" id="L1343">            List&lt;AbstractBuild&gt; r = new ArrayList&lt;AbstractBuild&gt;();</span>

<span class="nc" id="L1345">            AbstractBuild&lt;?,?&gt; b = project.getNearestBuild(fromId);</span>
<span class="nc bnc" id="L1346" title="All 4 branches missed.">            if (b!=null &amp;&amp; b.getNumber()==fromId)</span>
<span class="nc" id="L1347">                b = b.getNextBuild(); // fromId exclusive</span>

<span class="nc bnc" id="L1349" title="All 4 branches missed.">            while (b!=null &amp;&amp; b.getNumber()&lt;=toId) {</span>
<span class="nc" id="L1350">                r.add(b);</span>
<span class="nc" id="L1351">                b = b.getNextBuild();</span>
            }

<span class="nc" id="L1354">            return r;</span>
        }
    }

    //
    // web methods
    //

    /**
     * @deprecated as of 1.489
     *      Use {@link #doStop()}
     */
    @Deprecated
    public void doStop(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<span class="nc" id="L1368">        doStop().generateResponse(req,rsp,this);</span>
<span class="nc" id="L1369">    }</span>

    /**
     * Stops this build if it's still going.
     *
     * If we use this/executor/stop URL, it causes 404 if the build is already killed,
     * as {@link #getExecutor()} returns null.
     * 
     * @since 1.489
     */
    @RequirePOST
    public synchronized HttpResponse doStop() throws IOException, ServletException {
<span class="nc" id="L1381">        Executor e = getExecutor();</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">        if (e==null)</span>
<span class="nc" id="L1383">            e = getOneOffExecutor();</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">        if (e!=null)</span>
<span class="nc" id="L1385">            return e.doStop();</span>
        else
            // nothing is building
<span class="nc" id="L1388">            return HttpResponses.forwardToPreviousPage();</span>
    }

<span class="fc" id="L1391">    private static final Logger LOGGER = Logger.getLogger(AbstractBuild.class.getName());</span>
}


</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>jenkins-core (22-mrt-2016 21:51:03)</div></body></html>