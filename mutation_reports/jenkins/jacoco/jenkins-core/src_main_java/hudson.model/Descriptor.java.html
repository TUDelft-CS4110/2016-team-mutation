<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Descriptor.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">jenkins-core (22-mrt-2016 21:51:03)</a> &gt; <a href="../../index.html" class="el_group">jenkins-core</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">hudson.model</a> &gt; <span class="el_source">Descriptor.java</span></div><h1>Descriptor.java</h1><pre class="source lang-java linenums">/*
 * The MIT License
 * 
 * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package hudson.model;

import hudson.DescriptorExtensionList;
import hudson.PluginWrapper;
import hudson.RelativePath;
import hudson.XmlFile;
import hudson.BulkChange;
import hudson.ExtensionList;
import hudson.Util;
import hudson.model.listeners.SaveableListener;
import hudson.util.FormApply;
import hudson.util.FormValidation.CheckMethod;
import hudson.util.ReflectionUtils;
import hudson.util.ReflectionUtils.Parameter;
import hudson.views.ListViewColumn;
import jenkins.model.Jenkins;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import org.kohsuke.stapler.*;
import org.kohsuke.stapler.jelly.JellyCompatibleFacet;
import org.kohsuke.stapler.lang.Klass;
import org.springframework.util.StringUtils;
import org.jvnet.tiger_types.Types;
import org.apache.commons.io.IOUtils;

import static hudson.util.QuotedStringTokenizer.*;
import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
import javax.servlet.ServletException;
import javax.servlet.RequestDispatcher;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import java.util.Arrays;
import java.util.Collections;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.beans.Introspector;
import java.util.IdentityHashMap;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;

/**
 * Metadata about a configurable instance.
 *
 * &lt;p&gt;
 * {@link Descriptor} is an object that has metadata about a {@link Describable}
 * object, and also serves as a factory (in a way this relationship is similar
 * to {@link Object}/{@link Class} relationship.
 *
 * A {@link Descriptor}/{@link Describable}
 * combination is used throughout in Hudson to implement a
 * configuration/extensibility mechanism.
 *
 * &lt;p&gt;
 * Take the list view support as an example, which is implemented
 * in {@link ListView} class. Whenever a new view is created, a new
 * {@link ListView} instance is created with the configuration
 * information. This instance gets serialized to XML, and this instance
 * will be called to render the view page. This is the job
 * of {@link Describable} &amp;mdash; each instance represents a specific
 * configuration of a view (what projects are in it, regular expression, etc.)
 *
 * &lt;p&gt;
 * For Hudson to create such configured {@link ListView} instance, Hudson
 * needs another object that captures the metadata of {@link ListView},
 * and that is what a {@link Descriptor} is for. {@link ListView} class
 * has a singleton descriptor, and this descriptor helps render
 * the configuration form, remember system-wide configuration, and works as a factory.
 *
 * &lt;p&gt;
 * {@link Descriptor} also usually have its associated views.
 *
 *
 * &lt;h2&gt;Persistence&lt;/h2&gt;
 * &lt;p&gt;
 * {@link Descriptor} can persist data just by storing them in fields.
 * However, it is the responsibility of the derived type to properly
 * invoke {@link #save()} and {@link #load()}.
 *
 * &lt;h2&gt;Reflection Enhancement&lt;/h2&gt;
 * {@link Descriptor} defines addition to the standard Java reflection
 * and provides reflective information about its corresponding {@link Describable}.
 * These are primarily used by tag libraries to
 * keep the Jelly scripts concise. 
 *
 * @author Kohsuke Kawaguchi
 * @see Describable
 */
public abstract class Descriptor&lt;T extends Describable&lt;T&gt;&gt; implements Saveable {
    /**
     * The class being described by this descriptor.
     */
    public transient final Class&lt;? extends T&gt; clazz;

<span class="pc" id="L132">    private transient final Map&lt;String,CheckMethod&gt; checkMethods = new ConcurrentHashMap&lt;String,CheckMethod&gt;();</span>

    /**
     * Lazily computed list of properties on {@link #clazz} and on the descriptor itself.
     */
    private transient volatile Map&lt;String, PropertyType&gt; propertyTypes,globalPropertyTypes;

    /**
     * Represents a readable property on {@link Describable}.
     */
    public static final class PropertyType {
        public final Class clazz;
        public final Type type;
        private volatile Class itemType;
        public final String displayName;

<span class="nc" id="L148">        PropertyType(Class clazz, Type type, String displayName) {</span>
<span class="nc" id="L149">            this.clazz = clazz;</span>
<span class="nc" id="L150">            this.type = type;</span>
<span class="nc" id="L151">            this.displayName = displayName;</span>
<span class="nc" id="L152">        }</span>

        PropertyType(Field f) {
<span class="nc" id="L155">            this(f.getType(),f.getGenericType(),f.toString());</span>
<span class="nc" id="L156">        }</span>

        PropertyType(Method getter) {
<span class="nc" id="L159">            this(getter.getReturnType(),getter.getGenericReturnType(),getter.toString());</span>
<span class="nc" id="L160">        }</span>

        public Enum[] getEnumConstants() {
<span class="nc" id="L163">            return (Enum[])clazz.getEnumConstants();</span>
        }

        /**
         * If the property is a collection/array type, what is an item type?
         */
        public Class getItemType() {
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if(itemType==null)</span>
<span class="nc" id="L171">                itemType = computeItemType();</span>
<span class="nc" id="L172">            return itemType;</span>
        }

        private Class computeItemType() {
<span class="nc bnc" id="L176" title="All 2 branches missed.">            if(clazz.isArray()) {</span>
<span class="nc" id="L177">                return clazz.getComponentType();</span>
            }
<span class="nc bnc" id="L179" title="All 2 branches missed.">            if(Collection.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L180">                Type col = Types.getBaseClass(type, Collection.class);</span>

<span class="nc bnc" id="L182" title="All 2 branches missed.">                if (col instanceof ParameterizedType)</span>
<span class="nc" id="L183">                    return Types.erasure(Types.getTypeArgument(col,0));</span>
                else
<span class="nc" id="L185">                    return Object.class;</span>
            }
<span class="nc" id="L187">            return null;</span>
        }

        /**
         * Returns {@link Descriptor} whose 'clazz' is the same as {@link #getItemType() the item type}.
         */
        public Descriptor getItemTypeDescriptor() {
<span class="nc" id="L194">            return Jenkins.getInstance().getDescriptor(getItemType());</span>
        }

        public Descriptor getItemTypeDescriptorOrDie() {
<span class="nc" id="L198">            Class it = getItemType();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (it == null) {</span>
<span class="nc" id="L200">                throw new AssertionError(clazz + &quot; is not an array/collection type in &quot; + displayName + &quot;. See https://wiki.jenkins-ci.org/display/JENKINS/My+class+is+missing+descriptor&quot;);</span>
            }
<span class="nc" id="L202">            Descriptor d = Jenkins.getInstance().getDescriptor(it);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (d==null)</span>
<span class="nc" id="L204">                throw new AssertionError(it +&quot; is missing its descriptor in &quot;+displayName+&quot;. See https://wiki.jenkins-ci.org/display/JENKINS/My+class+is+missing+descriptor&quot;);</span>
<span class="nc" id="L205">            return d;</span>
        }

        /**
         * Returns all the descriptors that produce types assignable to the property type.
         */
        public List&lt;? extends Descriptor&gt; getApplicableDescriptors() {
<span class="nc" id="L212">            return Jenkins.getInstance().getDescriptorList(clazz);</span>
        }

        /**
         * Returns all the descriptors that produce types assignable to the item type for a collection property.
         */
        public List&lt;? extends Descriptor&gt; getApplicableItemDescriptors() {
<span class="nc" id="L219">            return Jenkins.getInstance().getDescriptorList(getItemType());</span>
        }
    }

    /**
     * Help file redirect, keyed by the field name to the path.
     *
     * @see #getHelpFile(String) 
     */
<span class="pc" id="L228">    private transient final Map&lt;String,HelpRedirect&gt; helpRedirect = new HashMap&lt;String,HelpRedirect&gt;();</span>

    private static class HelpRedirect {
        private final Class&lt;? extends Describable&gt; owner;
        private final String fieldNameToRedirectTo;

<span class="nc" id="L234">        private HelpRedirect(Class&lt;? extends Describable&gt; owner, String fieldNameToRedirectTo) {</span>
<span class="nc" id="L235">            this.owner = owner;</span>
<span class="nc" id="L236">            this.fieldNameToRedirectTo = fieldNameToRedirectTo;</span>
<span class="nc" id="L237">        }</span>

        private String resolve() {
            // the resolution has to be deferred to avoid ordering issue among descriptor registrations.
<span class="nc" id="L241">            return Jenkins.getInstance().getDescriptor(owner).getHelpFile(fieldNameToRedirectTo);</span>
        }
    }

    /**
     *
     * @param clazz
     *      Pass in {@link #self()} to have the descriptor describe itself,
     *      (this hack is needed since derived types can't call &quot;getClass()&quot; to refer to itself.
     */
<span class="nc" id="L251">    protected Descriptor(Class&lt;? extends T&gt; clazz) {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (clazz==self())</span>
<span class="nc" id="L253">            clazz = (Class)getClass();</span>
<span class="nc" id="L254">        this.clazz = clazz;</span>
        // doing this turns out to be very error prone,
        // as field initializers in derived types will override values.
        // load();
<span class="nc" id="L258">    }</span>

    /**
     * Infers the type of the corresponding {@link Describable} from the outer class.
     * This version works when you follow the common convention, where a descriptor
     * is written as the static nested class of the describable class.
     * 
     * @since 1.278
     */
<span class="fc" id="L267">    protected Descriptor() {</span>
<span class="fc" id="L268">        this.clazz = (Class&lt;T&gt;)getClass().getEnclosingClass();</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if(clazz==null)</span>
<span class="nc" id="L270">            throw new AssertionError(getClass()+&quot; doesn't have an outer class. Use the constructor that takes the Class object explicitly.&quot;);</span>

        // detect an type error
<span class="fc" id="L273">        Type bt = Types.getBaseClass(getClass(), Descriptor.class);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (bt instanceof ParameterizedType) {</span>
<span class="fc" id="L275">            ParameterizedType pt = (ParameterizedType) bt;</span>
            // this 't' is the closest approximation of T of Descriptor&lt;T&gt;.
<span class="fc" id="L277">            Class t = Types.erasure(pt.getActualTypeArguments()[0]);</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            if(!t.isAssignableFrom(clazz))</span>
<span class="nc" id="L279">                throw new AssertionError(&quot;Outer class &quot;+clazz+&quot; of &quot;+getClass()+&quot; is not assignable to &quot;+t+&quot;. Perhaps wrong outer class?&quot;);</span>
        }

        // detect a type error. this Descriptor is supposed to be returned from getDescriptor(), so make sure its type match up.
        // this prevents a bug like http://www.nabble.com/Creating-a-new-parameter-Type-%3A-Masked-Parameter-td24786554.html
        try {
<span class="fc" id="L285">            Method getd = clazz.getMethod(&quot;getDescriptor&quot;);</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">            if(!getd.getReturnType().isAssignableFrom(getClass())) {</span>
<span class="nc" id="L287">                throw new AssertionError(getClass()+&quot; must be assignable to &quot;+getd.getReturnType());</span>
            }
<span class="nc" id="L289">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L290">            throw new AssertionError(getClass()+&quot; is missing getDescriptor method.&quot;);</span>
        }

<span class="fc" id="L293">    }</span>

    /**
     * Human readable name of this kind of configurable object.
     * Should be overridden for most descriptors, if the display name is visible somehow.
     * As a fallback it uses {@link Class#getSimpleName} on {@link #clazz}, so for example {@code MyThing} from {@code some.pkg.MyThing.DescriptorImpl}.
     * Historically some implementations returned null as a way of hiding the descriptor from the UI,
     * but this is generally managed by an explicit method such as {@code isEnabled} or {@code isApplicable}.
     */
    @Nonnull
    public String getDisplayName() {
<span class="nc" id="L304">        return clazz.getSimpleName();</span>
    }

    /**
     * Uniquely identifies this {@link Descriptor} among all the other {@link Descriptor}s.
     *
     * &lt;p&gt;
     * Historically {@link #clazz} is assumed to be unique, so this method uses that as the default,
     * but if you are adding {@link Descriptor}s programmatically for the same type, you can change
     * this to disambiguate them.
     *
     * &lt;p&gt;
     * To look up {@link Descriptor} from ID, use {@link Jenkins#getDescriptor(String)}.
     *
     * @return
     *      Stick to valid Java identifier character, plus '.', which had to be allowed for historical reasons.
     * 
     * @since 1.391
     */
    public String getId() {
<span class="nc" id="L324">        return clazz.getName();</span>
    }

    /**
     * Unlike {@link #clazz}, return the parameter type 'T', which determines
     * the {@link DescriptorExtensionList} that this goes to.
     *
     * &lt;p&gt;
     * In those situations where subtypes cannot provide the type parameter,
     * this method can be overridden to provide it.
     */
    public Class&lt;T&gt; getT() {
<span class="nc" id="L336">        Type subTyping = Types.getBaseClass(getClass(), Descriptor.class);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (!(subTyping instanceof ParameterizedType)) {</span>
<span class="nc" id="L338">            throw new IllegalStateException(getClass()+&quot; doesn't extend Descriptor with a type parameter.&quot;);</span>
        }
<span class="nc" id="L340">        return Types.erasure(Types.getTypeArgument(subTyping, 0));</span>
    }

    /**
     * Gets the URL that this Descriptor is bound to, relative to the nearest {@link DescriptorByNameOwner}.
     * Since {@link Jenkins} is a {@link DescriptorByNameOwner}, there's always one such ancestor to any request.
     */
    public String getDescriptorUrl() {
<span class="nc" id="L348">        return &quot;descriptorByName/&quot;+getId();</span>
    }

    /**
     * Gets the URL that this Descriptor is bound to, relative to the context path.
     * @since 1.406
     */
    public final String getDescriptorFullUrl() {
<span class="nc" id="L356">        return getCurrentDescriptorByNameUrl()+'/'+getDescriptorUrl();</span>
    }

    /**
     * @since 1.402
     */
    public static String getCurrentDescriptorByNameUrl() {
<span class="nc" id="L363">        StaplerRequest req = Stapler.getCurrentRequest();</span>

        // this override allows RenderOnDemandClosure to preserve the proper value
<span class="nc" id="L366">        Object url = req.getAttribute(&quot;currentDescriptorByNameUrl&quot;);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (url!=null)  return url.toString();</span>

<span class="nc" id="L369">        Ancestor a = req.findAncestor(DescriptorByNameOwner.class);</span>
<span class="nc" id="L370">        return a.getUrl();</span>
    }

    /**
     * @deprecated since 1.528
     *      Use {@link #getCheckMethod(String)}
     */
    @Deprecated
    public String getCheckUrl(String fieldName) {
<span class="nc" id="L379">        return getCheckMethod(fieldName).toCheckUrl();</span>
    }

    /**
     * If the field &quot;xyz&quot; of a {@link Describable} has the corresponding &quot;doCheckXyz&quot; method,
     * return the model of the check method.
     * &lt;p&gt;
     * This method is used to hook up the form validation method to the corresponding HTML input element.
     */
    public CheckMethod getCheckMethod(String fieldName) {
<span class="nc" id="L389">        CheckMethod method = checkMethods.get(fieldName);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if(method==null) {</span>
<span class="nc" id="L391">            method = new CheckMethod(this,fieldName);</span>
<span class="nc" id="L392">            checkMethods.put(fieldName,method);</span>
        }

<span class="nc" id="L395">        return method;</span>
    }

    /**
     * Computes the list of other form fields that the given field depends on, via the doFillXyzItems method,
     * and sets that as the 'fillDependsOn' attribute. Also computes the URL of the doFillXyzItems and
     * sets that as the 'fillUrl' attribute.
     */
    public void calcFillSettings(String field, Map&lt;String,Object&gt; attributes) {
<span class="nc" id="L404">        String capitalizedFieldName = StringUtils.capitalize(field);</span>
<span class="nc" id="L405">        String methodName = &quot;doFill&quot; + capitalizedFieldName + &quot;Items&quot;;</span>
<span class="nc" id="L406">        Method method = ReflectionUtils.getPublicMethodNamed(getClass(), methodName);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if(method==null)</span>
<span class="nc" id="L408">            throw new IllegalStateException(String.format(&quot;%s doesn't have the %s method for filling a drop-down list&quot;, getClass(), methodName));</span>

        // build query parameter line by figuring out what should be submitted
<span class="nc" id="L411">        List&lt;String&gt; depends = buildFillDependencies(method, new ArrayList&lt;String&gt;());</span>

<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (!depends.isEmpty())</span>
<span class="nc" id="L414">            attributes.put(&quot;fillDependsOn&quot;,Util.join(depends,&quot; &quot;));</span>
<span class="nc" id="L415">        attributes.put(&quot;fillUrl&quot;, String.format(&quot;%s/%s/fill%sItems&quot;, getCurrentDescriptorByNameUrl(), getDescriptorUrl(), capitalizedFieldName));</span>
<span class="nc" id="L416">    }</span>

    private List&lt;String&gt; buildFillDependencies(Method method, List&lt;String&gt; depends) {
<span class="nc bnc" id="L419" title="All 2 branches missed.">        for (Parameter p : ReflectionUtils.getParameters(method)) {</span>
<span class="nc" id="L420">            QueryParameter qp = p.annotation(QueryParameter.class);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (qp!=null) {</span>
<span class="nc" id="L422">                String name = qp.value();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                if (name.length()==0) name = p.name();</span>
<span class="nc bnc" id="L424" title="All 4 branches missed.">                if (name==null || name.length()==0)</span>
<span class="nc" id="L425">                    continue;   // unknown parameter name. we'll report the error when the form is submitted.</span>

<span class="nc" id="L427">                RelativePath rp = p.annotation(RelativePath.class);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                if (rp!=null)</span>
<span class="nc" id="L429">                    name = rp.value()+'/'+name;</span>

<span class="nc" id="L431">                depends.add(name);</span>
<span class="nc" id="L432">                continue;</span>
            }

<span class="nc" id="L435">            Method m = ReflectionUtils.getPublicMethodNamed(p.type(), &quot;fromStapler&quot;);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            if (m!=null)</span>
<span class="nc" id="L437">                buildFillDependencies(m,depends);</span>
        }
<span class="nc" id="L439">        return depends;</span>
    }

    /**
     * Computes the auto-completion setting
     */
    public void calcAutoCompleteSettings(String field, Map&lt;String,Object&gt; attributes) {
<span class="nc" id="L446">        String capitalizedFieldName = StringUtils.capitalize(field);</span>
<span class="nc" id="L447">        String methodName = &quot;doAutoComplete&quot; + capitalizedFieldName;</span>
<span class="nc" id="L448">        Method method = ReflectionUtils.getPublicMethodNamed(getClass(), methodName);</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if(method==null)</span>
<span class="nc" id="L450">            return;    // no auto-completion</span>

<span class="nc" id="L452">        attributes.put(&quot;autoCompleteUrl&quot;, String.format(&quot;%s/%s/autoComplete%s&quot;, getCurrentDescriptorByNameUrl(), getDescriptorUrl(), capitalizedFieldName));</span>
<span class="nc" id="L453">    }</span>

    /**
     * Used by Jelly to abstract away the handlign of global.jelly vs config.jelly databinding difference.
     */
    public @CheckForNull PropertyType getPropertyType(@Nonnull Object instance, @Nonnull String field) {
        // in global.jelly, instance==descriptor
<span class="nc bnc" id="L460" title="All 2 branches missed.">        return instance==this ? getGlobalPropertyType(field) : getPropertyType(field);</span>
    }

    /**
     * Akin to {@link #getPropertyType(Object,String)} but never returns null.
     * @throws AssertionError in case the field cannot be found
     * @since 1.492
     */
    public @Nonnull PropertyType getPropertyTypeOrDie(@Nonnull Object instance, @Nonnull String field) {
<span class="nc" id="L469">        PropertyType propertyType = getPropertyType(instance, field);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (propertyType != null) {</span>
<span class="nc" id="L471">            return propertyType;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">        } else if (instance == this) {</span>
<span class="nc" id="L473">            throw new AssertionError(getClass().getName() + &quot; has no property &quot; + field);</span>
        } else {
<span class="nc" id="L475">            throw new AssertionError(clazz.getName() + &quot; has no property &quot; + field);</span>
        }
    }

    /**
     * Obtains the property type of the given field of {@link #clazz}
     */
    public PropertyType getPropertyType(String field) {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if(propertyTypes==null)</span>
<span class="nc" id="L484">            propertyTypes = buildPropertyTypes(clazz);</span>
<span class="nc" id="L485">        return propertyTypes.get(field);</span>
    }

    /**
     * Obtains the property type of the given field of this descriptor.
     */
    public PropertyType getGlobalPropertyType(String field) {
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if(globalPropertyTypes==null)</span>
<span class="nc" id="L493">            globalPropertyTypes = buildPropertyTypes(getClass());</span>
<span class="nc" id="L494">        return globalPropertyTypes.get(field);</span>
    }

    /**
     * Given the class, list up its {@link PropertyType}s from its public fields/getters.
     */
    private Map&lt;String, PropertyType&gt; buildPropertyTypes(Class&lt;?&gt; clazz) {
<span class="nc" id="L501">        Map&lt;String, PropertyType&gt; r = new HashMap&lt;String, PropertyType&gt;();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        for (Field f : clazz.getFields())</span>
<span class="nc" id="L503">            r.put(f.getName(),new PropertyType(f));</span>

<span class="nc bnc" id="L505" title="All 2 branches missed.">        for (Method m : clazz.getMethods())</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">            if(m.getName().startsWith(&quot;get&quot;))</span>
<span class="nc" id="L507">                r.put(Introspector.decapitalize(m.getName().substring(3)),new PropertyType(m));</span>

<span class="nc" id="L509">        return r;</span>
    }

    /**
     * Gets the class name nicely escaped to be usable as a key in the structured form submission.
     */
    public final String getJsonSafeClassName() {
<span class="nc" id="L516">        return getId().replace('.','-');</span>
    }

    /**
     * @deprecated
     *      Implement {@link #newInstance(StaplerRequest, JSONObject)} method instead.
     *      Deprecated as of 1.145. 
     */
    @Deprecated
    public T newInstance(StaplerRequest req) throws FormException {
<span class="nc" id="L526">        throw new UnsupportedOperationException(getClass()+&quot; should implement newInstance(StaplerRequest,JSONObject)&quot;);</span>
    }

    /**
     * Creates a configured instance from the submitted form.
     *
     * &lt;p&gt;
     * Hudson only invokes this method when the user wants an instance of &lt;tt&gt;T&lt;/tt&gt;.
     * So there's no need to check that in the implementation.
     *
     * &lt;p&gt;
     * Starting 1.206, the default implementation of this method does the following:
     * &lt;pre&gt;
     * req.bindJSON(clazz,formData);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * ... which performs the databinding on the constructor of {@link #clazz}.
     *
     * &lt;p&gt;
     * For some types of {@link Describable}, such as {@link ListViewColumn}, this method
     * can be invoked with null request object for historical reason. Such design is considered
     * broken, but due to the compatibility reasons we cannot fix it. Because of this, the
     * default implementation gracefully handles null request, but the contract of the method
     * still is &quot;request is always non-null.&quot; Extension points that need to define the &quot;default instance&quot;
     * semantics should define a descriptor subtype and add the no-arg newInstance method.
     *
     * @param req
     *      Always non-null (see note above.) This object includes represents the entire submission.
     * @param formData
     *      The JSON object that captures the configuration data for this {@link Descriptor}.
     *      See http://wiki.jenkins-ci.org/display/JENKINS/Structured+Form+Submission
     *      Always non-null.
     *
     * @throws FormException
     *      Signals a problem in the submitted form.
     * @since 1.145
     */
    public T newInstance(@CheckForNull StaplerRequest req, @Nonnull JSONObject formData) throws FormException {
        try {
<span class="nc" id="L565">            Method m = getClass().getMethod(&quot;newInstance&quot;, StaplerRequest.class);</span>

<span class="nc bnc" id="L567" title="All 2 branches missed.">            if(!Modifier.isAbstract(m.getDeclaringClass().getModifiers())) {</span>
                // this class overrides newInstance(StaplerRequest).
                // maintain the backward compatible behavior
<span class="nc" id="L570">                return verifyNewInstance(newInstance(req));</span>
            } else {
<span class="nc bnc" id="L572" title="All 2 branches missed.">                if (req==null) {</span>
                    // yes, req is supposed to be always non-null, but see the note above
<span class="nc" id="L574">                    return verifyNewInstance(clazz.newInstance());</span>
                }

                // new behavior as of 1.206
<span class="nc" id="L578">                BindInterceptor oldInterceptor = req.getBindInterceptor();</span>
                try {
                    NewInstanceBindInterceptor interceptor;
<span class="nc bnc" id="L581" title="All 2 branches missed.">                    if (oldInterceptor instanceof NewInstanceBindInterceptor) {</span>
<span class="nc" id="L582">                        interceptor = (NewInstanceBindInterceptor) oldInterceptor;</span>
<span class="nc" id="L583">                    } else {</span>
<span class="nc" id="L584">                        interceptor = new NewInstanceBindInterceptor(oldInterceptor);</span>
<span class="nc" id="L585">                        req.setBindInterceptor(interceptor);</span>
                    }
<span class="nc" id="L587">                    interceptor.processed.put(formData, true);</span>
<span class="nc" id="L588">                    return verifyNewInstance(req.bindJSON(clazz, formData));</span>
<span class="nc" id="L589">                } finally {</span>
<span class="nc" id="L590">                    req.setBindInterceptor(oldInterceptor);</span>
<span class="nc" id="L591">                }</span>
            }
<span class="nc" id="L593">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L594">            throw new AssertionError(e); // impossible</span>
<span class="nc" id="L595">        } catch (InstantiationException e) {</span>
<span class="nc" id="L596">            throw new Error(&quot;Failed to instantiate &quot;+clazz+&quot; from &quot;+formData,e);</span>
<span class="nc" id="L597">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L598">            throw new Error(&quot;Failed to instantiate &quot;+clazz+&quot; from &quot;+formData,e);</span>
<span class="nc" id="L599">        } catch (RuntimeException e) {</span>
<span class="nc" id="L600">            throw new RuntimeException(&quot;Failed to instantiate &quot;+clazz+&quot; from &quot;+formData,e);</span>
        }
    }

    /**
     * Ensures that calls to {@link StaplerRequest#bindJSON(Class, JSONObject)} from {@link #newInstance(StaplerRequest, JSONObject)} recurse properly.
     * {@code doConfigSubmit}-like methods will wind up calling {@code newInstance} directly
     * or via {@link #newInstancesFromHeteroList(StaplerRequest, Object, Collection)},
     * which consult any custom {@code newInstance} overrides for top-level {@link Describable} objects.
     * But for nested describable objects Stapler would know nothing about {@code newInstance} without this trick.
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    private static class NewInstanceBindInterceptor extends BindInterceptor {

        private final BindInterceptor oldInterceptor;
<span class="nc" id="L615">        private final Map&lt;JSONObject,Boolean&gt; processed = new IdentityHashMap&lt;&gt;();</span>

<span class="nc" id="L617">        NewInstanceBindInterceptor(BindInterceptor oldInterceptor) {</span>
<span class="nc" id="L618">            LOGGER.log(Level.FINER, &quot;new interceptor delegating to {0}&quot;, oldInterceptor);</span>
<span class="nc" id="L619">            this.oldInterceptor = oldInterceptor;</span>
<span class="nc" id="L620">        }</span>

        private boolean isApplicable(Class type, JSONObject json) {
<span class="nc bnc" id="L623" title="All 2 branches missed.">            if (Modifier.isAbstract(type.getModifiers())) {</span>
<span class="nc" id="L624">                LOGGER.log(Level.FINER, &quot;ignoring abstract {0} {1}&quot;, new Object[] {type.getName(), json});</span>
<span class="nc" id="L625">                return false;</span>
            }
<span class="nc bnc" id="L627" title="All 2 branches missed.">            if (!Describable.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L628">                LOGGER.log(Level.FINER, &quot;ignoring non-Describable {0} {1}&quot;, new Object[] {type.getName(), json});</span>
<span class="nc" id="L629">                return false;</span>
            }
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (Boolean.TRUE.equals(processed.put(json, true))) {</span>
<span class="nc" id="L632">                LOGGER.log(Level.FINER, &quot;already processed {0} {1}&quot;, new Object[] {type.getName(), json});</span>
<span class="nc" id="L633">                return false;</span>
            }
<span class="nc" id="L635">            return true;</span>
        }

        @Override
        public Object instantiate(Class actualType, JSONObject json) {
<span class="nc bnc" id="L640" title="All 2 branches missed.">            if (isApplicable(actualType, json)) {</span>
<span class="nc" id="L641">                LOGGER.log(Level.FINE, &quot;switching to newInstance {0} {1}&quot;, new Object[] {actualType.getName(), json});</span>
                try {
<span class="nc" id="L643">                    return Jenkins.getActiveInstance().getDescriptor(actualType).newInstance(Stapler.getCurrentRequest(), json);</span>
<span class="nc" id="L644">                } catch (Exception x) {</span>
<span class="nc" id="L645">                    LOGGER.log(Level.WARNING, &quot;falling back to default instantiation &quot; + actualType.getName() + &quot; &quot; + json, x);</span>
                    // If nested objects are not using newInstance, bindJSON will wind up throwing the same exception anyway,
                    // so logging above will result in a duplicated stack trace.
                    // However if they *are* then this is the only way to find errors in that newInstance.
                    // Normally oldInterceptor.instantiate will just return DEFAULT, not actually do anything,
                    // so we cannot try calling the default instantiation and then decide which problem to report.
                }
            }
<span class="nc" id="L653">            return oldInterceptor.instantiate(actualType, json);</span>
        }

        @Override
        public Object onConvert(Type targetType, Class targetTypeErasure, Object jsonSource) {
<span class="nc bnc" id="L658" title="All 2 branches missed.">            if (jsonSource instanceof JSONObject) {</span>
<span class="nc" id="L659">                JSONObject json = (JSONObject) jsonSource;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">                if (isApplicable(targetTypeErasure, json)) {</span>
<span class="nc" id="L661">                    LOGGER.log(Level.FINE, &quot;switching to newInstance {0} {1}&quot;, new Object[] {targetTypeErasure.getName(), json});</span>
                    try {
<span class="nc" id="L663">                        return Jenkins.getActiveInstance().getDescriptor(targetTypeErasure).newInstance(Stapler.getCurrentRequest(), json);</span>
<span class="nc" id="L664">                    } catch (Exception x) {</span>
<span class="nc" id="L665">                        LOGGER.log(Level.WARNING, &quot;falling back to default instantiation &quot; + targetTypeErasure.getName() + &quot; &quot; + json, x);</span>
                    }
                }
<span class="nc" id="L668">            } else {</span>
<span class="nc" id="L669">                LOGGER.log(Level.FINER, &quot;ignoring non-object {0}&quot;, jsonSource);</span>
            }
<span class="nc" id="L671">            return oldInterceptor.onConvert(targetType, targetTypeErasure, jsonSource);</span>
        }

    }

    /**
     * Look out for a typical error a plugin developer makes.
     * See http://hudson.361315.n4.nabble.com/Help-Hint-needed-Post-build-action-doesn-t-stay-activated-td2308833.html
     */
    private T verifyNewInstance(T t) {
<span class="nc bnc" id="L681" title="All 4 branches missed.">        if (t!=null &amp;&amp; t.getDescriptor()!=this) {</span>
            // TODO: should this be a fatal error?
<span class="nc" id="L683">            LOGGER.warning(&quot;Father of &quot;+ t+&quot; and its getDescriptor() points to two different instances. Probably malplaced @Extension. See http://hudson.361315.n4.nabble.com/Help-Hint-needed-Post-build-action-doesn-t-stay-activated-td2308833.html&quot;);</span>
        }
<span class="nc" id="L685">        return t;</span>
    }

    /**
     * Returns the {@link Klass} object used for the purpose of loading resources from this descriptor.
     *
     * This hook enables other JVM languages to provide more integrated lookup.
     */
    public Klass&lt;?&gt; getKlass() {
<span class="nc" id="L694">        return Klass.java(clazz);</span>
    }

    /**
     * Returns the resource path to the help screen HTML, if any.
     *
     * &lt;p&gt;
     * Starting 1.282, this method uses &quot;convention over configuration&quot; &amp;mdash; you should
     * just put the &quot;help.html&quot; (and its localized versions, if any) in the same directory
     * you put your Jelly view files, and this method will automatically does the right thing.
     *
     * &lt;p&gt;
     * This value is relative to the context root of Hudson, so normally
     * the values are something like &lt;tt&gt;&quot;/plugin/emma/help.html&quot;&lt;/tt&gt; to
     * refer to static resource files in a plugin, or &lt;tt&gt;&quot;/publisher/EmmaPublisher/abc&quot;&lt;/tt&gt;
     * to refer to Jelly script &lt;tt&gt;abc.jelly&lt;/tt&gt; or a method &lt;tt&gt;EmmaPublisher.doAbc()&lt;/tt&gt;.
     *
     * @return
     *      null to indicate that there's no help.
     */
    public String getHelpFile() {
<span class="nc" id="L715">        return getHelpFile(null);</span>
    }

    /**
     * Returns the path to the help screen HTML for the given field.
     *
     * &lt;p&gt;
     * The help files are assumed to be at &quot;help/FIELDNAME.html&quot; with possible
     * locale variations.
     */
    public String getHelpFile(final String fieldName) {
<span class="nc" id="L726">        return getHelpFile(getKlass(),fieldName);</span>
    }

    public String getHelpFile(Klass&lt;?&gt; clazz, String fieldName) {
<span class="nc" id="L730">        HelpRedirect r = helpRedirect.get(fieldName);</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (r!=null)    return r.resolve();</span>

<span class="nc bnc" id="L733" title="All 2 branches missed.">        for (Klass&lt;?&gt; c : clazz.getAncestors()) {</span>
<span class="nc" id="L734">            String page = &quot;/descriptor/&quot; + getId() + &quot;/help&quot;;</span>
            String suffix;
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if(fieldName==null) {</span>
<span class="nc" id="L737">                suffix=&quot;&quot;;</span>
<span class="nc" id="L738">            } else {</span>
<span class="nc" id="L739">                page += '/'+fieldName;</span>
<span class="nc" id="L740">                suffix='-'+fieldName;</span>
            }

            try {
<span class="nc bnc" id="L744" title="All 2 branches missed.">                if(Stapler.getCurrentRequest().getView(c,&quot;help&quot;+suffix)!=null)</span>
<span class="nc" id="L745">                    return page;</span>
<span class="nc" id="L746">            } catch (IOException e) {</span>
<span class="nc" id="L747">                throw new Error(e);</span>
            }

<span class="nc bnc" id="L750" title="All 2 branches missed.">            if(getStaticHelpUrl(c, suffix) !=null)    return page;</span>
        }
<span class="nc" id="L752">        return null;</span>
    }
    
    /**
     * Tells Jenkins that the help file for the field 'fieldName' is defined in the help file for
     * the 'fieldNameToRedirectTo' in the 'owner' class.
     * @since 1.425
     */
    protected void addHelpFileRedirect(String fieldName, Class&lt;? extends Describable&gt; owner, String fieldNameToRedirectTo) {
<span class="nc" id="L761">        helpRedirect.put(fieldName, new HelpRedirect(owner,fieldNameToRedirectTo));</span>
<span class="nc" id="L762">    }</span>

    /**
     * Checks if the given object is created from this {@link Descriptor}.
     */
    public final boolean isInstance( T instance ) {
<span class="nc" id="L768">        return clazz.isInstance(instance);</span>
    }

    /**
     * Checks if the type represented by this descriptor is a subtype of the given type.
     */
    public final boolean isSubTypeOf(Class type) {
<span class="nc" id="L775">        return type.isAssignableFrom(clazz);</span>
    }

    /**
     * @deprecated
     *      As of 1.239, use {@link #configure(StaplerRequest, JSONObject)}.
     */
    @Deprecated
    public boolean configure( StaplerRequest req ) throws FormException {
<span class="nc" id="L784">        return true;</span>
    }

    /**
     * Invoked when the global configuration page is submitted.
     *
     * Can be overriden to store descriptor-specific information.
     *
     * @param json
     *      The JSON object that captures the configuration data for this {@link Descriptor}.
     *      See http://wiki.jenkins-ci.org/display/JENKINS/Structured+Form+Submission
     * @return false
     *      to keep the client in the same config page.
     */
    public boolean configure( StaplerRequest req, JSONObject json ) throws FormException {
        // compatibility
<span class="nc" id="L800">        return configure(req);</span>
    }

    public String getConfigPage() {
<span class="nc" id="L804">        return getViewPage(clazz, getPossibleViewNames(&quot;config&quot;), &quot;config.jelly&quot;);</span>
    }

    public String getGlobalConfigPage() {
<span class="nc" id="L808">        return getViewPage(clazz, getPossibleViewNames(&quot;global&quot;), null);</span>
    }
    
    private String getViewPage(Class&lt;?&gt; clazz, String pageName, String defaultValue) {
<span class="nc" id="L812">        return getViewPage(clazz,Collections.singleton(pageName),defaultValue);</span>
    }

    private String getViewPage(Class&lt;?&gt; clazz, Collection&lt;String&gt; pageNames, String defaultValue) {
<span class="nc bnc" id="L816" title="All 4 branches missed.">        while(clazz!=Object.class &amp;&amp; clazz!=null) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">            for (String pageName : pageNames) {</span>
<span class="nc" id="L818">                String name = clazz.getName().replace('.', '/').replace('$', '/') + &quot;/&quot; + pageName;</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">                if(clazz.getClassLoader().getResource(name)!=null)</span>
<span class="nc" id="L820">                    return '/'+name;</span>
            }
<span class="nc" id="L822">            clazz = clazz.getSuperclass();</span>
        }
<span class="nc" id="L824">        return defaultValue;</span>
    }

    protected final String getViewPage(Class&lt;?&gt; clazz, String pageName) {
        // We didn't find the configuration page.
        // Either this is non-fatal, in which case it doesn't matter what string we return so long as
        // it doesn't exist.
        // Or this error is fatal, in which case we want the developer to see what page he's missing.
        // so we put the page name.
<span class="nc" id="L833">        return getViewPage(clazz,pageName,pageName);</span>
    }

    protected List&lt;String&gt; getPossibleViewNames(String baseName) {
<span class="nc" id="L837">        List&lt;String&gt; names = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">        for (Facet f : WebApp.get(Jenkins.getInstance().servletContext).facets) {</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">            if (f instanceof JellyCompatibleFacet) {</span>
<span class="nc" id="L840">                JellyCompatibleFacet jcf = (JellyCompatibleFacet) f;</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">                for (String ext : jcf.getScriptExtensions())</span>
<span class="nc" id="L842">                    names.add(baseName +ext);</span>
            }
        }
<span class="nc" id="L845">        return names;</span>
    }


    /**
     * Saves the configuration info to the disk.
     */
    public synchronized void save() {
<span class="nc bnc" id="L853" title="All 2 branches missed.">        if(BulkChange.contains(this))   return;</span>
        try {
<span class="nc" id="L855">            getConfigFile().write(this);</span>
<span class="nc" id="L856">            SaveableListener.fireOnChange(this, getConfigFile());</span>
<span class="nc" id="L857">        } catch (IOException e) {</span>
<span class="nc" id="L858">            LOGGER.log(Level.WARNING, &quot;Failed to save &quot;+getConfigFile(),e);</span>
        }
<span class="nc" id="L860">    }</span>

    /**
     * Loads the data from the disk into this object.
     *
     * &lt;p&gt;
     * The constructor of the derived class must call this method.
     * (If we do that in the base class, the derived class won't
     * get a chance to set default values.)
     */
    public synchronized void load() {
<span class="nc" id="L871">        XmlFile file = getConfigFile();</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if(!file.exists())</span>
<span class="nc" id="L873">            return;</span>

        try {
<span class="nc" id="L876">            file.unmarshal(this);</span>
<span class="nc" id="L877">        } catch (IOException e) {</span>
<span class="nc" id="L878">            LOGGER.log(Level.WARNING, &quot;Failed to load &quot;+file, e);</span>
        }
<span class="nc" id="L880">    }</span>

    protected XmlFile getConfigFile() {
<span class="nc" id="L883">        return new XmlFile(new File(Jenkins.getInstance().getRootDir(),getId()+&quot;.xml&quot;));</span>
    }

    /**
     * Returns the plugin in which this descriptor is defined.
     *
     * @return
     *      null to indicate that this descriptor came from the core.
     */
    protected PluginWrapper getPlugin() {
<span class="nc" id="L893">        return Jenkins.getInstance().getPluginManager().whichPlugin(clazz);</span>
    }

    /**
     * Serves &lt;tt&gt;help.html&lt;/tt&gt; from the resource of {@link #clazz}.
     */
    public void doHelp(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<span class="nc" id="L900">        String path = req.getRestOfPath();</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if(path.contains(&quot;..&quot;)) throw new ServletException(&quot;Illegal path: &quot;+path);</span>

<span class="nc" id="L903">        path = path.replace('/','-');</span>

<span class="nc" id="L905">        PluginWrapper pw = getPlugin();</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">        if (pw!=null) {</span>
<span class="nc" id="L907">            rsp.setHeader(&quot;X-Plugin-Short-Name&quot;,pw.getShortName());</span>
<span class="nc" id="L908">            rsp.setHeader(&quot;X-Plugin-Long-Name&quot;,pw.getLongName());</span>
<span class="nc" id="L909">            rsp.setHeader(&quot;X-Plugin-From&quot;, Messages.Descriptor_From(</span>
<span class="nc" id="L910">                    pw.getLongName().replace(&quot;Hudson&quot;,&quot;Jenkins&quot;).replace(&quot;hudson&quot;,&quot;jenkins&quot;), pw.getUrl()));</span>
        }

<span class="nc bnc" id="L913" title="All 2 branches missed.">        for (Klass&lt;?&gt; c= getKlass(); c!=null; c=c.getSuperClass()) {</span>
<span class="nc" id="L914">            RequestDispatcher rd = Stapler.getCurrentRequest().getView(c, &quot;help&quot;+path);</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">            if(rd!=null) {// template based help page</span>
<span class="nc" id="L916">                rd.forward(req,rsp);</span>
<span class="nc" id="L917">                return;</span>
            }

<span class="nc" id="L920">            URL url = getStaticHelpUrl(c, path);</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">            if(url!=null) {</span>
                // TODO: generalize macro expansion and perhaps even support JEXL
<span class="nc" id="L923">                rsp.setContentType(&quot;text/html;charset=UTF-8&quot;);</span>
<span class="nc" id="L924">                InputStream in = url.openStream();</span>
                try {
<span class="nc" id="L926">                    String literal = IOUtils.toString(in,&quot;UTF-8&quot;);</span>
<span class="nc" id="L927">                    rsp.getWriter().println(Util.replaceMacro(literal, Collections.singletonMap(&quot;rootURL&quot;,req.getContextPath())));</span>
<span class="nc" id="L928">                } finally {</span>
<span class="nc" id="L929">                    IOUtils.closeQuietly(in);</span>
<span class="nc" id="L930">                }</span>
<span class="nc" id="L931">                return;</span>
            }
        }
<span class="nc" id="L934">        rsp.sendError(SC_NOT_FOUND);</span>
<span class="nc" id="L935">    }</span>

    private URL getStaticHelpUrl(Klass&lt;?&gt; c, String suffix) {
<span class="nc" id="L938">        Locale locale = Stapler.getCurrentRequest().getLocale();</span>

<span class="nc" id="L940">        String base = &quot;help&quot;+suffix;</span>

        URL url;
<span class="nc" id="L943">        url = c.getResource(base + '_' + locale.getLanguage() + '_' + locale.getCountry() + '_' + locale.getVariant() + &quot;.html&quot;);</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">        if(url!=null)    return url;</span>
<span class="nc" id="L945">        url = c.getResource(base + '_' + locale.getLanguage() + '_' + locale.getCountry() + &quot;.html&quot;);</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if(url!=null)    return url;</span>
<span class="nc" id="L947">        url = c.getResource(base + '_' + locale.getLanguage() + &quot;.html&quot;);</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">        if(url!=null)    return url;</span>

        // default
<span class="nc" id="L951">        return c.getResource(base + &quot;.html&quot;);</span>
    }


//
// static methods
//


    // to work around warning when creating a generic array type
    public static &lt;T&gt; T[] toArray( T... values ) {
<span class="nc" id="L962">        return values;</span>
    }

    public static &lt;T&gt; List&lt;T&gt; toList( T... values ) {
<span class="nc" id="L966">        return new ArrayList&lt;T&gt;(Arrays.asList(values));</span>
    }

    public static &lt;T extends Describable&lt;T&gt;&gt;
    Map&lt;Descriptor&lt;T&gt;,T&gt; toMap(Iterable&lt;T&gt; describables) {
<span class="nc" id="L971">        Map&lt;Descriptor&lt;T&gt;,T&gt; m = new LinkedHashMap&lt;Descriptor&lt;T&gt;,T&gt;();</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">        for (T d : describables) {</span>
<span class="nc" id="L973">            m.put(d.getDescriptor(),d);</span>
        }
<span class="nc" id="L975">        return m;</span>
    }

    /**
     * Used to build {@link Describable} instance list from &amp;lt;f:hetero-list&gt; tag.
     *
     * @param req
     *      Request that represents the form submission.
     * @param formData
     *      Structured form data that represents the contains data for the list of describables.
     * @param key
     *      The JSON property name for 'formData' that represents the data for the list of describables.
     * @param descriptors
     *      List of descriptors to create instances from.
     * @return
     *      Can be empty but never null.
     */
    public static &lt;T extends Describable&lt;T&gt;&gt;
    List&lt;T&gt; newInstancesFromHeteroList(StaplerRequest req, JSONObject formData, String key,
                Collection&lt;? extends Descriptor&lt;T&gt;&gt; descriptors) throws FormException {

<span class="nc" id="L996">        return newInstancesFromHeteroList(req,formData.get(key),descriptors);</span>
    }

    public static &lt;T extends Describable&lt;T&gt;&gt;
    List&lt;T&gt; newInstancesFromHeteroList(StaplerRequest req, Object formData,
                Collection&lt;? extends Descriptor&lt;T&gt;&gt; descriptors) throws FormException {

<span class="nc" id="L1003">        List&lt;T&gt; items = new ArrayList&lt;T&gt;();</span>

<span class="nc bnc" id="L1005" title="All 2 branches missed.">        if (formData!=null) {</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">            for (Object o : JSONArray.fromObject(formData)) {</span>
<span class="nc" id="L1007">                JSONObject jo = (JSONObject)o;</span>
<span class="nc" id="L1008">                Descriptor&lt;T&gt; d = null;</span>
                // 'kind' and '$class' are mutually exclusive (see class-entry.jelly), but to be more lenient on the reader side,
                // we check them both anyway. 'kind' (which maps to ID) is more unique than '$class', which can have multiple matching
                // Descriptors, so we prefer 'kind' if it's present.
<span class="nc" id="L1012">                String kind = jo.optString(&quot;kind&quot;, null);</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">                if (kind != null) {</span>
                    // Only applies when Descriptor.getId is overridden.
                    // Note that kind is only supported here,
                    // *not* inside the StaplerRequest.bindJSON which is normally called by newInstance
                    // (since Descriptor.newInstance is not itself available to Stapler).
                    // If you merely override getId for some reason, but use @DataBoundConstructor on your Describable,
                    // there is no problem; but you can only rely on newInstance being called at top level.
<span class="nc" id="L1020">                    d = findById(descriptors, kind);</span>
                }
<span class="nc bnc" id="L1022" title="All 2 branches missed.">                if (d == null) {</span>
<span class="nc" id="L1023">                  kind = jo.optString(&quot;$class&quot;);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                  if (kind != null) { // else we will fall through to the warning</span>
                      // This is the normal case.
<span class="nc" id="L1026">                      d = findByDescribableClassName(descriptors, kind);</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">                      if (d == null) {</span>
                          // Deprecated system where stapler-class was the Descriptor class name (rather than Describable class name).
<span class="nc" id="L1029">                          d = findByClassName(descriptors, kind);</span>
                      }
                  }
                }
<span class="nc bnc" id="L1033" title="All 2 branches missed.">                if (d != null) {</span>
<span class="nc" id="L1034">                    items.add(d.newInstance(req, jo));</span>
<span class="nc" id="L1035">                } else {</span>
<span class="nc" id="L1036">                    LOGGER.log(Level.WARNING, &quot;Received unexpected form data element: {0}&quot;, jo);</span>
                }
            }
        }

<span class="nc" id="L1041">        return items;</span>
    }

    /**
     * Finds a descriptor from a collection by its ID.
     * @param id should match {@link #getId}
     * @since 1.610
     */
    public static @CheckForNull &lt;T extends Descriptor&gt; T findById(Collection&lt;? extends T&gt; list, String id) {
<span class="nc bnc" id="L1050" title="All 2 branches missed.">        for (T d : list) {</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">            if(d.getId().equals(id))</span>
<span class="nc" id="L1052">                return d;</span>
        }
<span class="nc" id="L1054">        return null;</span>
    }

    /**
     * Finds a descriptor from a collection by the class name of the {@link Descriptor}.
     * This is useless as of the introduction of {@link #getId} and so only very old compatibility code needs it.
     */
    private static @CheckForNull &lt;T extends Descriptor&gt; T findByClassName(Collection&lt;? extends T&gt; list, String className) {
<span class="nc bnc" id="L1062" title="All 2 branches missed.">        for (T d : list) {</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">            if(d.getClass().getName().equals(className))</span>
<span class="nc" id="L1064">                return d;</span>
        }
<span class="nc" id="L1066">        return null;</span>
    }

    /**
     * Finds a descriptor from a collection by the class name of the {@link Describable} it describes.
     * @param className should match {@link Class#getName} of a {@link #clazz}
     * @since 1.610
     */
    public static @CheckForNull &lt;T extends Descriptor&gt; T findByDescribableClassName(Collection&lt;? extends T&gt; list, String className) {
<span class="nc bnc" id="L1075" title="All 2 branches missed.">        for (T d : list) {</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">            if(d.clazz.getName().equals(className))</span>
<span class="nc" id="L1077">                return d;</span>
        }
<span class="nc" id="L1079">        return null;</span>
    }

    /**
     * Finds a descriptor from a collection by its class name or ID.
     * @deprecated choose between {@link #findById} or {@link #findByDescribableClassName}
     */
    public static @CheckForNull &lt;T extends Descriptor&gt; T find(Collection&lt;? extends T&gt; list, String string) {
<span class="nc" id="L1087">        T d = findByClassName(list, string);</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">        if (d != null) {</span>
<span class="nc" id="L1089">                return d;</span>
        }
<span class="nc" id="L1091">        return findById(list, string);</span>
    }

    /**
     * @deprecated choose between {@link #findById} or {@link #findByDescribableClassName}
     */
    public static @CheckForNull Descriptor find(String className) {
<span class="nc" id="L1098">        return find(ExtensionList.lookup(Descriptor.class),className);</span>
    }

    public static final class FormException extends Exception implements HttpResponse {
        private final String formField;

        public FormException(String message, String formField) {
<span class="nc" id="L1105">            super(message);</span>
<span class="nc" id="L1106">            this.formField = formField;</span>
<span class="nc" id="L1107">        }</span>

        public FormException(String message, Throwable cause, String formField) {
<span class="nc" id="L1110">            super(message, cause);</span>
<span class="nc" id="L1111">            this.formField = formField;</span>
<span class="nc" id="L1112">        }</span>

        public FormException(Throwable cause, String formField) {
<span class="nc" id="L1115">            super(cause);</span>
<span class="nc" id="L1116">            this.formField = formField;</span>
<span class="nc" id="L1117">        }</span>

        /**
         * Which form field contained an error?
         */
        public String getFormField() {
<span class="nc" id="L1123">            return formField;</span>
        }

        public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {
<span class="nc bnc" id="L1127" title="All 2 branches missed.">            if (FormApply.isApply(req)) {</span>
<span class="nc" id="L1128">                FormApply.applyResponse(&quot;notificationBar.show(&quot; + quote(getMessage())+ &quot;,notificationBar.ERROR)&quot;)</span>
<span class="nc" id="L1129">                        .generateResponse(req, rsp, node);</span>
<span class="nc" id="L1130">            } else {</span>
                // for now, we can't really use the field name that caused the problem.
<span class="nc" id="L1132">                new Failure(getMessage()).generateResponse(req,rsp,node);</span>
            }
<span class="nc" id="L1134">        }</span>
    }

<span class="fc" id="L1137">    private static final Logger LOGGER = Logger.getLogger(Descriptor.class.getName());</span>

    /**
     * Special type indicating that {@link Descriptor} describes itself.
     * @see Descriptor#Descriptor(Class)
     */
<span class="nc" id="L1143">    public static final class Self {}</span>

<span class="nc" id="L1145">    protected static Class self() { return Self.class; }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>jenkins-core (22-mrt-2016 21:51:03)</div></body></html>