<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Run.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">jenkins-core (22-mrt-2016 21:51:03)</a> &gt; <a href="../../index.html" class="el_group">jenkins-core</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">hudson.model</a> &gt; <span class="el_source">Run.java</span></div><h1>Run.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/*</span>
 * The MIT License
 * 
 * Copyright (c) 2004-2012, Sun Microsystems, Inc., Kohsuke Kawaguchi,
 * Daniel Dyer, Red Hat, Inc., Tom Huybrechts, Romain Seguy, Yahoo! Inc.,
 * Darek Ostolski, CloudBees, Inc.
 *
 * Copyright (c) 2012, Martin Schroeder, Intel Mobile Communications GmbH
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package hudson.model;

import com.jcraft.jzlib.GZIPInputStream;
import com.thoughtworks.xstream.XStream;
import hudson.AbortException;
import hudson.BulkChange;
import hudson.EnvVars;
import hudson.ExtensionList;
import hudson.ExtensionPoint;
import hudson.FeedAdapter;
import hudson.Functions;
import hudson.Util;
import hudson.XmlFile;
import hudson.cli.declarative.CLIMethod;
import hudson.console.*;
import hudson.model.Descriptor.FormException;
import hudson.model.Run.RunExecution;
import hudson.model.listeners.RunListener;
import hudson.model.listeners.SaveableListener;
import hudson.model.queue.Executables;
import hudson.search.SearchIndexBuilder;
import hudson.security.ACL;
import hudson.security.AccessControlled;
import hudson.security.Permission;
import hudson.security.PermissionGroup;
import hudson.security.PermissionScope;
import hudson.tasks.BuildWrapper;
import hudson.util.FormApply;
import hudson.util.LogTaskListener;
import hudson.util.ProcessTree;
import hudson.util.XStream2;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.StringWriter;
import java.nio.charset.Charset;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import static java.util.logging.Level.*;
import java.util.logging.Logger;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import jenkins.model.ArtifactManager;
import jenkins.model.ArtifactManagerConfiguration;
import jenkins.model.ArtifactManagerFactory;
import jenkins.model.BuildDiscarder;
import jenkins.model.Jenkins;
import jenkins.model.JenkinsLocationConfiguration;
import jenkins.model.PeepholePermalink;
import jenkins.model.RunAction2;
import jenkins.model.StandardArtifactManager;
import jenkins.model.lazy.BuildReference;
import jenkins.util.VirtualFile;
import jenkins.util.io.OnMaster;
import net.sf.json.JSONObject;
import org.acegisecurity.AccessDeniedException;
import org.acegisecurity.Authentication;
import org.apache.commons.io.IOUtils;
import org.apache.commons.jelly.XMLOutput;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import org.kohsuke.stapler.*;
import org.kohsuke.stapler.export.Exported;
import org.kohsuke.stapler.export.ExportedBean;
import org.kohsuke.stapler.interceptor.RequirePOST;

/**
 * A particular execution of {@link Job}.
 *
 * &lt;p&gt;
 * Custom {@link Run} type is always used in conjunction with
 * a custom {@link Job} type, so there's no separate registration
 * mechanism for custom {@link Run} types.
 *
 * @author Kohsuke Kawaguchi
 * @see RunListener
 */
@ExportedBean
public abstract class Run &lt;JobT extends Job&lt;JobT,RunT&gt;,RunT extends Run&lt;JobT,RunT&gt;&gt;
        extends Actionable implements ExtensionPoint, Comparable&lt;RunT&gt;, AccessControlled, PersistenceRoot, DescriptorByNameOwner, OnMaster {

    /**
     * The original {@link Queue.Item#getId()} has not yet been mapped onto the {@link Run} instance.
     * @since 1.601
     */
    public static final long QUEUE_ID_UNKNOWN = -1;

    protected transient final @Nonnull JobT project;

    /**
     * Build number.
     *
     * &lt;p&gt;
     * In earlier versions &amp;lt; 1.24, this number is not unique nor continuous,
     * but going forward, it will, and this really replaces the build id.
     */
    public transient /*final*/ int number;

    /**
     * The original Queue task ID from where this Run instance originated.
     */
<span class="pc" id="L155">    private long queueId = Run.QUEUE_ID_UNKNOWN;</span>

    /**
     * Previous build. Can be null.
     * TODO JENKINS-22052 this is not actually implemented any more
     *
     * External code should use {@link #getPreviousBuild()}
     */
    @Restricted(NoExternalUse.class)
    protected volatile transient RunT previousBuild;

    /**
     * Next build. Can be null.
     *
     * External code should use {@link #getNextBuild()}
     */
    @Restricted(NoExternalUse.class)
    protected volatile transient RunT nextBuild;

    /**
     * Pointer to the next younger build in progress. This data structure is lazily updated,
     * so it may point to the build that's already completed. This pointer is set to 'this'
     * if the computation determines that everything earlier than this build is already completed.
     */
    /* does not compile on JDK 7: private*/ volatile transient RunT previousBuildInProgress;

    /** ID as used for historical build records; otherwise null. */
    private @CheckForNull String id;
    
    /**
     * When the build is scheduled.
     */
    protected /*final*/ long timestamp;

    /**
     * When the build has started running.
     *
     * For historical reasons, 0 means no value is recorded.
     *
     * @see #getStartTimeInMillis()
     */
    private long startTime;

    /**
     * The build result.
     * This value may change while the state is in {@link Run.State#BUILDING}.
     */
    protected volatile Result result;

    /**
     * Human-readable description. Can be null.
     */
    protected volatile String description;

    /**
     * Human-readable name of this build. Can be null.
     * If non-null, this text is displayed instead of &quot;#NNN&quot;, which is the default.
     * @since 1.390
     */
    private volatile String displayName;

    /**
     * The current build state.
     */
    private volatile transient State state;

<span class="fc" id="L221">    private static enum State {</span>
<span class="fc" id="L222">        /**</span>
         * Build is created/queued but we haven't started building it.
         */
<span class="fc" id="L225">        NOT_STARTED,</span>
<span class="fc" id="L226">        /**</span>
         * Build is in progress.
         */
<span class="fc" id="L229">        BUILDING,</span>
<span class="fc" id="L230">        /**</span>
         * Build is completed now, and the status is determined,
         * but log files are still being updated.
         *
         * The significance of this state is that Jenkins
         * will now see this build as completed. Things like
         * &quot;triggering other builds&quot; requires this as pre-condition.
         * See JENKINS-980.
         */
<span class="fc" id="L239">        POST_PRODUCTION,</span>
<span class="fc" id="L240">        /**</span>
         * Build is completed now, and log file is closed.
         */
<span class="fc" id="L243">        COMPLETED</span>
    }

    /**
     * Number of milli-seconds it took to run this build.
     */
    protected long duration;

    /**
     * Charset in which the log file is written.
     * For compatibility reason, this field may be null.
     * For persistence, this field is string and not {@link Charset}.
     *
     * @see #getCharset()
     * @since 1.257
     */
    protected String charset;

    /**
     * Keeps this log entries.
     */
    private boolean keepLog;

    /**
     * If the build is in progress, remember {@link RunExecution} that's running it.
     * This field is not persisted.
     */
    private volatile transient RunExecution runner;

    /**
     * Artifact manager associated with this build, if any.
     * @since 1.532
     */
    private @CheckForNull ArtifactManager artifactManager;

    /**
     * Creates a new {@link Run}.
     * @param job Owner job
     */
    protected Run(@Nonnull JobT job) throws IOException {
<span class="fc" id="L283">        this(job, System.currentTimeMillis());</span>
<span class="fc" id="L284">        this.number = project.assignBuildNumber();</span>
<span class="fc" id="L285">        LOGGER.log(FINER, &quot;new {0} @{1}&quot;, new Object[] {this, hashCode()});</span>
<span class="fc" id="L286">    }</span>

    /**
     * Constructor for creating a {@link Run} object in
     * an arbitrary state.
     * {@link #number} must be set manually.
     * &lt;p&gt;May be used in a {@link SubTask#createExecutable} (instead of calling {@link LazyBuildMixIn#newBuild}).
     * For example, {@code MatrixConfiguration.newBuild} does this
     * so that the {@link #timestamp} as well as {@link #number} are shared with the parent build.
     */
    protected Run(@Nonnull JobT job, @Nonnull Calendar timestamp) {
<span class="nc" id="L297">        this(job,timestamp.getTimeInMillis());</span>
<span class="nc" id="L298">    }</span>

    /** @see #Run(Job, Calendar) */
<span class="fc" id="L301">    protected Run(@Nonnull JobT job, long timestamp) {</span>
<span class="fc" id="L302">        this.project = job;</span>
<span class="fc" id="L303">        this.timestamp = timestamp;</span>
<span class="fc" id="L304">        this.state = State.NOT_STARTED;</span>
<span class="fc" id="L305">    }</span>

    /**
     * Loads a run from a log file.
     */
<span class="nc" id="L310">    protected Run(@Nonnull JobT project, @Nonnull File buildDir) throws IOException {</span>
<span class="nc" id="L311">        this.project = project;</span>
<span class="nc" id="L312">        this.previousBuildInProgress = _this(); // loaded builds are always completed</span>
<span class="nc" id="L313">        number = Integer.parseInt(buildDir.getName());</span>
<span class="nc" id="L314">        reload();</span>
<span class="nc" id="L315">    }</span>

    /**
     * Reloads the build record from disk.
     *
     * @since 1.410
     */
    public void reload() throws IOException {
<span class="nc" id="L323">        this.state = State.COMPLETED;</span>
        // TODO ABORTED would perhaps make more sense than FAILURE:
<span class="nc" id="L325">        this.result = Result.FAILURE;  // defensive measure. value should be overwritten by unmarshal, but just in case the saved data is inconsistent</span>
<span class="nc" id="L326">        getDataFile().unmarshal(this); // load the rest of the data</span>

<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (state == State.COMPLETED) {</span>
<span class="nc" id="L329">            LOGGER.log(FINER, &quot;reload {0} @{1}&quot;, new Object[] {this, hashCode()});</span>
<span class="nc" id="L330">        } else {</span>
<span class="nc" id="L331">            LOGGER.log(WARNING, &quot;reload {0} @{1} with anomalous state {2}&quot;, new Object[] {this, hashCode(), state});</span>
        }

        // not calling onLoad upon reload. partly because we don't want to call that from Run constructor,
        // and partly because some existing use of onLoad isn't assuming that it can be invoked multiple times.
<span class="nc" id="L336">    }</span>

    /**
     * Called after the build is loaded and the object is added to the build list.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    protected void onLoad() {
<span class="nc bnc" id="L343" title="All 2 branches missed.">        for (Action a : getAllActions()) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (a instanceof RunAction2) {</span>
                try {
<span class="nc" id="L346">                    ((RunAction2) a).onLoad(this);</span>
<span class="nc" id="L347">                } catch (RuntimeException x) {</span>
<span class="nc" id="L348">                    LOGGER.log(WARNING, &quot;failed to load &quot; + a + &quot; from &quot; + getDataFile(), x);</span>
<span class="nc" id="L349">                    getActions().remove(a); // if possible; might be in an inconsistent state</span>
                }
<span class="nc bnc" id="L351" title="All 2 branches missed.">            } else if (a instanceof RunAction) {</span>
<span class="nc" id="L352">                ((RunAction) a).onLoad();</span>
            }
        }
<span class="nc bnc" id="L355" title="All 2 branches missed.">        if (artifactManager != null) {</span>
<span class="nc" id="L356">            artifactManager.onLoad(this);</span>
        }
<span class="nc" id="L358">    }</span>
    
    /**
     * Return all transient actions associated with this build.
     * 
     * @return the list can be empty but never null. read only.
     * @deprecated Use {@link #getAllActions} instead.
     */
    @Deprecated
    public List&lt;Action&gt; getTransientActions() {
<span class="nc" id="L368">        List&lt;Action&gt; actions = new ArrayList&lt;Action&gt;();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">        for (TransientBuildActionFactory factory: TransientBuildActionFactory.all()) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            for (Action created : factory.createFor(this)) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                if (created == null) {</span>
<span class="nc" id="L372">                    LOGGER.log(WARNING, &quot;null action added by {0}&quot;, factory);</span>
<span class="nc" id="L373">                    continue;</span>
                }
<span class="nc" id="L375">                actions.add(created);</span>
            }
        }
<span class="nc" id="L378">        return Collections.unmodifiableList(actions);</span>
    }

    /**
     * {@inheritDoc}
     * A {@link RunAction2} is handled specially.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    @Override
    public void addAction(@Nonnull Action a) {
<span class="nc" id="L388">        super.addAction(a);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (a instanceof RunAction2) {</span>
<span class="nc" id="L390">            ((RunAction2) a).onAttached(this);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        } else if (a instanceof RunAction) {</span>
<span class="nc" id="L392">            ((RunAction) a).onAttached(this);</span>
        }
<span class="nc" id="L394">    }</span>

    /**
     * Obtains 'this' in a more type safe signature.
     */   
    @SuppressWarnings({&quot;unchecked&quot;})
    protected @Nonnull RunT _this() {
<span class="nc" id="L401">        return (RunT)this;</span>
    }

    /**
     * Ordering based on build numbers.
     */
    public int compareTo(@Nonnull RunT that) {
<span class="nc" id="L408">        return this.number - that.number;</span>
    }

    /**
     * Get the {@link Queue.Item#getId()} of the original queue item from where this Run instance
     * originated.
     * @return The queue item ID.
     * @since 1.601
     */
    @Exported
    public long getQueueId() {
<span class="nc" id="L419">        return queueId;</span>
    }

    /**
     * Set the queue item ID.
     * &lt;p/&gt;
     * Mapped from the {@link Queue.Item#getId()}.
     * @param queueId The queue item ID.
     */
    @Restricted(NoExternalUse.class)
    public void setQueueId(long queueId) {
<span class="nc" id="L430">        this.queueId = queueId;</span>
<span class="nc" id="L431">    }</span>

    /**
     * Returns the build result.
     *
     * &lt;p&gt;
     * When a build is {@link #isBuilding() in progress}, this method
     * returns an intermediate result.
     * @return The status of the build, if it has completed or some build step has set a status; may be null if the build is ongoing.
     */
    @Exported
    public @CheckForNull Result getResult() {
<span class="nc" id="L443">        return result;</span>
    }

    /**
     * Sets the {@link #getResult} of this build.
     * Has no effect when the result is already set and worse than the proposed result.
     * May only be called after the build has started and before it has moved into post-production
     * (normally meaning both {@link #isInProgress} and {@link #isBuilding} are true).
     * @param r the proposed new result
     * @throws IllegalStateException if the build has not yet started, is in post-production, or is complete
     */
    public void setResult(@Nonnull Result r) {
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (state != State.BUILDING) {</span>
<span class="nc" id="L456">            throw new IllegalStateException(&quot;cannot change build result while in &quot; + state);</span>
        }

        // result can only get worse
<span class="nc bnc" id="L460" title="All 4 branches missed.">        if (result==null || r.isWorseThan(result)) {</span>
<span class="nc" id="L461">            result = r;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">            LOGGER.log(FINE, this + &quot; in &quot; + getRootDir() + &quot;: result is set to &quot; + r, LOGGER.isLoggable(Level.FINER) ? new Exception() : null);</span>
        }
<span class="nc" id="L464">    }</span>

    /**
     * Gets the subset of {@link #getActions()} that consists of {@link BuildBadgeAction}s.
     */
    public @Nonnull List&lt;BuildBadgeAction&gt; getBadgeActions() {
<span class="nc" id="L470">        List&lt;BuildBadgeAction&gt; r = getActions(BuildBadgeAction.class);</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        if(isKeepLog()) {</span>
<span class="nc" id="L472">            r.add(new KeepLogBuildBadge());</span>
        }
<span class="nc" id="L474">        return r;</span>
    }

    /**
     * Returns true if the build is not completed yet.
     * This includes &quot;not started yet&quot; state.
     */
    @Exported
    public boolean isBuilding() {
<span class="fc bfc" id="L483" title="All 2 branches covered.">        return state.compareTo(State.POST_PRODUCTION) &lt; 0;</span>
    }

    /**
     * Determine whether the run is being build right now.
     * @return true if after started and before completed.
     * @since 1.538
     */
    protected boolean isInProgress() {
<span class="nc bnc" id="L492" title="All 4 branches missed.">        return state.equals(State.BUILDING) || state.equals(State.POST_PRODUCTION);</span>
    }

    /**
     * Returns true if the log file is still being updated.
     */
    public boolean isLogUpdated() {
<span class="nc bnc" id="L499" title="All 2 branches missed.">        return state.compareTo(State.COMPLETED) &lt; 0;</span>
    }

    /**
     * Gets the {@link Executor} building this job, if it's being built.
     * Otherwise null.
     * 
     * This method looks for {@link Executor} who's {@linkplain Executor#getCurrentExecutable() assigned to this build},
     * and because of that this might not be necessarily in sync with the return value of {@link #isBuilding()} &amp;mdash;
     * an executor holds on to {@link Run} some more time even after the build is finished (for example to
     * perform {@linkplain Run.State#POST_PRODUCTION post-production processing}.)
     * @see Executables#getExecutor
     */
    @Exported 
    public @CheckForNull Executor getExecutor() {
<span class="nc bnc" id="L514" title="All 2 branches missed.">        return this instanceof Queue.Executable ? Executor.of((Queue.Executable) this) : null;</span>
    }

    /**
     * Gets the one off {@link Executor} building this job, if it's being built.
     * Otherwise null.
     * @since 1.433 
     */
    public @CheckForNull Executor getOneOffExecutor() {
<span class="nc bnc" id="L523" title="All 2 branches missed.">        for( Computer c : Jenkins.getInstance().getComputers() ) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">            for (Executor e : c.getOneOffExecutors()) {</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                if(e.getCurrentExecutable()==this)</span>
<span class="nc" id="L526">                    return e;</span>
            }
        }
<span class="nc" id="L529">        return null;</span>
    }

    /**
     * Gets the charset in which the log file is written.
     * @return never null.
     * @since 1.257
     */   
    public final @Nonnull Charset getCharset() {
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if(charset==null)   return Charset.defaultCharset();</span>
<span class="nc" id="L539">        return Charset.forName(charset);</span>
    }

    /**
     * Returns the {@link Cause}s that triggered a build.
     *
     * &lt;p&gt;
     * If a build sits in the queue for a long time, multiple build requests made during this period
     * are all rolled up into one build, hence this method may return a list.
     *
     * @return
     *      can be empty but never null. read-only.
     * @since 1.321
     */
    public @Nonnull List&lt;Cause&gt; getCauses() {
<span class="nc" id="L554">        CauseAction a = getAction(CauseAction.class);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (a==null)    return Collections.emptyList();</span>
<span class="nc" id="L556">        return Collections.unmodifiableList(a.getCauses());</span>
    }

    /**
     * Returns a {@link Cause} of a particular type.
     *
     * @since 1.362
     */ 
    public @CheckForNull &lt;T extends Cause&gt; T getCause(Class&lt;T&gt; type) {
<span class="nc bnc" id="L565" title="All 2 branches missed.">        for (Cause c : getCauses())</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">            if (type.isInstance(c))</span>
<span class="nc" id="L567">                return type.cast(c);</span>
<span class="nc" id="L568">        return null;</span>
    }

    /**
     * Returns true if this log file should be kept and not deleted.
     *
     * This is used as a signal to the {@link BuildDiscarder}.
     */
    @Exported
    public final boolean isKeepLog() {
<span class="nc bnc" id="L578" title="All 2 branches missed.">        return getWhyKeepLog()!=null;</span>
    }

    /**
     * If {@link #isKeepLog()} returns true, returns a short, human-readable
     * sentence that explains why it's being kept.
     */ 
    public @CheckForNull String getWhyKeepLog() {
<span class="nc bnc" id="L586" title="All 2 branches missed.">        if(keepLog)</span>
<span class="nc" id="L587">            return Messages.Run_MarkedExplicitly();</span>
<span class="nc" id="L588">        return null;    // not marked at all</span>
    }

    /**
     * The project this build is for.
     */ 
    public @Nonnull JobT getParent() {
<span class="fc" id="L595">        return project;</span>
    }

    /**
     * When the build is scheduled.
     *
     * @see #getStartTimeInMillis()
     */   
    @Exported
    public @Nonnull Calendar getTimestamp() {
<span class="nc" id="L605">        GregorianCalendar c = new GregorianCalendar();</span>
<span class="nc" id="L606">        c.setTimeInMillis(timestamp);</span>
<span class="nc" id="L607">        return c;</span>
    }

    /**
     * Same as {@link #getTimestamp()} but in a different type.
     */   
    public final @Nonnull Date getTime() {
<span class="nc" id="L614">        return new Date(timestamp);</span>
    }

    /**
     * Same as {@link #getTimestamp()} but in a different type, that is since the time of the epoc.
     */
    public final long getTimeInMillis() {
<span class="nc" id="L621">        return timestamp;</span>
    }

    /**
     * When the build has started running in an executor.
     *
     * For example, if a build is scheduled 1pm, and stayed in the queue for 1 hour (say, no idle slaves),
     * then this method returns 2pm, which is the time the job moved from the queue to the building state.
     *
     * @see #getTimestamp()
     */
    public final long getStartTimeInMillis() {
<span class="nc bnc" id="L633" title="All 2 branches missed.">        if (startTime==0)   return timestamp;   // fallback: approximate by the queuing time</span>
<span class="nc" id="L634">        return startTime;</span>
    }

    @Exported
    public String getDescription() {
<span class="nc" id="L639">        return description;</span>
    }


    /**
     * Returns the length-limited description.
     * @return The length-limited description.
     */   
    public @Nonnull String getTruncatedDescription() {
<span class="nc" id="L648">        final int maxDescrLength = 100;</span>
<span class="nc bnc" id="L649" title="All 4 branches missed.">        if (description == null || description.length() &lt; maxDescrLength) {</span>
<span class="nc" id="L650">            return description;</span>
        }

<span class="nc" id="L653">        final String ending = &quot;...&quot;;</span>
<span class="nc" id="L654">        final int sz = description.length(), maxTruncLength = maxDescrLength - ending.length();</span>

<span class="nc" id="L656">        boolean inTag = false;</span>
<span class="nc" id="L657">        int displayChars = 0;</span>
<span class="nc" id="L658">        int lastTruncatablePoint = -1;</span>

<span class="nc bnc" id="L660" title="All 2 branches missed.">        for (int i=0; i&lt;sz; i++) {</span>
<span class="nc" id="L661">            char ch = description.charAt(i);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            if(ch == '&lt;') {</span>
<span class="nc" id="L663">                inTag = true;</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">            } else if (ch == '&gt;') {</span>
<span class="nc" id="L665">                inTag = false;</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                if (displayChars &lt;= maxTruncLength) {</span>
<span class="nc" id="L667">                    lastTruncatablePoint = i + 1;</span>
                }
            }
<span class="nc bnc" id="L670" title="All 2 branches missed.">            if (!inTag) {</span>
<span class="nc" id="L671">                displayChars++;</span>
<span class="nc bnc" id="L672" title="All 4 branches missed.">                if (displayChars &lt;= maxTruncLength &amp;&amp; ch == ' ') {</span>
<span class="nc" id="L673">                    lastTruncatablePoint = i;</span>
                }
            }
        }

<span class="nc" id="L678">        String truncDesc = description;</span>

        // Could not find a preferred truncable index, force a trunc at maxTruncLength
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (lastTruncatablePoint == -1)</span>
<span class="nc" id="L682">            lastTruncatablePoint = maxTruncLength;</span>

<span class="nc bnc" id="L684" title="All 2 branches missed.">        if (displayChars &gt;= maxDescrLength) {</span>
<span class="nc" id="L685">            truncDesc = truncDesc.substring(0, lastTruncatablePoint) + ending;</span>
        }
        
<span class="nc" id="L688">        return truncDesc;</span>
        
    }

    /**
     * Gets the string that says how long since this build has started.
     *
     * @return
     *      string like &quot;3 minutes&quot; &quot;1 day&quot; etc.
     */
    public @Nonnull String getTimestampString() {
<span class="nc" id="L699">        long duration = new GregorianCalendar().getTimeInMillis()-timestamp;</span>
<span class="nc" id="L700">        return Util.getPastTimeString(duration);</span>
    }

    /**
     * Returns the timestamp formatted in xs:dateTime.
     */
    public @Nonnull String getTimestampString2() {
<span class="nc" id="L707">        return Util.XS_DATETIME_FORMATTER.format(new Date(timestamp));</span>
    }

    /**
     * Gets the string that says how long the build took to run.
     */
    public @Nonnull String getDurationString() {
<span class="fc bfc" id="L714" title="All 2 branches covered.">        if (hasntStartedYet()) {</span>
<span class="fc" id="L715">            return Messages.Run_NotStartedYet();</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">        } else if (isBuilding()) {</span>
<span class="fc" id="L717">            return Messages.Run_InProgressDuration(</span>
<span class="fc" id="L718">                    Util.getTimeSpanString(System.currentTimeMillis()-startTime));</span>
        }
<span class="fc" id="L720">        return Util.getTimeSpanString(duration);</span>
    }

    /**
     * Gets the millisecond it took to build.
     */
    @Exported
    public long getDuration() {
<span class="nc" id="L728">        return duration;</span>
    }

    /**
     * Gets the icon color for display.
     */
    public @Nonnull BallColor getIconColor() {
<span class="nc bnc" id="L735" title="All 2 branches missed.">        if(!isBuilding()) {</span>
            // already built
<span class="nc" id="L737">            return getResult().color;</span>
        }

        // a new build is in progress
        BallColor baseColor;
<span class="nc" id="L742">        RunT pb = getPreviousBuild();</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if(pb==null)</span>
<span class="nc" id="L744">            baseColor = BallColor.NOTBUILT;</span>
        else
<span class="nc" id="L746">            baseColor = pb.getIconColor();</span>

<span class="nc" id="L748">        return baseColor.anime();</span>
    }

    /**
     * Returns true if the build is still queued and hasn't started yet.
     */
    public boolean hasntStartedYet() {
<span class="fc bfc" id="L755" title="All 2 branches covered.">        return state ==State.NOT_STARTED;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L760">        return project.getFullName() + &quot; #&quot; + number;</span>
    }

    @Exported
    public String getFullDisplayName() {
<span class="nc" id="L765">        return project.getFullDisplayName()+' '+getDisplayName();</span>
    }

    @Exported
    public String getDisplayName() {
<span class="nc bnc" id="L770" title="All 2 branches missed.">        return displayName!=null ? displayName : &quot;#&quot;+number;</span>
    }

    public boolean hasCustomDisplayName() {
<span class="nc bnc" id="L774" title="All 2 branches missed.">        return displayName!=null;</span>
    }

    /**
     * @param value
     *      Set to null to revert back to the default &quot;#NNN&quot;.
     */
    public void setDisplayName(String value) throws IOException {
<span class="nc" id="L782">        checkPermission(UPDATE);</span>
<span class="nc" id="L783">        this.displayName = value;</span>
<span class="nc" id="L784">        save();</span>
<span class="nc" id="L785">    }</span>

    @Exported(visibility=2)
    public int getNumber() {
<span class="nc" id="L789">        return number;</span>
    }

    /**
     * Called by {@link RunMap} to obtain a reference to this run.
     * @return Reference to the build. Never null
     * @see jenkins.model.lazy.LazyBuildMixIn.RunMixIn#createReference
     * @since 1.556
     */   
    protected @Nonnull BuildReference&lt;RunT&gt; createReference() {
<span class="nc" id="L799">        return new BuildReference&lt;RunT&gt;(getId(), _this());</span>
    }

    /**
     * Called by {@link RunMap} to drop bi-directional links in preparation for
     * deleting a build.
     * @see jenkins.model.lazy.LazyBuildMixIn.RunMixIn#dropLinks
     * @since 1.556
     */
    protected void dropLinks() {
<span class="nc bnc" id="L809" title="All 2 branches missed.">        if(nextBuild!=null)</span>
<span class="nc" id="L810">            nextBuild.previousBuild = previousBuild;</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if(previousBuild!=null)</span>
<span class="nc" id="L812">            previousBuild.nextBuild = nextBuild;</span>
<span class="nc" id="L813">    }</span>

    /**
     * @see jenkins.model.lazy.LazyBuildMixIn.RunMixIn#getPreviousBuild
     */  
    public @CheckForNull RunT getPreviousBuild() {
<span class="nc" id="L819">        return previousBuild;</span>
    }

    /**
     * Gets the most recent {@linkplain #isBuilding() completed} build excluding 'this' Run itself.
     */   
    public final @CheckForNull RunT getPreviousCompletedBuild() {
<span class="nc" id="L826">        RunT r=getPreviousBuild();</span>
<span class="nc bnc" id="L827" title="All 4 branches missed.">        while (r!=null &amp;&amp; r.isBuilding())</span>
<span class="nc" id="L828">            r=r.getPreviousBuild();</span>
<span class="nc" id="L829">        return r;</span>
    }

    /**
     * Obtains the next younger build in progress. It uses a skip-pointer so that we can compute this without
     * O(n) computation time. This method also fixes up the skip list as we go, in a way that's concurrency safe.
     *
     * &lt;p&gt;
     * We basically follow the existing skip list, and wherever we find a non-optimal pointer, we remember them
     * in 'fixUp' and update them later.
     */  
    public final @CheckForNull RunT getPreviousBuildInProgress() {
<span class="nc bnc" id="L841" title="All 2 branches missed.">        if(previousBuildInProgress==this)   return null;    // the most common case</span>

<span class="nc" id="L843">        List&lt;RunT&gt; fixUp = new ArrayList&lt;RunT&gt;();</span>
<span class="nc" id="L844">        RunT r = _this(); // 'r' is the source of the pointer (so that we can add it to fix up if we find that the target of the pointer is inefficient.)</span>
        RunT answer;
<span class="nc" id="L846">        while (true) {</span>
<span class="nc" id="L847">            RunT n = r.previousBuildInProgress;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">            if (n==null) {// no field computed yet.</span>
<span class="nc" id="L849">                n=r.getPreviousBuild();</span>
<span class="nc" id="L850">                fixUp.add(r);</span>
            }
<span class="nc bnc" id="L852" title="All 4 branches missed.">            if (r==n || n==null) {</span>
                // this indicates that we know there's no build in progress beyond this point
<span class="nc" id="L854">                answer = null;</span>
<span class="nc" id="L855">                break;</span>
            }
<span class="nc bnc" id="L857" title="All 2 branches missed.">            if (n.isBuilding()) {</span>
                // we now know 'n' is the target we wanted
<span class="nc" id="L859">                answer = n;</span>
<span class="nc" id="L860">                break;</span>
            }

<span class="nc" id="L863">            fixUp.add(r);   // r contains the stale 'previousBuildInProgress' back pointer</span>
<span class="nc" id="L864">            r = n;</span>
        }

        // fix up so that the next look up will run faster
<span class="nc bnc" id="L868" title="All 2 branches missed.">        for (RunT f : fixUp)</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">            f.previousBuildInProgress = answer==null ? f : answer;</span>
<span class="nc" id="L870">        return answer;</span>
    }

    /**
     * Returns the last build that was actually built - i.e., skipping any with Result.NOT_BUILT
     */ 
    public @CheckForNull RunT getPreviousBuiltBuild() {
<span class="nc" id="L877">        RunT r=getPreviousBuild();</span>
        // in certain situations (aborted m2 builds) r.getResult() can still be null, although it should theoretically never happen
<span class="nc bnc" id="L879" title="All 6 branches missed.">        while( r!=null &amp;&amp; (r.getResult() == null || r.getResult()==Result.NOT_BUILT) )</span>
<span class="nc" id="L880">            r=r.getPreviousBuild();</span>
<span class="nc" id="L881">        return r;</span>
    }

    /**
     * Returns the last build that didn't fail before this build.
     */ 
    public @CheckForNull RunT getPreviousNotFailedBuild() {
<span class="nc" id="L888">        RunT r=getPreviousBuild();</span>
<span class="nc bnc" id="L889" title="All 4 branches missed.">        while( r!=null &amp;&amp; r.getResult()==Result.FAILURE )</span>
<span class="nc" id="L890">            r=r.getPreviousBuild();</span>
<span class="nc" id="L891">        return r;</span>
    }

    /**
     * Returns the last failed build before this build.
     */  
    public @CheckForNull RunT getPreviousFailedBuild() {
<span class="nc" id="L898">        RunT r=getPreviousBuild();</span>
<span class="nc bnc" id="L899" title="All 4 branches missed.">        while( r!=null &amp;&amp; r.getResult()!=Result.FAILURE )</span>
<span class="nc" id="L900">            r=r.getPreviousBuild();</span>
<span class="nc" id="L901">        return r;</span>
    }

    /**
     * Returns the last successful build before this build.
     * @since 1.383
     */
    public @CheckForNull RunT getPreviousSuccessfulBuild() {
<span class="nc" id="L909">        RunT r=getPreviousBuild();</span>
<span class="nc bnc" id="L910" title="All 4 branches missed.">        while( r!=null &amp;&amp; r.getResult()!=Result.SUCCESS )</span>
<span class="nc" id="L911">            r=r.getPreviousBuild();</span>
<span class="nc" id="L912">        return r;</span>
    }

    /**
     * Returns the last 'numberOfBuilds' builds with a build result &gt;= 'threshold'.
     * 
     * @param numberOfBuilds the desired number of builds
     * @param threshold the build result threshold
     * @return a list with the builds (youngest build first).
     *   May be smaller than 'numberOfBuilds' or even empty
     *   if not enough builds satisfying the threshold have been found. Never null.
     * @since 1.383
     */  
    public @Nonnull List&lt;RunT&gt; getPreviousBuildsOverThreshold(int numberOfBuilds, @Nonnull Result threshold) {
<span class="nc" id="L926">        List&lt;RunT&gt; builds = new ArrayList&lt;RunT&gt;(numberOfBuilds);</span>
        
<span class="nc" id="L928">        RunT r = getPreviousBuild();</span>
<span class="nc bnc" id="L929" title="All 4 branches missed.">        while (r != null &amp;&amp; builds.size() &lt; numberOfBuilds) {</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">            if (!r.isBuilding() &amp;&amp; </span>
<span class="nc bnc" id="L931" title="All 4 branches missed.">                 (r.getResult() != null &amp;&amp; r.getResult().isBetterOrEqualTo(threshold))) {</span>
<span class="nc" id="L932">                builds.add(r);</span>
            }
<span class="nc" id="L934">            r = r.getPreviousBuild();</span>
        }
        
<span class="nc" id="L937">        return builds;</span>
    }

    /**
     * @see jenkins.model.lazy.LazyBuildMixIn.RunMixIn#getNextBuild
     */   
    public @CheckForNull RunT getNextBuild() {
<span class="nc" id="L944">        return nextBuild;</span>
    }

    /**
     * Returns the URL of this {@link Run}, relative to the context root of Hudson.
     *
     * @return
     *      String like &quot;job/foo/32/&quot; with trailing slash but no leading slash. 
     */
    // I really messed this up. I'm hoping to fix this some time
    // it shouldn't have trailing '/', and instead it should have leading '/'
    public @Nonnull String getUrl() {

        // RUN may be accessed using permalinks, as &quot;/lastSuccessful&quot; or other, so try to retrieve this base URL
        // looking for &quot;this&quot; in the current request ancestors
        // @see also {@link AbstractItem#getUrl}
<span class="nc" id="L960">        StaplerRequest req = Stapler.getCurrentRequest();</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">        if (req != null) {</span>
<span class="nc" id="L962">            String seed = Functions.getNearestAncestorUrl(req,this);</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">            if(seed!=null) {</span>
                // trim off the context path portion and leading '/', but add trailing '/'
<span class="nc" id="L965">                return seed.substring(req.getContextPath().length()+1)+'/';</span>
            }
        }

<span class="nc" id="L969">        return project.getUrl()+getNumber()+'/';</span>
    }

    /**
     * Obtains the absolute URL to this build.
     *
     * @deprecated
     *      This method shall &lt;b&gt;NEVER&lt;/b&gt; be used during HTML page rendering, as it's too easy for
     *      misconfiguration to break this value, with network set up like Apache reverse proxy.
     *      This method is only intended for the remote API clients who cannot resolve relative references.
     */
    @Exported(visibility=2,name=&quot;url&quot;)
    @Deprecated
    public final @Nonnull String getAbsoluteUrl() {
<span class="nc" id="L983">        return project.getAbsoluteUrl()+getNumber()+'/';</span>
    }

    public final @Nonnull String getSearchUrl() {
<span class="nc" id="L987">        return getNumber()+&quot;/&quot;;</span>
    }

    /**
     * Unique ID of this build.
     * Usually the decimal form of {@link #number}, but may be a formatted timestamp for historical builds.
     */
    @Exported
    public @Nonnull String getId() {
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">        return id != null ? id : Integer.toString(number);</span>
    }
    
    @Override
    public @CheckForNull Descriptor getDescriptorByName(String className) {
<span class="nc" id="L1001">        return Jenkins.getInstance().getDescriptorByName(className);</span>
    }

    /**
     * Get the root directory of this {@link Run} on the master.
     * Files related to this {@link Run} should be stored below this directory.
     * @return Root directory of this {@link Run} on the master. Never null
     */
    @Override
    public @Nonnull File getRootDir() {
<span class="fc" id="L1011">        return new File(project.getBuildDir(), Integer.toString(number));</span>
    }

    /**
     * Gets an object responsible for storing and retrieving build artifacts.
     * If {@link #pickArtifactManager} has previously been called on this build,
     * and a nondefault manager selected, that will be returned.
     * Otherwise (including if we are loading a historical build created prior to this feature) {@link StandardArtifactManager} is used.
     * &lt;p&gt;This method should be used when existing artifacts are to be loaded, displayed, or removed.
     * If adding artifacts, use {@link #pickArtifactManager} instead.
     * @return an appropriate artifact manager
     * @since 1.532
     */
    public final @Nonnull ArtifactManager getArtifactManager() {
<span class="nc bnc" id="L1025" title="All 2 branches missed.">        return artifactManager != null ? artifactManager : new StandardArtifactManager(this);</span>
    }

    /**
     * Selects an object responsible for storing and retrieving build artifacts.
     * The first time this is called on a running build, {@link ArtifactManagerConfiguration} is checked
     * to see if one will handle this build.
     * If so, that manager is saved in the build and it will be used henceforth.
     * If no manager claimed the build, {@link StandardArtifactManager} is used.
     * &lt;p&gt;This method should be used when a build step expects to archive some artifacts.
     * If only displaying existing artifacts, use {@link #getArtifactManager} instead.
     * @return an appropriate artifact manager
     * @throws IOException if a custom manager was selected but the selection could not be saved
     * @since 1.532
     */
    public final synchronized @Nonnull ArtifactManager pickArtifactManager() throws IOException {
<span class="nc bnc" id="L1041" title="All 2 branches missed.">        if (artifactManager != null) {</span>
<span class="nc" id="L1042">            return artifactManager;</span>
        } else {
<span class="nc bnc" id="L1044" title="All 2 branches missed.">            for (ArtifactManagerFactory f : ArtifactManagerConfiguration.get().getArtifactManagerFactories()) {</span>
<span class="nc" id="L1045">                ArtifactManager mgr = f.managerFor(this);</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                if (mgr != null) {</span>
<span class="nc" id="L1047">                    artifactManager = mgr;</span>
<span class="nc" id="L1048">                    save();</span>
<span class="nc" id="L1049">                    return mgr;</span>
                }
            }
<span class="nc" id="L1052">            return new StandardArtifactManager(this);</span>
        }
    }

    /**
     * Gets the directory where the artifacts are archived.
     * @deprecated Should only be used from {@link StandardArtifactManager} or subclasses.
     */
    @Deprecated
    public File getArtifactsDir() {
<span class="nc" id="L1062">        return new File(getRootDir(),&quot;archive&quot;);</span>
    }

    /**
     * Gets the artifacts (relative to {@link #getArtifactsDir()}.
     * @return The list can be empty but never null
     */    
    @Exported  
    public @Nonnull List&lt;Artifact&gt; getArtifacts() {
<span class="nc" id="L1071">        return getArtifactsUpTo(Integer.MAX_VALUE);</span>
    }

    /**
     * Gets the first N artifacts.
     * @return The list can be empty but never null
     */ 
    public @Nonnull List&lt;Artifact&gt; getArtifactsUpTo(int artifactsNumber) {
<span class="nc" id="L1079">        ArtifactList r = new ArtifactList();</span>
        try {
<span class="nc" id="L1081">            addArtifacts(getArtifactManager().root(), &quot;&quot;, &quot;&quot;, r, null, artifactsNumber);</span>
<span class="nc" id="L1082">        } catch (IOException x) {</span>
<span class="nc" id="L1083">            LOGGER.log(Level.WARNING, null, x);</span>
        }
<span class="nc" id="L1085">        r.computeDisplayName();</span>
<span class="nc" id="L1086">        return r;</span>
    }

    /**
     * Check if the {@link Run} contains artifacts.
     * The strange method name is so that we can access it from EL.
     * @return true if this run has any artifacts
     */
    public boolean getHasArtifacts() {
<span class="nc bnc" id="L1095" title="All 2 branches missed.">        return !getArtifactsUpTo(1).isEmpty();</span>
    }

    private int addArtifacts(@Nonnull VirtualFile dir, 
            @Nonnull String path, @Nonnull String pathHref, 
            @Nonnull ArtifactList r, @Nonnull Artifact parent, int upTo) throws IOException {
<span class="nc" id="L1101">        VirtualFile[] kids = dir.list();</span>
<span class="nc" id="L1102">        Arrays.sort(kids);</span>

<span class="nc" id="L1104">        int n = 0;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        for (VirtualFile sub : kids) {</span>
<span class="nc" id="L1106">            String child = sub.getName();</span>
<span class="nc" id="L1107">            String childPath = path + child;</span>
<span class="nc" id="L1108">            String childHref = pathHref + Util.rawEncode(child);</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">            String length = sub.isFile() ? String.valueOf(sub.length()) : &quot;&quot;;</span>
<span class="nc bnc" id="L1110" title="All 4 branches missed.">            boolean collapsed = (kids.length==1 &amp;&amp; parent!=null);</span>
            Artifact a;
<span class="nc bnc" id="L1112" title="All 2 branches missed.">            if (collapsed) {</span>
                // Collapse single items into parent node where possible:
<span class="nc" id="L1114">                a = new Artifact(parent.getFileName() + '/' + child, childPath,</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">                                 sub.isDirectory() ? null : childHref, length,</span>
<span class="nc" id="L1116">                                 parent.getTreeNodeId());</span>
<span class="nc" id="L1117">                r.tree.put(a, r.tree.remove(parent));</span>
<span class="nc" id="L1118">            } else {</span>
                // Use null href for a directory:
<span class="nc" id="L1120">                a = new Artifact(child, childPath,</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">                                 sub.isDirectory() ? null : childHref, length,</span>
<span class="nc" id="L1122">                                 &quot;n&quot; + ++r.idSeq);</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">                r.tree.put(a, parent!=null ? parent.getTreeNodeId() : null);</span>
            }
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            if (sub.isDirectory()) {</span>
<span class="nc" id="L1126">                n += addArtifacts(sub, childPath + '/', childHref + '/', r, a, upTo-n);</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">                if (n&gt;=upTo) break;</span>
            } else {
                // Don't store collapsed path in ArrayList (for correct data in external API)
<span class="nc bnc" id="L1130" title="All 2 branches missed.">                r.add(collapsed ? new Artifact(child, a.relativePath, a.href, length, a.treeNodeId) : a);</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">                if (++n&gt;=upTo) break;</span>
            }
        }
<span class="nc" id="L1134">        return n;</span>
    }

    /**
     * Maximum number of artifacts to list before using switching to the tree view.
     */
<span class="fc" id="L1140">    public static final int LIST_CUTOFF = Integer.parseInt(System.getProperty(&quot;hudson.model.Run.ArtifactList.listCutoff&quot;, &quot;16&quot;));</span>

    /**
     * Maximum number of artifacts to show in tree view before just showing a link.
     */
<span class="fc" id="L1145">    public static final int TREE_CUTOFF = Integer.parseInt(System.getProperty(&quot;hudson.model.Run.ArtifactList.treeCutoff&quot;, &quot;40&quot;));</span>

    // ..and then &quot;too many&quot;

<span class="fc" id="L1149">    public final class ArtifactList extends ArrayList&lt;Artifact&gt; {</span>
        private static final long serialVersionUID = 1L;
        /**
         * Map of Artifact to treeNodeId of parent node in tree view.
         * Contains Artifact objects for directories and files (the ArrayList contains only files).
         */
<span class="fc" id="L1155">        private LinkedHashMap&lt;Artifact,String&gt; tree = new LinkedHashMap&lt;Artifact,String&gt;();</span>
<span class="fc" id="L1156">        private int idSeq = 0;</span>

        public Map&lt;Artifact,String&gt; getTree() {
<span class="nc" id="L1159">            return tree;</span>
        }

        public void computeDisplayName() {
<span class="pc bpc" id="L1163" title="1 of 2 branches missed.">            if(size()&gt;LIST_CUTOFF)   return; // we are not going to display file names, so no point in computing this</span>

<span class="fc" id="L1165">            int maxDepth = 0;</span>
<span class="fc" id="L1166">            int[] len = new int[size()];</span>
<span class="fc" id="L1167">            String[][] tokens = new String[size()][];</span>
<span class="fc bfc" id="L1168" title="All 2 branches covered.">            for( int i=0; i&lt;tokens.length; i++ ) {</span>
<span class="fc" id="L1169">                tokens[i] = get(i).relativePath.split(&quot;[\\\\/]+&quot;);</span>
<span class="fc" id="L1170">                maxDepth = Math.max(maxDepth,tokens[i].length);</span>
<span class="fc" id="L1171">                len[i] = 1;</span>
            }

            boolean collision;
<span class="fc" id="L1175">            int depth=0;</span>
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">            do {</span>
<span class="fc" id="L1177">                collision = false;</span>
<span class="fc" id="L1178">                Map&lt;String,Integer/*index*/&gt; names = new HashMap&lt;String,Integer&gt;();</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">                for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="fc" id="L1180">                    String[] token = tokens[i];</span>
<span class="fc" id="L1181">                    String displayName = combineLast(token,len[i]);</span>
<span class="fc" id="L1182">                    Integer j = names.put(displayName, i);</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">                    if(j!=null) {</span>
<span class="fc" id="L1184">                        collision = true;</span>
<span class="pc bpc" id="L1185" title="1 of 2 branches missed.">                        if(j&gt;=0)</span>
<span class="fc" id="L1186">                            len[j]++;</span>
<span class="fc" id="L1187">                        len[i]++;</span>
<span class="fc" id="L1188">                        names.put(displayName,-1);  // occupy this name but don't let len[i] incremented with additional collisions</span>
                    }
                }
<span class="fc bfc" id="L1191" title="All 2 branches covered.">            } while(collision &amp;&amp; depth++&lt;maxDepth);</span>

<span class="fc bfc" id="L1193" title="All 2 branches covered.">            for (int i = 0; i &lt; tokens.length; i++)</span>
<span class="fc" id="L1194">                get(i).displayPath = combineLast(tokens[i],len[i]);</span>

//            OUTER:
//            for( int n=1; n&lt;maxLen; n++ ) {
//                // if we just display the last n token, would it be suffice for disambiguation?
//                Set&lt;String&gt; names = new HashSet&lt;String&gt;();
//                for (String[] token : tokens) {
//                    if(!names.add(combineLast(token,n)))
//                        continue OUTER; // collision. Increase n and try again
//                }
//
//                // this n successfully diambiguates
//                for (int i = 0; i &lt; tokens.length; i++) {
//                    String[] token = tokens[i];
//                    get(i).displayPath = combineLast(token,n);
//                }
//                return;
//            }

//            // it's impossible to get here, as that means
//            // we have the same artifacts archived twice, but be defensive
//            for (Artifact a : this)
//                a.displayPath = a.relativePath;
<span class="fc" id="L1217">        }</span>

        /**
         * Combines last N token into the &quot;a/b/c&quot; form.
         */
        private String combineLast(String[] token, int n) {
<span class="fc" id="L1223">            StringBuilder buf = new StringBuilder();</span>
<span class="fc bfc" id="L1224" title="All 2 branches covered.">            for( int i=Math.max(0,token.length-n); i&lt;token.length; i++ ) {</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">                if(buf.length()&gt;0)  buf.append('/');</span>
<span class="fc" id="L1226">                buf.append(token[i]);</span>
            }
<span class="fc" id="L1228">            return buf.toString();</span>
        }
    }

    /**
     * A build artifact.
     */
    @ExportedBean
    public class Artifact {
        /**
         * Relative path name from artifacts root.
         */
    	@Exported(visibility=3)
        public final String relativePath;

        /**
         * Truncated form of {@link #relativePath} just enough
         * to disambiguate {@link Artifact}s.
         */
        /*package*/ String displayPath;

        /**
         * The filename of the artifact.
         * (though when directories with single items are collapsed for tree view, name may
         *  include multiple path components, like &quot;dist/pkg/mypkg&quot;)
         */
        private String name;

        /**
         * Properly encoded relativePath for use in URLs.  This field is null for directories.
         */
        private String href;

        /**
         * Id of this node for use in tree view.
         */
        private String treeNodeId;

        /**
         *length of this artifact for files.
         */
        private String length;

<span class="fc" id="L1271">        /*package for test*/ Artifact(String name, String relativePath, String href, String len, String treeNodeId) {</span>
<span class="fc" id="L1272">            this.name = name;</span>
<span class="fc" id="L1273">            this.relativePath = relativePath;</span>
<span class="fc" id="L1274">            this.href = href;</span>
<span class="fc" id="L1275">            this.treeNodeId = treeNodeId;</span>
<span class="fc" id="L1276">            this.length = len;</span>
<span class="fc" id="L1277">        }</span>

        /**
         * Gets the artifact file.
         * @deprecated May not be meaningful with custom artifact managers. Use {@link ArtifactManager#root} plus {@link VirtualFile#child} with {@link #relativePath} instead.
         */
        @Deprecated
        public @Nonnull File getFile() {
<span class="nc" id="L1285">            return new File(getArtifactsDir(),relativePath);</span>
        }

        /**
         * Returns just the file name portion, without the path.
         */
    	@Exported(visibility=3)
        public String getFileName() {
<span class="nc" id="L1293">            return name;</span>
        }

    	@Exported(visibility=3)
        public String getDisplayPath() {
<span class="fc" id="L1298">            return displayPath;</span>
        }

        public String getHref() {
<span class="nc" id="L1302">            return href;</span>
        }

        public String getLength() {
<span class="nc" id="L1306">            return length;</span>
        }
        
        public long getFileSize(){
<span class="nc" id="L1310">            return Long.decode(length);</span>
        }

        public String getTreeNodeId() {
<span class="nc" id="L1314">            return treeNodeId;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L1319">            return relativePath;</span>
        }
    }

    /**
     * Returns the log file.
     * @return The file may reference both uncompressed or compressed logs
     */  
    public @Nonnull File getLogFile() {
<span class="fc" id="L1328">        File rawF = new File(getRootDir(), &quot;log&quot;);</span>
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">        if (rawF.isFile()) {</span>
<span class="nc" id="L1330">            return rawF;</span>
        }
<span class="fc" id="L1332">        File gzF = new File(getRootDir(), &quot;log.gz&quot;);</span>
<span class="pc bpc" id="L1333" title="1 of 2 branches missed.">        if (gzF.isFile()) {</span>
<span class="nc" id="L1334">            return gzF;</span>
        }
        //If both fail, return the standard, uncompressed log file
<span class="fc" id="L1337">        return rawF;</span>
    }

    /**
     * Returns an input stream that reads from the log file.
     * It will use a gzip-compressed log file (log.gz) if that exists.
     *
     * @throws IOException 
     * @return An input stream from the log file. 
     *   If the log file does not exist, the error message will be returned to the output.
     * @since 1.349
     */
    public @Nonnull InputStream getLogInputStream() throws IOException {
<span class="nc" id="L1350">    	File logFile = getLogFile();</span>
    	
<span class="nc bnc" id="L1352" title="All 2 branches missed.">    	if (logFile.exists() ) {</span>
    	    // Checking if a &quot;.gz&quot; file was return
<span class="nc" id="L1354">    	    FileInputStream fis = new FileInputStream(logFile);</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">    	    if (logFile.getName().endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L1356">    	        return new GZIPInputStream(fis);</span>
    	    } else {
<span class="nc" id="L1358">    	        return fis;</span>
    	    }
    	}
    	
<span class="nc" id="L1362">        String message = &quot;No such file: &quot; + logFile;</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">    	return new ByteArrayInputStream(charset != null ? message.getBytes(charset) : message.getBytes());</span>
    }
   
    public @Nonnull Reader getLogReader() throws IOException {
<span class="nc bnc" id="L1367" title="All 2 branches missed.">        if (charset==null)  return new InputStreamReader(getLogInputStream());</span>
<span class="nc" id="L1368">        else                return new InputStreamReader(getLogInputStream(),charset);</span>
    }

    /**
     * Used from &lt;tt&gt;console.jelly&lt;/tt&gt; to write annotated log to the given output.
     *
     * @since 1.349
     */
    public void writeLogTo(long offset, @Nonnull XMLOutput out) throws IOException {
        try {
<span class="nc" id="L1378">			getLogText().writeHtmlTo(offset,out.asWriter());</span>
<span class="nc" id="L1379">		} catch (IOException e) {</span>
			// try to fall back to the old getLogInputStream()
			// mainly to support .gz compressed files
			// In this case, console annotation handling will be turned off.
<span class="nc" id="L1383">			InputStream input = getLogInputStream();</span>
			try {
<span class="nc" id="L1385">				IOUtils.copy(input, out.asWriter());</span>
<span class="nc" id="L1386">			} finally {</span>
<span class="nc" id="L1387">				IOUtils.closeQuietly(input);</span>
<span class="nc" id="L1388">			}</span>
		}
<span class="nc" id="L1390">    }</span>

    /**
     * Writes the complete log from the start to finish to the {@link OutputStream}.
     *
     * If someone is still writing to the log, this method will not return until the whole log
     * file gets written out.
     * &lt;p/&gt;
     * The method does not close the {@link OutputStream}.
     */
    public void writeWholeLogTo(@Nonnull OutputStream out) throws IOException, InterruptedException {
<span class="nc" id="L1401">        long pos = 0;</span>
        AnnotatedLargeText logText;
<span class="nc" id="L1403">        logText = getLogText();</span>
<span class="nc" id="L1404">        pos = logText.writeLogTo(pos, out);</span>

<span class="nc bnc" id="L1406" title="All 2 branches missed.">        while (!logText.isComplete()) {</span>
            // Instead of us hitting the log file as many times as possible, instead we get the information once every
            // second to avoid CPU usage getting very high.
<span class="nc" id="L1409">            Thread.sleep(1000);</span>
<span class="nc" id="L1410">            logText = getLogText();</span>
<span class="nc" id="L1411">            pos = logText.writeLogTo(pos, out);</span>
        }
<span class="nc" id="L1413">    }</span>

    /**
     * Used to URL-bind {@link AnnotatedLargeText}.
     * @return A {@link Run} log with annotations
     */   
    public @Nonnull AnnotatedLargeText getLogText() {
<span class="nc bnc" id="L1420" title="All 2 branches missed.">        return new AnnotatedLargeText(getLogFile(),getCharset(),!isLogUpdated(),this);</span>
    }

    @Override
    protected @Nonnull SearchIndexBuilder makeSearchIndex() {
<span class="nc" id="L1425">        SearchIndexBuilder builder = super.makeSearchIndex()</span>
<span class="nc" id="L1426">                .add(&quot;console&quot;)</span>
<span class="nc" id="L1427">                .add(&quot;changes&quot;);</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">        for (Action a : getAllActions()) {</span>
<span class="nc bnc" id="L1429" title="All 2 branches missed.">            if(a.getIconFileName()!=null)</span>
<span class="nc" id="L1430">                builder.add(a.getUrlName());</span>
        }
<span class="nc" id="L1432">        return builder;</span>
    }

    public @Nonnull Api getApi() {
<span class="nc" id="L1436">        return new Api(this);</span>
    }

    @Override
    public void checkPermission(@Nonnull Permission p) {
<span class="nc" id="L1441">        getACL().checkPermission(p);</span>
<span class="nc" id="L1442">    }</span>

    @Override
    public boolean hasPermission(@Nonnull Permission p) {
<span class="nc" id="L1446">        return getACL().hasPermission(p);</span>
    }

    @Override
    public ACL getACL() {
        // for now, don't maintain ACL per run, and do it at project level
<span class="nc" id="L1452">        return getParent().getACL();</span>
    }

    /**
     * Deletes this build's artifacts. 
     *
     * @throws IOException
     *      if we fail to delete.
     *
     * @since 1.350
     */
    public synchronized void deleteArtifacts() throws IOException {
        try {
<span class="nc" id="L1465">            getArtifactManager().delete();</span>
<span class="nc" id="L1466">        } catch (InterruptedException x) {</span>
<span class="nc" id="L1467">            throw new IOException(x);</span>
        }
<span class="nc" id="L1469">    }</span>

    /**
     * Deletes this build and its entire log
     *
     * @throws IOException
     *      if we fail to delete.
     */
    public void delete() throws IOException {
<span class="nc" id="L1478">        File rootDir = getRootDir();</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">        if (!rootDir.isDirectory()) {</span>
<span class="nc" id="L1480">            throw new IOException(this + &quot;: &quot; + rootDir + &quot; looks to have already been deleted; siblings: &quot; + Arrays.toString(project.getBuildDir().list()));</span>
        }
        
<span class="nc" id="L1483">        RunListener.fireDeleted(this);</span>

<span class="nc" id="L1485">        synchronized (this) { // avoid holding a lock while calling plugin impls of onDeleted</span>
<span class="nc" id="L1486">        File tmp = new File(rootDir.getParentFile(),'.'+rootDir.getName());</span>
        
<span class="nc bnc" id="L1488" title="All 2 branches missed.">        if (tmp.exists()) {</span>
<span class="nc" id="L1489">            Util.deleteRecursive(tmp);</span>
        }
        // TODO on Java 7 prefer: Files.move(rootDir.toPath(), tmp.toPath(), StandardCopyOption.ATOMIC_MOVE)
<span class="nc" id="L1492">        boolean renamingSucceeded = rootDir.renameTo(tmp);</span>
<span class="nc" id="L1493">        Util.deleteRecursive(tmp);</span>
        // some user reported that they see some left-over .xyz files in the workspace,
        // so just to make sure we've really deleted it, schedule the deletion on VM exit, too.
<span class="nc bnc" id="L1496" title="All 2 branches missed.">        if(tmp.exists())</span>
<span class="nc" id="L1497">            tmp.deleteOnExit();</span>

<span class="nc bnc" id="L1499" title="All 2 branches missed.">        if(!renamingSucceeded)</span>
<span class="nc" id="L1500">            throw new IOException(rootDir+&quot; is in use&quot;);</span>
<span class="nc" id="L1501">        LOGGER.log(FINE, &quot;{0}: {1} successfully deleted&quot;, new Object[] {this, rootDir});</span>

<span class="nc" id="L1503">        removeRunFromParent();</span>
        }
<span class="nc" id="L1505">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;) // seems this is too clever for Java's type system?
    private void removeRunFromParent() {
<span class="nc" id="L1509">        getParent().removeRun((RunT)this);</span>
<span class="nc" id="L1510">    }</span>


    /**
     * @see CheckPoint#report()
     */
    /*package*/ static void reportCheckpoint(@Nonnull CheckPoint id) {
<span class="nc" id="L1517">        Run&lt;?,?&gt;.RunExecution exec = RunnerStack.INSTANCE.peek();</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">        if (exec == null) {</span>
<span class="nc" id="L1519">            return;</span>
        }
<span class="nc" id="L1521">        exec.checkpoints.report(id);</span>
<span class="nc" id="L1522">    }</span>

    /**
     * @see CheckPoint#block()
     */
    /*package*/ static void waitForCheckpoint(@Nonnull CheckPoint id, @CheckForNull BuildListener listener, @CheckForNull String waiter) throws InterruptedException {
        while(true) {
<span class="nc" id="L1529">            Run&lt;?,?&gt;.RunExecution exec = RunnerStack.INSTANCE.peek();</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">            if (exec == null) {</span>
<span class="nc" id="L1531">                return;</span>
            }
<span class="nc" id="L1533">            Run b = exec.getBuild().getPreviousBuildInProgress();</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">            if(b==null)     return; // no pending earlier build</span>
<span class="nc" id="L1535">            Run.RunExecution runner = b.runner;</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">            if(runner==null) {</span>
                // polled at the wrong moment. try again.
<span class="nc" id="L1538">                Thread.sleep(0);</span>
<span class="nc" id="L1539">                continue;</span>
            }
<span class="nc bnc" id="L1541" title="All 2 branches missed.">            if(runner.checkpoints.waitForCheckPoint(id, listener, waiter))</span>
<span class="nc" id="L1542">                return; // confirmed that the previous build reached the check point</span>

            // the previous build finished without ever reaching the check point. try again.
        }
    }

    /**
     * @deprecated as of 1.467
     *      Please use {@link RunExecution}
     */
    @Deprecated
<span class="nc" id="L1553">    protected abstract class Runner extends RunExecution {}</span>

    /**
     * Object that lives while the build is executed, to keep track of things that
     * are needed only during the build.
     */
<span class="nc" id="L1559">    public abstract class RunExecution {</span>
        /**
         * Keeps track of the check points attained by a build, and abstracts away the synchronization needed to 
         * maintain this data structure.
         */
<span class="nc" id="L1564">        private final class CheckpointSet {</span>
            /**
             * Stages of the builds that this runner has completed. This is used for concurrent {@link RunExecution}s to
             * coordinate and serialize their executions where necessary.
             */
<span class="nc" id="L1569">            private final Set&lt;CheckPoint&gt; checkpoints = new HashSet&lt;CheckPoint&gt;();</span>

            private boolean allDone;

            protected synchronized void report(@Nonnull CheckPoint identifier) {
<span class="nc" id="L1574">                checkpoints.add(identifier);</span>
<span class="nc" id="L1575">                notifyAll();</span>
<span class="nc" id="L1576">            }</span>

            protected synchronized boolean waitForCheckPoint(@Nonnull CheckPoint identifier, @CheckForNull BuildListener listener, @CheckForNull String waiter) throws InterruptedException {
<span class="nc" id="L1579">                final Thread t = Thread.currentThread();</span>
<span class="nc" id="L1580">                final String oldName = t.getName();</span>
<span class="nc" id="L1581">                t.setName(oldName + &quot; : waiting for &quot; + identifier + &quot; on &quot; + getFullDisplayName() + &quot; from &quot; + waiter);</span>
                try {
<span class="nc" id="L1583">                    boolean first = true;</span>
<span class="nc bnc" id="L1584" title="All 4 branches missed.">                    while (!allDone &amp;&amp; !checkpoints.contains(identifier)) {</span>
<span class="nc bnc" id="L1585" title="All 6 branches missed.">                        if (first &amp;&amp; listener != null &amp;&amp; waiter != null) {</span>
<span class="nc" id="L1586">                            listener.getLogger().println(Messages.Run__is_waiting_for_a_checkpoint_on_(waiter, getFullDisplayName()));</span>
                        }
<span class="nc" id="L1588">                        wait();</span>
<span class="nc" id="L1589">                        first = false;</span>
                    }
<span class="nc" id="L1591">                    return checkpoints.contains(identifier);</span>
<span class="nc" id="L1592">                } finally {</span>
<span class="nc" id="L1593">                    t.setName(oldName);</span>
<span class="nc" id="L1594">                }</span>
            }

            /**
             * Notifies that the build is fully completed and all the checkpoint locks be released.
             */
            private synchronized void allDone() {
<span class="nc" id="L1601">                allDone = true;</span>
<span class="nc" id="L1602">                notifyAll();</span>
<span class="nc" id="L1603">            }</span>
        }

<span class="nc" id="L1606">        private final CheckpointSet checkpoints = new CheckpointSet();</span>

<span class="nc" id="L1608">        private final Map&lt;Object,Object&gt; attributes = new HashMap&lt;Object, Object&gt;();</span>

        /**
         * Performs the main build and returns the status code.
         *
         * @throws Exception
         *      exception will be recorded and the build will be considered a failure.
         */
        public abstract @Nonnull Result run(@Nonnull BuildListener listener ) throws Exception, RunnerAbortedException;

        /**
         * Performs the post-build action.
         * &lt;p&gt;
         * This method is called after {@linkplain #run(BuildListener) the main portion of the build is completed.}
         * This is a good opportunity to do notifications based on the result
         * of the build. When this method is called, the build is not really
         * finalized yet, and the build is still considered in progress --- for example,
         * even if the build is successful, this build still won't be picked up
         * by {@link Job#getLastSuccessfulBuild()}.
         */
        public abstract void post(@Nonnull BuildListener listener ) throws Exception;

        /**
         * Performs final clean up action.
         * &lt;p&gt;
         * This method is called after {@link #post(BuildListener)},
         * after the build result is fully finalized. This is the point
         * where the build is already considered completed.
         * &lt;p&gt;
         * Among other things, this is often a necessary pre-condition
         * before invoking other builds that depend on this build.
         */
        public abstract void cleanUp(@Nonnull BuildListener listener) throws Exception;

        public @Nonnull RunT getBuild() {
<span class="nc" id="L1643">            return _this();</span>
        }

        public @Nonnull JobT getProject() {
<span class="nc" id="L1647">            return _this().getParent();</span>
        }

        /**
         * Bag of stuff to allow plugins to store state for the duration of a build
         * without persisting it.
         *
         * @since 1.473
         */
        public @Nonnull Map&lt;Object,Object&gt; getAttributes() {
<span class="nc" id="L1657">            return attributes;</span>
        }
    }

    /**
     * Used in {@link Run.RunExecution#run} to indicates that a fatal error in a build
     * is reported to {@link BuildListener} and the build should be simply aborted
     * without further recording a stack trace.
     */
<span class="nc" id="L1666">    public static final class RunnerAbortedException extends RuntimeException {</span>
        private static final long serialVersionUID = 1L;
    }

    /**
     * @deprecated as of 1.467
     *      Use {@link #execute(RunExecution)}
     */
    @Deprecated
    protected final void run(@Nonnull Runner job) {
<span class="nc" id="L1676">        execute(job);</span>
<span class="nc" id="L1677">    }</span>

    protected final void execute(@Nonnull RunExecution job) {
<span class="nc bnc" id="L1680" title="All 2 branches missed.">        if(result!=null)</span>
<span class="nc" id="L1681">            return;     // already built.</span>

<span class="nc" id="L1683">        StreamBuildListener listener=null;</span>

<span class="nc" id="L1685">        runner = job;</span>
<span class="nc" id="L1686">        onStartBuilding();</span>
        try {
            // to set the state to COMPLETE in the end, even if the thread dies abnormally.
            // otherwise the queue state becomes inconsistent

<span class="nc" id="L1691">            long start = System.currentTimeMillis();</span>

            try {
                try {
<span class="nc" id="L1695">                    Computer computer = Computer.currentComputer();</span>
<span class="nc" id="L1696">                    Charset charset = null;</span>
<span class="nc bnc" id="L1697" title="All 2 branches missed.">                    if (computer != null) {</span>
<span class="nc" id="L1698">                        charset = computer.getDefaultCharset();</span>
<span class="nc" id="L1699">                        this.charset = charset.name();</span>
                    }

                    // don't do buffering so that what's written to the listener
                    // gets reflected to the file immediately, which can then be
                    // served to the browser immediately
<span class="nc" id="L1705">                    OutputStream logger = new FileOutputStream(getLogFile());</span>
<span class="nc" id="L1706">                    RunT build = job.getBuild();</span>

                    // Global log filters
<span class="nc bnc" id="L1709" title="All 2 branches missed.">                    for (ConsoleLogFilter filter : ConsoleLogFilter.all()) {</span>
<span class="nc" id="L1710">                        logger = filter.decorateLogger(build, logger);</span>
                    }

                    // Project specific log filters
<span class="nc bnc" id="L1714" title="All 4 branches missed.">                    if (project instanceof BuildableItemWithBuildWrappers &amp;&amp; build instanceof AbstractBuild) {</span>
<span class="nc" id="L1715">                        BuildableItemWithBuildWrappers biwbw = (BuildableItemWithBuildWrappers) project;</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">                        for (BuildWrapper bw : biwbw.getBuildWrappersList()) {</span>
<span class="nc" id="L1717">                            logger = bw.decorateLogger((AbstractBuild) build, logger);</span>
                        }
                    }

<span class="nc" id="L1721">                    listener = new StreamBuildListener(logger,charset);</span>

<span class="nc" id="L1723">                    listener.started(getCauses());</span>

<span class="nc" id="L1725">                    Authentication auth = Jenkins.getAuthentication();</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">                    if (!auth.equals(ACL.SYSTEM)) {</span>
<span class="nc" id="L1727">                        String name = auth.getName();</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">                        if (!auth.equals(Jenkins.ANONYMOUS)) {</span>
<span class="nc" id="L1729">                            name = ModelHyperlinkNote.encodeTo(User.get(name));</span>
                        }
<span class="nc" id="L1731">                        listener.getLogger().println(Messages.Run_running_as_(name));</span>
                    }

<span class="nc" id="L1734">                    RunListener.fireStarted(this,listener);</span>

<span class="nc" id="L1736">                    updateSymlinks(listener);</span>

<span class="nc" id="L1738">                    setResult(job.run(listener));</span>

<span class="nc" id="L1740">                    LOGGER.log(INFO, &quot;{0} main build action completed: {1}&quot;, new Object[] {this, result});</span>
<span class="nc" id="L1741">                    CheckPoint.MAIN_COMPLETED.report();</span>
<span class="nc" id="L1742">                } catch (ThreadDeath t) {</span>
<span class="nc" id="L1743">                    throw t;</span>
<span class="nc" id="L1744">                } catch( AbortException e ) {// orderly abortion.</span>
<span class="nc" id="L1745">                    result = Result.FAILURE;</span>
<span class="nc" id="L1746">                    listener.error(e.getMessage());</span>
<span class="nc" id="L1747">                    LOGGER.log(FINE, &quot;Build &quot;+this+&quot; aborted&quot;,e);</span>
<span class="nc" id="L1748">                } catch( RunnerAbortedException e ) {// orderly abortion.</span>
<span class="nc" id="L1749">                    result = Result.FAILURE;</span>
<span class="nc" id="L1750">                    LOGGER.log(FINE, &quot;Build &quot;+this+&quot; aborted&quot;,e);</span>
<span class="nc" id="L1751">                } catch( InterruptedException e) {</span>
                    // aborted
<span class="nc" id="L1753">                    result = Executor.currentExecutor().abortResult();</span>
<span class="nc" id="L1754">                    listener.getLogger().println(Messages.Run_BuildAborted());</span>
<span class="nc" id="L1755">                    Executor.currentExecutor().recordCauseOfInterruption(Run.this,listener);</span>
<span class="nc" id="L1756">                    LOGGER.log(Level.INFO, this + &quot; aborted&quot;, e);</span>
<span class="nc" id="L1757">                } catch( Throwable e ) {</span>
<span class="nc" id="L1758">                    handleFatalBuildProblem(listener,e);</span>
<span class="nc" id="L1759">                    result = Result.FAILURE;</span>
                }

                // even if the main build fails fatally, try to run post build processing
<span class="nc" id="L1763">                job.post(listener);</span>

<span class="nc" id="L1765">            } catch (ThreadDeath t) {</span>
<span class="nc" id="L1766">                throw t;</span>
<span class="nc" id="L1767">            } catch( Throwable e ) {</span>
<span class="nc" id="L1768">                handleFatalBuildProblem(listener,e);</span>
<span class="nc" id="L1769">                result = Result.FAILURE;</span>
<span class="nc" id="L1770">            } finally {</span>
<span class="nc" id="L1771">                long end = System.currentTimeMillis();</span>
<span class="nc" id="L1772">                duration = Math.max(end - start, 0);  // @see HUDSON-5844</span>

                // advance the state.
                // the significance of doing this is that Jenkins
                // will now see this build as completed.
                // things like triggering other builds requires this as pre-condition.
                // see issue #980.
<span class="nc" id="L1779">                LOGGER.log(FINER, &quot;moving into POST_PRODUCTION on {0}&quot;, this);</span>
<span class="nc" id="L1780">                state = State.POST_PRODUCTION;</span>

<span class="nc bnc" id="L1782" title="All 6 branches missed.">                if (listener != null) {</span>
<span class="nc" id="L1783">                    RunListener.fireCompleted(this,listener);</span>
                    try {
<span class="nc" id="L1785">                        job.cleanUp(listener);</span>
<span class="nc" id="L1786">                    } catch (Exception e) {</span>
<span class="nc" id="L1787">                        handleFatalBuildProblem(listener,e);</span>
                        // too late to update the result now
                    }
<span class="nc" id="L1790">                    listener.finished(result);</span>
<span class="nc" id="L1791">                    listener.closeQuietly();</span>
                }

                try {
<span class="nc" id="L1795">                    save();</span>
<span class="nc" id="L1796">                } catch (IOException e) {</span>
<span class="nc" id="L1797">                    LOGGER.log(Level.SEVERE, &quot;Failed to save build record&quot;,e);</span>
                }
<span class="nc" id="L1799">            }</span>

            try {
<span class="nc" id="L1802">                getParent().logRotate();</span>
<span class="nc" id="L1803">            } catch (Exception e) {</span>
<span class="nc" id="L1804">		LOGGER.log(Level.SEVERE, &quot;Failed to rotate log&quot;,e);</span>
	    }
<span class="nc" id="L1806">        } finally {</span>
<span class="nc" id="L1807">            onEndBuilding();</span>
<span class="nc" id="L1808">        }</span>
<span class="nc" id="L1809">    }</span>

    /**
     * Makes sure that {@code lastSuccessful} and {@code lastStable} legacy links in the project’s root directory exist.
     * Normally you do not need to call this explicitly, since {@link #execute} does so,
     * but this may be needed if you are creating synthetic {@link Run}s as part of a container project (such as Maven builds in a module set).
     * You should also ensure that {@link RunListener#fireStarted} and {@link RunListener#fireCompleted} are called.
     * @param listener probably unused
     * @throws InterruptedException probably not thrown
     * @since 1.530
     */
    public final void updateSymlinks(@Nonnull TaskListener listener) throws InterruptedException {
<span class="nc" id="L1821">        createSymlink(listener, &quot;lastSuccessful&quot;, PermalinkProjectAction.Permalink.LAST_SUCCESSFUL_BUILD);</span>
<span class="nc" id="L1822">        createSymlink(listener, &quot;lastStable&quot;, PermalinkProjectAction.Permalink.LAST_STABLE_BUILD);</span>
<span class="nc" id="L1823">    }</span>
    /**
     * Backward compatibility.
     *
     * We used to have $JENKINS_HOME/jobs/JOBNAME/lastStable and lastSuccessful symlinked to the appropriate
     * builds, but now those are done in {@link PeepholePermalink}. So here, we simply create symlinks that
     * resolves to the symlink created by {@link PeepholePermalink}.
     */
    private void createSymlink(@Nonnull TaskListener listener, @Nonnull String name, @Nonnull PermalinkProjectAction.Permalink target) throws InterruptedException {
<span class="nc" id="L1832">        File buildDir = getParent().getBuildDir();</span>
<span class="nc" id="L1833">        File rootDir = getParent().getRootDir();</span>
        String targetDir;
<span class="nc bnc" id="L1835" title="All 2 branches missed.">        if (buildDir.equals(new File(rootDir, &quot;builds&quot;))) {</span>
<span class="nc" id="L1836">            targetDir = &quot;builds&quot; + File.separator + target.getId();</span>
<span class="nc" id="L1837">        } else {</span>
<span class="nc" id="L1838">            targetDir = buildDir + File.separator + target.getId();</span>
        }
<span class="nc" id="L1840">        Util.createSymlink(rootDir, targetDir, name, listener);</span>
<span class="nc" id="L1841">    }</span>

    /**
     * Handles a fatal build problem (exception) that occurred during the build.
     */
    private void handleFatalBuildProblem(@Nonnull BuildListener listener, @Nonnull Throwable e) {
<span class="nc bnc" id="L1847" title="All 2 branches missed.">        if(listener!=null) {</span>
<span class="nc" id="L1848">            LOGGER.log(FINE, getDisplayName()+&quot; failed to build&quot;,e);</span>

<span class="nc bnc" id="L1850" title="All 2 branches missed.">            if(e instanceof IOException)</span>
<span class="nc" id="L1851">                Util.displayIOException((IOException)e,listener);</span>

<span class="nc" id="L1853">            e.printStackTrace(listener.fatalError(e.getMessage()));</span>
<span class="nc" id="L1854">        } else {</span>
<span class="nc" id="L1855">            LOGGER.log(SEVERE, getDisplayName()+&quot; failed to build and we don't even have a listener&quot;,e);</span>
        }
<span class="nc" id="L1857">    }</span>

    /**
     * Called when a job started building.
     */
    protected void onStartBuilding() {
<span class="fc" id="L1863">        LOGGER.log(FINER, &quot;moving to BUILDING on {0}&quot;, this);</span>
<span class="fc" id="L1864">        state = State.BUILDING;</span>
<span class="fc" id="L1865">        startTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L1866" title="1 of 2 branches missed.">        if (runner!=null)</span>
<span class="nc" id="L1867">            RunnerStack.INSTANCE.push(runner);</span>
<span class="fc" id="L1868">    }</span>

    /**
     * Called when a job finished building normally or abnormally.
     */
    protected void onEndBuilding() {
        // signal that we've finished building.
<span class="fc" id="L1875">        state = State.COMPLETED;</span>
<span class="fc" id="L1876">        LOGGER.log(FINER, &quot;moving to COMPLETED on {0}&quot;, this);</span>
<span class="pc bpc" id="L1877" title="1 of 2 branches missed.">        if (runner!=null) {</span>
            // MavenBuilds may be created without their corresponding runners.
<span class="nc" id="L1879">            runner.checkpoints.allDone();</span>
<span class="nc" id="L1880">            runner = null;</span>
<span class="nc" id="L1881">            RunnerStack.INSTANCE.pop();</span>
        }
<span class="pc bpc" id="L1883" title="1 of 2 branches missed.">        if (result == null) {</span>
<span class="fc" id="L1884">            result = Result.FAILURE;</span>
<span class="fc" id="L1885">            LOGGER.log(WARNING, &quot;{0}: No build result is set, so marking as failure. This should not happen.&quot;, this);</span>
        }

<span class="fc" id="L1888">        RunListener.fireFinalized(this);</span>
<span class="fc" id="L1889">    }</span>

    /**
     * Save the settings to a file.
     */
    public synchronized void save() throws IOException {
<span class="nc bnc" id="L1895" title="All 2 branches missed.">        if(BulkChange.contains(this))   return;</span>
<span class="nc" id="L1896">        getDataFile().write(this);</span>
<span class="nc" id="L1897">        SaveableListener.fireOnChange(this, getDataFile());</span>
<span class="nc" id="L1898">    }</span>

    private @Nonnull XmlFile getDataFile() {
<span class="nc" id="L1901">        return new XmlFile(XSTREAM,new File(getRootDir(),&quot;build.xml&quot;));</span>
    }

    /**
     * Gets the log of the build as a string.
     * @return Returns the log or an empty string if it has not been found
     * @deprecated since 2007-11-11.
     *     Use {@link #getLog(int)} instead as it avoids loading
     *     the whole log into memory unnecessarily.
     */
    @Deprecated
    public @Nonnull String getLog() throws IOException {
<span class="nc" id="L1913">        return Util.loadFile(getLogFile(),getCharset());</span>
    }

    /**
     * Gets the log of the build as a list of strings (one per log line).
     * The number of lines returned is constrained by the maxLines parameter.
     *
     * @param maxLines The maximum number of log lines to return.  If the log
     * is bigger than this, only the most recent lines are returned.
     * @return A list of log lines.  Will have no more than maxLines elements.
     * @throws IOException If there is a problem reading the log file.
     */
    public @Nonnull List&lt;String&gt; getLog(int maxLines) throws IOException {
<span class="fc" id="L1926">        int lineCount = 0;</span>
<span class="fc" id="L1927">        List&lt;String&gt; logLines = new LinkedList&lt;String&gt;();</span>
<span class="pc bpc" id="L1928" title="1 of 2 branches missed.">        if (maxLines == 0) {</span>
<span class="fc" id="L1929">            return logLines;</span>
        }
<span class="nc" id="L1931">        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(getLogFile()),getCharset()));</span>
        try {
<span class="nc bnc" id="L1933" title="All 2 branches missed.">            for (String line = reader.readLine(); line != null; line = reader.readLine()) {</span>
<span class="nc" id="L1934">                logLines.add(line);</span>
<span class="nc" id="L1935">                ++lineCount;</span>
                // If we have too many lines, remove the oldest line.  This way we
                // never have to hold the full contents of a huge log file in memory.
                // Adding to and removing from the ends of a linked list are cheap
                // operations.
<span class="nc bnc" id="L1940" title="All 2 branches missed.">                if (lineCount &gt; maxLines)</span>
<span class="nc" id="L1941">                    logLines.remove(0);</span>
            }
<span class="nc" id="L1943">        } finally {</span>
<span class="nc" id="L1944">            reader.close();</span>
<span class="nc" id="L1945">        }</span>

        // If the log has been truncated, include that information.
        // Use set (replaces the first element) rather than add so that
        // the list doesn't grow beyond the specified maximum number of lines.
<span class="nc bnc" id="L1950" title="All 2 branches missed.">        if (lineCount &gt; maxLines)</span>
<span class="nc" id="L1951">            logLines.set(0, &quot;[...truncated &quot; + (lineCount - (maxLines - 1)) + &quot; lines...]&quot;);</span>

<span class="nc" id="L1953">        return ConsoleNote.removeNotes(logLines);</span>
    }

    public void doBuildStatus( StaplerRequest req, StaplerResponse rsp ) throws IOException {
<span class="nc" id="L1957">        rsp.sendRedirect2(req.getContextPath()+&quot;/images/48x48/&quot;+getBuildStatusUrl());</span>
<span class="nc" id="L1958">    }</span>

    public @Nonnull String getBuildStatusUrl() {
<span class="nc" id="L1961">        return getIconColor().getImage();</span>
    }

    public String getBuildStatusIconClassName() {
<span class="nc" id="L1965">        return getIconColor().getIconClassName();</span>
    }

    public static class Summary {
        /**
         * Is this build worse or better, compared to the previous build?
         */
        public boolean isWorse;
        public String message;

<span class="fc" id="L1975">        public Summary(boolean worse, String message) {</span>
<span class="fc" id="L1976">            this.isWorse = worse;</span>
<span class="fc" id="L1977">            this.message = message;</span>
<span class="fc" id="L1978">        }</span>
    }

    /**
     * Used to implement {@link #getBuildStatusSummary}.
     * @since 1.575
     */
<span class="nc" id="L1985">    public static abstract class StatusSummarizer implements ExtensionPoint {</span>
        /**
         * Possibly summarizes the reasons for a build’s status.
         * @param run a completed build
         * @param trend the result of {@link ResultTrend#getResultTrend(hudson.model.Run)} on {@code run} (precomputed for efficiency)
         * @return a summary, or null to fall back to other summarizers or built-in behavior
         */
        public abstract @CheckForNull Summary summarize(@Nonnull Run&lt;?,?&gt; run, @Nonnull ResultTrend trend);
    }

    /**
     * Gets an object which represents the single line summary of the status of this build
     * (especially in comparison with the previous build.)
     * @see StatusSummarizer
     */
    public @Nonnull Summary getBuildStatusSummary() {
<span class="fc bfc" id="L2001" title="All 2 branches covered.">        if (isBuilding()) {</span>
<span class="fc" id="L2002">            return new Summary(false, Messages.Run_Summary_Unknown());</span>
        }
        
<span class="fc" id="L2005">        ResultTrend trend = ResultTrend.getResultTrend(this);</span>
        
<span class="pc bpc" id="L2007" title="1 of 2 branches missed.">        for (StatusSummarizer summarizer : ExtensionList.lookup(StatusSummarizer.class)) {</span>
<span class="nc" id="L2008">            Summary summary = summarizer.summarize(this, trend);</span>
<span class="nc bnc" id="L2009" title="All 2 branches missed.">            if (summary != null) {</span>
<span class="nc" id="L2010">                return summary;</span>
            }
        }

<span class="pc bpc" id="L2014" title="1 of 9 branches missed.">        switch (trend) {</span>
<span class="fc" id="L2015">            case ABORTED : return new Summary(false, Messages.Run_Summary_Aborted());</span>
            
<span class="fc" id="L2017">            case NOT_BUILT : return new Summary(false, Messages.Run_Summary_NotBuilt());</span>
            
<span class="fc" id="L2019">            case FAILURE : return new Summary(true, Messages.Run_Summary_BrokenSinceThisBuild());</span>
            
            case STILL_FAILING : 
<span class="fc" id="L2022">                RunT since = getPreviousNotFailedBuild();</span>
<span class="fc bfc" id="L2023" title="All 2 branches covered.">                if(since==null)</span>
<span class="fc" id="L2024">                    return new Summary(false, Messages.Run_Summary_BrokenForALongTime());</span>
<span class="fc" id="L2025">                RunT failedBuild = since.getNextBuild();</span>
<span class="fc" id="L2026">                return new Summary(false, Messages.Run_Summary_BrokenSince(failedBuild.getDisplayName()));</span>
           
            case NOW_UNSTABLE:
            case STILL_UNSTABLE :
<span class="fc" id="L2030">                return new Summary(false, Messages.Run_Summary_Unstable());</span>
            case UNSTABLE :
<span class="fc" id="L2032">                return new Summary(true, Messages.Run_Summary_Unstable());</span>
                
            case SUCCESS :
<span class="fc" id="L2035">                return new Summary(false, Messages.Run_Summary_Stable());</span>
            
            case FIXED :
<span class="fc" id="L2038">                return new Summary(false, Messages.Run_Summary_BackToNormal());</span>
                
        }
        
<span class="nc" id="L2042">        return new Summary(false, Messages.Run_Summary_Unknown());</span>
    }

    /**
     * Serves the artifacts.
     * @throws AccessDeniedException Access denied
     */
    public @Nonnull DirectoryBrowserSupport doArtifact() {
<span class="nc bnc" id="L2050" title="All 2 branches missed.">        if(Functions.isArtifactsPermissionEnabled()) {</span>
<span class="nc" id="L2051">          checkPermission(ARTIFACTS);</span>
        }
<span class="nc" id="L2053">        return new DirectoryBrowserSupport(this, getArtifactManager().root(), Messages.Run_ArtifactsBrowserTitle(project.getDisplayName(), getDisplayName()), &quot;package.png&quot;, true);</span>
    }

    /**
     * Returns the build number in the body.
     */
    public void doBuildNumber(StaplerResponse rsp) throws IOException {
<span class="nc" id="L2060">        rsp.setContentType(&quot;text/plain&quot;);</span>
<span class="nc" id="L2061">        rsp.setCharacterEncoding(&quot;US-ASCII&quot;);</span>
<span class="nc" id="L2062">        rsp.setStatus(HttpServletResponse.SC_OK);</span>
<span class="nc" id="L2063">        rsp.getWriter().print(number);</span>
<span class="nc" id="L2064">    }</span>

    /**
     * Returns the build time stamp in the body.
     */
    public void doBuildTimestamp( StaplerRequest req, StaplerResponse rsp, @QueryParameter String format) throws IOException {
<span class="nc" id="L2070">        rsp.setContentType(&quot;text/plain&quot;);</span>
<span class="nc" id="L2071">        rsp.setCharacterEncoding(&quot;US-ASCII&quot;);</span>
<span class="nc" id="L2072">        rsp.setStatus(HttpServletResponse.SC_OK);</span>
<span class="nc bnc" id="L2073" title="All 2 branches missed.">        DateFormat df = format==null ?</span>
<span class="nc" id="L2074">                DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.SHORT, Locale.ENGLISH) :</span>
<span class="nc" id="L2075">                new SimpleDateFormat(format,req.getLocale());</span>
<span class="nc" id="L2076">        rsp.getWriter().print(df.format(getTime()));</span>
<span class="nc" id="L2077">    }</span>

    /**
     * Sends out the raw console output.
     */
    public void doConsoleText(StaplerRequest req, StaplerResponse rsp) throws IOException {
<span class="nc" id="L2083">        rsp.setContentType(&quot;text/plain;charset=UTF-8&quot;);</span>
<span class="nc" id="L2084">        PlainTextConsoleOutputStream out = new PlainTextConsoleOutputStream(rsp.getCompressedOutputStream(req));</span>
<span class="nc" id="L2085">        InputStream input = getLogInputStream();</span>
        try {
<span class="nc" id="L2087">            IOUtils.copy(input, out);</span>
<span class="nc" id="L2088">            out.flush();</span>
<span class="nc" id="L2089">        } finally {</span>
<span class="nc" id="L2090">            IOUtils.closeQuietly(input);</span>
<span class="nc" id="L2091">            IOUtils.closeQuietly(out);</span>
<span class="nc" id="L2092">        }</span>
<span class="nc" id="L2093">    }</span>

    /**
     * Handles incremental log output.
     * @deprecated as of 1.352
     *      Use {@code getLogText().doProgressiveText(req,rsp)}
     */
    @Deprecated
    public void doProgressiveLog( StaplerRequest req, StaplerResponse rsp) throws IOException {
<span class="nc" id="L2102">        getLogText().doProgressText(req,rsp);</span>
<span class="nc" id="L2103">    }</span>

    /**
     * Checks whether keep status can be toggled.
     * Normally it can, but if there is a complex reason (from subclasses) why this build must be kept, the toggle is meaningless.
     * @return true if {@link #doToggleLogKeep} and {@link #keepLog(boolean)} and {@link #keepLog()} are options
     * @since 1.510
     */
    public boolean canToggleLogKeep() {
<span class="nc bnc" id="L2112" title="All 4 branches missed.">        if (!keepLog &amp;&amp; isKeepLog()) {</span>
            // Definitely prevented.
<span class="nc" id="L2114">            return false;</span>
        }
        // TODO may be that keepLog is on (perhaps toggler earlier) yet isKeepLog() would be true anyway.
        // In such a case this will incorrectly return true and logKeep.jelly will allow the toggle.
        // However at least then (after redirecting to the same page) the toggle button will correctly disappear.
<span class="nc" id="L2119">        return true;</span>
    }

    public void doToggleLogKeep( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
<span class="nc bnc" id="L2123" title="All 2 branches missed.">        keepLog(!keepLog);</span>
<span class="nc" id="L2124">        rsp.forwardToPreviousPage(req);</span>
<span class="nc" id="L2125">    }</span>

    /**
     * Marks this build to keep the log.
     */
    @CLIMethod(name=&quot;keep-build&quot;)
    public final void keepLog() throws IOException {
<span class="nc" id="L2132">        keepLog(true);</span>
<span class="nc" id="L2133">    }</span>

    public void keepLog(boolean newValue) throws IOException {
<span class="nc bnc" id="L2136" title="All 2 branches missed.">        checkPermission(newValue ? UPDATE : DELETE);</span>
<span class="nc" id="L2137">        keepLog = newValue;</span>
<span class="nc" id="L2138">        save();</span>
<span class="nc" id="L2139">    }</span>

    /**
     * Deletes the build when the button is pressed.
     */
    @RequirePOST
    public void doDoDelete( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
<span class="nc" id="L2146">        checkPermission(DELETE);</span>

        // We should not simply delete the build if it has been explicitly
        // marked to be preserved, or if the build should not be deleted
        // due to dependencies!
<span class="nc" id="L2151">        String why = getWhyKeepLog();</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">        if (why!=null) {</span>
<span class="nc" id="L2153">            sendError(Messages.Run_UnableToDelete(getFullDisplayName(), why), req, rsp);</span>
<span class="nc" id="L2154">            return;</span>
        }

        try{
<span class="nc" id="L2158">            delete();</span>
<span class="nc" id="L2159">        }</span>
<span class="nc" id="L2160">        catch(IOException ex){</span>
<span class="nc" id="L2161">            StringWriter writer = new StringWriter();</span>
<span class="nc" id="L2162">            ex.printStackTrace(new PrintWriter(writer));</span>
<span class="nc" id="L2163">            req.setAttribute(&quot;stackTraces&quot;, writer);</span>
<span class="nc" id="L2164">            req.getView(this, &quot;delete-retry.jelly&quot;).forward(req, rsp);  </span>
<span class="nc" id="L2165">            return;</span>
        }
<span class="nc" id="L2167">        rsp.sendRedirect2(req.getContextPath()+'/' + getParent().getUrl());</span>
<span class="nc" id="L2168">    }</span>

    public void setDescription(String description) throws IOException {
<span class="nc" id="L2171">        checkPermission(UPDATE);</span>
<span class="nc" id="L2172">        this.description = description;</span>
<span class="nc" id="L2173">        save();</span>
<span class="nc" id="L2174">    }</span>
    
    /**
     * Accepts the new description.
     */
    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
<span class="nc" id="L2180">        setDescription(req.getParameter(&quot;description&quot;));</span>
<span class="nc" id="L2181">        rsp.sendRedirect(&quot;.&quot;);  // go to the top page</span>
<span class="nc" id="L2182">    }</span>

    /**
     * @deprecated as of 1.292
     *      Use {@link #getEnvironment(TaskListener)} instead.
     */
    @Deprecated
    public Map&lt;String,String&gt; getEnvVars() {
<span class="nc" id="L2190">        LOGGER.log(WARNING, &quot;deprecated call to Run.getEnvVars\n\tat {0}&quot;, new Throwable().getStackTrace()[1]);</span>
        try {
<span class="nc" id="L2192">            return getEnvironment(new LogTaskListener(LOGGER, Level.INFO));</span>
<span class="nc" id="L2193">        } catch (IOException e) {</span>
<span class="nc" id="L2194">            return new EnvVars();</span>
<span class="nc" id="L2195">        } catch (InterruptedException e) {</span>
<span class="nc" id="L2196">            return new EnvVars();</span>
        }
    }

    /**
     * @deprecated as of 1.305 use {@link #getEnvironment(TaskListener)}
     */
    @Deprecated
    public EnvVars getEnvironment() throws IOException, InterruptedException {
<span class="nc" id="L2205">        LOGGER.log(WARNING, &quot;deprecated call to Run.getEnvironment\n\tat {0}&quot;, new Throwable().getStackTrace()[1]);</span>
<span class="nc" id="L2206">        return getEnvironment(new LogTaskListener(LOGGER, Level.INFO));</span>
    }

    /**
     * Returns the map that contains environmental variables to be used for launching
     * processes for this build.
     *
     * &lt;p&gt;
     * {@link hudson.tasks.BuildStep}s that invoke external processes should use this.
     * This allows {@link BuildWrapper}s and other project configurations (such as JDK selection)
     * to take effect.
     *
     * &lt;p&gt;
     * Unlike earlier {@link #getEnvVars()}, this map contains the whole environment,
     * not just the overrides, so one can introspect values to change its behavior.
     * 
     * @return the map with the environmental variables.
     * @since 1.305
     */
    public @Nonnull EnvVars getEnvironment(@Nonnull TaskListener listener) throws IOException, InterruptedException {
<span class="nc" id="L2226">        Computer c = Computer.currentComputer();</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">        Node n = c==null ? null : c.getNode();</span>

<span class="nc" id="L2229">        EnvVars env = getParent().getEnvironment(n,listener);</span>
<span class="nc" id="L2230">        env.putAll(getCharacteristicEnvVars());</span>

        // apply them in a reverse order so that higher ordinal ones can modify values added by lower ordinal ones
<span class="nc bnc" id="L2233" title="All 2 branches missed.">        for (EnvironmentContributor ec : EnvironmentContributor.all().reverseView())</span>
<span class="nc" id="L2234">            ec.buildEnvironmentFor(this,env,listener);</span>

<span class="nc" id="L2236">        return env;</span>
    }

    /**
     * Builds up the environment variable map that's sufficient to identify a process
     * as ours. This is used to kill run-away processes via {@link ProcessTree#killAll(Map)}.
     */
    public @Nonnull final EnvVars getCharacteristicEnvVars() {
<span class="nc" id="L2244">        EnvVars env = getParent().getCharacteristicEnvVars();</span>
<span class="nc" id="L2245">        env.put(&quot;BUILD_NUMBER&quot;,String.valueOf(number));</span>
<span class="nc" id="L2246">        env.put(&quot;BUILD_ID&quot;,getId());</span>
<span class="nc" id="L2247">        env.put(&quot;BUILD_TAG&quot;,&quot;jenkins-&quot;+getParent().getFullName().replace('/', '-')+&quot;-&quot;+number);</span>
<span class="nc" id="L2248">        return env;</span>
    }

    /**
     * Produces an identifier for this run unique in the system.
     * @return the {@link Job#getFullName}, then {@code #}, then {@link #getNumber}
     * @see #fromExternalizableId
     */
    public @Nonnull String getExternalizableId() {
<span class="nc" id="L2257">        return project.getFullName() + &quot;#&quot; + getNumber();</span>
    }

    /**
     * Tries to find a run from an persisted identifier.
     * @param id as produced by {@link #getExternalizableId}
     * @return the same run, or null if the job or run was not found
     * @throws IllegalArgumentException if the ID is malformed
     */
    public @CheckForNull static Run&lt;?,?&gt; fromExternalizableId(String id) throws IllegalArgumentException {
<span class="nc" id="L2267">        int hash = id.lastIndexOf('#');</span>
<span class="nc bnc" id="L2268" title="All 2 branches missed.">        if (hash &lt;= 0) {</span>
<span class="nc" id="L2269">            throw new IllegalArgumentException(&quot;Invalid id&quot;);</span>
        }
<span class="nc" id="L2271">        String jobName = id.substring(0, hash);</span>
        int number;
        try {
<span class="nc" id="L2274">            number = Integer.parseInt(id.substring(hash + 1));</span>
<span class="nc" id="L2275">        } catch (NumberFormatException x) {</span>
<span class="nc" id="L2276">            throw new IllegalArgumentException(x);</span>
        }
<span class="nc" id="L2278">        Jenkins j = Jenkins.getInstance();</span>
<span class="nc bnc" id="L2279" title="All 2 branches missed.">        if (j == null) {</span>
<span class="nc" id="L2280">            return null;</span>
        }
<span class="nc" id="L2282">        Job&lt;?,?&gt; job = j.getItemByFullName(jobName, Job.class);</span>
<span class="nc bnc" id="L2283" title="All 2 branches missed.">        if (job == null) {</span>
<span class="nc" id="L2284">            return null;</span>
        }
<span class="nc" id="L2286">        return job.getBuildByNumber(number);</span>
    }

    /**
     * Returns the estimated duration for this run if it is currently running.
     * Default to {@link Job#getEstimatedDuration()}, may be overridden in subclasses
     * if duration may depend on run specific parameters (like incremental Maven builds).
     * 
     * @return the estimated duration in milliseconds
     * @since 1.383
     */
    @Exported
    public long getEstimatedDuration() {
<span class="nc" id="L2299">        return project.getEstimatedDuration();</span>
    }

    @RequirePOST
    public @Nonnull HttpResponse doConfigSubmit( StaplerRequest req ) throws IOException, ServletException, FormException {
<span class="nc" id="L2304">        checkPermission(UPDATE);</span>
<span class="nc" id="L2305">        BulkChange bc = new BulkChange(this);</span>
        try {
<span class="nc" id="L2307">            JSONObject json = req.getSubmittedForm();</span>
<span class="nc" id="L2308">            submit(json);</span>
<span class="nc" id="L2309">            bc.commit();</span>
<span class="nc" id="L2310">        } finally {</span>
<span class="nc" id="L2311">            bc.abort();</span>
<span class="nc" id="L2312">        }</span>
<span class="nc" id="L2313">        return FormApply.success(&quot;.&quot;);</span>
    }

    protected void submit(JSONObject json) throws IOException {
<span class="nc" id="L2317">        setDisplayName(Util.fixEmptyAndTrim(json.getString(&quot;displayName&quot;)));</span>
<span class="nc" id="L2318">        setDescription(json.getString(&quot;description&quot;));</span>
<span class="nc" id="L2319">    }</span>

<span class="fc" id="L2321">    public static final XStream XSTREAM = new XStream2();</span>

    /**
     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.
     */
<span class="fc" id="L2326">    public static final XStream2 XSTREAM2 = (XStream2)XSTREAM;</span>

    static {
<span class="fc" id="L2329">        XSTREAM.alias(&quot;build&quot;,FreeStyleBuild.class);</span>
<span class="fc" id="L2330">        XSTREAM.registerConverter(Result.conv);</span>
    }

<span class="fc" id="L2333">    private static final Logger LOGGER = Logger.getLogger(Run.class.getName());</span>

    /**
     * Sort by date. Newer ones first. 
     */
<span class="fc" id="L2338">    public static final Comparator&lt;Run&gt; ORDER_BY_DATE = new Comparator&lt;Run&gt;() {</span>
        public int compare(@Nonnull Run lhs, @Nonnull Run rhs) {
<span class="nc" id="L2340">            long lt = lhs.getTimeInMillis();</span>
<span class="nc" id="L2341">            long rt = rhs.getTimeInMillis();</span>
<span class="nc bnc" id="L2342" title="All 2 branches missed.">            if(lt&gt;rt)   return -1;</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">            if(lt&lt;rt)   return 1;</span>
<span class="nc" id="L2344">            return 0;</span>
        }
    };

    /**
     * {@link FeedAdapter} to produce feed from the summary of this build.
     */
<span class="fc" id="L2351">    public static final FeedAdapter&lt;Run&gt; FEED_ADAPTER = new DefaultFeedAdapter();</span>

    /**
     * {@link FeedAdapter} to produce feeds to show one build per project.
     */
<span class="fc" id="L2356">    public static final FeedAdapter&lt;Run&gt; FEED_ADAPTER_LATEST = new DefaultFeedAdapter() {</span>
        /**
         * The entry unique ID needs to be tied to a project, so that
         * new builds will replace the old result.
         */
        @Override
        public String getEntryID(Run e) {
            // can't use a meaningful year field unless we remember when the job was created.
<span class="nc" id="L2364">            return &quot;tag:hudson.dev.java.net,2008:&quot;+e.getParent().getAbsoluteUrl();</span>
        }
    };

    /**
     * {@link BuildBadgeAction} that shows the logs are being kept.
     */
<span class="nc" id="L2371">    public final class KeepLogBuildBadge implements BuildBadgeAction {</span>
<span class="nc" id="L2372">        public @CheckForNull String getIconFileName() { return null; }</span>
<span class="nc" id="L2373">        public @CheckForNull String getDisplayName() { return null; }</span>
<span class="nc" id="L2374">        public @CheckForNull String getUrlName() { return null; }</span>
<span class="nc" id="L2375">        public @CheckForNull String getWhyKeepLog() { return Run.this.getWhyKeepLog(); }</span>
    }

<span class="fc" id="L2378">    public static final PermissionGroup PERMISSIONS = new PermissionGroup(Run.class,Messages._Run_Permissions_Title());</span>
<span class="fc" id="L2379">    public static final Permission DELETE = new Permission(PERMISSIONS,&quot;Delete&quot;,Messages._Run_DeletePermission_Description(),Permission.DELETE, PermissionScope.RUN);</span>
<span class="fc" id="L2380">    public static final Permission UPDATE = new Permission(PERMISSIONS,&quot;Update&quot;,Messages._Run_UpdatePermission_Description(),Permission.UPDATE, PermissionScope.RUN);</span>
    /** See {@link hudson.Functions#isArtifactsPermissionEnabled} */
<span class="fc" id="L2382">    public static final Permission ARTIFACTS = new Permission(PERMISSIONS,&quot;Artifacts&quot;,Messages._Run_ArtifactsPermission_Description(), null,</span>
<span class="fc" id="L2383">                                                              Functions.isArtifactsPermissionEnabled(), new PermissionScope[]{PermissionScope.RUN});</span>

<span class="fc" id="L2385">    private static class DefaultFeedAdapter implements FeedAdapter&lt;Run&gt; {</span>
        public String getEntryTitle(Run entry) {
<span class="nc" id="L2387">            return entry+&quot; (&quot;+entry.getBuildStatusSummary().message+&quot;)&quot;;</span>
        }

        public String getEntryUrl(Run entry) {
<span class="nc" id="L2391">            return entry.getUrl();</span>
        }

        public String getEntryID(Run entry) {
<span class="nc" id="L2395">            return &quot;tag:&quot; + &quot;hudson.dev.java.net,&quot;</span>
<span class="nc" id="L2396">                + entry.getTimestamp().get(Calendar.YEAR) + &quot;:&quot;</span>
<span class="nc" id="L2397">                + entry.getParent().getName()+':'+entry.getId();</span>
        }

        public String getEntryDescription(Run entry) {
<span class="nc" id="L2401">            return entry.getDescription();</span>
        }

        public Calendar getEntryTimestamp(Run entry) {
<span class="nc" id="L2405">            return entry.getTimestamp();</span>
        }

        public String getEntryAuthor(Run entry) {
<span class="nc" id="L2409">            return JenkinsLocationConfiguration.get().getAdminAddress();</span>
        }
    }

    @Override
    public Object getDynamic(String token, StaplerRequest req, StaplerResponse rsp) {
<span class="nc" id="L2415">        Object returnedResult = super.getDynamic(token, req, rsp);</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">        if (returnedResult == null){</span>
            //check transient actions too
<span class="nc bnc" id="L2418" title="All 2 branches missed.">            for(Action action: getTransientActions()){</span>
<span class="nc" id="L2419">                String urlName = action.getUrlName();</span>
<span class="nc bnc" id="L2420" title="All 2 branches missed.">                if (urlName == null) {</span>
<span class="nc" id="L2421">                    continue;</span>
                }
<span class="nc bnc" id="L2423" title="All 2 branches missed.">                if (urlName.equals(token)) {</span>
<span class="nc" id="L2424">                    return action;</span>
                }
            }
            // Next/Previous Build links on an action page (like /job/Abc/123/testReport)
            // will also point to same action (/job/Abc/124/testReport), but other builds
            // may not have the action.. tell browsers to redirect up to the build page.
<span class="nc" id="L2430">            returnedResult = new RedirectUp();</span>
        }
<span class="nc" id="L2432">        return returnedResult;</span>
    }

<span class="nc" id="L2435">    public static class RedirectUp {</span>
        public void doDynamic(StaplerResponse rsp) throws IOException {
            // Compromise to handle both browsers (auto-redirect) and programmatic access
            // (want accurate 404 response).. send 404 with javscript to redirect browsers.
<span class="nc" id="L2439">            rsp.setStatus(HttpServletResponse.SC_NOT_FOUND);</span>
<span class="nc" id="L2440">            rsp.setContentType(&quot;text/html;charset=UTF-8&quot;);</span>
<span class="nc" id="L2441">            PrintWriter out = rsp.getWriter();</span>
<span class="nc" id="L2442">            out.println(&quot;&lt;html&gt;&lt;head&gt;&quot; +</span>
                &quot;&lt;meta http-equiv='refresh' content='1;url=..'/&gt;&quot; +
                &quot;&lt;script&gt;window.location.replace('..');&lt;/script&gt;&quot; +
                &quot;&lt;/head&gt;&quot; +
                &quot;&lt;body style='background-color:white; color:white;'&gt;&quot; +
                &quot;Not found&lt;/body&gt;&lt;/html&gt;&quot;);
<span class="nc" id="L2448">            out.flush();</span>
<span class="nc" id="L2449">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>jenkins-core (22-mrt-2016 21:51:03)</div></body></html>