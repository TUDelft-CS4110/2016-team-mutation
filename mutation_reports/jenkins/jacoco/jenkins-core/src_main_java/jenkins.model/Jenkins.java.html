<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Jenkins.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">jenkins-core (22-mrt-2016 21:51:03)</a> &gt; <a href="../../index.html" class="el_group">jenkins-core</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">jenkins.model</a> &gt; <span class="el_source">Jenkins.java</span></div><h1>Jenkins.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/*</span>
 * The MIT License
 *
 * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,
 * Erik Ramfelt, Koichi Fujikawa, Red Hat, Inc., Seiji Sogabe,
 * Stephen Connolly, Tom Huybrechts, Yahoo! Inc., Alan Harder, CloudBees, Inc.,
 * Yahoo!, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package jenkins.model;

import antlr.ANTLRException;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.inject.Injector;
import com.thoughtworks.xstream.XStream;
import hudson.BulkChange;
import hudson.DNSMultiCast;
import hudson.DescriptorExtensionList;
import hudson.Extension;
import hudson.ExtensionComponent;
import hudson.ExtensionFinder;
import hudson.ExtensionList;
import hudson.ExtensionPoint;
import hudson.FilePath;
import hudson.Functions;
import hudson.Launcher;
import hudson.Launcher.LocalLauncher;
import hudson.LocalPluginManager;
import hudson.Lookup;
import hudson.Plugin;
import hudson.PluginManager;
import hudson.PluginWrapper;
import hudson.ProxyConfiguration;
import hudson.TcpSlaveAgentListener;
import hudson.UDPBroadcastThread;
import hudson.Util;
import hudson.WebAppMain;
import hudson.XmlFile;
import hudson.cli.declarative.CLIMethod;
import hudson.cli.declarative.CLIResolver;
import hudson.init.InitMilestone;
import hudson.init.InitStrategy;
import hudson.init.TerminatorFinder;
import hudson.lifecycle.Lifecycle;
import hudson.lifecycle.RestartNotSupportedException;
import hudson.logging.LogRecorderManager;
import hudson.markup.EscapedMarkupFormatter;
import hudson.markup.MarkupFormatter;
import hudson.model.AbstractCIBase;
import hudson.model.AbstractProject;
import hudson.model.Action;
import hudson.model.AdministrativeMonitor;
import hudson.model.AllView;
import hudson.model.Api;
import hudson.model.Computer;
import hudson.model.ComputerSet;
import hudson.model.DependencyGraph;
import hudson.model.Describable;
import hudson.model.Descriptor;
import hudson.model.Descriptor.FormException;
import hudson.model.DescriptorByNameOwner;
import hudson.model.DirectoryBrowserSupport;
import hudson.model.Failure;
import hudson.model.Fingerprint;
import hudson.model.FingerprintCleanupThread;
import hudson.model.FingerprintMap;
import hudson.model.Hudson;
import hudson.model.Item;
import hudson.model.ItemGroup;
import hudson.model.ItemGroupMixIn;
import hudson.model.Items;
import hudson.model.JDK;
import hudson.model.Job;
import hudson.model.JobPropertyDescriptor;
import hudson.model.Label;
import hudson.model.ListView;
import hudson.model.LoadBalancer;
import hudson.model.LoadStatistics;
import hudson.model.ManagementLink;
import hudson.model.Messages;
import hudson.model.ModifiableViewGroup;
import hudson.model.NoFingerprintMatch;
import hudson.model.Node;
import hudson.model.OverallLoadStatistics;
import hudson.model.PaneStatusProperties;
import hudson.model.Project;
import hudson.model.Queue;
import hudson.model.Queue.FlyweightTask;
import hudson.model.RestartListener;
import hudson.model.RootAction;
import hudson.model.Slave;
import hudson.model.TaskListener;
import hudson.model.TopLevelItem;
import hudson.model.TopLevelItemDescriptor;
import hudson.model.UnprotectedRootAction;
import hudson.model.UpdateCenter;
import hudson.model.User;
import hudson.model.View;
import hudson.model.ViewGroupMixIn;
import hudson.model.WorkspaceCleanupThread;
import hudson.model.labels.LabelAtom;
import hudson.model.listeners.ItemListener;
import hudson.model.listeners.SCMListener;
import hudson.model.listeners.SaveableListener;
import hudson.remoting.Callable;
import hudson.remoting.LocalChannel;
import hudson.remoting.VirtualChannel;
import hudson.scm.RepositoryBrowser;
import hudson.scm.SCM;
import hudson.search.CollectionSearchIndex;
import hudson.search.SearchIndexBuilder;
import hudson.search.SearchItem;
import hudson.security.ACL;
import hudson.security.AccessControlled;
import hudson.security.AuthorizationStrategy;
import hudson.security.BasicAuthenticationFilter;
import hudson.security.FederatedLoginService;
import hudson.security.FullControlOnceLoggedInAuthorizationStrategy;
import hudson.security.HudsonFilter;
import hudson.security.LegacyAuthorizationStrategy;
import hudson.security.LegacySecurityRealm;
import hudson.security.Permission;
import hudson.security.PermissionGroup;
import hudson.security.PermissionScope;
import hudson.security.SecurityMode;
import hudson.security.SecurityRealm;
import hudson.security.csrf.CrumbIssuer;
import hudson.slaves.Cloud;
import hudson.slaves.ComputerListener;
import hudson.slaves.DumbSlave;
import hudson.slaves.NodeDescriptor;
import hudson.slaves.NodeList;
import hudson.slaves.NodeProperty;
import hudson.slaves.NodePropertyDescriptor;
import hudson.slaves.NodeProvisioner;
import hudson.slaves.OfflineCause;
import hudson.slaves.RetentionStrategy;
import hudson.tasks.BuildWrapper;
import hudson.tasks.Builder;
import hudson.tasks.Publisher;
import hudson.triggers.SafeTimerTask;
import hudson.triggers.Trigger;
import hudson.triggers.TriggerDescriptor;
import hudson.util.AdministrativeError;
import hudson.util.CaseInsensitiveComparator;
import hudson.util.ClockDifference;
import hudson.util.CopyOnWriteList;
import hudson.util.CopyOnWriteMap;
import hudson.util.DaemonThreadFactory;
import hudson.util.DescribableList;
import hudson.util.FormApply;
import hudson.util.FormValidation;
import hudson.util.Futures;
import hudson.util.HudsonIsLoading;
import hudson.util.HudsonIsRestarting;
import hudson.util.IOUtils;
import hudson.util.Iterators;
import hudson.util.JenkinsReloadFailed;
import hudson.util.Memoizer;
import hudson.util.MultipartFormDataParser;
import hudson.util.NamingThreadFactory;
import hudson.util.RemotingDiagnostics;
import hudson.util.RemotingDiagnostics.HeapDump;
import hudson.util.TextFile;
import hudson.util.TimeUnit2;
import hudson.util.VersionNumber;
import hudson.util.XStream2;
import hudson.views.DefaultMyViewsTabBar;
import hudson.views.DefaultViewsTabBar;
import hudson.views.MyViewsTabBar;
import hudson.views.ViewsTabBar;
import hudson.widgets.Widget;
import jenkins.ExtensionComponentSet;
import jenkins.ExtensionRefreshException;
import jenkins.InitReactorRunner;
import jenkins.model.ProjectNamingStrategy.DefaultProjectNamingStrategy;
import jenkins.security.ConfidentialKey;
import jenkins.security.ConfidentialStore;
import jenkins.security.SecurityListener;
import jenkins.security.MasterToSlaveCallable;
import jenkins.slaves.WorkspaceLocator;
import jenkins.util.Timer;
import jenkins.util.io.FileBoolean;
import net.sf.json.JSONObject;
import org.acegisecurity.AccessDeniedException;
import org.acegisecurity.AcegiSecurityException;
import org.acegisecurity.Authentication;
import org.acegisecurity.GrantedAuthority;
import org.acegisecurity.GrantedAuthorityImpl;
import org.acegisecurity.context.SecurityContextHolder;
import org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;
import org.acegisecurity.ui.AbstractProcessingFilter;
import org.apache.commons.jelly.JellyException;
import org.apache.commons.jelly.Script;
import org.apache.commons.logging.LogFactory;
import org.jvnet.hudson.reactor.Executable;
import org.jvnet.hudson.reactor.Reactor;
import org.jvnet.hudson.reactor.ReactorException;
import org.jvnet.hudson.reactor.Task;
import org.jvnet.hudson.reactor.TaskBuilder;
import org.jvnet.hudson.reactor.TaskGraphBuilder;
import org.jvnet.hudson.reactor.TaskGraphBuilder.Handle;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.Option;
import org.kohsuke.stapler.HttpRedirect;
import org.kohsuke.stapler.HttpResponse;
import org.kohsuke.stapler.HttpResponses;
import org.kohsuke.stapler.MetaClass;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.Stapler;
import org.kohsuke.stapler.StaplerFallback;
import org.kohsuke.stapler.StaplerProxy;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import org.kohsuke.stapler.WebApp;
import org.kohsuke.stapler.export.Exported;
import org.kohsuke.stapler.export.ExportedBean;
import org.kohsuke.stapler.framework.adjunct.AdjunctManager;
import org.kohsuke.stapler.interceptor.RequirePOST;
import org.kohsuke.stapler.jelly.JellyClassLoaderTearOff;
import org.kohsuke.stapler.jelly.JellyRequestDispatcher;
import org.xml.sax.InputSource;

import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.crypto.SecretKey;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.net.BindException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.Charset;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;

import static hudson.Util.*;
import static hudson.init.InitMilestone.*;
import hudson.util.LogTaskListener;
import static java.util.logging.Level.*;
import static javax.servlet.http.HttpServletResponse.*;

/**
 * Root object of the system.
 *
 * @author Kohsuke Kawaguchi
 */
@ExportedBean
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">public class Jenkins extends AbstractCIBase implements DirectlyModifiableTopLevelItemGroup, StaplerProxy, StaplerFallback,</span>
        ModifiableViewGroup, AccessControlled, DescriptorByNameOwner,
        ModelObjectWithContextMenu, ModelObjectWithChildren {
    private transient final Queue queue;

    /**
     * Stores various objects scoped to {@link Jenkins}.
     */
<span class="nc" id="L315">    public transient final Lookup lookup = new Lookup();</span>

    /**
     * We update this field to the current version of Jenkins whenever we save {@code config.xml}.
     * This can be used to detect when an upgrade happens from one version to next.
     *
     * &lt;p&gt;
     * Since this field is introduced starting 1.301, &quot;1.0&quot; is used to represent every version
     * up to 1.300. This value may also include non-standard versions like &quot;1.301-SNAPSHOT&quot; or
     * &quot;?&quot;, etc., so parsing needs to be done with a care.
     *
     * @since 1.301
     */
    // this field needs to be at the very top so that other components can look at this value even during unmarshalling
<span class="nc" id="L329">    private String version = &quot;1.0&quot;;</span>

    /**
     * Number of executors of the master node.
     */
<span class="nc" id="L334">    private int numExecutors = 2;</span>

    /**
     * Job allocation strategy.
     */
<span class="nc" id="L339">    private Mode mode = Mode.NORMAL;</span>

    /**
     * False to enable anyone to do anything.
     * Left as a field so that we can still read old data that uses this flag.
     *
     * @see #authorizationStrategy
     * @see #securityRealm
     */
    private Boolean useSecurity;

    /**
     * Controls how the
     * &lt;a href=&quot;http://en.wikipedia.org/wiki/Authorization&quot;&gt;authorization&lt;/a&gt;
     * is handled in Jenkins.
     * &lt;p&gt;
     * This ultimately controls who has access to what.
     *
     * Never null.
     */
<span class="nc" id="L359">    private volatile AuthorizationStrategy authorizationStrategy = AuthorizationStrategy.UNSECURED;</span>

    /**
     * Controls a part of the
     * &lt;a href=&quot;http://en.wikipedia.org/wiki/Authentication&quot;&gt;authentication&lt;/a&gt;
     * handling in Jenkins.
     * &lt;p&gt;
     * Intuitively, this corresponds to the user database.
     *
     * See {@link HudsonFilter} for the concrete authentication protocol.
     *
     * Never null. Always use {@link #setSecurityRealm(SecurityRealm)} to
     * update this field.
     *
     * @see #getSecurity()
     * @see #setSecurityRealm(SecurityRealm)
     */
<span class="nc" id="L376">    private volatile SecurityRealm securityRealm = SecurityRealm.NO_AUTHENTICATION;</span>

    /**
     * Disables the remember me on this computer option in the standard login screen.
     *
     * @since 1.534
     */
    private volatile boolean disableRememberMe;

    /**
     * The project naming strategy defines/restricts the names which can be given to a project/job. e.g. does the name have to follow a naming convention?
     */
<span class="nc" id="L388">    private ProjectNamingStrategy projectNamingStrategy = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;</span>

    /**
     * Root directory for the workspaces.
     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.
     * @see #getWorkspaceFor(TopLevelItem)
     */
<span class="nc" id="L395">    private String workspaceDir = &quot;${ITEM_ROOTDIR}/&quot;+WORKSPACE_DIRNAME;</span>

    /**
     * Root directory for the builds.
     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.
     * @see #getBuildDirFor(Job)
     */
<span class="nc" id="L402">    private String buildsDir = &quot;${ITEM_ROOTDIR}/builds&quot;;</span>

    /**
     * Message displayed in the top page.
     */
    private String systemMessage;

    private MarkupFormatter markupFormatter;

    /**
     * Root directory of the system.
     */
    public transient final File root;

    /**
     * Where are we in the initialization?
     */
<span class="nc" id="L419">    private transient volatile InitMilestone initLevel = InitMilestone.STARTED;</span>

    /**
     * All {@link Item}s keyed by their {@link Item#getName() name}s.
     */
<span class="nc" id="L424">    /*package*/ transient final Map&lt;String,TopLevelItem&gt; items = new CopyOnWriteMap.Tree&lt;String,TopLevelItem&gt;(CaseInsensitiveComparator.INSTANCE);</span>

    /**
     * The sole instance.
     */
    private static Jenkins theInstance;

    private transient volatile boolean isQuietingDown;
    private transient volatile boolean terminating;

<span class="nc" id="L434">    private volatile List&lt;JDK&gt; jdks = new ArrayList&lt;JDK&gt;();</span>

    private transient volatile DependencyGraph dependencyGraph;
<span class="nc" id="L437">    private final transient AtomicBoolean dependencyGraphDirty = new AtomicBoolean();</span>

    /**
     * Currently active Views tab bar.
     */
<span class="nc" id="L442">    private volatile ViewsTabBar viewsTabBar = new DefaultViewsTabBar();</span>

    /**
     * Currently active My Views tab bar.
     */
<span class="nc" id="L447">    private volatile MyViewsTabBar myViewsTabBar = new DefaultMyViewsTabBar();</span>

    /**
     * All {@link ExtensionList} keyed by their {@link ExtensionList#extensionType}.
     */
<span class="nc" id="L452">    private transient final Memoizer&lt;Class,ExtensionList&gt; extensionLists = new Memoizer&lt;Class,ExtensionList&gt;() {</span>
        public ExtensionList compute(Class key) {
<span class="nc" id="L454">            return ExtensionList.create(Jenkins.this,key);</span>
        }
    };

    /**
     * All {@link DescriptorExtensionList} keyed by their {@link DescriptorExtensionList#describableType}.
     */
<span class="nc" id="L461">    private transient final Memoizer&lt;Class,DescriptorExtensionList&gt; descriptorLists = new Memoizer&lt;Class,DescriptorExtensionList&gt;() {</span>
        public DescriptorExtensionList compute(Class key) {
<span class="nc" id="L463">            return DescriptorExtensionList.createDescriptorList(Jenkins.this,key);</span>
        }
    };

    /**
     * {@link Computer}s in this Jenkins system. Read-only.
     */
<span class="nc" id="L470">    protected transient final Map&lt;Node,Computer&gt; computers = new CopyOnWriteMap.Hash&lt;Node,Computer&gt;();</span>

    /**
     * Active {@link Cloud}s.
     */
<span class="nc" id="L475">    public final Hudson.CloudList clouds = new Hudson.CloudList(this);</span>

    public static class CloudList extends DescribableList&lt;Cloud,Descriptor&lt;Cloud&gt;&gt; {
        public CloudList(Jenkins h) {
<span class="nc" id="L479">            super(h);</span>
<span class="nc" id="L480">        }</span>

<span class="nc" id="L482">        public CloudList() {// needed for XStream deserialization</span>
<span class="nc" id="L483">        }</span>

        public Cloud getByName(String name) {
<span class="nc bnc" id="L486" title="All 2 branches missed.">            for (Cloud c : this)</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                if (c.name.equals(name))</span>
<span class="nc" id="L488">                    return c;</span>
<span class="nc" id="L489">            return null;</span>
        }

        @Override
        protected void onModified() throws IOException {
<span class="nc" id="L494">            super.onModified();</span>
<span class="nc" id="L495">            Jenkins.getInstance().trimLabels();</span>
<span class="nc" id="L496">        }</span>
    }

    /**
     * Legacy store of the set of installed cluster nodes.
     * @deprecated in favour of {@link Nodes}
     */
    @Deprecated
    protected transient volatile NodeList slaves;

    /**
     * The holder of the set of installed cluster nodes.
     *
     * @since 1.607
     */
<span class="nc" id="L511">    private transient final Nodes nodes = new Nodes(this);</span>

    /**
     * Quiet period.
     *
     * This is {@link Integer} so that we can initialize it to '5' for upgrading users.
     */
    /*package*/ Integer quietPeriod;

    /**
     * Global default for {@link AbstractProject#getScmCheckoutRetryCount()}
     */
    /*package*/ int scmCheckoutRetryCount;

    /**
     * {@link View}s.
     */
<span class="nc" id="L528">    private final CopyOnWriteArrayList&lt;View&gt; views = new CopyOnWriteArrayList&lt;View&gt;();</span>

    /**
     * Name of the primary view.
     * &lt;p&gt;
     * Start with null, so that we can upgrade pre-1.269 data well.
     * @since 1.269
     */
    private volatile String primaryView;

<span class="nc" id="L538">    private transient final ViewGroupMixIn viewGroupMixIn = new ViewGroupMixIn(this) {</span>
<span class="nc" id="L539">        protected List&lt;View&gt; views() { return views; }</span>
<span class="nc" id="L540">        protected String primaryView() { return primaryView; }</span>
<span class="nc" id="L541">        protected void primaryView(String name) { primaryView=name; }</span>
    };


<span class="nc" id="L545">    private transient final FingerprintMap fingerprintMap = new FingerprintMap();</span>

    /**
     * Loaded plugins.
     */
    public transient final PluginManager pluginManager;

    public transient volatile TcpSlaveAgentListener tcpSlaveAgentListener;

<span class="nc" id="L554">    private transient final Object tcpSlaveAgentListenerLock = new Object();</span>

    private transient UDPBroadcastThread udpBroadcastThread;

    private transient DNSMultiCast dnsMultiCast;

    /**
     * List of registered {@link SCMListener}s.
     */
<span class="nc" id="L563">    private transient final CopyOnWriteList&lt;SCMListener&gt; scmListeners = new CopyOnWriteList&lt;SCMListener&gt;();</span>

    /**
     * TCP slave agent port.
     * 0 for random, -1 to disable.
     */
<span class="nc" id="L569">    private int slaveAgentPort = Integer.getInteger(Jenkins.class.getName()+&quot;.slaveAgentPort&quot;,0);</span>

    /**
     * Whitespace-separated labels assigned to the master as a {@link Node}.
     */
<span class="nc" id="L574">    private String label=&quot;&quot;;</span>

    /**
     * {@link hudson.security.csrf.CrumbIssuer}
     */
    private volatile CrumbIssuer crumbIssuer;

    /**
     * All labels known to Jenkins. This allows us to reuse the same label instances
     * as much as possible, even though that's not a strict requirement.
     */
<span class="nc" id="L585">    private transient final ConcurrentHashMap&lt;String,Label&gt; labels = new ConcurrentHashMap&lt;String,Label&gt;();</span>

    /**
     * Load statistics of the entire system.
     *
     * This includes every executor and every job in the system.
     */
    @Exported
<span class="nc" id="L593">    public transient final OverallLoadStatistics overallLoad = new OverallLoadStatistics();</span>

    /**
     * Load statistics of the free roaming jobs and slaves.
     *
     * This includes all executors on {@link hudson.model.Node.Mode#NORMAL} nodes and jobs that do not have any assigned nodes.
     *
     * @since 1.467
     */
    @Exported
<span class="nc" id="L603">    public transient final LoadStatistics unlabeledLoad = new UnlabeledLoadStatistics();</span>

    /**
     * {@link NodeProvisioner} that reacts to {@link #unlabeledLoad}.
     * @since 1.467
     */
<span class="nc" id="L609">    public transient final NodeProvisioner unlabeledNodeProvisioner = new NodeProvisioner(null,unlabeledLoad);</span>

    /**
     * @deprecated as of 1.467
     *      Use {@link #unlabeledNodeProvisioner}.
     *      This was broken because it was tracking all the executors in the system, but it was only tracking
     *      free-roaming jobs in the queue. So {@link Cloud} fails to launch nodes when you have some exclusive
     *      slaves and free-roaming jobs in the queue.
     */
    @Restricted(NoExternalUse.class)
    @Deprecated
<span class="nc" id="L620">    public transient final NodeProvisioner overallNodeProvisioner = unlabeledNodeProvisioner;</span>


    public transient final ServletContext servletContext;

    /**
     * Transient action list. Useful for adding navigation items to the navigation bar
     * on the left.
     */
<span class="nc" id="L629">    private transient final List&lt;Action&gt; actions = new CopyOnWriteArrayList&lt;Action&gt;();</span>

    /**
     * List of master node properties
     */
<span class="nc" id="L634">    private DescribableList&lt;NodeProperty&lt;?&gt;,NodePropertyDescriptor&gt; nodeProperties = new DescribableList&lt;NodeProperty&lt;?&gt;,NodePropertyDescriptor&gt;(this);</span>

    /**
     * List of global properties
     */
<span class="nc" id="L639">    private DescribableList&lt;NodeProperty&lt;?&gt;,NodePropertyDescriptor&gt; globalNodeProperties = new DescribableList&lt;NodeProperty&lt;?&gt;,NodePropertyDescriptor&gt;(this);</span>

    /**
     * {@link AdministrativeMonitor}s installed on this system.
     *
     * @see AdministrativeMonitor
     */
<span class="nc" id="L646">    public transient final List&lt;AdministrativeMonitor&gt; administrativeMonitors = getExtensionList(AdministrativeMonitor.class);</span>

    /**
     * Widgets on Jenkins.
     */
<span class="nc" id="L651">    private transient final List&lt;Widget&gt; widgets = getExtensionList(Widget.class);</span>

    /**
     * {@link AdjunctManager}
     */
    private transient final AdjunctManager adjuncts;

    /**
     * Code that handles {@link ItemGroup} work.
     */
<span class="nc" id="L661">    private transient final ItemGroupMixIn itemGroupMixIn = new ItemGroupMixIn(this,this) {</span>
        @Override
        protected void add(TopLevelItem item) {
<span class="nc" id="L664">            items.put(item.getName(),item);</span>
<span class="nc" id="L665">        }</span>

        @Override
        protected File getRootDirFor(String name) {
<span class="nc" id="L669">            return Jenkins.this.getRootDirFor(name);</span>
        }
    };


    /**
     * Hook for a test harness to intercept Jenkins.getInstance()
     *
     * Do not use in the production code as the signature may change.
     */
    public interface JenkinsHolder {
        @CheckForNull Jenkins getInstance();
    }

<span class="fc" id="L683">    static JenkinsHolder HOLDER = new JenkinsHolder() {</span>
        public @CheckForNull Jenkins getInstance() {
<span class="fc" id="L685">            return theInstance;</span>
        }
    };

    /**
     * Gets the {@link Jenkins} singleton.
     * {@link #getInstance()} provides the unchecked versions of the method.
     * @return {@link Jenkins} instance
     * @throws IllegalStateException {@link Jenkins} has not been started, or was already shut down
     * @since 1.590
     */
    public static @Nonnull Jenkins getActiveInstance() throws IllegalStateException {
<span class="nc" id="L697">        Jenkins instance = HOLDER.getInstance();</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (instance == null) {</span>
<span class="nc" id="L699">            throw new IllegalStateException(&quot;Jenkins has not been started, or was already shut down&quot;);</span>
        }
<span class="nc" id="L701">        return instance;</span>
    }

    /**
     * Gets the {@link Jenkins} singleton.
     * {@link #getActiveInstance()} provides the checked versions of the method.
     * @return The instance. Null if the {@link Jenkins} instance has not been started,
     * or was already shut down
     */
    @CLIResolver
    @CheckForNull
    public static Jenkins getInstance() {
<span class="fc" id="L713">        return HOLDER.getInstance();</span>
    }

    /**
     * Secret key generated once and used for a long time, beyond
     * container start/stop. Persisted outside &lt;tt&gt;config.xml&lt;/tt&gt; to avoid
     * accidental exposure.
     */
    private transient final String secretKey;

<span class="nc" id="L723">    private transient final UpdateCenter updateCenter = new UpdateCenter();</span>

    /**
     * True if the user opted out from the statistics tracking. We'll never send anything if this is true.
     */
    private Boolean noUsageStatistics;

    /**
     * HTTP proxy configuration.
     */
    public transient volatile ProxyConfiguration proxy;

    /**
     * Bound to &quot;/log&quot;.
     */
<span class="nc" id="L738">    private transient final LogRecorderManager log = new LogRecorderManager();</span>

    protected Jenkins(File root, ServletContext context) throws IOException, InterruptedException, ReactorException {
<span class="nc" id="L741">        this(root,context,null);</span>
<span class="nc" id="L742">    }</span>

    /**
     * @param pluginManager
     *      If non-null, use existing plugin manager.  create a new one.
     */
    @edu.umd.cs.findbugs.annotations.SuppressWarnings({
        &quot;SC_START_IN_CTOR&quot;, // bug in FindBugs. It flags UDPBroadcastThread.start() call but that's for another class
        &quot;ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD&quot; // Trigger.timer
    })
<span class="nc" id="L752">    protected Jenkins(File root, ServletContext context, PluginManager pluginManager) throws IOException, InterruptedException, ReactorException {</span>
<span class="nc" id="L753">        long start = System.currentTimeMillis();</span>

    	// As Jenkins is starting, grant this process full control
<span class="nc" id="L756">        ACL.impersonate(ACL.SYSTEM);</span>
        try {
<span class="nc" id="L758">            this.root = root;</span>
<span class="nc" id="L759">            this.servletContext = context;</span>
<span class="nc" id="L760">            computeVersion(context);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">            if(theInstance!=null)</span>
<span class="nc" id="L762">                throw new IllegalStateException(&quot;second instance&quot;);</span>
<span class="nc" id="L763">            theInstance = this;</span>

<span class="nc bnc" id="L765" title="All 2 branches missed.">            if (!new File(root,&quot;jobs&quot;).exists()) {</span>
                // if this is a fresh install, use more modern default layout that's consistent with slaves
<span class="nc" id="L767">                workspaceDir = &quot;${JENKINS_HOME}/workspace/${ITEM_FULLNAME}&quot;;</span>
            }

            // doing this early allows InitStrategy to set environment upfront
<span class="nc" id="L771">            final InitStrategy is = InitStrategy.get(Thread.currentThread().getContextClassLoader());</span>

<span class="nc" id="L773">            Trigger.timer = new java.util.Timer(&quot;Jenkins cron thread&quot;);</span>
<span class="nc" id="L774">            queue = new Queue(LoadBalancer.CONSISTENT_HASH);</span>

            try {
<span class="nc" id="L777">                dependencyGraph = DependencyGraph.EMPTY;</span>
<span class="nc" id="L778">            } catch (InternalError e) {</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                if(e.getMessage().contains(&quot;window server&quot;)) {</span>
<span class="nc" id="L780">                    throw new Error(&quot;Looks like the server runs without X. Please specify -Djava.awt.headless=true as JVM option&quot;,e);</span>
                }
<span class="nc" id="L782">                throw e;</span>
            }

            // get or create the secret
<span class="nc" id="L786">            TextFile secretFile = new TextFile(new File(getRootDir(),&quot;secret.key&quot;));</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if(secretFile.exists()) {</span>
<span class="nc" id="L788">                secretKey = secretFile.readTrim();</span>
<span class="nc" id="L789">            } else {</span>
<span class="nc" id="L790">                SecureRandom sr = new SecureRandom();</span>
<span class="nc" id="L791">                byte[] random = new byte[32];</span>
<span class="nc" id="L792">                sr.nextBytes(random);</span>
<span class="nc" id="L793">                secretKey = Util.toHexString(random);</span>
<span class="nc" id="L794">                secretFile.write(secretKey);</span>

                // this marker indicates that the secret.key is generated by the version of Jenkins post SECURITY-49.
                // this indicates that there's no need to rewrite secrets on disk
<span class="nc" id="L798">                new FileBoolean(new File(root,&quot;secret.key.not-so-secret&quot;)).on();</span>
            }

            try {
<span class="nc" id="L802">                proxy = ProxyConfiguration.load();</span>
<span class="nc" id="L803">            } catch (IOException e) {</span>
<span class="nc" id="L804">                LOGGER.log(SEVERE, &quot;Failed to load proxy configuration&quot;, e);</span>
            }

<span class="nc bnc" id="L807" title="All 2 branches missed.">            if (pluginManager==null)</span>
<span class="nc" id="L808">                pluginManager = new LocalPluginManager(this);</span>
<span class="nc" id="L809">            this.pluginManager = pluginManager;</span>
            // JSON binding needs to be able to see all the classes from all the plugins
<span class="nc" id="L811">            WebApp.get(servletContext).setClassLoader(pluginManager.uberClassLoader);</span>

<span class="nc" id="L813">            adjuncts = new AdjunctManager(servletContext, pluginManager.uberClassLoader,&quot;adjuncts/&quot;+SESSION_HASH, TimeUnit2.DAYS.toMillis(365));</span>

            // initialization consists of ...
<span class="nc" id="L816">            executeReactor( is,</span>
<span class="nc" id="L817">                    pluginManager.initTasks(is),    // loading and preparing plugins</span>
<span class="nc" id="L818">                    loadTasks(),                    // load jobs</span>
<span class="nc" id="L819">                    InitMilestone.ordering()        // forced ordering among key milestones</span>
            );

<span class="nc bnc" id="L822" title="All 2 branches missed.">            if(KILL_AFTER_LOAD)</span>
<span class="nc" id="L823">                System.exit(0);</span>

<span class="nc" id="L825">            launchTcpSlaveAgentListener();</span>

<span class="nc bnc" id="L827" title="All 2 branches missed.">            if (UDPBroadcastThread.PORT != -1) {</span>
                try {
<span class="nc" id="L829">                    udpBroadcastThread = new UDPBroadcastThread(this);</span>
<span class="nc" id="L830">                    udpBroadcastThread.start();</span>
<span class="nc" id="L831">                } catch (IOException e) {</span>
<span class="nc" id="L832">                    LOGGER.log(Level.WARNING, &quot;Failed to broadcast over UDP (use -Dhudson.udp=-1 to disable)&quot;, e);</span>
                }
            }
<span class="nc" id="L835">            dnsMultiCast = new DNSMultiCast(this);</span>

<span class="nc" id="L837">            Timer.get().scheduleAtFixedRate(new SafeTimerTask() {</span>
                @Override
                protected void doRun() throws Exception {
<span class="nc" id="L840">                    trimLabels();</span>
<span class="nc" id="L841">                }</span>
<span class="nc" id="L842">            }, TimeUnit2.MINUTES.toMillis(5), TimeUnit2.MINUTES.toMillis(5), TimeUnit.MILLISECONDS);</span>

<span class="nc" id="L844">            updateComputerList();</span>

            {// master is online now
<span class="nc" id="L847">                Computer c = toComputer();</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">                if(c!=null)</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">                    for (ComputerListener cl : ComputerListener.all())</span>
<span class="nc" id="L850">                        cl.onOnline(c, new LogTaskListener(LOGGER, INFO));</span>
            }

<span class="nc bnc" id="L853" title="All 2 branches missed.">            for (ItemListener l : ItemListener.all()) {</span>
<span class="nc" id="L854">                long itemListenerStart = System.currentTimeMillis();</span>
                try {
<span class="nc" id="L856">                    l.onLoaded();</span>
<span class="nc" id="L857">                } catch (RuntimeException x) {</span>
<span class="nc" id="L858">                    LOGGER.log(Level.WARNING, null, x);</span>
                }
<span class="nc bnc" id="L860" title="All 2 branches missed.">                if (LOG_STARTUP_PERFORMANCE)</span>
<span class="nc" id="L861">                    LOGGER.info(String.format(&quot;Took %dms for item listener %s startup&quot;,</span>
<span class="nc" id="L862">                            System.currentTimeMillis()-itemListenerStart,l.getClass().getName()));</span>
            }

            // All plugins are loaded. Now we can figure out who depends on who.
<span class="nc" id="L866">            resolveDependantPlugins();</span>

<span class="nc bnc" id="L868" title="All 2 branches missed.">            if (LOG_STARTUP_PERFORMANCE)</span>
<span class="nc" id="L869">                LOGGER.info(String.format(&quot;Took %dms for complete Jenkins startup&quot;,</span>
<span class="nc" id="L870">                        System.currentTimeMillis()-start));</span>
<span class="nc" id="L871">        } finally {</span>
<span class="nc" id="L872">            SecurityContextHolder.clearContext();</span>
<span class="nc" id="L873">        }</span>
<span class="nc" id="L874">    }</span>

    private void resolveDependantPlugins() throws InterruptedException, ReactorException, IOException {
<span class="nc" id="L877">        TaskGraphBuilder graphBuilder = new TaskGraphBuilder();</span>

<span class="nc" id="L879">        graphBuilder.add(&quot;Resolving Dependant Plugins Graph&quot;, new Executable() {</span>
            @Override
            public void run(Reactor reactor) throws Exception {
<span class="nc" id="L882">                pluginManager.resolveDependantPlugins();</span>
<span class="nc" id="L883">            }</span>
        });

<span class="nc" id="L886">        executeReactor(null, graphBuilder);</span>
<span class="nc" id="L887">    }</span>

    /**
     * Maintains backwards compatibility. Invoked by XStream when this object is de-serialized.
     */
    @SuppressWarnings({&quot;unused&quot;})
    private Object readResolve() {
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (jdks == null) {</span>
<span class="nc" id="L895">            jdks = new ArrayList&lt;&gt;();</span>
        }
<span class="nc" id="L897">        return this;</span>
    }

    /**
     * Executes a reactor.
     *
     * @param is
     *      If non-null, this can be consulted for ignoring some tasks. Only used during the initialization of Jenkins.
     */
    private void executeReactor(final InitStrategy is, TaskBuilder... builders) throws IOException, InterruptedException, ReactorException {
<span class="nc" id="L907">        Reactor reactor = new Reactor(builders) {</span>
            /**
             * Sets the thread name to the task for better diagnostics.
             */
            @Override
            protected void runTask(Task task) throws Exception {
<span class="nc bnc" id="L913" title="All 4 branches missed.">                if (is!=null &amp;&amp; is.skipInitTask(task))  return;</span>

<span class="nc" id="L915">                ACL.impersonate(ACL.SYSTEM); // full access in the initialization thread</span>
<span class="nc" id="L916">                String taskName = task.getDisplayName();</span>

<span class="nc" id="L918">                Thread t = Thread.currentThread();</span>
<span class="nc" id="L919">                String name = t.getName();</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">                if (taskName !=null)</span>
<span class="nc" id="L921">                    t.setName(taskName);</span>
                try {
<span class="nc" id="L923">                    long start = System.currentTimeMillis();</span>
<span class="nc" id="L924">                    super.runTask(task);</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                    if(LOG_STARTUP_PERFORMANCE)</span>
<span class="nc" id="L926">                        LOGGER.info(String.format(&quot;Took %dms for %s by %s&quot;,</span>
<span class="nc" id="L927">                                System.currentTimeMillis()-start, taskName, name));</span>
<span class="nc" id="L928">                } finally {</span>
<span class="nc" id="L929">                    t.setName(name);</span>
<span class="nc" id="L930">                    SecurityContextHolder.clearContext();</span>
<span class="nc" id="L931">                }</span>
<span class="nc" id="L932">            }</span>
        };

<span class="nc" id="L935">        new InitReactorRunner() {</span>
            @Override
            protected void onInitMilestoneAttained(InitMilestone milestone) {
<span class="nc" id="L938">                initLevel = milestone;</span>
<span class="nc" id="L939">            }</span>
<span class="nc" id="L940">        }.run(reactor);</span>
<span class="nc" id="L941">    }</span>


    public TcpSlaveAgentListener getTcpSlaveAgentListener() {
<span class="nc" id="L945">        return tcpSlaveAgentListener;</span>
    }

    /**
     * Makes {@link AdjunctManager} URL-bound.
     * The dummy parameter allows us to use different URLs for the same adjunct,
     * for proper cache handling.
     */
    public AdjunctManager getAdjuncts(String dummy) {
<span class="nc" id="L954">        return adjuncts;</span>
    }

    @Exported
    public int getSlaveAgentPort() {
<span class="nc" id="L959">        return slaveAgentPort;</span>
    }

    /**
     * @param port
     *      0 to indicate random available TCP port. -1 to disable this service.
     */
    public void setSlaveAgentPort(int port) throws IOException {
<span class="nc" id="L967">        this.slaveAgentPort = port;</span>
<span class="nc" id="L968">        launchTcpSlaveAgentListener();</span>
<span class="nc" id="L969">    }</span>

    private void launchTcpSlaveAgentListener() throws IOException {
<span class="nc" id="L972">        synchronized(tcpSlaveAgentListenerLock) {</span>
            // shutdown previous agent if the port has changed
<span class="nc bnc" id="L974" title="All 4 branches missed.">            if (tcpSlaveAgentListener != null &amp;&amp; tcpSlaveAgentListener.configuredPort != slaveAgentPort) {</span>
<span class="nc" id="L975">                tcpSlaveAgentListener.shutdown();</span>
<span class="nc" id="L976">                tcpSlaveAgentListener = null;</span>
            }
<span class="nc bnc" id="L978" title="All 4 branches missed.">            if (slaveAgentPort != -1 &amp;&amp; tcpSlaveAgentListener == null) {</span>
<span class="nc" id="L979">                String administrativeMonitorId = getClass().getName() + &quot;.tcpBind&quot;;</span>
                try {
<span class="nc" id="L981">                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);</span>
                    // remove previous monitor in case of previous error
<span class="nc bnc" id="L983" title="All 2 branches missed.">                    for (Iterator&lt;AdministrativeMonitor&gt; it = AdministrativeMonitor.all().iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L984">                        AdministrativeMonitor am = it.next();</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">                        if (administrativeMonitorId.equals(am.id)) {</span>
<span class="nc" id="L986">                            it.remove();</span>
                        }
                    }
<span class="nc" id="L989">                } catch (BindException e) {</span>
<span class="nc" id="L990">                    new AdministrativeError(administrativeMonitorId,</span>
<span class="nc" id="L991">                            &quot;Failed to listen to incoming slave connection&quot;,</span>
<span class="nc" id="L992">                            &quot;Failed to listen to incoming slave connection. &lt;a href='configure'&gt;Change the port number&lt;/a&gt; to solve the problem.&quot;, e);</span>
                }
            }
        }
<span class="nc" id="L996">    }</span>

    public void setNodeName(String name) {
<span class="nc" id="L999">        throw new UnsupportedOperationException(); // not allowed</span>
    }

    public String getNodeDescription() {
<span class="nc" id="L1003">        return Messages.Hudson_NodeDescription();</span>
    }

    @Exported
    public String getDescription() {
<span class="nc" id="L1008">        return systemMessage;</span>
    }

    public PluginManager getPluginManager() {
<span class="nc" id="L1012">        return pluginManager;</span>
    }

    public UpdateCenter getUpdateCenter() {
<span class="nc" id="L1016">        return updateCenter;</span>
    }

    public boolean isUsageStatisticsCollected() {
<span class="nc bnc" id="L1020" title="All 4 branches missed.">        return noUsageStatistics==null || !noUsageStatistics;</span>
    }

    public void setNoUsageStatistics(Boolean noUsageStatistics) throws IOException {
<span class="nc" id="L1024">        this.noUsageStatistics = noUsageStatistics;</span>
<span class="nc" id="L1025">        save();</span>
<span class="nc" id="L1026">    }</span>

    public View.People getPeople() {
<span class="nc" id="L1029">        return new View.People(this);</span>
    }

    /**
     * @since 1.484
     */
    public View.AsynchPeople getAsynchPeople() {
<span class="nc" id="L1036">        return new View.AsynchPeople(this);</span>
    }

    /**
     * Does this {@link View} has any associated user information recorded?
     * @deprecated Potentially very expensive call; do not use from Jelly views.
     */
    @Deprecated
    public boolean hasPeople() {
<span class="nc" id="L1045">        return View.People.isApplicable(items.values());</span>
    }

    public Api getApi() {
<span class="nc" id="L1049">        return new Api(this);</span>
    }

    /**
     * Returns a secret key that survives across container start/stop.
     * &lt;p&gt;
     * This value is useful for implementing some of the security features.
     *
     * @deprecated
     *      Due to the past security advisory, this value should not be used any more to protect sensitive information.
     *      See {@link ConfidentialStore} and {@link ConfidentialKey} for how to store secrets.
     */
    @Deprecated
    public String getSecretKey() {
<span class="nc" id="L1063">        return secretKey;</span>
    }

    /**
     * Gets {@linkplain #getSecretKey() the secret key} as a key for AES-128.
     * @since 1.308
     * @deprecated
     *       See {@link #getSecretKey()}.
     */
    @Deprecated
    public SecretKey getSecretKeyAsAES128() {
<span class="nc" id="L1074">        return Util.toAes128Key(secretKey);</span>
    }

    /**
     * Returns the unique identifier of this Jenkins that has been historically used to identify
     * this Jenkins to the outside world.
     *
     * &lt;p&gt;
     * This form of identifier is weak in that it can be impersonated by others. See
     * https://wiki.jenkins-ci.org/display/JENKINS/Instance+Identity for more modern form of instance ID
     * that can be challenged and verified.
     *
     * @since 1.498
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public String getLegacyInstanceId() {
<span class="nc" id="L1090">        return Util.getDigestOf(getSecretKey());</span>
    }

    /**
     * Gets the SCM descriptor by name. Primarily used for making them web-visible.
     */
    public Descriptor&lt;SCM&gt; getScm(String shortClassName) {
<span class="nc" id="L1097">        return findDescriptor(shortClassName,SCM.all());</span>
    }

    /**
     * Gets the repository browser descriptor by name. Primarily used for making them web-visible.
     */
    public Descriptor&lt;RepositoryBrowser&lt;?&gt;&gt; getRepositoryBrowser(String shortClassName) {
<span class="nc" id="L1104">        return findDescriptor(shortClassName,RepositoryBrowser.all());</span>
    }

    /**
     * Gets the builder descriptor by name. Primarily used for making them web-visible.
     */
    public Descriptor&lt;Builder&gt; getBuilder(String shortClassName) {
<span class="nc" id="L1111">        return findDescriptor(shortClassName, Builder.all());</span>
    }

    /**
     * Gets the build wrapper descriptor by name. Primarily used for making them web-visible.
     */
    public Descriptor&lt;BuildWrapper&gt; getBuildWrapper(String shortClassName) {
<span class="nc" id="L1118">        return findDescriptor(shortClassName, BuildWrapper.all());</span>
    }

    /**
     * Gets the publisher descriptor by name. Primarily used for making them web-visible.
     */
    public Descriptor&lt;Publisher&gt; getPublisher(String shortClassName) {
<span class="nc" id="L1125">        return findDescriptor(shortClassName, Publisher.all());</span>
    }

    /**
     * Gets the trigger descriptor by name. Primarily used for making them web-visible.
     */
    public TriggerDescriptor getTrigger(String shortClassName) {
<span class="nc" id="L1132">        return (TriggerDescriptor) findDescriptor(shortClassName, Trigger.all());</span>
    }

    /**
     * Gets the retention strategy descriptor by name. Primarily used for making them web-visible.
     */
    public Descriptor&lt;RetentionStrategy&lt;?&gt;&gt; getRetentionStrategy(String shortClassName) {
<span class="nc" id="L1139">        return findDescriptor(shortClassName, RetentionStrategy.all());</span>
    }

    /**
     * Gets the {@link JobPropertyDescriptor} by name. Primarily used for making them web-visible.
     */
    public JobPropertyDescriptor getJobProperty(String shortClassName) {
        // combining these two lines triggers javac bug. See issue #610.
<span class="nc" id="L1147">        Descriptor d = findDescriptor(shortClassName, JobPropertyDescriptor.all());</span>
<span class="nc" id="L1148">        return (JobPropertyDescriptor) d;</span>
    }

    /**
     * @deprecated
     *      UI method. Not meant to be used programatically.
     */
    @Deprecated
    public ComputerSet getComputer() {
<span class="nc" id="L1157">        return new ComputerSet();</span>
    }

    /**
     * Exposes {@link Descriptor} by its name to URL.
     *
     * After doing all the {@code getXXX(shortClassName)} methods, I finally realized that
     * this just doesn't scale.
     *
     * @param id
     *      Either {@link Descriptor#getId()} (recommended) or the short name of a {@link Describable} subtype (for compatibility)
     * @throws IllegalArgumentException if a short name was passed which matches multiple IDs (fail fast)
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;}) // too late to fix
    public Descriptor getDescriptor(String id) {
        // legacy descriptors that are reigstered manually doesn't show up in getExtensionList, so check them explicitly.
<span class="nc" id="L1173">        Iterable&lt;Descriptor&gt; descriptors = Iterators.sequence(getExtensionList(Descriptor.class), DescriptorExtensionList.listLegacyInstances());</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        for (Descriptor d : descriptors) {</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">            if (d.getId().equals(id)) {</span>
<span class="nc" id="L1176">                return d;</span>
            }
        }
<span class="nc" id="L1179">        Descriptor candidate = null;</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">        for (Descriptor d : descriptors) {</span>
<span class="nc" id="L1181">            String name = d.getId();</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">            if (name.substring(name.lastIndexOf('.') + 1).equals(id)) {</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">                if (candidate == null) {</span>
<span class="nc" id="L1184">                    candidate = d;</span>
<span class="nc" id="L1185">                } else {</span>
<span class="nc" id="L1186">                    throw new IllegalArgumentException(id + &quot; is ambiguous; matches both &quot; + name + &quot; and &quot; + candidate.getId());</span>
                }
            }
        }
<span class="nc" id="L1190">        return candidate;</span>
    }

    /**
     * Alias for {@link #getDescriptor(String)}.
     */
    public Descriptor getDescriptorByName(String id) {
<span class="nc" id="L1197">        return getDescriptor(id);</span>
    }

    /**
     * Gets the {@link Descriptor} that corresponds to the given {@link Describable} type.
     * &lt;p&gt;
     * If you have an instance of {@code type} and call {@link Describable#getDescriptor()},
     * you'll get the same instance that this method returns.
     */
    public Descriptor getDescriptor(Class&lt;? extends Describable&gt; type) {
<span class="nc bnc" id="L1207" title="All 2 branches missed.">        for( Descriptor d : getExtensionList(Descriptor.class) )</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">            if(d.clazz==type)</span>
<span class="nc" id="L1209">                return d;</span>
<span class="nc" id="L1210">        return null;</span>
    }

    /**
     * Works just like {@link #getDescriptor(Class)} but don't take no for an answer.
     *
     * @throws AssertionError
     *      If the descriptor is missing.
     * @since 1.326
     */
    public Descriptor getDescriptorOrDie(Class&lt;? extends Describable&gt; type) {
<span class="nc" id="L1221">        Descriptor d = getDescriptor(type);</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">        if (d==null)</span>
<span class="nc" id="L1223">            throw new AssertionError(type+&quot; is missing its descriptor&quot;);</span>
<span class="nc" id="L1224">        return d;</span>
    }

    /**
     * Gets the {@link Descriptor} instance in the current Jenkins by its type.
     */
    public &lt;T extends Descriptor&gt; T getDescriptorByType(Class&lt;T&gt; type) {
<span class="nc bnc" id="L1231" title="All 2 branches missed.">        for( Descriptor d : getExtensionList(Descriptor.class) )</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">            if(d.getClass()==type)</span>
<span class="nc" id="L1233">                return type.cast(d);</span>
<span class="nc" id="L1234">        return null;</span>
    }

    /**
     * Gets the {@link SecurityRealm} descriptors by name. Primarily used for making them web-visible.
     */
    public Descriptor&lt;SecurityRealm&gt; getSecurityRealms(String shortClassName) {
<span class="nc" id="L1241">        return findDescriptor(shortClassName,SecurityRealm.all());</span>
    }

    /**
     * Finds a descriptor that has the specified name.
     */
    private &lt;T extends Describable&lt;T&gt;&gt;
    Descriptor&lt;T&gt; findDescriptor(String shortClassName, Collection&lt;? extends Descriptor&lt;T&gt;&gt; descriptors) {
<span class="nc" id="L1249">        String name = '.'+shortClassName;</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">        for (Descriptor&lt;T&gt; d : descriptors) {</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">            if(d.clazz.getName().endsWith(name))</span>
<span class="nc" id="L1252">                return d;</span>
        }
<span class="nc" id="L1254">        return null;</span>
    }

    protected void updateComputerList() {
<span class="nc" id="L1258">        updateComputerList(AUTOMATIC_SLAVE_LAUNCH);</span>
<span class="nc" id="L1259">    }</span>

    /** @deprecated Use {@link SCMListener#all} instead. */
    @Deprecated
    public CopyOnWriteList&lt;SCMListener&gt; getSCMListeners() {
<span class="nc" id="L1264">        return scmListeners;</span>
    }

    /**
     * Gets the plugin object from its short name.
     *
     * &lt;p&gt;
     * This allows URL &lt;tt&gt;hudson/plugin/ID&lt;/tt&gt; to be served by the views
     * of the plugin class.
     */
    public Plugin getPlugin(String shortName) {
<span class="nc" id="L1275">        PluginWrapper p = pluginManager.getPlugin(shortName);</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">        if(p==null)     return null;</span>
<span class="nc" id="L1277">        return p.getPlugin();</span>
    }

    /**
     * Gets the plugin object from its class.
     *
     * &lt;p&gt;
     * This allows easy storage of plugin information in the plugin singleton without
     * every plugin reimplementing the singleton pattern.
     *
     * @param clazz The plugin class (beware class-loader fun, this will probably only work
     * from within the jpi that defines the plugin class, it may or may not work in other cases)
     *
     * @return The plugin instance.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;P extends Plugin&gt; P getPlugin(Class&lt;P&gt; clazz) {
<span class="nc" id="L1294">        PluginWrapper p = pluginManager.getPlugin(clazz);</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">        if(p==null)     return null;</span>
<span class="nc" id="L1296">        return (P) p.getPlugin();</span>
    }

    /**
     * Gets the plugin objects from their super-class.
     *
     * @param clazz The plugin class (beware class-loader fun)
     *
     * @return The plugin instances.
     */
    public &lt;P extends Plugin&gt; List&lt;P&gt; getPlugins(Class&lt;P&gt; clazz) {
<span class="nc" id="L1307">        List&lt;P&gt; result = new ArrayList&lt;P&gt;();</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">        for (PluginWrapper w: pluginManager.getPlugins(clazz)) {</span>
<span class="nc" id="L1309">            result.add((P)w.getPlugin());</span>
        }
<span class="nc" id="L1311">        return Collections.unmodifiableList(result);</span>
    }

    /**
     * Synonym for {@link #getDescription}.
     */
    public String getSystemMessage() {
<span class="nc" id="L1318">        return systemMessage;</span>
    }

    /**
     * Gets the markup formatter used in the system.
     *
     * @return
     *      never null.
     * @since 1.391
     */
    public @Nonnull MarkupFormatter getMarkupFormatter() {
<span class="nc" id="L1329">        MarkupFormatter f = markupFormatter;</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">        return f != null ? f : new EscapedMarkupFormatter();</span>
    }

    /**
     * Sets the markup formatter used in the system globally.
     *
     * @since 1.391
     */
    public void setMarkupFormatter(MarkupFormatter f) {
<span class="nc" id="L1339">        this.markupFormatter = f;</span>
<span class="nc" id="L1340">    }</span>

    /**
     * Sets the system message.
     */
    public void setSystemMessage(String message) throws IOException {
<span class="nc" id="L1346">        this.systemMessage = message;</span>
<span class="nc" id="L1347">        save();</span>
<span class="nc" id="L1348">    }</span>

    public FederatedLoginService getFederatedLoginService(String name) {
<span class="nc bnc" id="L1351" title="All 2 branches missed.">        for (FederatedLoginService fls : FederatedLoginService.all()) {</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">            if (fls.getUrlName().equals(name))</span>
<span class="nc" id="L1353">                return fls;</span>
        }
<span class="nc" id="L1355">        return null;</span>
    }

    public List&lt;FederatedLoginService&gt; getFederatedLoginServices() {
<span class="nc" id="L1359">        return FederatedLoginService.all();</span>
    }

    public Launcher createLauncher(TaskListener listener) {
<span class="nc" id="L1363">        return new LocalLauncher(listener).decorateFor(this);</span>
    }


    public String getFullName() {
<span class="nc" id="L1368">        return &quot;&quot;;</span>
    }

    public String getFullDisplayName() {
<span class="nc" id="L1372">        return &quot;&quot;;</span>
    }

    /**
     * Returns the transient {@link Action}s associated with the top page.
     *
     * &lt;p&gt;
     * Adding {@link Action} is primarily useful for plugins to contribute
     * an item to the navigation bar of the top page. See existing {@link Action}
     * implementation for it affects the GUI.
     *
     * &lt;p&gt;
     * To register an {@link Action}, implement {@link RootAction} extension point, or write code like
     * {@code Jenkins.getInstance().getActions().add(...)}.
     *
     * @return
     *      Live list where the changes can be made. Can be empty but never null.
     * @since 1.172
     */
    public List&lt;Action&gt; getActions() {
<span class="nc" id="L1392">        return actions;</span>
    }

    /**
     * Gets just the immediate children of {@link Jenkins}.
     *
     * @see #getAllItems(Class)
     */
    @Exported(name=&quot;jobs&quot;)
    public List&lt;TopLevelItem&gt; getItems() {
<span class="nc bnc" id="L1402" title="All 2 branches missed.">		if (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">			authorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {</span>
<span class="nc" id="L1404">			return new ArrayList(items.values());</span>
		}

<span class="nc" id="L1407">        List&lt;TopLevelItem&gt; viewableItems = new ArrayList&lt;TopLevelItem&gt;();</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">        for (TopLevelItem item : items.values()) {</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">            if (item.hasPermission(Item.READ))</span>
<span class="nc" id="L1410">                viewableItems.add(item);</span>
        }

<span class="nc" id="L1413">        return viewableItems;</span>
    }

    /**
     * Returns the read-only view of all the {@link TopLevelItem}s keyed by their names.
     * &lt;p&gt;
     * This method is efficient, as it doesn't involve any copying.
     *
     * @since 1.296
     */
    public Map&lt;String,TopLevelItem&gt; getItemMap() {
<span class="nc" id="L1424">        return Collections.unmodifiableMap(items);</span>
    }

    /**
     * Gets just the immediate children of {@link Jenkins} but of the given type.
     */
    public &lt;T&gt; List&lt;T&gt; getItems(Class&lt;T&gt; type) {
<span class="nc" id="L1431">        List&lt;T&gt; r = new ArrayList&lt;T&gt;();</span>
<span class="nc bnc" id="L1432" title="All 2 branches missed.">        for (TopLevelItem i : getItems())</span>
<span class="nc bnc" id="L1433" title="All 2 branches missed.">            if (type.isInstance(i))</span>
<span class="nc" id="L1434">                 r.add(type.cast(i));</span>
<span class="nc" id="L1435">        return r;</span>
    }

    /**
     * Gets all the {@link Item}s recursively in the {@link ItemGroup} tree
     * and filter them by the given type.
     */
    public &lt;T extends Item&gt; List&lt;T&gt; getAllItems(Class&lt;T&gt; type) {
<span class="nc" id="L1443">        return Items.getAllItems(this, type);</span>
    }

    /**
     * Gets all the items recursively.
     *
     * @since 1.402
     */
    public List&lt;Item&gt; getAllItems() {
<span class="nc" id="L1452">        return getAllItems(Item.class);</span>
    }

    /**
     * Gets a list of simple top-level projects.
     * @deprecated This method will ignore Maven and matrix projects, as well as projects inside containers such as folders.
     * You may prefer to call {@link #getAllItems(Class)} on {@link AbstractProject},
     * perhaps also using {@link Util#createSubList} to consider only {@link TopLevelItem}s.
     * (That will also consider the caller's permissions.)
     * If you really want to get just {@link Project}s at top level, ignoring permissions,
     * you can filter the values from {@link #getItemMap} using {@link Util#createSubList}.
     */
    @Deprecated
    public List&lt;Project&gt; getProjects() {
<span class="nc" id="L1466">        return Util.createSubList(items.values(),Project.class);</span>
    }

    /**
     * Gets the names of all the {@link Job}s.
     */
    public Collection&lt;String&gt; getJobNames() {
<span class="nc" id="L1473">        List&lt;String&gt; names = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">        for (Job j : getAllItems(Job.class))</span>
<span class="nc" id="L1475">            names.add(j.getFullName());</span>
<span class="nc" id="L1476">        return names;</span>
    }

    public List&lt;Action&gt; getViewActions() {
<span class="nc" id="L1480">        return getActions();</span>
    }

    /**
     * Gets the names of all the {@link TopLevelItem}s.
     */
    public Collection&lt;String&gt; getTopLevelItemNames() {
<span class="nc" id="L1487">        List&lt;String&gt; names = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L1488" title="All 2 branches missed.">        for (TopLevelItem j : items.values())</span>
<span class="nc" id="L1489">            names.add(j.getName());</span>
<span class="nc" id="L1490">        return names;</span>
    }

    public View getView(String name) {
<span class="nc" id="L1494">        return viewGroupMixIn.getView(name);</span>
    }

    /**
     * Gets the read-only list of all {@link View}s.
     */
    @Exported
    public Collection&lt;View&gt; getViews() {
<span class="nc" id="L1502">        return viewGroupMixIn.getViews();</span>
    }

    @Override
    public void addView(View v) throws IOException {
<span class="nc" id="L1507">        viewGroupMixIn.addView(v);</span>
<span class="nc" id="L1508">    }</span>

    public boolean canDelete(View view) {
<span class="nc" id="L1511">        return viewGroupMixIn.canDelete(view);</span>
    }

    public synchronized void deleteView(View view) throws IOException {
<span class="nc" id="L1515">        viewGroupMixIn.deleteView(view);</span>
<span class="nc" id="L1516">    }</span>

    public void onViewRenamed(View view, String oldName, String newName) {
<span class="nc" id="L1519">        viewGroupMixIn.onViewRenamed(view,oldName,newName);</span>
<span class="nc" id="L1520">    }</span>

    /**
     * Returns the primary {@link View} that renders the top-page of Jenkins.
     */
    @Exported
    public View getPrimaryView() {
<span class="nc" id="L1527">        return viewGroupMixIn.getPrimaryView();</span>
     }

    public void setPrimaryView(View v) {
<span class="nc" id="L1531">        this.primaryView = v.getViewName();</span>
<span class="nc" id="L1532">    }</span>

    public ViewsTabBar getViewsTabBar() {
<span class="nc" id="L1535">        return viewsTabBar;</span>
    }

    public void setViewsTabBar(ViewsTabBar viewsTabBar) {
<span class="nc" id="L1539">        this.viewsTabBar = viewsTabBar;</span>
<span class="nc" id="L1540">    }</span>

    public Jenkins getItemGroup() {
<span class="nc" id="L1543">        return this;</span>
   }

    public MyViewsTabBar getMyViewsTabBar() {
<span class="nc" id="L1547">        return myViewsTabBar;</span>
    }

    public void setMyViewsTabBar(MyViewsTabBar myViewsTabBar) {
<span class="nc" id="L1551">        this.myViewsTabBar = myViewsTabBar;</span>
<span class="nc" id="L1552">    }</span>

    /**
     * Returns true if the current running Jenkins is upgraded from a version earlier than the specified version.
     *
     * &lt;p&gt;
     * This method continues to return true until the system configuration is saved, at which point
     * {@link #version} will be overwritten and Jenkins forgets the upgrade history.
     *
     * &lt;p&gt;
     * To handle SNAPSHOTS correctly, pass in &quot;1.N.*&quot; to test if it's upgrading from the version
     * equal or younger than N. So say if you implement a feature in 1.301 and you want to check
     * if the installation upgraded from pre-1.301, pass in &quot;1.300.*&quot;
     *
     * @since 1.301
     */
    public boolean isUpgradedFromBefore(VersionNumber v) {
        try {
<span class="nc" id="L1570">            return new VersionNumber(version).isOlderThan(v);</span>
<span class="nc" id="L1571">        } catch (IllegalArgumentException e) {</span>
            // fail to parse this version number
<span class="nc" id="L1573">            return false;</span>
        }
    }

    /**
     * Gets the read-only list of all {@link Computer}s.
     */
    public Computer[] getComputers() {
<span class="nc" id="L1581">        Computer[] r = computers.values().toArray(new Computer[computers.size()]);</span>
<span class="nc" id="L1582">        Arrays.sort(r,new Comparator&lt;Computer&gt;() {</span>
            @Override public int compare(Computer lhs, Computer rhs) {
<span class="nc bnc" id="L1584" title="All 2 branches missed.">                if(lhs.getNode()==Jenkins.this)  return -1;</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">                if(rhs.getNode()==Jenkins.this)  return 1;</span>
<span class="nc" id="L1586">                return lhs.getName().compareTo(rhs.getName());</span>
            }
        });
<span class="nc" id="L1589">        return r;</span>
    }

    @CLIResolver
    public @CheckForNull Computer getComputer(@Argument(required=true,metaVar=&quot;NAME&quot;,usage=&quot;Node name&quot;) @Nonnull String name) {
<span class="nc bnc" id="L1594" title="All 2 branches missed.">        if(name.equals(&quot;(master)&quot;))</span>
<span class="nc" id="L1595">            name = &quot;&quot;;</span>

<span class="nc bnc" id="L1597" title="All 2 branches missed.">        for (Computer c : computers.values()) {</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">            if(c.getName().equals(name))</span>
<span class="nc" id="L1599">                return c;</span>
        }
<span class="nc" id="L1601">        return null;</span>
    }

    /**
     * Gets the label that exists on this system by the name.
     *
     * @return null if name is null.
     * @see Label#parseExpression(String) (String)
     */
    public Label getLabel(String expr) {
<span class="nc bnc" id="L1611" title="All 2 branches missed.">        if(expr==null)  return null;</span>
<span class="nc" id="L1612">        expr = hudson.util.QuotedStringTokenizer.unquote(expr);</span>
        while(true) {
<span class="nc" id="L1614">            Label l = labels.get(expr);</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">            if(l!=null)</span>
<span class="nc" id="L1616">                return l;</span>

            // non-existent
            try {
<span class="nc" id="L1620">                labels.putIfAbsent(expr,Label.parseExpression(expr));</span>
<span class="nc" id="L1621">            } catch (ANTLRException e) {</span>
                // laxly accept it as a single label atom for backward compatibility
<span class="nc" id="L1623">                return getLabelAtom(expr);</span>
            }
        }
    }

    /**
     * Returns the label atom of the given name.
     * @return non-null iff name is non-null
     */
    public @Nullable LabelAtom getLabelAtom(@CheckForNull String name) {
<span class="nc bnc" id="L1633" title="All 2 branches missed.">        if (name==null)  return null;</span>

<span class="nc" id="L1635">        while(true) {</span>
<span class="nc" id="L1636">            Label l = labels.get(name);</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">            if(l!=null)</span>
<span class="nc" id="L1638">                return (LabelAtom)l;</span>

            // non-existent
<span class="nc" id="L1641">            LabelAtom la = new LabelAtom(name);</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">            if (labels.putIfAbsent(name, la)==null)</span>
<span class="nc" id="L1643">                la.load();</span>
        }
    }

    /**
     * Gets all the active labels in the current system.
     */
    public Set&lt;Label&gt; getLabels() {
<span class="nc" id="L1651">        Set&lt;Label&gt; r = new TreeSet&lt;Label&gt;();</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">        for (Label l : labels.values()) {</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">            if(!l.isEmpty())</span>
<span class="nc" id="L1654">                r.add(l);</span>
        }
<span class="nc" id="L1656">        return r;</span>
    }

    public Set&lt;LabelAtom&gt; getLabelAtoms() {
<span class="nc" id="L1660">        Set&lt;LabelAtom&gt; r = new TreeSet&lt;LabelAtom&gt;();</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">        for (Label l : labels.values()) {</span>
<span class="nc bnc" id="L1662" title="All 4 branches missed.">            if(!l.isEmpty() &amp;&amp; l instanceof LabelAtom)</span>
<span class="nc" id="L1663">                r.add((LabelAtom)l);</span>
        }
<span class="nc" id="L1665">        return r;</span>
    }

    public Queue getQueue() {
<span class="nc" id="L1669">        return queue;</span>
    }

    @Override
    public String getDisplayName() {
<span class="nc" id="L1674">        return Messages.Hudson_DisplayName();</span>
    }

    public List&lt;JDK&gt; getJDKs() {
<span class="nc" id="L1678">        return jdks;</span>
    }

    /**
     * Replaces all JDK installations with those from the given collection.
     *
     * Use {@link hudson.model.JDK.DescriptorImpl#setInstallations(JDK...)} to
     * set JDK installations from external code.
     */
    @Restricted(NoExternalUse.class)
    public void setJDKs(Collection&lt;? extends JDK&gt; jdks) {
<span class="nc" id="L1689">        this.jdks = new ArrayList&lt;JDK&gt;(jdks);</span>
<span class="nc" id="L1690">    }</span>

    /**
     * Gets the JDK installation of the given name, or returns null.
     */
    public JDK getJDK(String name) {
<span class="nc bnc" id="L1696" title="All 2 branches missed.">        if(name==null) {</span>
            // if only one JDK is configured, &quot;default JDK&quot; should mean that JDK.
<span class="nc" id="L1698">            List&lt;JDK&gt; jdks = getJDKs();</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">            if(jdks.size()==1)  return jdks.get(0);</span>
<span class="nc" id="L1700">            return null;</span>
        }
<span class="nc bnc" id="L1702" title="All 2 branches missed.">        for (JDK j : getJDKs()) {</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">            if(j.getName().equals(name))</span>
<span class="nc" id="L1704">                return j;</span>
        }
<span class="nc" id="L1706">        return null;</span>
    }



    /**
     * Gets the slave node of the give name, hooked under this Jenkins.
     */
    public @CheckForNull Node getNode(String name) {
<span class="nc" id="L1715">        return nodes.getNode(name);</span>
    }

    /**
     * Gets a {@link Cloud} by {@link Cloud#name its name}, or null.
     */
    public Cloud getCloud(String name) {
<span class="nc" id="L1722">        return clouds.getByName(name);</span>
    }

    protected Map&lt;Node,Computer&gt; getComputerMap() {
<span class="nc" id="L1726">        return computers;</span>
    }

    /**
     * Returns all {@link Node}s in the system, excluding {@link Jenkins} instance itself which
     * represents the master.
     */
    public List&lt;Node&gt; getNodes() {
<span class="nc" id="L1734">        return nodes.getNodes();</span>
    }

    /**
     * Get the {@link Nodes} object that handles maintaining individual {@link Node}s.
     * @return The Nodes object.
     */
    @Restricted(NoExternalUse.class)
    public Nodes getNodesObject() {
        // TODO replace this with something better when we properly expose Nodes.
<span class="nc" id="L1744">        return nodes;</span>
    }

    /**
     * Adds one more {@link Node} to Jenkins.
     */
    public void addNode(Node n) throws IOException {
<span class="nc" id="L1751">        nodes.addNode(n);</span>
<span class="nc" id="L1752">    }</span>

    /**
     * Removes a {@link Node} from Jenkins.
     */
    public void removeNode(@Nonnull Node n) throws IOException {
<span class="nc" id="L1758">        nodes.removeNode(n);</span>
<span class="nc" id="L1759">    }</span>

    /**
     * Saves an existing {@link Node} on disk, called by {@link Node#save()}. This method is preferred in those cases
     * where you need to determine atomically that the node being saved is actually in the list of nodes.
     *
     * @param n the node to be updated.
     * @return {@code true}, if the node was updated. {@code false}, if the node was not in the list of nodes.
     * @throws IOException if the node could not be persisted.
     * @see Nodes#updateNode
     * @since 1.634
     */
    public boolean updateNode(Node n) throws IOException {
<span class="nc" id="L1772">        return nodes.updateNode(n);</span>
    }

    public void setNodes(final List&lt;? extends Node&gt; n) throws IOException {
<span class="nc" id="L1776">        nodes.setNodes(n);</span>
<span class="nc" id="L1777">    }</span>

    public DescribableList&lt;NodeProperty&lt;?&gt;, NodePropertyDescriptor&gt; getNodeProperties() {
<span class="nc" id="L1780">    	return nodeProperties;</span>
    }

    public DescribableList&lt;NodeProperty&lt;?&gt;, NodePropertyDescriptor&gt; getGlobalNodeProperties() {
<span class="nc" id="L1784">    	return globalNodeProperties;</span>
    }

    /**
     * Resets all labels and remove invalid ones.
     *
     * This should be called when the assumptions behind label cache computation changes,
     * but we also call this periodically to self-heal any data out-of-sync issue.
     */
    /*package*/ void trimLabels() {
<span class="nc bnc" id="L1794" title="All 2 branches missed.">        for (Iterator&lt;Label&gt; itr = labels.values().iterator(); itr.hasNext();) {</span>
<span class="nc" id="L1795">            Label l = itr.next();</span>
<span class="nc" id="L1796">            resetLabel(l);</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">            if(l.isEmpty())</span>
<span class="nc" id="L1798">                itr.remove();</span>
        }
<span class="nc" id="L1800">    }</span>

    /**
     * Binds {@link AdministrativeMonitor}s to URL.
     */
    public AdministrativeMonitor getAdministrativeMonitor(String id) {
<span class="nc bnc" id="L1806" title="All 2 branches missed.">        for (AdministrativeMonitor m : administrativeMonitors)</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">            if(m.id.equals(id))</span>
<span class="nc" id="L1808">                return m;</span>
<span class="nc" id="L1809">        return null;</span>
    }

    public NodeDescriptor getDescriptor() {
<span class="nc" id="L1813">        return DescriptorImpl.INSTANCE;</span>
    }

<span class="nc" id="L1816">    public static final class DescriptorImpl extends NodeDescriptor {</span>
        @Extension
<span class="nc" id="L1818">        public static final DescriptorImpl INSTANCE = new DescriptorImpl();</span>

        @Override
        public boolean isInstantiable() {
<span class="nc" id="L1822">            return false;</span>
        }

        public FormValidation doCheckNumExecutors(@QueryParameter String value) {
<span class="nc" id="L1826">            return FormValidation.validateNonNegativeInteger(value);</span>
        }

        public FormValidation doCheckRawBuildsDir(@QueryParameter String value) {
            // do essentially what expandVariablesForDirectory does, without an Item
<span class="nc" id="L1831">            String replacedValue = expandVariablesForDirectory(value,</span>
<span class="nc" id="L1832">                    &quot;doCheckRawBuildsDir-Marker:foo&quot;,</span>
<span class="nc" id="L1833">                    Jenkins.getInstance().getRootDir().getPath() + &quot;/jobs/doCheckRawBuildsDir-Marker$foo&quot;);</span>

<span class="nc" id="L1835">            File replacedFile = new File(replacedValue);</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">            if (!replacedFile.isAbsolute()) {</span>
<span class="nc" id="L1837">                return FormValidation.error(value + &quot; does not resolve to an absolute path&quot;);</span>
            }

<span class="nc bnc" id="L1840" title="All 2 branches missed.">            if (!replacedValue.contains(&quot;doCheckRawBuildsDir-Marker&quot;)) {</span>
<span class="nc" id="L1841">                return FormValidation.error(value + &quot; does not contain ${ITEM_FULL_NAME} or ${ITEM_ROOTDIR}, cannot distinguish between projects&quot;);</span>
            }

<span class="nc bnc" id="L1844" title="All 2 branches missed.">            if (replacedValue.contains(&quot;doCheckRawBuildsDir-Marker:foo&quot;)) {</span>
                // make sure platform can handle colon
                try {
<span class="nc" id="L1847">                    File tmp = File.createTempFile(&quot;Jenkins-doCheckRawBuildsDir&quot;, &quot;foo:bar&quot;);</span>
<span class="nc" id="L1848">                    tmp.delete();</span>
<span class="nc" id="L1849">                } catch (IOException e) {</span>
<span class="nc" id="L1850">                    return FormValidation.error(value + &quot; contains ${ITEM_FULLNAME} but your system does not support it (JENKINS-12251). Use ${ITEM_FULL_NAME} instead&quot;);</span>
                }
            }

<span class="nc" id="L1854">            File d = new File(replacedValue);</span>
<span class="nc bnc" id="L1855" title="All 2 branches missed.">            if (!d.isDirectory()) {</span>
                // if dir does not exist (almost guaranteed) need to make sure nearest existing ancestor can be written to
<span class="nc" id="L1857">                d = d.getParentFile();</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">                while (!d.exists()) {</span>
<span class="nc" id="L1859">                    d = d.getParentFile();</span>
                }
<span class="nc bnc" id="L1861" title="All 2 branches missed.">                if (!d.canWrite()) {</span>
<span class="nc" id="L1862">                    return FormValidation.error(value + &quot; does not exist and probably cannot be created&quot;);</span>
                }
            }

<span class="nc" id="L1866">            return FormValidation.ok();</span>
        }

        // to route /descriptor/FQCN/xxx to getDescriptor(FQCN).xxx
        public Object getDynamic(String token) {
<span class="nc" id="L1871">            return Jenkins.getInstance().getDescriptor(token);</span>
        }
    }

    /**
     * Gets the system default quiet period.
     */
    public int getQuietPeriod() {
<span class="nc bnc" id="L1879" title="All 2 branches missed.">        return quietPeriod!=null ? quietPeriod : 5;</span>
    }

    /**
     * Sets the global quiet period.
     *
     * @param quietPeriod
     *      null to the default value.
     */
    public void setQuietPeriod(Integer quietPeriod) throws IOException {
<span class="nc" id="L1889">        this.quietPeriod = quietPeriod;</span>
<span class="nc" id="L1890">        save();</span>
<span class="nc" id="L1891">    }</span>

    /**
     * Gets the global SCM check out retry count.
     */
    public int getScmCheckoutRetryCount() {
<span class="nc" id="L1897">        return scmCheckoutRetryCount;</span>
    }

    public void setScmCheckoutRetryCount(int scmCheckoutRetryCount) throws IOException {
<span class="nc" id="L1901">        this.scmCheckoutRetryCount = scmCheckoutRetryCount;</span>
<span class="nc" id="L1902">        save();</span>
<span class="nc" id="L1903">    }</span>

    @Override
    public String getSearchUrl() {
<span class="nc" id="L1907">        return &quot;&quot;;</span>
    }

    @Override
    public SearchIndexBuilder makeSearchIndex() {
<span class="nc" id="L1912">        return super.makeSearchIndex()</span>
<span class="nc" id="L1913">            .add(&quot;configure&quot;, &quot;config&quot;,&quot;configure&quot;)</span>
<span class="nc" id="L1914">            .add(&quot;manage&quot;)</span>
<span class="nc" id="L1915">            .add(&quot;log&quot;)</span>
<span class="nc" id="L1916">            .add(new CollectionSearchIndex&lt;TopLevelItem&gt;() {</span>
<span class="nc" id="L1917">                protected SearchItem get(String key) { return getItemByFullName(key, TopLevelItem.class); }</span>
<span class="nc" id="L1918">                protected Collection&lt;TopLevelItem&gt; all() { return getAllItems(TopLevelItem.class); }</span>
            })
<span class="nc" id="L1920">            .add(getPrimaryView().makeSearchIndex())</span>
<span class="nc" id="L1921">            .add(new CollectionSearchIndex() {// for computers</span>
<span class="nc" id="L1922">                protected Computer get(String key) { return getComputer(key); }</span>
<span class="nc" id="L1923">                protected Collection&lt;Computer&gt; all() { return computers.values(); }</span>
            })
<span class="nc" id="L1925">            .add(new CollectionSearchIndex() {// for users</span>
<span class="nc" id="L1926">                protected User get(String key) { return User.get(key,false); }</span>
<span class="nc" id="L1927">                protected Collection&lt;User&gt; all() { return User.getAll(); }</span>
            })
<span class="nc" id="L1929">            .add(new CollectionSearchIndex() {// for views</span>
<span class="nc" id="L1930">                protected View get(String key) { return getView(key); }</span>
<span class="nc" id="L1931">                protected Collection&lt;View&gt; all() { return views; }</span>
            });
    }

    public String getUrlChildPrefix() {
<span class="nc" id="L1936">        return &quot;job&quot;;</span>
    }

    /**
     * Gets the absolute URL of Jenkins, such as {@code http://localhost/jenkins/}.
     *
     * &lt;p&gt;
     * This method first tries to use the manually configured value, then
     * fall back to {@link #getRootUrlFromRequest}.
     * It is done in this order so that it can work correctly even in the face
     * of a reverse proxy.
     *
     * @return null if this parameter is not configured by the user and the calling thread is not in an HTTP request; otherwise the returned URL will always have the trailing {@code /}
     * @since 1.66
     * @see &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Hyperlinks+in+HTML&quot;&gt;Hyperlinks in HTML&lt;/a&gt;
     */
    public @Nullable String getRootUrl() {
<span class="nc" id="L1953">        String url = JenkinsLocationConfiguration.get().getUrl();</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">        if(url!=null) {</span>
<span class="nc" id="L1955">            return Util.ensureEndsWith(url,&quot;/&quot;);</span>
        }
<span class="nc" id="L1957">        StaplerRequest req = Stapler.getCurrentRequest();</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">        if(req!=null)</span>
<span class="nc" id="L1959">            return getRootUrlFromRequest();</span>
<span class="nc" id="L1960">        return null;</span>
    }

    /**
     * Is Jenkins running in HTTPS?
     *
     * Note that we can't really trust {@link StaplerRequest#isSecure()} because HTTPS might be terminated
     * in the reverse proxy.
     */
    public boolean isRootUrlSecure() {
<span class="nc" id="L1970">        String url = getRootUrl();</span>
<span class="nc bnc" id="L1971" title="All 4 branches missed.">        return url!=null &amp;&amp; url.startsWith(&quot;https&quot;);</span>
    }

    /**
     * Gets the absolute URL of Jenkins top page, such as {@code http://localhost/jenkins/}.
     *
     * &lt;p&gt;
     * Unlike {@link #getRootUrl()}, which uses the manually configured value,
     * this one uses the current request to reconstruct the URL. The benefit is
     * that this is immune to the configuration mistake (users often fail to set the root URL
     * correctly, especially when a migration is involved), but the downside
     * is that unless you are processing a request, this method doesn't work.
     *
     * &lt;p&gt;Please note that this will not work in all cases if Jenkins is running behind a
     * reverse proxy which has not been fully configured.
     * Specifically the {@code Host} and {@code X-Forwarded-Proto} headers must be set.
     * &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Running+Jenkins+behind+Apache&quot;&gt;Running Jenkins behind Apache&lt;/a&gt;
     * shows some examples of configuration.
     * @since 1.263
     */
    public @Nonnull String getRootUrlFromRequest() {
<span class="nc" id="L1992">        StaplerRequest req = Stapler.getCurrentRequest();</span>
<span class="nc bnc" id="L1993" title="All 2 branches missed.">        if (req == null) {</span>
<span class="nc" id="L1994">            throw new IllegalStateException(&quot;cannot call getRootUrlFromRequest from outside a request handling thread&quot;);</span>
        }
<span class="nc" id="L1996">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L1997">        String scheme = getXForwardedHeader(req, &quot;X-Forwarded-Proto&quot;, req.getScheme());</span>
<span class="nc" id="L1998">        buf.append(scheme).append(&quot;://&quot;);</span>
<span class="nc" id="L1999">        String host = getXForwardedHeader(req, &quot;X-Forwarded-Host&quot;, req.getServerName());</span>
<span class="nc" id="L2000">        int index = host.indexOf(':');</span>
<span class="nc" id="L2001">        int port = req.getServerPort();</span>
<span class="nc bnc" id="L2002" title="All 2 branches missed.">        if (index == -1) {</span>
            // Almost everyone else except Nginx put the host and port in separate headers
<span class="nc" id="L2004">            buf.append(host);</span>
<span class="nc" id="L2005">        } else {</span>
            // Nginx uses the same spec as for the Host header, i.e. hostanme:port
<span class="nc" id="L2007">            buf.append(host.substring(0, index));</span>
<span class="nc bnc" id="L2008" title="All 2 branches missed.">            if (index + 1 &lt; host.length()) {</span>
                try {
<span class="nc" id="L2010">                    port = Integer.parseInt(host.substring(index + 1));</span>
<span class="nc" id="L2011">                } catch (NumberFormatException e) {</span>
                    // ignore
                }
            }
            // but if a user has configured Nginx with an X-Forwarded-Port, that will win out.
        }
<span class="nc" id="L2017">        String forwardedPort = getXForwardedHeader(req, &quot;X-Forwarded-Port&quot;, null);</span>
<span class="nc bnc" id="L2018" title="All 2 branches missed.">        if (forwardedPort != null) {</span>
            try {
<span class="nc" id="L2020">                port = Integer.parseInt(forwardedPort);</span>
<span class="nc" id="L2021">            } catch (NumberFormatException e) {</span>
                // ignore
            }
        }
<span class="nc bnc" id="L2025" title="All 4 branches missed.">        if (port != (&quot;https&quot;.equals(scheme) ? 443 : 80)) {</span>
<span class="nc" id="L2026">            buf.append(':').append(port);</span>
        }
<span class="nc" id="L2028">        buf.append(req.getContextPath()).append('/');</span>
<span class="nc" id="L2029">        return buf.toString();</span>
    }

    /**
     * Gets the originating &quot;X-Forwarded-...&quot; header from the request. If there are multiple headers the originating
     * header is the first header. If the originating header contains a comma separated list, the originating entry
     * is the first one.
     * @param req the request
     * @param header the header name
     * @param defaultValue the value to return if the header is absent.
     * @return the originating entry of the header or the default value if the header was not present.
     */
    private static String getXForwardedHeader(StaplerRequest req, String header, String defaultValue) {
<span class="nc" id="L2042">        String value = req.getHeader(header);</span>
<span class="nc bnc" id="L2043" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L2044">            int index = value.indexOf(',');</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">            return index == -1 ? value.trim() : value.substring(0,index).trim();</span>
        }
<span class="nc" id="L2047">        return defaultValue;</span>
    }

    public File getRootDir() {
<span class="nc" id="L2051">        return root;</span>
    }

    public FilePath getWorkspaceFor(TopLevelItem item) {
<span class="nc bnc" id="L2055" title="All 2 branches missed.">        for (WorkspaceLocator l : WorkspaceLocator.all()) {</span>
<span class="nc" id="L2056">            FilePath workspace = l.locate(item, this);</span>
<span class="nc bnc" id="L2057" title="All 2 branches missed.">            if (workspace != null) {</span>
<span class="nc" id="L2058">                return workspace;</span>
            }
        }

<span class="nc" id="L2062">        return new FilePath(expandVariablesForDirectory(workspaceDir, item));</span>
    }

    public File getBuildDirFor(Job job) {
<span class="nc" id="L2066">        return expandVariablesForDirectory(buildsDir, job);</span>
    }

    private File expandVariablesForDirectory(String base, Item item) {
<span class="nc" id="L2070">        return new File(expandVariablesForDirectory(base, item.getFullName(), item.getRootDir().getPath()));</span>
    }

    @Restricted(NoExternalUse.class)
    static String expandVariablesForDirectory(String base, String itemFullName, String itemRootDir) {
<span class="nc" id="L2075">        return Util.replaceMacro(base, ImmutableMap.of(</span>
<span class="nc" id="L2076">                &quot;JENKINS_HOME&quot;, Jenkins.getInstance().getRootDir().getPath(),</span>
<span class="nc" id="L2077">                &quot;ITEM_ROOTDIR&quot;, itemRootDir,</span>
<span class="nc" id="L2078">                &quot;ITEM_FULLNAME&quot;, itemFullName,   // legacy, deprecated</span>
<span class="nc" id="L2079">                &quot;ITEM_FULL_NAME&quot;, itemFullName.replace(':','$'))); // safe, see JENKINS-12251</span>

    }

    public String getRawWorkspaceDir() {
<span class="nc" id="L2084">        return workspaceDir;</span>
    }

    public String getRawBuildsDir() {
<span class="nc" id="L2088">        return buildsDir;</span>
    }

    @Restricted(NoExternalUse.class)
    public void setRawBuildsDir(String buildsDir) {
<span class="nc" id="L2093">        this.buildsDir = buildsDir;</span>
<span class="nc" id="L2094">    }</span>

    @Override public @Nonnull FilePath getRootPath() {
<span class="nc" id="L2097">        return new FilePath(getRootDir());</span>
    }

    @Override
    public FilePath createPath(String absolutePath) {
<span class="nc" id="L2102">        return new FilePath((VirtualChannel)null,absolutePath);</span>
    }

    public ClockDifference getClockDifference() {
<span class="nc" id="L2106">        return ClockDifference.ZERO;</span>
    }

    @Override
    public Callable&lt;ClockDifference, IOException&gt; getClockDifferenceCallable() {
<span class="nc" id="L2111">        return new MasterToSlaveCallable&lt;ClockDifference, IOException&gt;() {</span>
            public ClockDifference call() throws IOException {
<span class="nc" id="L2113">                return new ClockDifference(0);</span>
            }
        };
    }

    /**
     * For binding {@link LogRecorderManager} to &quot;/log&quot;.
     * Everything below here is admin-only, so do the check here.
     */
    public LogRecorderManager getLog() {
<span class="nc" id="L2123">        checkPermission(ADMINISTER);</span>
<span class="nc" id="L2124">        return log;</span>
    }

    /**
     * A convenience method to check if there's some security
     * restrictions in place.
     */
    @Exported
    public boolean isUseSecurity() {
<span class="nc bnc" id="L2133" title="All 4 branches missed.">        return securityRealm!=SecurityRealm.NO_AUTHENTICATION || authorizationStrategy!=AuthorizationStrategy.UNSECURED;</span>
    }

    public boolean isUseProjectNamingStrategy(){
<span class="nc bnc" id="L2137" title="All 2 branches missed.">        return projectNamingStrategy != DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;</span>
    }

    /**
     * If true, all the POST requests to Jenkins would have to have crumb in it to protect
     * Jenkins from CSRF vulnerabilities.
     */
    @Exported
    public boolean isUseCrumbs() {
<span class="nc bnc" id="L2146" title="All 2 branches missed.">        return crumbIssuer!=null;</span>
    }

    /**
     * Returns the constant that captures the three basic security modes in Jenkins.
     */
    public SecurityMode getSecurity() {
        // fix the variable so that this code works under concurrent modification to securityRealm.
<span class="nc" id="L2154">        SecurityRealm realm = securityRealm;</span>

<span class="nc bnc" id="L2156" title="All 2 branches missed.">        if(realm==SecurityRealm.NO_AUTHENTICATION)</span>
<span class="nc" id="L2157">            return SecurityMode.UNSECURED;</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">        if(realm instanceof LegacySecurityRealm)</span>
<span class="nc" id="L2159">            return SecurityMode.LEGACY;</span>
<span class="nc" id="L2160">        return SecurityMode.SECURED;</span>
    }

    /**
     * @return
     *      never null.
     */
    public SecurityRealm getSecurityRealm() {
<span class="nc" id="L2168">        return securityRealm;</span>
    }

    public void setSecurityRealm(SecurityRealm securityRealm) {
<span class="nc bnc" id="L2172" title="All 2 branches missed.">        if(securityRealm==null)</span>
<span class="nc" id="L2173">            securityRealm= SecurityRealm.NO_AUTHENTICATION;</span>
<span class="nc" id="L2174">        this.useSecurity = true;</span>
<span class="nc bnc" id="L2175" title="All 2 branches missed.">        IdStrategy oldUserIdStrategy = this.securityRealm == null</span>
<span class="nc" id="L2176">                ? securityRealm.getUserIdStrategy() // don't trigger rekey on Jenkins load</span>
<span class="nc" id="L2177">                : this.securityRealm.getUserIdStrategy();</span>
<span class="nc" id="L2178">        this.securityRealm = securityRealm;</span>
        // reset the filters and proxies for the new SecurityRealm
        try {
<span class="nc" id="L2181">            HudsonFilter filter = HudsonFilter.get(servletContext);</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">            if (filter == null) {</span>
                // Fix for #3069: This filter is not necessarily initialized before the servlets.
                // when HudsonFilter does come back, it'll initialize itself.
<span class="nc" id="L2185">                LOGGER.fine(&quot;HudsonFilter has not yet been initialized: Can't perform security setup for now&quot;);</span>
<span class="nc" id="L2186">            } else {</span>
<span class="nc" id="L2187">                LOGGER.fine(&quot;HudsonFilter has been previously initialized: Setting security up&quot;);</span>
<span class="nc" id="L2188">                filter.reset(securityRealm);</span>
<span class="nc" id="L2189">                LOGGER.fine(&quot;Security is now fully set up&quot;);</span>
            }
<span class="nc bnc" id="L2191" title="All 2 branches missed.">            if (!oldUserIdStrategy.equals(this.securityRealm.getUserIdStrategy())) {</span>
<span class="nc" id="L2192">                User.rekey();</span>
            }
<span class="nc" id="L2194">        } catch (ServletException e) {</span>
            // for binary compatibility, this method cannot throw a checked exception
<span class="nc" id="L2196">            throw new AcegiSecurityException(&quot;Failed to configure filter&quot;,e) {};</span>
        }
<span class="nc" id="L2198">    }</span>

    public void setAuthorizationStrategy(AuthorizationStrategy a) {
<span class="nc bnc" id="L2201" title="All 2 branches missed.">        if (a == null)</span>
<span class="nc" id="L2202">            a = AuthorizationStrategy.UNSECURED;</span>
<span class="nc" id="L2203">        useSecurity = true;</span>
<span class="nc" id="L2204">        authorizationStrategy = a;</span>
<span class="nc" id="L2205">    }</span>

    public boolean isDisableRememberMe() {
<span class="nc" id="L2208">        return disableRememberMe;</span>
    }

    public void setDisableRememberMe(boolean disableRememberMe) {
<span class="nc" id="L2212">        this.disableRememberMe = disableRememberMe;</span>
<span class="nc" id="L2213">    }</span>

    public void disableSecurity() {
<span class="nc" id="L2216">        useSecurity = null;</span>
<span class="nc" id="L2217">        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);</span>
<span class="nc" id="L2218">        authorizationStrategy = AuthorizationStrategy.UNSECURED;</span>
<span class="nc" id="L2219">    }</span>

    public void setProjectNamingStrategy(ProjectNamingStrategy ns) {
<span class="nc bnc" id="L2222" title="All 2 branches missed.">        if(ns == null){</span>
<span class="nc" id="L2223">            ns = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;</span>
        }
<span class="nc" id="L2225">        projectNamingStrategy = ns;</span>
<span class="nc" id="L2226">    }</span>

    public Lifecycle getLifecycle() {
<span class="nc" id="L2229">        return Lifecycle.get();</span>
    }

    /**
     * Gets the dependency injection container that hosts all the extension implementations and other
     * components in Jenkins.
     *
     * @since 1.433
     */
    public Injector getInjector() {
<span class="nc" id="L2239">        return lookup(Injector.class);</span>
    }

    /**
     * Returns {@link ExtensionList} that retains the discovered instances for the given extension type.
     *
     * @param extensionType
     *      The base type that represents the extension point. Normally {@link ExtensionPoint} subtype
     *      but that's not a hard requirement.
     * @return
     *      Can be an empty list but never null.
     * @see ExtensionList#lookup
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    public &lt;T&gt; ExtensionList&lt;T&gt; getExtensionList(Class&lt;T&gt; extensionType) {
<span class="nc" id="L2254">        return extensionLists.get(extensionType);</span>
    }

    /**
     * Used to bind {@link ExtensionList}s to URLs.
     *
     * @since 1.349
     */
    public ExtensionList getExtensionList(String extensionType) throws ClassNotFoundException {
<span class="nc" id="L2263">        return getExtensionList(pluginManager.uberClassLoader.loadClass(extensionType));</span>
    }

    /**
     * Returns {@link ExtensionList} that retains the discovered {@link Descriptor} instances for the given
     * kind of {@link Describable}.
     *
     * @return
     *      Can be an empty list but never null.
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    public &lt;T extends Describable&lt;T&gt;,D extends Descriptor&lt;T&gt;&gt; DescriptorExtensionList&lt;T,D&gt; getDescriptorList(Class&lt;T&gt; type) {
<span class="nc" id="L2275">        return descriptorLists.get(type);</span>
    }

    /**
     * Refresh {@link ExtensionList}s by adding all the newly discovered extensions.
     *
     * Exposed only for {@link PluginManager#dynamicLoad(File)}.
     */
    public void refreshExtensions() throws ExtensionRefreshException {
<span class="nc" id="L2284">        ExtensionList&lt;ExtensionFinder&gt; finders = getExtensionList(ExtensionFinder.class);</span>
<span class="nc bnc" id="L2285" title="All 2 branches missed.">        for (ExtensionFinder ef : finders) {</span>
<span class="nc bnc" id="L2286" title="All 2 branches missed.">            if (!ef.isRefreshable())</span>
<span class="nc" id="L2287">                throw new ExtensionRefreshException(ef+&quot; doesn't support refresh&quot;);</span>
        }

<span class="nc" id="L2290">        List&lt;ExtensionComponentSet&gt; fragments = Lists.newArrayList();</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">        for (ExtensionFinder ef : finders) {</span>
<span class="nc" id="L2292">            fragments.add(ef.refresh());</span>
        }
<span class="nc" id="L2294">        ExtensionComponentSet delta = ExtensionComponentSet.union(fragments).filtered();</span>

        // if we find a new ExtensionFinder, we need it to list up all the extension points as well
<span class="nc" id="L2297">        List&lt;ExtensionComponent&lt;ExtensionFinder&gt;&gt; newFinders = Lists.newArrayList(delta.find(ExtensionFinder.class));</span>
<span class="nc bnc" id="L2298" title="All 2 branches missed.">        while (!newFinders.isEmpty()) {</span>
<span class="nc" id="L2299">            ExtensionFinder f = newFinders.remove(newFinders.size()-1).getInstance();</span>

<span class="nc" id="L2301">            ExtensionComponentSet ecs = ExtensionComponentSet.allOf(f).filtered();</span>
<span class="nc" id="L2302">            newFinders.addAll(ecs.find(ExtensionFinder.class));</span>
<span class="nc" id="L2303">            delta = ExtensionComponentSet.union(delta, ecs);</span>
        }

<span class="nc bnc" id="L2306" title="All 2 branches missed.">        for (ExtensionList el : extensionLists.values()) {</span>
<span class="nc" id="L2307">            el.refresh(delta);</span>
        }
<span class="nc bnc" id="L2309" title="All 2 branches missed.">        for (ExtensionList el : descriptorLists.values()) {</span>
<span class="nc" id="L2310">            el.refresh(delta);</span>
        }

        // TODO: we need some generalization here so that extension points can be notified when a refresh happens?
<span class="nc bnc" id="L2314" title="All 2 branches missed.">        for (ExtensionComponent&lt;RootAction&gt; ea : delta.find(RootAction.class)) {</span>
<span class="nc" id="L2315">            Action a = ea.getInstance();</span>
<span class="nc bnc" id="L2316" title="All 2 branches missed.">            if (!actions.contains(a)) actions.add(a);</span>
        }
<span class="nc" id="L2318">    }</span>

    /**
     * Returns the root {@link ACL}.
     *
     * @see AuthorizationStrategy#getRootACL()
     */
    @Override
    public ACL getACL() {
<span class="nc" id="L2327">        return authorizationStrategy.getRootACL();</span>
    }

    /**
     * @return
     *      never null.
     */
    public AuthorizationStrategy getAuthorizationStrategy() {
<span class="nc" id="L2335">        return authorizationStrategy;</span>
    }

    /**
     * The strategy used to check the project names.
     * @return never &lt;code&gt;null&lt;/code&gt;
     */
    public ProjectNamingStrategy getProjectNamingStrategy() {
<span class="nc bnc" id="L2343" title="All 2 branches missed.">        return projectNamingStrategy == null ? ProjectNamingStrategy.DEFAULT_NAMING_STRATEGY : projectNamingStrategy;</span>
    }

    /**
     * Returns true if Jenkins is quieting down.
     * &lt;p&gt;
     * No further jobs will be executed unless it
     * can be finished while other current pending builds
     * are still in progress.
     */
    @Exported
    public boolean isQuietingDown() {
<span class="nc" id="L2355">        return isQuietingDown;</span>
    }

    /**
     * Returns true if the container initiated the termination of the web application.
     */
    public boolean isTerminating() {
<span class="nc" id="L2362">        return terminating;</span>
    }

    /**
     * Gets the initialization milestone that we've already reached.
     *
     * @return
     *      {@link InitMilestone#STARTED} even if the initialization hasn't been started, so that this method
     *      never returns null.
     */
    public InitMilestone getInitLevel() {
<span class="nc" id="L2373">        return initLevel;</span>
    }

    public void setNumExecutors(int n) throws IOException {
<span class="nc bnc" id="L2377" title="All 2 branches missed.">        if (this.numExecutors != n) {</span>
<span class="nc" id="L2378">            this.numExecutors = n;</span>
<span class="nc" id="L2379">            updateComputerList();</span>
<span class="nc" id="L2380">            save();</span>
        }
<span class="nc" id="L2382">    }</span>



    /**
     * {@inheritDoc}.
     *
     * Note that the look up is case-insensitive.
     */
    @Override public TopLevelItem getItem(String name) throws AccessDeniedException {
<span class="nc bnc" id="L2392" title="All 2 branches missed.">        if (name==null)    return null;</span>
<span class="nc" id="L2393">    	TopLevelItem item = items.get(name);</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">        if (item==null)</span>
<span class="nc" id="L2395">            return null;</span>
<span class="nc bnc" id="L2396" title="All 2 branches missed.">        if (!item.hasPermission(Item.READ)) {</span>
<span class="nc bnc" id="L2397" title="All 2 branches missed.">            if (item.hasPermission(Item.DISCOVER)) {</span>
<span class="nc" id="L2398">                throw new AccessDeniedException(&quot;Please login to access job &quot; + name);</span>
            }
<span class="nc" id="L2400">            return null;</span>
        }
<span class="nc" id="L2402">        return item;</span>
    }

    /**
     * Gets the item by its path name from the given context
     *
     * &lt;h2&gt;Path Names&lt;/h2&gt;
     * &lt;p&gt;
     * If the name starts from '/', like &quot;/foo/bar/zot&quot;, then it's interpreted as absolute.
     * Otherwise, the name should be something like &quot;foo/bar&quot; and it's interpreted like
     * relative path name in the file system is, against the given context.
     * &lt;p&gt;For compatibility, as a fallback when nothing else matches, a simple path
     * like {@code foo/bar} can also be treated with {@link #getItemByFullName}.
     * @param context
     *      null is interpreted as {@link Jenkins}. Base 'directory' of the interpretation.
     * @since 1.406
     */
    public Item getItem(String pathName, ItemGroup context) {
<span class="nc bnc" id="L2420" title="All 2 branches missed.">        if (context==null)  context = this;</span>
<span class="nc bnc" id="L2421" title="All 2 branches missed.">        if (pathName==null) return null;</span>

<span class="nc bnc" id="L2423" title="All 2 branches missed.">        if (pathName.startsWith(&quot;/&quot;))   // absolute</span>
<span class="nc" id="L2424">            return getItemByFullName(pathName);</span>

<span class="nc" id="L2426">        Object/*Item|ItemGroup*/ ctx = context;</span>

<span class="nc" id="L2428">        StringTokenizer tokens = new StringTokenizer(pathName,&quot;/&quot;);</span>
<span class="nc bnc" id="L2429" title="All 2 branches missed.">        while (tokens.hasMoreTokens()) {</span>
<span class="nc" id="L2430">            String s = tokens.nextToken();</span>
<span class="nc bnc" id="L2431" title="All 2 branches missed.">            if (s.equals(&quot;..&quot;)) {</span>
<span class="nc bnc" id="L2432" title="All 2 branches missed.">                if (ctx instanceof Item) {</span>
<span class="nc" id="L2433">                    ctx = ((Item)ctx).getParent();</span>
<span class="nc" id="L2434">                    continue;</span>
                }

<span class="nc" id="L2437">                ctx=null;    // can't go up further</span>
<span class="nc" id="L2438">                break;</span>
            }
<span class="nc bnc" id="L2440" title="All 2 branches missed.">            if (s.equals(&quot;.&quot;)) {</span>
<span class="nc" id="L2441">                continue;</span>
            }

<span class="nc bnc" id="L2444" title="All 2 branches missed.">            if (ctx instanceof ItemGroup) {</span>
<span class="nc" id="L2445">                ItemGroup g = (ItemGroup) ctx;</span>
<span class="nc" id="L2446">                Item i = g.getItem(s);</span>
<span class="nc bnc" id="L2447" title="All 4 branches missed.">                if (i==null || !i.hasPermission(Item.READ)) { // TODO consider DISCOVER</span>
<span class="nc" id="L2448">                    ctx=null;    // can't go up further</span>
<span class="nc" id="L2449">                    break;</span>
                }
<span class="nc" id="L2451">                ctx=i;</span>
<span class="nc" id="L2452">            } else {</span>
<span class="nc" id="L2453">                return null;</span>
            }
        }

<span class="nc bnc" id="L2457" title="All 2 branches missed.">        if (ctx instanceof Item)</span>
<span class="nc" id="L2458">            return (Item)ctx;</span>

        // fall back to the classic interpretation
<span class="nc" id="L2461">        return getItemByFullName(pathName);</span>
    }

    public final Item getItem(String pathName, Item context) {
<span class="nc bnc" id="L2465" title="All 2 branches missed.">        return getItem(pathName,context!=null?context.getParent():null);</span>
    }

    public final &lt;T extends Item&gt; T getItem(String pathName, ItemGroup context, @Nonnull Class&lt;T&gt; type) {
<span class="nc" id="L2469">        Item r = getItem(pathName, context);</span>
<span class="nc bnc" id="L2470" title="All 2 branches missed.">        if (type.isInstance(r))</span>
<span class="nc" id="L2471">            return type.cast(r);</span>
<span class="nc" id="L2472">        return null;</span>
    }

    public final &lt;T extends Item&gt; T getItem(String pathName, Item context, Class&lt;T&gt; type) {
<span class="nc bnc" id="L2476" title="All 2 branches missed.">        return getItem(pathName,context!=null?context.getParent():null,type);</span>
    }

    public File getRootDirFor(TopLevelItem child) {
<span class="nc" id="L2480">        return getRootDirFor(child.getName());</span>
    }

    private File getRootDirFor(String name) {
<span class="nc" id="L2484">        return new File(new File(getRootDir(),&quot;jobs&quot;), name);</span>
    }

    /**
     * Gets the {@link Item} object by its full name.
     * Full names are like path names, where each name of {@link Item} is
     * combined by '/'.
     *
     * @return
     *      null if either such {@link Item} doesn't exist under the given full name,
     *      or it exists but it's no an instance of the given type.
     * @throws AccessDeniedException as per {@link ItemGroup#getItem}
     */
    public @CheckForNull &lt;T extends Item&gt; T getItemByFullName(String fullName, Class&lt;T&gt; type) throws AccessDeniedException {
<span class="nc" id="L2498">        StringTokenizer tokens = new StringTokenizer(fullName,&quot;/&quot;);</span>
<span class="nc" id="L2499">        ItemGroup parent = this;</span>

<span class="nc bnc" id="L2501" title="All 2 branches missed.">        if(!tokens.hasMoreTokens()) return null;    // for example, empty full name.</span>

<span class="nc" id="L2503">        while(true) {</span>
<span class="nc" id="L2504">            Item item = parent.getItem(tokens.nextToken());</span>
<span class="nc bnc" id="L2505" title="All 2 branches missed.">            if(!tokens.hasMoreTokens()) {</span>
<span class="nc bnc" id="L2506" title="All 2 branches missed.">                if(type.isInstance(item))</span>
<span class="nc" id="L2507">                    return type.cast(item);</span>
                else
<span class="nc" id="L2509">                    return null;</span>
            }

<span class="nc bnc" id="L2512" title="All 2 branches missed.">            if(!(item instanceof ItemGroup))</span>
<span class="nc" id="L2513">                return null;    // this item can't have any children</span>

<span class="nc bnc" id="L2515" title="All 2 branches missed.">            if (!item.hasPermission(Item.READ))</span>
<span class="nc" id="L2516">                return null; // TODO consider DISCOVER</span>

<span class="nc" id="L2518">            parent = (ItemGroup) item;</span>
        }
    }

    public @CheckForNull Item getItemByFullName(String fullName) {
<span class="nc" id="L2523">        return getItemByFullName(fullName,Item.class);</span>
    }

    /**
     * Gets the user of the given name.
     *
     * @return the user of the given name, if that person exists or the invoker {@link #hasPermission} on {@link #ADMINISTER}; else null
     * @see User#get(String,boolean)
     */
    public @CheckForNull User getUser(String name) {
<span class="nc" id="L2533">        return User.get(name,hasPermission(ADMINISTER));</span>
    }

    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name ) throws IOException {
<span class="nc" id="L2537">        return createProject(type, name, true);</span>
    }

    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name, boolean notify ) throws IOException {
<span class="nc" id="L2541">        return itemGroupMixIn.createProject(type,name,notify);</span>
    }

    /**
     * Overwrites the existing item by new one.
     *
     * &lt;p&gt;
     * This is a short cut for deleting an existing job and adding a new one.
     */
    public synchronized void putItem(TopLevelItem item) throws IOException, InterruptedException {
<span class="nc" id="L2551">        String name = item.getName();</span>
<span class="nc" id="L2552">        TopLevelItem old = items.get(name);</span>
<span class="nc bnc" id="L2553" title="All 2 branches missed.">        if (old ==item)  return; // noop</span>

<span class="nc" id="L2555">        checkPermission(Item.CREATE);</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">        if (old!=null)</span>
<span class="nc" id="L2557">            old.delete();</span>
<span class="nc" id="L2558">        items.put(name,item);</span>
<span class="nc" id="L2559">        ItemListener.fireOnCreated(item);</span>
<span class="nc" id="L2560">    }</span>

    /**
     * Creates a new job.
     *
     * &lt;p&gt;
     * This version infers the descriptor from the type of the top-level item.
     *
     * @throws IllegalArgumentException
     *      if the project of the given name already exists.
     */
    public synchronized &lt;T extends TopLevelItem&gt; T createProject( Class&lt;T&gt; type, String name ) throws IOException {
<span class="nc" id="L2572">        return type.cast(createProject((TopLevelItemDescriptor)getDescriptor(type),name));</span>
    }

    /**
     * Called by {@link Job#renameTo(String)} to update relevant data structure.
     * assumed to be synchronized on Jenkins by the caller.
     */
    public void onRenamed(TopLevelItem job, String oldName, String newName) throws IOException {
<span class="nc" id="L2580">        items.remove(oldName);</span>
<span class="nc" id="L2581">        items.put(newName,job);</span>

        // For compatibility with old views:
<span class="nc bnc" id="L2584" title="All 2 branches missed.">        for (View v : views)</span>
<span class="nc" id="L2585">            v.onJobRenamed(job, oldName, newName);</span>
<span class="nc" id="L2586">    }</span>

    /**
     * Called in response to {@link Job#doDoDelete(StaplerRequest, StaplerResponse)}
     */
    public void onDeleted(TopLevelItem item) throws IOException {
<span class="nc" id="L2592">        ItemListener.fireOnDeleted(item);</span>

<span class="nc" id="L2594">        items.remove(item.getName());</span>
        // For compatibility with old views:
<span class="nc bnc" id="L2596" title="All 2 branches missed.">        for (View v : views)</span>
<span class="nc" id="L2597">            v.onJobRenamed(item, item.getName(), null);</span>
<span class="nc" id="L2598">    }</span>

    @Override public boolean canAdd(TopLevelItem item) {
<span class="nc" id="L2601">        return true;</span>
    }

    @Override synchronized public &lt;I extends TopLevelItem&gt; I add(I item, String name) throws IOException, IllegalArgumentException {
<span class="nc bnc" id="L2605" title="All 2 branches missed.">        if (items.containsKey(name)) {</span>
<span class="nc" id="L2606">            throw new IllegalArgumentException(&quot;already an item '&quot; + name + &quot;'&quot;);</span>
        }
<span class="nc" id="L2608">        items.put(name, item);</span>
<span class="nc" id="L2609">        return item;</span>
    }

    @Override public void remove(TopLevelItem item) throws IOException, IllegalArgumentException {
<span class="nc" id="L2613">        items.remove(item.getName());</span>
<span class="nc" id="L2614">    }</span>

    public FingerprintMap getFingerprintMap() {
<span class="nc" id="L2617">        return fingerprintMap;</span>
    }

    // if no finger print matches, display &quot;not found page&quot;.
    public Object getFingerprint( String md5sum ) throws IOException {
<span class="nc" id="L2622">        Fingerprint r = fingerprintMap.get(md5sum);</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">        if(r==null)     return new NoFingerprintMatch(md5sum);</span>
<span class="nc" id="L2624">        else            return r;</span>
    }

    /**
     * Gets a {@link Fingerprint} object if it exists.
     * Otherwise null.
     */
    public Fingerprint _getFingerprint( String md5sum ) throws IOException {
<span class="nc" id="L2632">        return fingerprintMap.get(md5sum);</span>
    }

    /**
     * The file we save our configuration.
     */
    private XmlFile getConfigFile() {
<span class="nc" id="L2639">        return new XmlFile(XSTREAM, new File(root,&quot;config.xml&quot;));</span>
    }

    public int getNumExecutors() {
<span class="nc" id="L2643">        return numExecutors;</span>
    }

    public Mode getMode() {
<span class="nc" id="L2647">        return mode;</span>
    }

    public void setMode(Mode m) throws IOException {
<span class="nc" id="L2651">        this.mode = m;</span>
<span class="nc" id="L2652">        save();</span>
<span class="nc" id="L2653">    }</span>

    public String getLabelString() {
<span class="nc" id="L2656">        return fixNull(label).trim();</span>
    }

    @Override
    public void setLabelString(String label) throws IOException {
<span class="nc" id="L2661">        this.label = label;</span>
<span class="nc" id="L2662">        save();</span>
<span class="nc" id="L2663">    }</span>

    @Override
    public LabelAtom getSelfLabel() {
<span class="nc" id="L2667">        return getLabelAtom(&quot;master&quot;);</span>
    }

    public Computer createComputer() {
<span class="nc" id="L2671">        return new Hudson.MasterComputer();</span>
    }

    private synchronized TaskBuilder loadTasks() throws IOException {
<span class="nc" id="L2675">        File projectsDir = new File(root,&quot;jobs&quot;);</span>
<span class="nc bnc" id="L2676" title="All 4 branches missed.">        if(!projectsDir.getCanonicalFile().isDirectory() &amp;&amp; !projectsDir.mkdirs()) {</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">            if(projectsDir.exists())</span>
<span class="nc" id="L2678">                throw new IOException(projectsDir+&quot; is not a directory&quot;);</span>
<span class="nc" id="L2679">            throw new IOException(&quot;Unable to create &quot;+projectsDir+&quot;\nPermission issue? Please create this directory manually.&quot;);</span>
        }
<span class="nc" id="L2681">        File[] subdirs = projectsDir.listFiles();</span>

<span class="nc" id="L2683">        final Set&lt;String&gt; loadedNames = Collections.synchronizedSet(new HashSet&lt;String&gt;());</span>

<span class="nc" id="L2685">        TaskGraphBuilder g = new TaskGraphBuilder();</span>
<span class="nc" id="L2686">        Handle loadJenkins = g.requires(EXTENSIONS_AUGMENTED).attains(JOB_LOADED).add(&quot;Loading global config&quot;, new Executable() {</span>
            public void run(Reactor session) throws Exception {
<span class="nc" id="L2688">                XmlFile cfg = getConfigFile();</span>
<span class="nc bnc" id="L2689" title="All 2 branches missed.">                if (cfg.exists()) {</span>
                    // reset some data that may not exist in the disk file
                    // so that we can take a proper compensation action later.
<span class="nc" id="L2692">                    primaryView = null;</span>
<span class="nc" id="L2693">                    views.clear();</span>

                    // load from disk
<span class="nc" id="L2696">                    cfg.unmarshal(Jenkins.this);</span>
                }

                // if we are loading old data that doesn't have this field
<span class="nc bnc" id="L2700" title="All 6 branches missed.">                if (slaves != null &amp;&amp; !slaves.isEmpty() &amp;&amp; nodes.isLegacy()) {</span>
<span class="nc" id="L2701">                    nodes.setNodes(slaves);</span>
<span class="nc" id="L2702">                    slaves = null;</span>
<span class="nc" id="L2703">                } else {</span>
<span class="nc" id="L2704">                    nodes.load();</span>
                }

<span class="nc" id="L2707">                clouds.setOwner(Jenkins.this);</span>
<span class="nc" id="L2708">            }</span>
        });

<span class="nc bnc" id="L2711" title="All 2 branches missed.">        for (final File subdir : subdirs) {</span>
<span class="nc" id="L2712">            g.requires(loadJenkins).attains(JOB_LOADED).notFatal().add(&quot;Loading job &quot;+subdir.getName(),new Executable() {</span>
                public void run(Reactor session) throws Exception {
<span class="nc bnc" id="L2714" title="All 2 branches missed.">                    if(!Items.getConfigFile(subdir).exists()) {</span>
                        //Does not have job config file, so it is not a jenkins job hence skip it
<span class="nc" id="L2716">                        return;</span>
                    }
<span class="nc" id="L2718">                    TopLevelItem item = (TopLevelItem) Items.load(Jenkins.this, subdir);</span>
<span class="nc" id="L2719">                    items.put(item.getName(), item);</span>
<span class="nc" id="L2720">                    loadedNames.add(item.getName());</span>
<span class="nc" id="L2721">                }</span>
            });
        }

<span class="nc" id="L2725">        g.requires(JOB_LOADED).add(&quot;Cleaning up old builds&quot;,new Executable() {</span>
            public void run(Reactor reactor) throws Exception {
                // anything we didn't load from disk, throw them away.
                // doing this after loading from disk allows newly loaded items
                // to inspect what already existed in memory (in case of reloading)

                // retainAll doesn't work well because of CopyOnWriteMap implementation, so remove one by one
                // hopefully there shouldn't be too many of them.
<span class="nc bnc" id="L2733" title="All 2 branches missed.">                for (String name : items.keySet()) {</span>
<span class="nc bnc" id="L2734" title="All 2 branches missed.">                    if (!loadedNames.contains(name))</span>
<span class="nc" id="L2735">                        items.remove(name);</span>
                }
<span class="nc" id="L2737">            }</span>
        });

<span class="nc" id="L2740">        g.requires(JOB_LOADED).add(&quot;Finalizing set up&quot;,new Executable() {</span>
            public void run(Reactor session) throws Exception {
<span class="nc" id="L2742">                rebuildDependencyGraph();</span>

                {// recompute label objects - populates the labels mapping.
<span class="nc bnc" id="L2745" title="All 2 branches missed.">                    for (Node slave : nodes.getNodes())</span>
                        // Note that not all labels are visible until the slaves have connected.
<span class="nc" id="L2747">                        slave.getAssignedLabels();</span>
<span class="nc" id="L2748">                    getAssignedLabels();</span>
                }

                // initialize views by inserting the default view if necessary
                // this is both for clean Jenkins and for backward compatibility.
<span class="nc bnc" id="L2753" title="All 4 branches missed.">                if(views.size()==0 || primaryView==null) {</span>
<span class="nc" id="L2754">                    View v = new AllView(Messages.Hudson_ViewName());</span>
<span class="nc" id="L2755">                    setViewOwner(v);</span>
<span class="nc" id="L2756">                    views.add(0,v);</span>
<span class="nc" id="L2757">                    primaryView = v.getViewName();</span>
                }

<span class="nc bnc" id="L2760" title="All 4 branches missed.">                if (useSecurity!=null &amp;&amp; !useSecurity) {</span>
                    // forced reset to the unsecure mode.
                    // this works as an escape hatch for people who locked themselves out.
<span class="nc" id="L2763">                    authorizationStrategy = AuthorizationStrategy.UNSECURED;</span>
<span class="nc" id="L2764">                    setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);</span>
<span class="nc" id="L2765">                } else {</span>
                    // read in old data that doesn't have the security field set
<span class="nc bnc" id="L2767" title="All 2 branches missed.">                    if(authorizationStrategy==null) {</span>
<span class="nc bnc" id="L2768" title="All 2 branches missed.">                        if(useSecurity==null)</span>
<span class="nc" id="L2769">                            authorizationStrategy = AuthorizationStrategy.UNSECURED;</span>
                        else
<span class="nc" id="L2771">                            authorizationStrategy = new LegacyAuthorizationStrategy();</span>
                    }
<span class="nc bnc" id="L2773" title="All 2 branches missed.">                    if(securityRealm==null) {</span>
<span class="nc bnc" id="L2774" title="All 2 branches missed.">                        if(useSecurity==null)</span>
<span class="nc" id="L2775">                            setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);</span>
                        else
<span class="nc" id="L2777">                            setSecurityRealm(new LegacySecurityRealm());</span>
<span class="nc" id="L2778">                    } else {</span>
                        // force the set to proxy
<span class="nc" id="L2780">                        setSecurityRealm(securityRealm);</span>
                    }
                }


                // Initialize the filter with the crumb issuer
<span class="nc" id="L2786">                setCrumbIssuer(crumbIssuer);</span>

                // auto register root actions
<span class="nc bnc" id="L2789" title="All 2 branches missed.">                for (Action a : getExtensionList(RootAction.class))</span>
<span class="nc bnc" id="L2790" title="All 2 branches missed.">                    if (!actions.contains(a)) actions.add(a);</span>
<span class="nc" id="L2791">            }</span>
        });

<span class="nc" id="L2794">        return g;</span>
    }

    /**
     * Save the settings to a file.
     */
    public synchronized void save() throws IOException {
<span class="nc bnc" id="L2801" title="All 2 branches missed.">        if(BulkChange.contains(this))   return;</span>
<span class="nc" id="L2802">        getConfigFile().write(this);</span>
<span class="nc" id="L2803">        SaveableListener.fireOnChange(this, getConfigFile());</span>
<span class="nc" id="L2804">    }</span>


    /**
     * Called to shut down the system.
     */
    @edu.umd.cs.findbugs.annotations.SuppressWarnings(&quot;ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD&quot;)
    public void cleanUp() {
<span class="nc bnc" id="L2812" title="All 2 branches missed.">        for (ItemListener l : ItemListener.all())</span>
<span class="nc" id="L2813">            l.onBeforeShutdown();</span>

        try {
<span class="nc" id="L2816">            final TerminatorFinder tf = new TerminatorFinder(</span>
<span class="nc bnc" id="L2817" title="All 2 branches missed.">                    pluginManager != null ? pluginManager.uberClassLoader : Thread.currentThread().getContextClassLoader());</span>
<span class="nc" id="L2818">            new Reactor(tf).execute(new Executor() {</span>
                @Override
                public void execute(Runnable command) {
<span class="nc" id="L2821">                    command.run();</span>
<span class="nc" id="L2822">                }</span>
            });
<span class="nc" id="L2824">        } catch (InterruptedException e) {</span>
<span class="nc" id="L2825">            LOGGER.log(SEVERE, &quot;Failed to execute termination&quot;,e);</span>
<span class="nc" id="L2826">            e.printStackTrace();</span>
<span class="nc" id="L2827">        } catch (ReactorException e) {</span>
<span class="nc" id="L2828">            LOGGER.log(SEVERE, &quot;Failed to execute termination&quot;,e);</span>
<span class="nc" id="L2829">        } catch (IOException e) {</span>
<span class="nc" id="L2830">            LOGGER.log(SEVERE, &quot;Failed to execute termination&quot;,e);</span>
        }

<span class="nc" id="L2833">        final Set&lt;Future&lt;?&gt;&gt; pending = new HashSet&lt;Future&lt;?&gt;&gt;();</span>
<span class="nc" id="L2834">        terminating = true;</span>
        // JENKINS-28840 we know we will be interrupting all the Computers so get the Queue lock once for all
<span class="nc" id="L2836">        Queue.withLock(new Runnable() {</span>
            @Override
            public void run() {
<span class="nc bnc" id="L2839" title="All 2 branches missed.">                for( Computer c : computers.values() ) {</span>
<span class="nc" id="L2840">                    c.interrupt();</span>
<span class="nc" id="L2841">                    killComputer(c);</span>
<span class="nc" id="L2842">                    pending.add(c.disconnect(null));</span>
                }
<span class="nc" id="L2844">            }</span>
        });
<span class="nc bnc" id="L2846" title="All 2 branches missed.">        if(udpBroadcastThread!=null)</span>
<span class="nc" id="L2847">            udpBroadcastThread.shutdown();</span>
<span class="nc bnc" id="L2848" title="All 2 branches missed.">        if(dnsMultiCast!=null)</span>
<span class="nc" id="L2849">            dnsMultiCast.close();</span>
<span class="nc" id="L2850">        interruptReloadThread();</span>

<span class="nc" id="L2852">        java.util.Timer timer = Trigger.timer;</span>
<span class="nc bnc" id="L2853" title="All 2 branches missed.">        if (timer != null) {</span>
<span class="nc" id="L2854">            timer.cancel();</span>
        }
        // TODO: how to wait for the completion of the last job?
<span class="nc" id="L2857">        Trigger.timer = null;</span>

<span class="nc" id="L2859">        Timer.shutdown();</span>

<span class="nc bnc" id="L2861" title="All 2 branches missed.">        if(tcpSlaveAgentListener!=null)</span>
<span class="nc" id="L2862">            tcpSlaveAgentListener.shutdown();</span>

<span class="nc bnc" id="L2864" title="All 2 branches missed.">        if(pluginManager!=null) // be defensive. there could be some ugly timing related issues</span>
<span class="nc" id="L2865">            pluginManager.stop();</span>

<span class="nc bnc" id="L2867" title="All 2 branches missed.">        if(getRootDir().exists())</span>
            // if we are aborting because we failed to create JENKINS_HOME,
            // don't try to save. Issue #536
<span class="nc" id="L2870">            getQueue().save();</span>

<span class="nc" id="L2872">        threadPoolForLoad.shutdown();</span>
<span class="nc bnc" id="L2873" title="All 2 branches missed.">        for (Future&lt;?&gt; f : pending)</span>
            try {
<span class="nc" id="L2875">                f.get(10, TimeUnit.SECONDS);    // if clean up operation didn't complete in time, we fail the test</span>
<span class="nc" id="L2876">            } catch (InterruptedException e) {</span>
<span class="nc" id="L2877">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L2878">                break;  // someone wants us to die now. quick!</span>
<span class="nc" id="L2879">            } catch (ExecutionException e) {</span>
<span class="nc" id="L2880">                LOGGER.log(Level.WARNING, &quot;Failed to shut down properly&quot;,e);</span>
<span class="nc" id="L2881">            } catch (TimeoutException e) {</span>
<span class="nc" id="L2882">                LOGGER.log(Level.WARNING, &quot;Failed to shut down properly&quot;,e);</span>
            }

<span class="nc" id="L2885">        LogFactory.releaseAll();</span>

<span class="nc" id="L2887">        theInstance = null;</span>
<span class="nc" id="L2888">    }</span>

    public Object getDynamic(String token) {
<span class="nc bnc" id="L2891" title="All 2 branches missed.">        for (Action a : getActions()) {</span>
<span class="nc" id="L2892">            String url = a.getUrlName();</span>
<span class="nc bnc" id="L2893" title="All 2 branches missed.">            if (url==null)  continue;</span>
<span class="nc bnc" id="L2894" title="All 4 branches missed.">            if (url.equals(token) || url.equals('/' + token))</span>
<span class="nc" id="L2895">                return a;</span>
        }
<span class="nc bnc" id="L2897" title="All 2 branches missed.">        for (Action a : getManagementLinks())</span>
<span class="nc bnc" id="L2898" title="All 2 branches missed.">            if(a.getUrlName().equals(token))</span>
<span class="nc" id="L2899">                return a;</span>
<span class="nc" id="L2900">        return null;</span>
    }


//
//
// actions
//
//
    /**
     * Accepts submission from the configuration page.
     */
    public synchronized void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {
<span class="nc" id="L2913">        BulkChange bc = new BulkChange(this);</span>
        try {
<span class="nc" id="L2915">            checkPermission(ADMINISTER);</span>

<span class="nc" id="L2917">            JSONObject json = req.getSubmittedForm();</span>

<span class="nc" id="L2919">            workspaceDir = json.getString(&quot;rawWorkspaceDir&quot;);</span>
<span class="nc" id="L2920">            buildsDir = json.getString(&quot;rawBuildsDir&quot;);</span>

<span class="nc" id="L2922">            systemMessage = Util.nullify(req.getParameter(&quot;system_message&quot;));</span>

<span class="nc" id="L2924">            setJDKs(req.bindJSONToList(JDK.class, json.get(&quot;jdks&quot;)));</span>

<span class="nc" id="L2926">            boolean result = true;</span>
<span class="nc bnc" id="L2927" title="All 2 branches missed.">            for (Descriptor&lt;?&gt; d : Functions.getSortedDescriptorsForGlobalConfigUnclassified())</span>
<span class="nc" id="L2928">                result &amp;= configureDescriptor(req,json,d);</span>

<span class="nc" id="L2930">            version = VERSION;</span>

<span class="nc" id="L2932">            save();</span>
<span class="nc" id="L2933">            updateComputerList();</span>
<span class="nc bnc" id="L2934" title="All 2 branches missed.">            if(result)</span>
<span class="nc" id="L2935">                FormApply.success(req.getContextPath()+'/').generateResponse(req, rsp, null);</span>
            else
<span class="nc" id="L2937">                FormApply.success(&quot;configure&quot;).generateResponse(req, rsp, null);    // back to config</span>
<span class="nc" id="L2938">        } finally {</span>
<span class="nc" id="L2939">            bc.commit();</span>
<span class="nc" id="L2940">        }</span>
<span class="nc" id="L2941">    }</span>

    /**
     * Gets the {@link CrumbIssuer} currently in use.
     *
     * @return null if none is in use.
     */
    public CrumbIssuer getCrumbIssuer() {
<span class="nc" id="L2949">        return crumbIssuer;</span>
    }

    public void setCrumbIssuer(CrumbIssuer issuer) {
<span class="nc" id="L2953">        crumbIssuer = issuer;</span>
<span class="nc" id="L2954">    }</span>

    public synchronized void doTestPost( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
<span class="nc" id="L2957">        rsp.sendRedirect(&quot;foo&quot;);</span>
<span class="nc" id="L2958">    }</span>

    private boolean configureDescriptor(StaplerRequest req, JSONObject json, Descriptor&lt;?&gt; d) throws FormException {
        // collapse the structure to remain backward compatible with the JSON structure before 1.
<span class="nc" id="L2962">        String name = d.getJsonSafeClassName();</span>
<span class="nc bnc" id="L2963" title="All 2 branches missed.">        JSONObject js = json.has(name) ? json.getJSONObject(name) : new JSONObject(); // if it doesn't have the property, the method returns invalid null object.</span>
<span class="nc" id="L2964">        json.putAll(js);</span>
<span class="nc" id="L2965">        return d.configure(req, js);</span>
    }

    /**
     * Accepts submission from the node configuration page.
     */
    @RequirePOST
    public synchronized void doConfigExecutorsSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {
<span class="nc" id="L2973">        checkPermission(ADMINISTER);</span>

<span class="nc" id="L2975">        BulkChange bc = new BulkChange(this);</span>
        try {
<span class="nc" id="L2977">            JSONObject json = req.getSubmittedForm();</span>

<span class="nc" id="L2979">            MasterBuildConfiguration mbc = MasterBuildConfiguration.all().get(MasterBuildConfiguration.class);</span>
<span class="nc bnc" id="L2980" title="All 2 branches missed.">            if (mbc!=null)</span>
<span class="nc" id="L2981">                mbc.configure(req,json);</span>

<span class="nc" id="L2983">            getNodeProperties().rebuild(req, json.optJSONObject(&quot;nodeProperties&quot;), NodeProperty.all());</span>
<span class="nc" id="L2984">        } finally {</span>
<span class="nc" id="L2985">            bc.commit();</span>
<span class="nc" id="L2986">        }</span>

<span class="nc" id="L2988">        updateComputerList();</span>

<span class="nc" id="L2990">        rsp.sendRedirect(req.getContextPath()+'/'+toComputer().getUrl());  // back to the computer page</span>
<span class="nc" id="L2991">    }</span>

    /**
     * Accepts the new description.
     */
    @RequirePOST
    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
<span class="nc" id="L2998">        getPrimaryView().doSubmitDescription(req, rsp);</span>
<span class="nc" id="L2999">    }</span>

    @RequirePOST // TODO does not seem to work on _either_ overload!
    public synchronized HttpRedirect doQuietDown() throws IOException {
        try {
<span class="nc" id="L3004">            return doQuietDown(false,0);</span>
<span class="nc" id="L3005">        } catch (InterruptedException e) {</span>
<span class="nc" id="L3006">            throw new AssertionError(); // impossible</span>
        }
    }

    @CLIMethod(name=&quot;quiet-down&quot;)
    @RequirePOST
    public HttpRedirect doQuietDown(
            @Option(name=&quot;-block&quot;,usage=&quot;Block until the system really quiets down and no builds are running&quot;) @QueryParameter boolean block,
            @Option(name=&quot;-timeout&quot;,usage=&quot;If non-zero, only block up to the specified number of milliseconds&quot;) @QueryParameter int timeout) throws InterruptedException, IOException {
<span class="nc" id="L3015">        synchronized (this) {</span>
<span class="nc" id="L3016">            checkPermission(ADMINISTER);</span>
<span class="nc" id="L3017">            isQuietingDown = true;</span>
        }
<span class="nc bnc" id="L3019" title="All 2 branches missed.">        if (block) {</span>
<span class="nc" id="L3020">            long waitUntil = timeout;</span>
<span class="nc bnc" id="L3021" title="All 2 branches missed.">            if (timeout &gt; 0) waitUntil += System.currentTimeMillis();</span>
<span class="nc bnc" id="L3022" title="All 2 branches missed.">            while (isQuietingDown</span>
<span class="nc bnc" id="L3023" title="All 4 branches missed.">                   &amp;&amp; (timeout &lt;= 0 || System.currentTimeMillis() &lt; waitUntil)</span>
<span class="nc bnc" id="L3024" title="All 2 branches missed.">                   &amp;&amp; !RestartListener.isAllReady()) {</span>
<span class="nc" id="L3025">                Thread.sleep(1000);</span>
            }
        }
<span class="nc" id="L3028">        return new HttpRedirect(&quot;.&quot;);</span>
    }

    @CLIMethod(name=&quot;cancel-quiet-down&quot;)
    @RequirePOST // TODO the cancel link needs to be updated accordingly
    public synchronized HttpRedirect doCancelQuietDown() {
<span class="nc" id="L3034">        checkPermission(ADMINISTER);</span>
<span class="nc" id="L3035">        isQuietingDown = false;</span>
<span class="nc" id="L3036">        getQueue().scheduleMaintenance();</span>
<span class="nc" id="L3037">        return new HttpRedirect(&quot;.&quot;);</span>
    }

    public HttpResponse doToggleCollapse() throws ServletException, IOException {
<span class="nc" id="L3041">    	final StaplerRequest request = Stapler.getCurrentRequest();</span>
<span class="nc" id="L3042">    	final String paneId = request.getParameter(&quot;paneId&quot;);</span>

<span class="nc" id="L3044">    	PaneStatusProperties.forCurrentUser().toggleCollapsed(paneId);</span>

<span class="nc" id="L3046">        return HttpResponses.forwardToPreviousPage();</span>
    }

    /**
     * Backward compatibility. Redirect to the thread dump.
     */
    public void doClassicThreadDump(StaplerResponse rsp) throws IOException, ServletException {
<span class="nc" id="L3053">        rsp.sendRedirect2(&quot;threadDump&quot;);</span>
<span class="nc" id="L3054">    }</span>

    /**
     * Obtains the thread dump of all slaves (including the master.)
     *
     * &lt;p&gt;
     * Since this is for diagnostics, it has a built-in precautionary measure against hang slaves.
     */
    public Map&lt;String,Map&lt;String,String&gt;&gt; getAllThreadDumps() throws IOException, InterruptedException {
<span class="nc" id="L3063">        checkPermission(ADMINISTER);</span>

        // issue the requests all at once
<span class="nc" id="L3066">        Map&lt;String,Future&lt;Map&lt;String,String&gt;&gt;&gt; future = new HashMap&lt;String, Future&lt;Map&lt;String, String&gt;&gt;&gt;();</span>

<span class="nc bnc" id="L3068" title="All 2 branches missed.">        for (Computer c : getComputers()) {</span>
            try {
<span class="nc" id="L3070">                future.put(c.getName(), RemotingDiagnostics.getThreadDumpAsync(c.getChannel()));</span>
<span class="nc" id="L3071">            } catch(Exception e) {</span>
<span class="nc" id="L3072">                LOGGER.info(&quot;Failed to get thread dump for node &quot; + c.getName() + &quot;: &quot; + e.getMessage());</span>
            }
        }
<span class="nc bnc" id="L3075" title="All 2 branches missed.">		if (toComputer() == null) {</span>
<span class="nc" id="L3076">			future.put(&quot;master&quot;, RemotingDiagnostics.getThreadDumpAsync(FilePath.localChannel));</span>
		}

        // if the result isn't available in 5 sec, ignore that.
        // this is a precaution against hang nodes
<span class="nc" id="L3081">        long endTime = System.currentTimeMillis() + 5000;</span>

<span class="nc" id="L3083">        Map&lt;String,Map&lt;String,String&gt;&gt; r = new HashMap&lt;String, Map&lt;String, String&gt;&gt;();</span>
<span class="nc bnc" id="L3084" title="All 2 branches missed.">        for (Entry&lt;String, Future&lt;Map&lt;String, String&gt;&gt;&gt; e : future.entrySet()) {</span>
            try {
<span class="nc" id="L3086">                r.put(e.getKey(), e.getValue().get(endTime-System.currentTimeMillis(), TimeUnit.MILLISECONDS));</span>
<span class="nc" id="L3087">            } catch (Exception x) {</span>
<span class="nc" id="L3088">                StringWriter sw = new StringWriter();</span>
<span class="nc" id="L3089">                x.printStackTrace(new PrintWriter(sw,true));</span>
<span class="nc" id="L3090">                r.put(e.getKey(), Collections.singletonMap(&quot;Failed to retrieve thread dump&quot;,sw.toString()));</span>
            }
        }
<span class="nc" id="L3093">        return Collections.unmodifiableSortedMap(new TreeMap&lt;String, Map&lt;String, String&gt;&gt;(r));</span>
    }

    @RequirePOST
    public synchronized TopLevelItem doCreateItem( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
<span class="nc" id="L3098">        return itemGroupMixIn.createTopLevelItem(req, rsp);</span>
    }

    /**
     * @since 1.319
     */
    public TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {
<span class="nc" id="L3105">        return itemGroupMixIn.createProjectFromXML(name, xml);</span>
    }


    @SuppressWarnings({&quot;unchecked&quot;})
    public &lt;T extends TopLevelItem&gt; T copy(T src, String name) throws IOException {
<span class="nc" id="L3111">        return itemGroupMixIn.copy(src, name);</span>
    }

    // a little more convenient overloading that assumes the caller gives us the right type
    // (or else it will fail with ClassCastException)
    public &lt;T extends AbstractProject&lt;?,?&gt;&gt; T copy(T src, String name) throws IOException {
<span class="nc" id="L3117">        return (T)copy((TopLevelItem)src,name);</span>
    }

    @RequirePOST
    public synchronized void doCreateView( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {
<span class="nc" id="L3122">        checkPermission(View.CREATE);</span>
<span class="nc" id="L3123">        addView(View.create(req,rsp, this));</span>
<span class="nc" id="L3124">    }</span>

    /**
     * Check if the given name is suitable as a name
     * for job, view, etc.
     *
     * @throws Failure
     *      if the given name is not good
     */
    public static void checkGoodName(String name) throws Failure {
<span class="nc bnc" id="L3134" title="All 4 branches missed.">        if(name==null || name.length()==0)</span>
<span class="nc" id="L3135">            throw new Failure(Messages.Hudson_NoName());</span>

<span class="nc bnc" id="L3137" title="All 2 branches missed.">        if(&quot;.&quot;.equals(name.trim()))</span>
<span class="nc" id="L3138">            throw new Failure(Messages.Jenkins_NotAllowedName(&quot;.&quot;));</span>
<span class="nc bnc" id="L3139" title="All 2 branches missed.">        if(&quot;..&quot;.equals(name.trim()))</span>
<span class="nc" id="L3140">            throw new Failure(Messages.Jenkins_NotAllowedName(&quot;..&quot;));</span>
<span class="nc bnc" id="L3141" title="All 2 branches missed.">        for( int i=0; i&lt;name.length(); i++ ) {</span>
<span class="nc" id="L3142">            char ch = name.charAt(i);</span>
<span class="nc bnc" id="L3143" title="All 2 branches missed.">            if(Character.isISOControl(ch)) {</span>
<span class="nc" id="L3144">                throw new Failure(Messages.Hudson_ControlCodeNotAllowed(toPrintableName(name)));</span>
            }
<span class="nc bnc" id="L3146" title="All 2 branches missed.">            if(&quot;?*/\\%!@#$^&amp;|&lt;&gt;[]:;&quot;.indexOf(ch)!=-1)</span>
<span class="nc" id="L3147">                throw new Failure(Messages.Hudson_UnsafeChar(ch));</span>
        }

        // looks good
<span class="nc" id="L3151">    }</span>

    /**
     * Makes sure that the given name is good as a job name.
     * @return trimmed name if valid; throws Failure if not
     */
    private String checkJobName(String name) throws Failure {
<span class="nc" id="L3158">        checkGoodName(name);</span>
<span class="nc" id="L3159">        name = name.trim();</span>
<span class="nc" id="L3160">        projectNamingStrategy.checkName(name);</span>
<span class="nc bnc" id="L3161" title="All 2 branches missed.">        if(getItem(name)!=null)</span>
<span class="nc" id="L3162">            throw new Failure(Messages.Hudson_JobAlreadyExists(name));</span>
        // looks good
<span class="nc" id="L3164">        return name;</span>
    }

    private static String toPrintableName(String name) {
<span class="nc" id="L3168">        StringBuilder printableName = new StringBuilder();</span>
<span class="nc bnc" id="L3169" title="All 2 branches missed.">        for( int i=0; i&lt;name.length(); i++ ) {</span>
<span class="nc" id="L3170">            char ch = name.charAt(i);</span>
<span class="nc bnc" id="L3171" title="All 2 branches missed.">            if(Character.isISOControl(ch))</span>
<span class="nc" id="L3172">                printableName.append(&quot;\\u&quot;).append((int)ch).append(';');</span>
            else
<span class="nc" id="L3174">                printableName.append(ch);</span>
        }
<span class="nc" id="L3176">        return printableName.toString();</span>
    }

    /**
     * Checks if the user was successfully authenticated.
     *
     * @see BasicAuthenticationFilter
     */
    public void doSecured( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
        // TODO fire something in SecurityListener? (seems to be used only for REST calls when LegacySecurityRealm is active)

<span class="nc bnc" id="L3187" title="All 2 branches missed.">        if(req.getUserPrincipal()==null) {</span>
            // authentication must have failed
<span class="nc" id="L3189">            rsp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span>
<span class="nc" id="L3190">            return;</span>
        }

        // the user is now authenticated, so send him back to the target
<span class="nc" id="L3194">        String path = req.getContextPath()+req.getOriginalRestOfPath();</span>
<span class="nc" id="L3195">        String q = req.getQueryString();</span>
<span class="nc bnc" id="L3196" title="All 2 branches missed.">        if(q!=null)</span>
<span class="nc" id="L3197">            path += '?'+q;</span>

<span class="nc" id="L3199">        rsp.sendRedirect2(path);</span>
<span class="nc" id="L3200">    }</span>

    /**
     * Called once the user logs in. Just forward to the top page.
     * Used only by {@link LegacySecurityRealm}.
     */
    public void doLoginEntry( StaplerRequest req, StaplerResponse rsp ) throws IOException {
<span class="nc bnc" id="L3207" title="All 2 branches missed.">        if(req.getUserPrincipal()==null) {</span>
<span class="nc" id="L3208">            rsp.sendRedirect2(&quot;noPrincipal&quot;);</span>
<span class="nc" id="L3209">            return;</span>
        }

        // TODO fire something in SecurityListener?

<span class="nc" id="L3214">        String from = req.getParameter(&quot;from&quot;);</span>
<span class="nc bnc" id="L3215" title="All 6 branches missed.">        if(from!=null &amp;&amp; from.startsWith(&quot;/&quot;) &amp;&amp; !from.equals(&quot;/loginError&quot;)) {</span>
<span class="nc" id="L3216">            rsp.sendRedirect2(from);    // I'm bit uncomfortable letting users redircted to other sites, make sure the URL falls into this domain</span>
<span class="nc" id="L3217">            return;</span>
        }

<span class="nc" id="L3220">        String url = AbstractProcessingFilter.obtainFullRequestUrl(req);</span>
<span class="nc bnc" id="L3221" title="All 2 branches missed.">        if(url!=null) {</span>
            // if the login redirect is initiated by Acegi
            // this should send the user back to where s/he was from.
<span class="nc" id="L3224">            rsp.sendRedirect2(url);</span>
<span class="nc" id="L3225">            return;</span>
        }

<span class="nc" id="L3228">        rsp.sendRedirect2(&quot;.&quot;);</span>
<span class="nc" id="L3229">    }</span>

    /**
     * Logs out the user.
     */
    public void doLogout( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
<span class="nc" id="L3235">        String user = getAuthentication().getName();</span>
<span class="nc" id="L3236">        securityRealm.doLogout(req, rsp);</span>
<span class="nc" id="L3237">        SecurityListener.fireLoggedOut(user);</span>
<span class="nc" id="L3238">    }</span>

    /**
     * Serves jar files for JNLP slave agents.
     */
    public Slave.JnlpJar getJnlpJars(String fileName) {
<span class="nc" id="L3244">        return new Slave.JnlpJar(fileName);</span>
    }

    public Slave.JnlpJar doJnlpJars(StaplerRequest req) {
<span class="nc" id="L3248">        return new Slave.JnlpJar(req.getRestOfPath().substring(1));</span>
    }

    /**
     * Reloads the configuration.
     */
    @CLIMethod(name=&quot;reload-configuration&quot;)
    @RequirePOST
    public synchronized HttpResponse doReload() throws IOException {
<span class="nc" id="L3257">        checkPermission(ADMINISTER);</span>

        // engage &quot;loading ...&quot; UI and then run the actual task in a separate thread
<span class="nc" id="L3260">        servletContext.setAttribute(&quot;app&quot;, new HudsonIsLoading());</span>

<span class="nc" id="L3262">        new Thread(&quot;Jenkins config reload thread&quot;) {</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L3266">                    ACL.impersonate(ACL.SYSTEM);</span>
<span class="nc" id="L3267">                    reload();</span>
<span class="nc" id="L3268">                } catch (Exception e) {</span>
<span class="nc" id="L3269">                    LOGGER.log(SEVERE,&quot;Failed to reload Jenkins config&quot;,e);</span>
<span class="nc" id="L3270">                    new JenkinsReloadFailed(e).publish(servletContext,root);</span>
                }
<span class="nc" id="L3272">            }</span>
<span class="nc" id="L3273">        }.start();</span>

<span class="nc" id="L3275">        return HttpResponses.redirectViaContextPath(&quot;/&quot;);</span>
    }

    /**
     * Reloads the configuration synchronously.
     */
    public void reload() throws IOException, InterruptedException, ReactorException {
<span class="nc" id="L3282">        executeReactor(null, loadTasks());</span>
<span class="nc" id="L3283">        User.reload();</span>
<span class="nc" id="L3284">        servletContext.setAttribute(&quot;app&quot;, this);</span>
<span class="nc" id="L3285">    }</span>

    /**
     * Do a finger-print check.
     */
    public void doDoFingerprintCheck( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
        // Parse the request
<span class="nc" id="L3292">        MultipartFormDataParser p = new MultipartFormDataParser(req);</span>
<span class="nc bnc" id="L3293" title="All 4 branches missed.">        if(isUseCrumbs() &amp;&amp; !getCrumbIssuer().validateCrumb(req, p)) {</span>
<span class="nc" id="L3294">            rsp.sendError(HttpServletResponse.SC_FORBIDDEN,&quot;No crumb found&quot;);</span>
        }
        try {
<span class="nc" id="L3297">            rsp.sendRedirect2(req.getContextPath()+&quot;/fingerprint/&quot;+</span>
<span class="nc" id="L3298">                Util.getDigestOf(p.getFileItem(&quot;name&quot;).getInputStream())+'/');</span>
<span class="nc" id="L3299">        } finally {</span>
<span class="nc" id="L3300">            p.cleanUp();</span>
<span class="nc" id="L3301">        }</span>
<span class="nc" id="L3302">    }</span>

    /**
     * For debugging. Expose URL to perform GC.
     */
    @edu.umd.cs.findbugs.annotations.SuppressWarnings(&quot;DM_GC&quot;)
    @RequirePOST
    public void doGc(StaplerResponse rsp) throws IOException {
<span class="nc" id="L3310">        checkPermission(Jenkins.ADMINISTER);</span>
<span class="nc" id="L3311">        System.gc();</span>
<span class="nc" id="L3312">        rsp.setStatus(HttpServletResponse.SC_OK);</span>
<span class="nc" id="L3313">        rsp.setContentType(&quot;text/plain&quot;);</span>
<span class="nc" id="L3314">        rsp.getWriter().println(&quot;GCed&quot;);</span>
<span class="nc" id="L3315">    }</span>

    /**
     * End point that intentionally throws an exception to test the error behaviour.
     * @since 1.467
     */
    public void doException() {
<span class="nc" id="L3322">        throw new RuntimeException();</span>
    }

    public ContextMenu doContextMenu(StaplerRequest request, StaplerResponse response) throws IOException, JellyException {
<span class="nc" id="L3326">        ContextMenu menu = new ContextMenu().from(this, request, response);</span>
<span class="nc bnc" id="L3327" title="All 2 branches missed.">        for (MenuItem i : menu.items) {</span>
<span class="nc bnc" id="L3328" title="All 2 branches missed.">            if (i.url.equals(request.getContextPath() + &quot;/manage&quot;)) {</span>
                // add &quot;Manage Jenkins&quot; subitems
<span class="nc" id="L3330">                i.subMenu = new ContextMenu().from(this, request, response, &quot;manage&quot;);</span>
            }
        }
<span class="nc" id="L3333">        return menu;</span>
    }

    public ContextMenu doChildrenContextMenu(StaplerRequest request, StaplerResponse response) throws Exception {
<span class="nc" id="L3337">        ContextMenu menu = new ContextMenu();</span>
<span class="nc bnc" id="L3338" title="All 2 branches missed.">        for (View view : getViews()) {</span>
<span class="nc" id="L3339">            menu.add(view.getViewUrl(),view.getDisplayName());</span>
        }
<span class="nc" id="L3341">        return menu;</span>
    }

    /**
     * Obtains the heap dump.
     */
    public HeapDump getHeapDump() throws IOException {
<span class="nc" id="L3348">        return new HeapDump(this,FilePath.localChannel);</span>
    }

    /**
     * Simulates OutOfMemoryError.
     * Useful to make sure OutOfMemoryHeapDump setting.
     */
    @RequirePOST
    public void doSimulateOutOfMemory() throws IOException {
<span class="nc" id="L3357">        checkPermission(ADMINISTER);</span>

<span class="nc" id="L3359">        System.out.println(&quot;Creating artificial OutOfMemoryError situation&quot;);</span>
<span class="nc" id="L3360">        List&lt;Object&gt; args = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L3361">        while (true)</span>
<span class="nc" id="L3362">            args.add(new byte[1024*1024]);</span>
    }

    /**
     * Binds /userContent/... to $JENKINS_HOME/userContent.
     */
    public DirectoryBrowserSupport doUserContent() {
<span class="nc" id="L3369">        return new DirectoryBrowserSupport(this,getRootPath().child(&quot;userContent&quot;),&quot;User content&quot;,&quot;folder.png&quot;,true);</span>
    }

    /**
     * Perform a restart of Jenkins, if we can.
     *
     * This first replaces &quot;app&quot; to {@link HudsonIsRestarting}
     */
    @CLIMethod(name=&quot;restart&quot;)
    public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, RestartNotSupportedException {
<span class="nc" id="L3379">        checkPermission(ADMINISTER);</span>
<span class="nc bnc" id="L3380" title="All 4 branches missed.">        if (req != null &amp;&amp; req.getMethod().equals(&quot;GET&quot;)) {</span>
<span class="nc" id="L3381">            req.getView(this,&quot;_restart.jelly&quot;).forward(req,rsp);</span>
<span class="nc" id="L3382">            return;</span>
        }

<span class="nc" id="L3385">        restart();</span>

<span class="nc bnc" id="L3387" title="All 2 branches missed.">        if (rsp != null) // null for CLI</span>
<span class="nc" id="L3388">            rsp.sendRedirect2(&quot;.&quot;);</span>
<span class="nc" id="L3389">    }</span>

    /**
     * Queues up a restart of Jenkins for when there are no builds running, if we can.
     *
     * This first replaces &quot;app&quot; to {@link HudsonIsRestarting}
     *
     * @since 1.332
     */
    @CLIMethod(name=&quot;safe-restart&quot;)
    public HttpResponse doSafeRestart(StaplerRequest req) throws IOException, ServletException, RestartNotSupportedException {
<span class="nc" id="L3400">        checkPermission(ADMINISTER);</span>
<span class="nc bnc" id="L3401" title="All 4 branches missed.">        if (req != null &amp;&amp; req.getMethod().equals(&quot;GET&quot;))</span>
<span class="nc" id="L3402">            return HttpResponses.forwardToView(this,&quot;_safeRestart.jelly&quot;);</span>

<span class="nc" id="L3404">        safeRestart();</span>

<span class="nc" id="L3406">        return HttpResponses.redirectToDot();</span>
    }

    /**
     * Performs a restart.
     */
    public void restart() throws RestartNotSupportedException {
<span class="nc" id="L3413">        final Lifecycle lifecycle = Lifecycle.get();</span>
<span class="nc" id="L3414">        lifecycle.verifyRestartable(); // verify that Jenkins is restartable</span>
<span class="nc" id="L3415">        servletContext.setAttribute(&quot;app&quot;, new HudsonIsRestarting());</span>

<span class="nc" id="L3417">        new Thread(&quot;restart thread&quot;) {</span>
<span class="nc" id="L3418">            final String exitUser = getAuthentication().getName();</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L3422">                    ACL.impersonate(ACL.SYSTEM);</span>

                    // give some time for the browser to load the &quot;reloading&quot; page
<span class="nc" id="L3425">                    Thread.sleep(5000);</span>
<span class="nc" id="L3426">                    LOGGER.severe(String.format(&quot;Restarting VM as requested by %s&quot;,exitUser));</span>
<span class="nc bnc" id="L3427" title="All 2 branches missed.">                    for (RestartListener listener : RestartListener.all())</span>
<span class="nc" id="L3428">                        listener.onRestart();</span>
<span class="nc" id="L3429">                    lifecycle.restart();</span>
<span class="nc" id="L3430">                } catch (InterruptedException e) {</span>
<span class="nc" id="L3431">                    LOGGER.log(Level.WARNING, &quot;Failed to restart Jenkins&quot;,e);</span>
<span class="nc" id="L3432">                } catch (IOException e) {</span>
<span class="nc" id="L3433">                    LOGGER.log(Level.WARNING, &quot;Failed to restart Jenkins&quot;,e);</span>
                }
<span class="nc" id="L3435">            }</span>
<span class="nc" id="L3436">        }.start();</span>
<span class="nc" id="L3437">    }</span>

    /**
     * Queues up a restart to be performed once there are no builds currently running.
     * @since 1.332
     */
    public void safeRestart() throws RestartNotSupportedException {
<span class="nc" id="L3444">        final Lifecycle lifecycle = Lifecycle.get();</span>
<span class="nc" id="L3445">        lifecycle.verifyRestartable(); // verify that Jenkins is restartable</span>
        // Quiet down so that we won't launch new builds.
<span class="nc" id="L3447">        isQuietingDown = true;</span>

<span class="nc" id="L3449">        new Thread(&quot;safe-restart thread&quot;) {</span>
<span class="nc" id="L3450">            final String exitUser = getAuthentication().getName();</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L3454">                    ACL.impersonate(ACL.SYSTEM);</span>

                    // Wait 'til we have no active executors.
<span class="nc" id="L3457">                    doQuietDown(true, 0);</span>

                    // Make sure isQuietingDown is still true.
<span class="nc bnc" id="L3460" title="All 2 branches missed.">                    if (isQuietingDown) {</span>
<span class="nc" id="L3461">                        servletContext.setAttribute(&quot;app&quot;,new HudsonIsRestarting());</span>
                        // give some time for the browser to load the &quot;reloading&quot; page
<span class="nc" id="L3463">                        LOGGER.info(&quot;Restart in 10 seconds&quot;);</span>
<span class="nc" id="L3464">                        Thread.sleep(10000);</span>
<span class="nc" id="L3465">                        LOGGER.severe(String.format(&quot;Restarting VM as requested by %s&quot;,exitUser));</span>
<span class="nc bnc" id="L3466" title="All 2 branches missed.">                        for (RestartListener listener : RestartListener.all())</span>
<span class="nc" id="L3467">                            listener.onRestart();</span>
<span class="nc" id="L3468">                        lifecycle.restart();</span>
<span class="nc" id="L3469">                    } else {</span>
<span class="nc" id="L3470">                        LOGGER.info(&quot;Safe-restart mode cancelled&quot;);</span>
                    }
<span class="nc" id="L3472">                } catch (Throwable e) {</span>
<span class="nc" id="L3473">                    LOGGER.log(Level.WARNING, &quot;Failed to restart Jenkins&quot;,e);</span>
                }
<span class="nc" id="L3475">            }</span>
<span class="nc" id="L3476">        }.start();</span>
<span class="nc" id="L3477">    }</span>

    @Extension @Restricted(NoExternalUse.class)
<span class="nc" id="L3480">    public static class MasterRestartNotifyier extends RestartListener {</span>

        @Override
        public void onRestart() {
<span class="nc" id="L3484">            Computer computer = Jenkins.getInstance().toComputer();</span>
<span class="nc bnc" id="L3485" title="All 2 branches missed.">            if (computer == null) return;</span>
<span class="nc" id="L3486">            RestartCause cause = new RestartCause();</span>
<span class="nc bnc" id="L3487" title="All 2 branches missed.">            for (ComputerListener listener: ComputerListener.all()) {</span>
<span class="nc" id="L3488">                listener.onOffline(computer, cause);</span>
            }
<span class="nc" id="L3490">        }</span>

        @Override
        public boolean isReadyToRestart() throws IOException, InterruptedException {
<span class="nc" id="L3494">            return true;</span>
        }

        private static class RestartCause extends OfflineCause.SimpleOfflineCause {
            protected RestartCause() {
<span class="nc" id="L3499">                super(Messages._Jenkins_IsRestarting());</span>
<span class="nc" id="L3500">            }</span>
        }
    }

    /**
     * Shutdown the system.
     * @since 1.161
     */
    @CLIMethod(name=&quot;shutdown&quot;)
    @RequirePOST
    public void doExit( StaplerRequest req, StaplerResponse rsp ) throws IOException {
<span class="nc" id="L3511">        checkPermission(ADMINISTER);</span>
<span class="nc" id="L3512">        LOGGER.severe(String.format(&quot;Shutting down VM as requested by %s from %s&quot;,</span>
<span class="nc bnc" id="L3513" title="All 2 branches missed.">                getAuthentication().getName(), req!=null?req.getRemoteAddr():&quot;???&quot;));</span>
<span class="nc bnc" id="L3514" title="All 2 branches missed.">        if (rsp!=null) {</span>
<span class="nc" id="L3515">            rsp.setStatus(HttpServletResponse.SC_OK);</span>
<span class="nc" id="L3516">            rsp.setContentType(&quot;text/plain&quot;);</span>
<span class="nc" id="L3517">            PrintWriter w = rsp.getWriter();</span>
<span class="nc" id="L3518">            w.println(&quot;Shutting down&quot;);</span>
<span class="nc" id="L3519">            w.close();</span>
        }

<span class="nc" id="L3522">        System.exit(0);</span>
<span class="nc" id="L3523">    }</span>


    /**
     * Shutdown the system safely.
     * @since 1.332
     */
    @CLIMethod(name=&quot;safe-shutdown&quot;)
    @RequirePOST
    public HttpResponse doSafeExit(StaplerRequest req) throws IOException {
<span class="nc" id="L3533">        checkPermission(ADMINISTER);</span>
<span class="nc" id="L3534">        isQuietingDown = true;</span>
<span class="nc" id="L3535">        final String exitUser = getAuthentication().getName();</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">        final String exitAddr = req!=null ? req.getRemoteAddr() : &quot;unknown&quot;;</span>
<span class="nc" id="L3537">        new Thread(&quot;safe-exit thread&quot;) {</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L3541">                    ACL.impersonate(ACL.SYSTEM);</span>
<span class="nc" id="L3542">                    LOGGER.severe(String.format(&quot;Shutting down VM as requested by %s from %s&quot;,</span>
<span class="nc" id="L3543">                                                exitUser, exitAddr));</span>
                    // Wait 'til we have no active executors.
<span class="nc" id="L3545">                    doQuietDown(true, 0);</span>
                    // Make sure isQuietingDown is still true.
<span class="nc bnc" id="L3547" title="All 2 branches missed.">                    if (isQuietingDown) {</span>
<span class="nc" id="L3548">                        cleanUp();</span>
<span class="nc" id="L3549">                        System.exit(0);</span>
                    }
<span class="nc" id="L3551">                } catch (Exception e) {</span>
<span class="nc" id="L3552">                    LOGGER.log(Level.WARNING, &quot;Failed to shut down Jenkins&quot;, e);</span>
                }
<span class="nc" id="L3554">            }</span>
<span class="nc" id="L3555">        }.start();</span>

<span class="nc" id="L3557">        return HttpResponses.plainText(&quot;Shutting down as soon as all jobs are complete&quot;);</span>
    }

    /**
     * Gets the {@link Authentication} object that represents the user
     * associated with the current request.
     */
    public static @Nonnull Authentication getAuthentication() {
<span class="fc" id="L3565">        Authentication a = SecurityContextHolder.getContext().getAuthentication();</span>
        // on Tomcat while serving the login page, this is null despite the fact
        // that we have filters. Looking at the stack trace, Tomcat doesn't seem to
        // run the request through filters when this is the login request.
        // see http://www.nabble.com/Matrix-authorization-problem-tp14602081p14886312.html
<span class="pc bpc" id="L3570" title="1 of 2 branches missed.">        if(a==null)</span>
<span class="fc" id="L3571">            a = ANONYMOUS;</span>
<span class="fc" id="L3572">        return a;</span>
    }

    /**
     * For system diagnostics.
     * Run arbitrary Groovy script.
     */
    public void doScript(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<span class="nc" id="L3580">        _doScript(req, rsp, req.getView(this, &quot;_script.jelly&quot;), FilePath.localChannel, getACL());</span>
<span class="nc" id="L3581">    }</span>

    /**
     * Run arbitrary Groovy script and return result as plain text.
     */
    public void doScriptText(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<span class="nc" id="L3587">        _doScript(req, rsp, req.getView(this, &quot;_scriptText.jelly&quot;), FilePath.localChannel, getACL());</span>
<span class="nc" id="L3588">    }</span>

    /**
     * @since 1.509.1
     */
    public static void _doScript(StaplerRequest req, StaplerResponse rsp, RequestDispatcher view, VirtualChannel channel, ACL acl) throws IOException, ServletException {
        // ability to run arbitrary script is dangerous
<span class="nc" id="L3595">        acl.checkPermission(RUN_SCRIPTS);</span>

<span class="nc" id="L3597">        String text = req.getParameter(&quot;script&quot;);</span>
<span class="nc bnc" id="L3598" title="All 2 branches missed.">        if (text != null) {</span>
<span class="nc bnc" id="L3599" title="All 2 branches missed.">            if (!&quot;POST&quot;.equals(req.getMethod())) {</span>
<span class="nc" id="L3600">                throw HttpResponses.error(HttpURLConnection.HTTP_BAD_METHOD, &quot;requires POST&quot;);</span>
            }

<span class="nc bnc" id="L3603" title="All 2 branches missed.">            if (channel == null) {</span>
<span class="nc" id="L3604">                throw HttpResponses.error(HttpURLConnection.HTTP_NOT_FOUND, &quot;Node is offline&quot;);</span>
            }

            try {
<span class="nc" id="L3608">                req.setAttribute(&quot;output&quot;,</span>
<span class="nc" id="L3609">                        RemotingDiagnostics.executeGroovy(text, channel));</span>
<span class="nc" id="L3610">            } catch (InterruptedException e) {</span>
<span class="nc" id="L3611">                throw new ServletException(e);</span>
            }
        }

<span class="nc" id="L3615">        view.forward(req, rsp);</span>
<span class="nc" id="L3616">    }</span>

    /**
     * Evaluates the Jelly script submitted by the client.
     *
     * This is useful for system administration as well as unit testing.
     */
    @RequirePOST
    public void doEval(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<span class="nc" id="L3625">        checkPermission(RUN_SCRIPTS);</span>

        try {
<span class="nc" id="L3628">            MetaClass mc = WebApp.getCurrent().getMetaClass(getClass());</span>
<span class="nc" id="L3629">            Script script = mc.classLoader.loadTearOff(JellyClassLoaderTearOff.class).createContext().compileScript(new InputSource(req.getReader()));</span>
<span class="nc" id="L3630">            new JellyRequestDispatcher(this,script).forward(req,rsp);</span>
<span class="nc" id="L3631">        } catch (JellyException e) {</span>
<span class="nc" id="L3632">            throw new ServletException(e);</span>
        }
<span class="nc" id="L3634">    }</span>

    /**
     * Sign up for the user account.
     */
    public void doSignup( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
<span class="nc bnc" id="L3640" title="All 2 branches missed.">        if (getSecurityRealm().allowsSignup()) {</span>
<span class="nc" id="L3641">            req.getView(getSecurityRealm(), &quot;signup.jelly&quot;).forward(req, rsp);</span>
<span class="nc" id="L3642">            return;</span>
        }
<span class="nc" id="L3644">        req.getView(SecurityRealm.class, &quot;signup.jelly&quot;).forward(req, rsp);</span>
<span class="nc" id="L3645">    }</span>

    /**
     * Changes the icon size by changing the cookie
     */
    public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
<span class="nc" id="L3651">        String qs = req.getQueryString();</span>
<span class="nc bnc" id="L3652" title="All 2 branches missed.">        if(qs==null)</span>
<span class="nc" id="L3653">            throw new ServletException();</span>
<span class="nc" id="L3654">        Cookie cookie = new Cookie(&quot;iconSize&quot;, Functions.validateIconSize(qs));</span>
<span class="nc" id="L3655">        cookie.setMaxAge(/* ~4 mo. */9999999); // #762</span>
<span class="nc" id="L3656">        rsp.addCookie(cookie);</span>
<span class="nc" id="L3657">        String ref = req.getHeader(&quot;Referer&quot;);</span>
<span class="nc bnc" id="L3658" title="All 2 branches missed.">        if(ref==null)   ref=&quot;.&quot;;</span>
<span class="nc" id="L3659">        rsp.sendRedirect2(ref);</span>
<span class="nc" id="L3660">    }</span>

    @RequirePOST
    public void doFingerprintCleanup(StaplerResponse rsp) throws IOException {
<span class="nc" id="L3664">        FingerprintCleanupThread.invoke();</span>
<span class="nc" id="L3665">        rsp.setStatus(HttpServletResponse.SC_OK);</span>
<span class="nc" id="L3666">        rsp.setContentType(&quot;text/plain&quot;);</span>
<span class="nc" id="L3667">        rsp.getWriter().println(&quot;Invoked&quot;);</span>
<span class="nc" id="L3668">    }</span>

    @RequirePOST
    public void doWorkspaceCleanup(StaplerResponse rsp) throws IOException {
<span class="nc" id="L3672">        WorkspaceCleanupThread.invoke();</span>
<span class="nc" id="L3673">        rsp.setStatus(HttpServletResponse.SC_OK);</span>
<span class="nc" id="L3674">        rsp.setContentType(&quot;text/plain&quot;);</span>
<span class="nc" id="L3675">        rsp.getWriter().println(&quot;Invoked&quot;);</span>
<span class="nc" id="L3676">    }</span>

    /**
     * If the user chose the default JDK, make sure we got 'java' in PATH.
     */
    public FormValidation doDefaultJDKCheck(StaplerRequest request, @QueryParameter String value) {
<span class="nc bnc" id="L3682" title="All 2 branches missed.">        if(!JDK.isDefaultName(value))</span>
            // assume the user configured named ones properly in system config ---
            // or else system config should have reported form field validation errors.
<span class="nc" id="L3685">            return FormValidation.ok();</span>

        // default JDK selected. Does such java really exist?
<span class="nc bnc" id="L3688" title="All 2 branches missed.">        if(JDK.isDefaultJDKValid(Jenkins.this))</span>
<span class="nc" id="L3689">            return FormValidation.ok();</span>
        else
<span class="nc" id="L3691">            return FormValidation.errorWithMarkup(Messages.Hudson_NoJavaInPath(request.getContextPath()));</span>
    }

    /**
     * Makes sure that the given name is good as a job name.
     */
    public FormValidation doCheckJobName(@QueryParameter String value) {
        // this method can be used to check if a file exists anywhere in the file system,
        // so it should be protected.
<span class="nc" id="L3700">        checkPermission(Item.CREATE);</span>

<span class="nc bnc" id="L3702" title="All 2 branches missed.">        if(fixEmpty(value)==null)</span>
<span class="nc" id="L3703">            return FormValidation.ok();</span>

        try {
<span class="nc" id="L3706">            checkJobName(value);</span>
<span class="nc" id="L3707">            return FormValidation.ok();</span>
<span class="nc" id="L3708">        } catch (Failure e) {</span>
<span class="nc" id="L3709">            return FormValidation.error(e.getMessage());</span>
        }
    }

    /**
     * Checks if a top-level view with the given name exists and
     * make sure that the name is good as a view name.
     */
    public FormValidation doCheckViewName(@QueryParameter String value) {
<span class="nc" id="L3718">        checkPermission(View.CREATE);</span>

<span class="nc" id="L3720">        String name = fixEmpty(value);</span>
<span class="nc bnc" id="L3721" title="All 2 branches missed.">        if (name == null)</span>
<span class="nc" id="L3722">            return FormValidation.ok();</span>

        // already exists?
<span class="nc bnc" id="L3725" title="All 2 branches missed.">        if (getView(name) != null)</span>
<span class="nc" id="L3726">            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(name));</span>

        // good view name?
        try {
<span class="nc" id="L3730">            checkGoodName(name);</span>
<span class="nc" id="L3731">        } catch (Failure e) {</span>
<span class="nc" id="L3732">            return FormValidation.error(e.getMessage());</span>
        }

<span class="nc" id="L3735">        return FormValidation.ok();</span>
    }

    /**
     * Checks if a top-level view with the given name exists.
     * @deprecated 1.512
     */
    @Deprecated
    public FormValidation doViewExistsCheck(@QueryParameter String value) {
<span class="nc" id="L3744">        checkPermission(View.CREATE);</span>

<span class="nc" id="L3746">        String view = fixEmpty(value);</span>
<span class="nc bnc" id="L3747" title="All 2 branches missed.">        if(view==null) return FormValidation.ok();</span>

<span class="nc bnc" id="L3749" title="All 2 branches missed.">        if(getView(view)==null)</span>
<span class="nc" id="L3750">            return FormValidation.ok();</span>
        else
<span class="nc" id="L3752">            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(view));</span>
    }

    /**
     * Serves static resources placed along with Jelly view files.
     * &lt;p&gt;
     * This method can serve a lot of files, so care needs to be taken
     * to make this method secure. It's not clear to me what's the best
     * strategy here, though the current implementation is based on
     * file extensions.
     */
    public void doResources(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<span class="nc" id="L3764">        String path = req.getRestOfPath();</span>
        // cut off the &quot;...&quot; portion of /resources/.../path/to/file
        // as this is only used to make path unique (which in turn
        // allows us to set a long expiration date
<span class="nc" id="L3768">        path = path.substring(path.indexOf('/',1)+1);</span>

<span class="nc" id="L3770">        int idx = path.lastIndexOf('.');</span>
<span class="nc" id="L3771">        String extension = path.substring(idx+1);</span>
<span class="nc bnc" id="L3772" title="All 2 branches missed.">        if(ALLOWED_RESOURCE_EXTENSIONS.contains(extension)) {</span>
<span class="nc" id="L3773">            URL url = pluginManager.uberClassLoader.getResource(path);</span>
<span class="nc bnc" id="L3774" title="All 2 branches missed.">            if(url!=null) {</span>
<span class="nc bnc" id="L3775" title="All 2 branches missed.">                long expires = MetaClass.NO_CACHE ? 0 : 365L * 24 * 60 * 60 * 1000; /*1 year*/</span>
<span class="nc" id="L3776">                rsp.serveFile(req,url,expires);</span>
<span class="nc" id="L3777">                return;</span>
            }
        }
<span class="nc" id="L3780">        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);</span>
<span class="nc" id="L3781">    }</span>

    /**
     * Extension list that {@link #doResources(StaplerRequest, StaplerResponse)} can serve.
     * This set is mutable to allow plugins to add additional extensions.
     */
<span class="fc" id="L3787">    public static final Set&lt;String&gt; ALLOWED_RESOURCE_EXTENSIONS = new HashSet&lt;String&gt;(Arrays.asList(</span>
<span class="fc" id="L3788">        &quot;js|css|jpeg|jpg|png|gif|html|htm&quot;.split(&quot;\\|&quot;)</span>
    ));

    /**
     * Checks if container uses UTF-8 to decode URLs. See
     * http://wiki.jenkins-ci.org/display/JENKINS/Tomcat#Tomcat-i18n
     */
    public FormValidation doCheckURIEncoding(StaplerRequest request) throws IOException {
        // expected is non-ASCII String
<span class="nc" id="L3797">        final String expected = &quot;\u57f7\u4e8b&quot;;</span>
<span class="nc" id="L3798">        final String value = fixEmpty(request.getParameter(&quot;value&quot;));</span>
<span class="nc bnc" id="L3799" title="All 2 branches missed.">        if (!expected.equals(value))</span>
<span class="nc" id="L3800">            return FormValidation.warningWithMarkup(Messages.Hudson_NotUsesUTF8ToDecodeURL());</span>
<span class="nc" id="L3801">        return FormValidation.ok();</span>
    }

    /**
     * Does not check when system default encoding is &quot;ISO-8859-1&quot;.
     */
    public static boolean isCheckURIEncodingEnabled() {
<span class="nc bnc" id="L3808" title="All 2 branches missed.">        return !&quot;ISO-8859-1&quot;.equalsIgnoreCase(System.getProperty(&quot;file.encoding&quot;));</span>
    }

    /**
     * Rebuilds the dependency map.
     */
    public void rebuildDependencyGraph() {
<span class="nc" id="L3815">        DependencyGraph graph = new DependencyGraph();</span>
<span class="nc" id="L3816">        graph.build();</span>
        // volatile acts a as a memory barrier here and therefore guarantees
        // that graph is fully build, before it's visible to other threads
<span class="nc" id="L3819">        dependencyGraph = graph;</span>
<span class="nc" id="L3820">        dependencyGraphDirty.set(false);</span>
<span class="nc" id="L3821">    }</span>

    /**
     * Rebuilds the dependency map asynchronously.
     *
     * &lt;p&gt;
     * This would keep the UI thread more responsive and helps avoid the deadlocks,
     * as dependency graph recomputation tends to touch a lot of other things.
     *
     * @since 1.522
     */
    public Future&lt;DependencyGraph&gt; rebuildDependencyGraphAsync() {
<span class="nc" id="L3833">        dependencyGraphDirty.set(true);</span>
<span class="nc" id="L3834">        return Timer.get().schedule(new java.util.concurrent.Callable&lt;DependencyGraph&gt;() {</span>
            @Override
            public DependencyGraph call() throws Exception {
<span class="nc bnc" id="L3837" title="All 2 branches missed.">                if (dependencyGraphDirty.get()) {</span>
<span class="nc" id="L3838">                    rebuildDependencyGraph();</span>
                }
<span class="nc" id="L3840">                return dependencyGraph;</span>
            }
<span class="nc" id="L3842">        }, 500, TimeUnit.MILLISECONDS);</span>
    }

    public DependencyGraph getDependencyGraph() {
<span class="nc" id="L3846">        return dependencyGraph;</span>
    }

    // for Jelly
    public List&lt;ManagementLink&gt; getManagementLinks() {
<span class="nc" id="L3851">        return ManagementLink.all();</span>
    }

    /**
     * Exposes the current user to &lt;tt&gt;/me&lt;/tt&gt; URL.
     */
    public User getMe() {
<span class="nc" id="L3858">        User u = User.current();</span>
<span class="nc bnc" id="L3859" title="All 2 branches missed.">        if (u == null)</span>
<span class="nc" id="L3860">            throw new AccessDeniedException(&quot;/me is not available when not logged in&quot;);</span>
<span class="nc" id="L3861">        return u;</span>
    }

    /**
     * Gets the {@link Widget}s registered on this object.
     *
     * &lt;p&gt;
     * Plugins who wish to contribute boxes on the side panel can add widgets
     * by {@code getWidgets().add(new MyWidget())} from {@link Plugin#start()}.
     */
    public List&lt;Widget&gt; getWidgets() {
<span class="nc" id="L3872">        return widgets;</span>
    }

    public Object getTarget() {
        try {
<span class="nc" id="L3877">            checkPermission(READ);</span>
<span class="nc" id="L3878">        } catch (AccessDeniedException e) {</span>
<span class="nc" id="L3879">            String rest = Stapler.getCurrentRequest().getRestOfPath();</span>
<span class="nc bnc" id="L3880" title="All 2 branches missed.">            for (String name : ALWAYS_READABLE_PATHS) {</span>
<span class="nc bnc" id="L3881" title="All 2 branches missed.">                if (rest.startsWith(name)) {</span>
<span class="nc" id="L3882">                    return this;</span>
                }
            }
<span class="nc bnc" id="L3885" title="All 2 branches missed.">            for (String name : getUnprotectedRootActions()) {</span>
<span class="nc bnc" id="L3886" title="All 4 branches missed.">                if (rest.startsWith(&quot;/&quot; + name + &quot;/&quot;) || rest.equals(&quot;/&quot; + name)) {</span>
<span class="nc" id="L3887">                    return this;</span>
                }
            }

            // TODO SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access
<span class="nc bnc" id="L3892" title="All 2 branches missed.">            if (rest.matches(&quot;/computer/[^/]+/slave-agent[.]jnlp&quot;)</span>
<span class="nc bnc" id="L3893" title="All 2 branches missed.">                &amp;&amp; &quot;true&quot;.equals(Stapler.getCurrentRequest().getParameter(&quot;encrypt&quot;))) {</span>
<span class="nc" id="L3894">                return this;</span>
            }


<span class="nc" id="L3898">            throw e;</span>
        }
<span class="nc" id="L3900">        return this;</span>
    }

    /**
     * Gets a list of unprotected root actions.
     * These URL prefixes should be exempted from access control checks by container-managed security.
     * Ideally would be synchronized with {@link #getTarget}.
     * @return a list of {@linkplain Action#getUrlName URL names}
     * @since 1.495
     */
    public Collection&lt;String&gt; getUnprotectedRootActions() {
<span class="nc" id="L3911">        Set&lt;String&gt; names = new TreeSet&lt;String&gt;();</span>
<span class="nc" id="L3912">        names.add(&quot;jnlpJars&quot;); // TODO cleaner to refactor doJnlpJars into a URA</span>
        // TODO consider caching (expiring cache when actions changes)
<span class="nc bnc" id="L3914" title="All 2 branches missed.">        for (Action a : getActions()) {</span>
<span class="nc bnc" id="L3915" title="All 2 branches missed.">            if (a instanceof UnprotectedRootAction) {</span>
<span class="nc" id="L3916">                names.add(a.getUrlName());</span>
            }
        }
<span class="nc" id="L3919">        return names;</span>
    }

    /**
     * Fallback to the primary view.
     */
    public View getStaplerFallback() {
<span class="nc" id="L3926">        return getPrimaryView();</span>
    }

    /**
     * This method checks all existing jobs to see if displayName is
     * unique. It does not check the displayName against the displayName of the
     * job that the user is configuring though to prevent a validation warning
     * if the user sets the displayName to what it currently is.
     * @param displayName
     * @param currentJobName
     */
    boolean isDisplayNameUnique(String displayName, String currentJobName) {
<span class="nc" id="L3938">        Collection&lt;TopLevelItem&gt; itemCollection = items.values();</span>

        // if there are a lot of projects, we'll have to store their
        // display names in a HashSet or something for a quick check
<span class="nc bnc" id="L3942" title="All 2 branches missed.">        for(TopLevelItem item : itemCollection) {</span>
<span class="nc bnc" id="L3943" title="All 2 branches missed.">            if(item.getName().equals(currentJobName)) {</span>
                // we won't compare the candidate displayName against the current
                // item. This is to prevent an validation warning if the user
                // sets the displayName to what the existing display name is
<span class="nc" id="L3947">                continue;</span>
            }
<span class="nc bnc" id="L3949" title="All 2 branches missed.">            else if(displayName.equals(item.getDisplayName())) {</span>
<span class="nc" id="L3950">                return false;</span>
            }
        }

<span class="nc" id="L3954">        return true;</span>
    }

    /**
     * True if there is no item in Jenkins that has this name
     * @param name The name to test
     * @param currentJobName The name of the job that the user is configuring
     */
    boolean isNameUnique(String name, String currentJobName) {
<span class="nc" id="L3963">        Item item = getItem(name);</span>

<span class="nc bnc" id="L3965" title="All 2 branches missed.">        if(null==item) {</span>
            // the candidate name didn't return any items so the name is unique
<span class="nc" id="L3967">            return true;</span>
        }
<span class="nc bnc" id="L3969" title="All 2 branches missed.">        else if(item.getName().equals(currentJobName)) {</span>
            // the candidate name returned an item, but the item is the item
            // that the user is configuring so this is ok
<span class="nc" id="L3972">            return true;</span>
        }
        else {
            // the candidate name returned an item, so it is not unique
<span class="nc" id="L3976">            return false;</span>
        }
    }

    /**
     * Checks to see if the candidate displayName collides with any
     * existing display names or project names
     * @param displayName The display name to test
     * @param jobName The name of the job the user is configuring
     */
    public FormValidation doCheckDisplayName(@QueryParameter String displayName,
            @QueryParameter String jobName) {
<span class="nc" id="L3988">        displayName = displayName.trim();</span>

<span class="nc bnc" id="L3990" title="All 2 branches missed.">        if(LOGGER.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L3991">            LOGGER.log(Level.FINE, &quot;Current job name is &quot; + jobName);</span>
        }

<span class="nc bnc" id="L3994" title="All 2 branches missed.">        if(!isNameUnique(displayName, jobName)) {</span>
<span class="nc" id="L3995">            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_NameNotUniqueWarning(displayName));</span>
        }
<span class="nc bnc" id="L3997" title="All 2 branches missed.">        else if(!isDisplayNameUnique(displayName, jobName)){</span>
<span class="nc" id="L3998">            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_DisplayNameNotUniqueWarning(displayName));</span>
        }
        else {
<span class="nc" id="L4001">            return FormValidation.ok();</span>
        }
    }

    public static class MasterComputer extends Computer {
        protected MasterComputer() {
<span class="nc" id="L4007">            super(Jenkins.getInstance());</span>
<span class="nc" id="L4008">        }</span>

        /**
         * Returns &quot;&quot; to match with {@link Jenkins#getNodeName()}.
         */
        @Override
        public String getName() {
<span class="nc" id="L4015">            return &quot;&quot;;</span>
        }

        @Override
        public boolean isConnecting() {
<span class="nc" id="L4020">            return false;</span>
        }

        @Override
        public String getDisplayName() {
<span class="nc" id="L4025">            return Messages.Hudson_Computer_DisplayName();</span>
        }

        @Override
        public String getCaption() {
<span class="nc" id="L4030">            return Messages.Hudson_Computer_Caption();</span>
        }

        @Override
        public String getUrl() {
<span class="nc" id="L4035">            return &quot;computer/(master)/&quot;;</span>
        }

        public RetentionStrategy getRetentionStrategy() {
<span class="nc" id="L4039">            return RetentionStrategy.NOOP;</span>
        }

        /**
         * Will always keep this guy alive so that it can function as a fallback to
         * execute {@link FlyweightTask}s. See JENKINS-7291.
         */
        @Override
        protected boolean isAlive() {
<span class="nc" id="L4048">            return true;</span>
        }

        @Override
        public Boolean isUnix() {
<span class="nc bnc" id="L4053" title="All 2 branches missed.">            return !Functions.isWindows();</span>
        }

        /**
         * Report an error.
         */
        @Override
        public HttpResponse doDoDelete() throws IOException {
<span class="nc" id="L4061">            throw HttpResponses.status(SC_BAD_REQUEST);</span>
        }

        @Override
        public void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {
<span class="nc" id="L4066">            Jenkins.getInstance().doConfigExecutorsSubmit(req, rsp);</span>
<span class="nc" id="L4067">        }</span>

        @Override
        public boolean hasPermission(Permission permission) {
            // no one should be allowed to delete the master.
            // this hides the &quot;delete&quot; link from the /computer/(master) page.
<span class="nc bnc" id="L4073" title="All 2 branches missed.">            if(permission==Computer.DELETE)</span>
<span class="nc" id="L4074">                return false;</span>
            // Configuration of master node requires ADMINISTER permission
<span class="nc bnc" id="L4076" title="All 2 branches missed.">            return super.hasPermission(permission==Computer.CONFIGURE ? Jenkins.ADMINISTER : permission);</span>
        }

        @Override
        public VirtualChannel getChannel() {
<span class="nc" id="L4081">            return FilePath.localChannel;</span>
        }

        @Override
        public Charset getDefaultCharset() {
<span class="nc" id="L4086">            return Charset.defaultCharset();</span>
        }

        public List&lt;LogRecord&gt; getLogRecords() throws IOException, InterruptedException {
<span class="nc" id="L4090">            return logRecords;</span>
        }

        @RequirePOST
        public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
            // this computer never returns null from channel, so
            // this method shall never be invoked.
<span class="nc" id="L4097">            rsp.sendError(SC_NOT_FOUND);</span>
<span class="nc" id="L4098">        }</span>

        protected Future&lt;?&gt; _connect(boolean forceReconnect) {
<span class="nc" id="L4101">            return Futures.precomputed(null);</span>
        }

        /**
         * {@link LocalChannel} instance that can be used to execute programs locally.
         *
         * @deprecated as of 1.558
         *      Use {@link FilePath#localChannel}
         */
        @Deprecated
<span class="nc" id="L4111">        public static final LocalChannel localChannel = FilePath.localChannel;</span>
    }

    /**
     * Shortcut for {@code Jenkins.getInstance().lookup.get(type)}
     */
    public static @CheckForNull &lt;T&gt; T lookup(Class&lt;T&gt; type) {
<span class="nc" id="L4118">        Jenkins j = Jenkins.getInstance();</span>
<span class="nc bnc" id="L4119" title="All 2 branches missed.">        return j != null ? j.lookup.get(type) : null;</span>
    }

    /**
     * Live view of recent {@link LogRecord}s produced by Jenkins.
     */
<span class="fc" id="L4125">    public static List&lt;LogRecord&gt; logRecords = Collections.emptyList(); // initialized to dummy value to avoid NPE</span>

    /**
     * Thread-safe reusable {@link XStream}.
     */
    public static final XStream XSTREAM;

    /**
     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.
     */
    public static final XStream2 XSTREAM2;

<span class="fc" id="L4137">    private static final int TWICE_CPU_NUM = Math.max(4, Runtime.getRuntime().availableProcessors() * 2);</span>

    /**
     * Thread pool used to load configuration in parallel, to improve the start up time.
     * &lt;p&gt;
     * The idea here is to overlap the CPU and I/O, so we want more threads than CPU numbers.
     */
<span class="nc" id="L4144">    /*package*/ transient final ExecutorService threadPoolForLoad = new ThreadPoolExecutor(</span>
<span class="nc" id="L4145">        TWICE_CPU_NUM, TWICE_CPU_NUM,</span>
<span class="nc" id="L4146">        5L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), new NamingThreadFactory(new DaemonThreadFactory(), &quot;Jenkins load&quot;));</span>


    private static void computeVersion(ServletContext context) {
        // set the version
<span class="nc" id="L4151">        Properties props = new Properties();</span>
<span class="nc" id="L4152">        InputStream is = null;</span>
        try {
<span class="nc" id="L4154">            is = Jenkins.class.getResourceAsStream(&quot;jenkins-version.properties&quot;);</span>
<span class="nc bnc" id="L4155" title="All 2 branches missed.">            if(is!=null)</span>
<span class="nc" id="L4156">                props.load(is);</span>
<span class="nc" id="L4157">        } catch (IOException e) {</span>
<span class="nc" id="L4158">            e.printStackTrace(); // if the version properties is missing, that's OK.</span>
<span class="nc" id="L4159">        } finally {</span>
<span class="nc" id="L4160">            IOUtils.closeQuietly(is);</span>
<span class="nc" id="L4161">        }</span>
<span class="nc" id="L4162">        String ver = props.getProperty(&quot;version&quot;);</span>
<span class="nc bnc" id="L4163" title="All 2 branches missed.">        if(ver==null)   ver=&quot;?&quot;;</span>
<span class="nc" id="L4164">        VERSION = ver;</span>
<span class="nc" id="L4165">        context.setAttribute(&quot;version&quot;,ver);</span>

<span class="nc" id="L4167">        VERSION_HASH = Util.getDigestOf(ver).substring(0, 8);</span>
<span class="nc" id="L4168">        SESSION_HASH = Util.getDigestOf(ver+System.currentTimeMillis()).substring(0, 8);</span>

<span class="nc bnc" id="L4170" title="All 4 branches missed.">        if(ver.equals(&quot;?&quot;) || Boolean.getBoolean(&quot;hudson.script.noCache&quot;))</span>
<span class="nc" id="L4171">            RESOURCE_PATH = &quot;&quot;;</span>
        else
<span class="nc" id="L4173">            RESOURCE_PATH = &quot;/static/&quot;+SESSION_HASH;</span>

<span class="nc" id="L4175">        VIEW_RESOURCE_PATH = &quot;/resources/&quot;+ SESSION_HASH;</span>
<span class="nc" id="L4176">    }</span>

    /**
     * Version number of this Jenkins.
     */
<span class="fc" id="L4181">    public static String VERSION=&quot;?&quot;;</span>

    /**
     * Parses {@link #VERSION} into {@link VersionNumber}, or null if it's not parseable as a version number
     * (such as when Jenkins is run with &quot;mvn hudson-dev:run&quot;)
     */
    public static VersionNumber getVersion() {
        try {
<span class="nc" id="L4189">            return new VersionNumber(VERSION);</span>
<span class="nc" id="L4190">        } catch (NumberFormatException e) {</span>
            try {
                // for non-released version of Jenkins, this looks like &quot;1.345 (private-foobar), so try to approximate.
<span class="nc" id="L4193">                int idx = VERSION.indexOf(' ');</span>
<span class="nc bnc" id="L4194" title="All 2 branches missed.">                if (idx&gt;0)</span>
<span class="nc" id="L4195">                    return new VersionNumber(VERSION.substring(0,idx));</span>
<span class="nc" id="L4196">            } catch (NumberFormatException _) {</span>
                // fall through
            }

            // totally unparseable
<span class="nc" id="L4201">            return null;</span>
<span class="nc" id="L4202">        } catch (IllegalArgumentException e) {</span>
            // totally unparseable
<span class="nc" id="L4204">            return null;</span>
        }
    }

    /**
     * Hash of {@link #VERSION}.
     */
    public static String VERSION_HASH;

    /**
     * Unique random token that identifies the current session.
     * Used to make {@link #RESOURCE_PATH} unique so that we can set long &quot;Expires&quot; header.
     *
     * We used to use {@link #VERSION_HASH}, but making this session local allows us to
     * reuse the same {@link #RESOURCE_PATH} for static resources in plugins.
     */
    public static String SESSION_HASH;

    /**
     * Prefix to static resources like images and javascripts in the war file.
     * Either &quot;&quot; or strings like &quot;/static/VERSION&quot;, which avoids Jenkins to pick up
     * stale cache when the user upgrades to a different version.
     * &lt;p&gt;
     * Value computed in {@link WebAppMain}.
     */
<span class="fc" id="L4229">    public static String RESOURCE_PATH = &quot;&quot;;</span>

    /**
     * Prefix to resources alongside view scripts.
     * Strings like &quot;/resources/VERSION&quot;, which avoids Jenkins to pick up
     * stale cache when the user upgrades to a different version.
     * &lt;p&gt;
     * Value computed in {@link WebAppMain}.
     */
<span class="fc" id="L4238">    public static String VIEW_RESOURCE_PATH = &quot;/resources/TBD&quot;;</span>

<span class="fc" id="L4240">    public static boolean PARALLEL_LOAD = Configuration.getBooleanConfigParameter(&quot;parallelLoad&quot;, true);</span>
<span class="fc" id="L4241">    public static boolean KILL_AFTER_LOAD = Configuration.getBooleanConfigParameter(&quot;killAfterLoad&quot;, false);</span>
    /**
     * @deprecated No longer used.
     */
    @Deprecated
<span class="fc" id="L4246">    public static boolean FLYWEIGHT_SUPPORT = true;</span>

    /**
     * Tentative switch to activate the concurrent build behavior.
     * When we merge this back to the trunk, this allows us to keep
     * this feature hidden for a while until we iron out the kinks.
     * @see AbstractProject#isConcurrentBuild()
     * @deprecated as of 1.464
     *      This flag will have no effect.
     */
    @Restricted(NoExternalUse.class)
    @Deprecated
<span class="fc" id="L4258">    public static boolean CONCURRENT_BUILD = true;</span>

    /**
     * Switch to enable people to use a shorter workspace name.
     */
<span class="fc" id="L4263">    private static final String WORKSPACE_DIRNAME = Configuration.getStringConfigParameter(&quot;workspaceDirName&quot;, &quot;workspace&quot;);</span>

    /**
     * Automatically try to launch a slave when Jenkins is initialized or a new slave is created.
     */
<span class="fc" id="L4268">    public static boolean AUTOMATIC_SLAVE_LAUNCH = true;</span>

<span class="fc" id="L4270">    private static final Logger LOGGER = Logger.getLogger(Jenkins.class.getName());</span>

<span class="fc" id="L4272">    public static final PermissionGroup PERMISSIONS = Permission.HUDSON_PERMISSIONS;</span>
<span class="fc" id="L4273">    public static final Permission ADMINISTER = Permission.HUDSON_ADMINISTER;</span>
<span class="fc" id="L4274">    public static final Permission READ = new Permission(PERMISSIONS,&quot;Read&quot;,Messages._Hudson_ReadPermission_Description(),Permission.READ,PermissionScope.JENKINS);</span>
<span class="fc" id="L4275">    public static final Permission RUN_SCRIPTS = new Permission(PERMISSIONS, &quot;RunScripts&quot;, Messages._Hudson_RunScriptsPermission_Description(),ADMINISTER,PermissionScope.JENKINS);</span>

    /**
     * Urls that are always visible without READ permission.
     *
     * &lt;p&gt;See also:{@link #getUnprotectedRootActions}.
     */
<span class="fc" id="L4282">    private static final ImmutableSet&lt;String&gt; ALWAYS_READABLE_PATHS = ImmutableSet.of(</span>
<span class="fc" id="L4283">        &quot;/login&quot;,</span>
<span class="fc" id="L4284">        &quot;/logout&quot;,</span>
<span class="fc" id="L4285">        &quot;/accessDenied&quot;,</span>
<span class="fc" id="L4286">        &quot;/adjuncts/&quot;,</span>
<span class="fc" id="L4287">        &quot;/error&quot;,</span>
<span class="fc" id="L4288">        &quot;/oops&quot;,</span>
<span class="fc" id="L4289">        &quot;/signup&quot;,</span>
<span class="fc" id="L4290">        &quot;/tcpSlaveAgentListener&quot;,</span>
<span class="fc" id="L4291">        &quot;/federatedLoginService/&quot;,</span>
<span class="fc" id="L4292">        &quot;/securityRealm&quot;</span>
    );

    /**
     * {@link Authentication} object that represents the anonymous user.
     * Because Acegi creates its own {@link AnonymousAuthenticationToken} instances, the code must not
     * expect the singleton semantics. This is just a convenient instance.
     *
     * @since 1.343
     */
    public static final Authentication ANONYMOUS;

    static {
        try {
<span class="fc" id="L4306">            ANONYMOUS = new AnonymousAuthenticationToken(</span>
<span class="fc" id="L4307">                    &quot;anonymous&quot;, &quot;anonymous&quot;, new GrantedAuthority[]{new GrantedAuthorityImpl(&quot;anonymous&quot;)});</span>
<span class="fc" id="L4308">            XSTREAM = XSTREAM2 = new XStream2();</span>

<span class="fc" id="L4310">            XSTREAM.alias(&quot;jenkins&quot;, Jenkins.class);</span>
<span class="fc" id="L4311">            XSTREAM.alias(&quot;slave&quot;, DumbSlave.class);</span>
<span class="fc" id="L4312">            XSTREAM.alias(&quot;jdk&quot;, JDK.class);</span>
            // for backward compatibility with &lt;1.75, recognize the tag name &quot;view&quot; as well.
<span class="fc" id="L4314">            XSTREAM.alias(&quot;view&quot;, ListView.class);</span>
<span class="fc" id="L4315">            XSTREAM.alias(&quot;listView&quot;, ListView.class);</span>
<span class="fc" id="L4316">            XSTREAM2.addCriticalField(Jenkins.class, &quot;securityRealm&quot;);</span>
<span class="fc" id="L4317">            XSTREAM2.addCriticalField(Jenkins.class, &quot;authorizationStrategy&quot;);</span>
            // this seems to be necessary to force registration of converter early enough
<span class="fc" id="L4319">            Mode.class.getEnumConstants();</span>

            // double check that initialization order didn't do any harm
<span class="pc bpc" id="L4322" title="3 of 4 branches missed.">            assert PERMISSIONS != null;</span>
<span class="pc bpc" id="L4323" title="3 of 4 branches missed.">            assert ADMINISTER != null;</span>
<span class="nc" id="L4324">        } catch (RuntimeException e) {</span>
            // when loaded on a slave and this fails, subsequent NoClassDefFoundError will fail to chain the cause.
            // see http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8051847
            // As we don't know where the first exception will go, let's also send this to logging so that
            // we have a known place to look at.
<span class="nc" id="L4329">            LOGGER.log(SEVERE, &quot;Failed to load Jenkins.class&quot;, e);</span>
<span class="nc" id="L4330">            throw e;</span>
<span class="nc" id="L4331">        } catch (Error e) {</span>
<span class="nc" id="L4332">            LOGGER.log(SEVERE, &quot;Failed to load Jenkins.class&quot;, e);</span>
<span class="nc" id="L4333">            throw e;</span>
        }
<span class="fc" id="L4335">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>jenkins-core (22-mrt-2016 21:51:03)</div></body></html>