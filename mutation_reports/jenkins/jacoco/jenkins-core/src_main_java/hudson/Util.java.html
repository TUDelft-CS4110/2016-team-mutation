<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Util.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">jenkins-core (22-mrt-2016 21:51:03)</a> &gt; <a href="../../index.html" class="el_group">jenkins-core</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">hudson</a> &gt; <span class="el_source">Util.java</span></div><h1>Util.java</h1><pre class="source lang-java linenums">/*
 * The MIT License
 *
 * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package hudson;

import com.sun.jna.Memory;
import com.sun.jna.Native;
import com.sun.jna.NativeLong;

import edu.umd.cs.findbugs.annotations.SuppressWarnings;
import hudson.Proc.LocalProc;
import hudson.model.TaskListener;
import hudson.os.PosixAPI;
import hudson.util.QuotedStringTokenizer;
import hudson.util.VariableResolver;
import hudson.util.jna.WinIOException;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.time.FastDateFormat;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Chmod;
import org.apache.tools.ant.taskdefs.Copy;
import org.apache.tools.ant.types.FileSet;

import jnr.posix.FileStat;
import jnr.posix.POSIX;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import java.io.*;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.InetAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import hudson.util.jna.Kernel32Utils;
import static hudson.util.jna.GNUCLibrary.LIBC;

import java.security.DigestInputStream;

import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import org.apache.commons.codec.digest.DigestUtils;

/**
 * Various utility methods that don't have more proper home.
 *
 * @author Kohsuke Kawaguchi
 */
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">public class Util {</span>

    // Constant number of milliseconds in various time units.
    private static final long ONE_SECOND_MS = 1000;
    private static final long ONE_MINUTE_MS = 60 * ONE_SECOND_MS;
    private static final long ONE_HOUR_MS = 60 * ONE_MINUTE_MS;
    private static final long ONE_DAY_MS = 24 * ONE_HOUR_MS;
    private static final long ONE_MONTH_MS = 30 * ONE_DAY_MS;
    private static final long ONE_YEAR_MS = 365 * ONE_DAY_MS;

    /**
     * Creates a filtered sublist.
     * @since 1.176
     */
    @Nonnull
    public static &lt;T&gt; List&lt;T&gt; filter( @Nonnull Iterable&lt;?&gt; base, @Nonnull Class&lt;T&gt; type ) {
<span class="nc" id="L110">        List&lt;T&gt; r = new ArrayList&lt;T&gt;();</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        for (Object i : base) {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">            if(type.isInstance(i))</span>
<span class="nc" id="L113">                r.add(type.cast(i));</span>
        }
<span class="nc" id="L115">        return r;</span>
    }

    /**
     * Creates a filtered sublist.
     */
    @Nonnull
    public static &lt;T&gt; List&lt;T&gt; filter( @Nonnull List&lt;?&gt; base, @Nonnull Class&lt;T&gt; type ) {
<span class="nc" id="L123">        return filter((Iterable)base,type);</span>
    }

    /**
     * Pattern for capturing variables. Either $xyz, ${xyz} or ${a.b} but not $a.b, while ignoring &quot;$$&quot;
      */
<span class="fc" id="L129">    private static final Pattern VARIABLE = Pattern.compile(&quot;\\$([A-Za-z0-9_]+|\\{[A-Za-z0-9_.]+\\}|\\$)&quot;);</span>

    /**
     * Replaces the occurrence of '$key' by &lt;tt&gt;properties.get('key')&lt;/tt&gt;.
     *
     * &lt;p&gt;
     * Unlike shell, undefined variables are left as-is (this behavior is the same as Ant.)
     *
     */
    @Nullable
    public static String replaceMacro( @CheckForNull String s, @Nonnull Map&lt;String,String&gt; properties) {
<span class="fc" id="L140">        return replaceMacro(s,new VariableResolver.ByMap&lt;String&gt;(properties));</span>
    }

    /**
     * Replaces the occurrence of '$key' by &lt;tt&gt;resolver.get('key')&lt;/tt&gt;.
     *
     * &lt;p&gt;
     * Unlike shell, undefined variables are left as-is (this behavior is the same as Ant.)
     */
    @Nullable
    public static String replaceMacro(@CheckForNull String s, @Nonnull VariableResolver&lt;String&gt; resolver) {
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">    	if (s == null) {</span>
<span class="nc" id="L152">    		return null;</span>
    	}

<span class="fc" id="L155">        int idx=0;</span>
<span class="fc" id="L156">        while(true) {</span>
<span class="fc" id="L157">            Matcher m = VARIABLE.matcher(s);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">            if(!m.find(idx))   return s;</span>

<span class="fc" id="L160">            String key = m.group().substring(1);</span>

            // escape the dollar sign or get the key to resolve
            String value;
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if(key.charAt(0)=='$') {</span>
<span class="fc" id="L165">               value = &quot;$&quot;;</span>
<span class="fc" id="L166">            } else {</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">               if(key.charAt(0)=='{')  key = key.substring(1,key.length()-1);</span>
<span class="fc" id="L168">               value = resolver.resolve(key);</span>
            }

<span class="fc bfc" id="L171" title="All 2 branches covered.">            if(value==null)</span>
<span class="fc" id="L172">                idx = m.end(); // skip this</span>
            else {
<span class="fc" id="L174">                s = s.substring(0,m.start())+value+s.substring(m.end());</span>
<span class="fc" id="L175">                idx = m.start() + value.length();</span>
            }
        }
    }

    /**
     * Loads the contents of a file into a string.
     */
    @Nonnull
    public static String loadFile(@Nonnull File logfile) throws IOException {
<span class="nc" id="L185">        return loadFile(logfile, Charset.defaultCharset());</span>
    }

    @Nonnull
    public static String loadFile(@Nonnull File logfile, @Nonnull Charset charset) throws IOException {
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if(!logfile.exists())</span>
<span class="nc" id="L191">            return &quot;&quot;;</span>

<span class="nc" id="L193">        StringBuilder str = new StringBuilder((int)logfile.length());</span>

<span class="nc" id="L195">        BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(logfile),charset));</span>
        try {
<span class="nc" id="L197">            char[] buf = new char[1024];</span>
            int len;
<span class="nc bnc" id="L199" title="All 2 branches missed.">            while((len=r.read(buf,0,buf.length))&gt;0)</span>
<span class="nc" id="L200">               str.append(buf,0,len);</span>
<span class="nc" id="L201">        } finally {</span>
<span class="nc" id="L202">            r.close();</span>
<span class="nc" id="L203">        }</span>

<span class="nc" id="L205">        return str.toString();</span>
    }

    /**
     * Deletes the contents of the given directory (but not the directory itself)
     * recursively.
     *
     * @throws IOException
     *      if the operation fails.
     */
    public static void deleteContentsRecursive(@Nonnull File file) throws IOException {
<span class="fc" id="L216">        File[] files = file.listFiles();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if(files==null)</span>
<span class="fc" id="L218">            return;     // the directory didn't exist in the first place</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        for (File child : files)</span>
<span class="fc" id="L220">            deleteRecursive(child);</span>
<span class="fc" id="L221">    }</span>

    /**
     * Deletes this file (and does not take no for an answer).
     * @param f a file to delete
     * @throws IOException if it exists but could not be successfully deleted
     */
    public static void deleteFile(@Nonnull File f) throws IOException {
<span class="fc bfc" id="L229" title="All 2 branches covered.">        if (!f.delete()) {</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            if(!f.exists())</span>
                // we are trying to delete a file that no longer exists, so this is not an error
<span class="nc" id="L232">                return;</span>

            // perhaps this file is read-only?
<span class="fc" id="L235">            makeWritable(f);</span>
            /*
             on Unix both the file and the directory that contains it has to be writable
             for a file deletion to be successful. (Confirmed on Solaris 9)

             $ ls -la
             total 6
             dr-xr-sr-x   2 hudson   hudson       512 Apr 18 14:41 .
             dr-xr-sr-x   3 hudson   hudson       512 Apr 17 19:36 ..
             -r--r--r--   1 hudson   hudson       469 Apr 17 19:36 manager.xml
             -rw-r--r--   1 hudson   hudson         0 Apr 18 14:41 x
             $ rm x
             rm: x not removed: Permission denied
             */

<span class="fc" id="L250">            makeWritable(f.getParentFile());</span>

<span class="pc bpc" id="L252" title="2 of 4 branches missed.">            if(!f.delete() &amp;&amp; f.exists()) {</span>
                // trouble-shooting.
                try {
<span class="nc" id="L255">                    Class.forName(&quot;java.nio.file.Files&quot;).getMethod(&quot;delete&quot;, Class.forName(&quot;java.nio.file.Path&quot;)).invoke(null, File.class.getMethod(&quot;toPath&quot;).invoke(f));</span>
<span class="pc" id="L256">                } catch (InvocationTargetException x) {</span>
<span class="fc" id="L257">                    Throwable x2 = x.getCause();</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">                    if (x2 instanceof IOException) {</span>
                        // may have a specific exception message
<span class="fc" id="L260">                        throw (IOException) x2;</span>
                    }
                    // else suppress
<span class="nc" id="L263">                } catch (Throwable x) {</span>
                    // linkage errors, etc.; suppress
                }
                // see http://www.nabble.com/Sometimes-can%27t-delete-files-from-hudson.scm.SubversionSCM%24CheckOutTask.invoke%28%29-tt17333292.html
                // I suspect other processes putting files in this directory
<span class="nc" id="L268">                File[] files = f.listFiles();</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">                if(files!=null &amp;&amp; files.length&gt;0)</span>
<span class="nc" id="L270">                    throw new IOException(&quot;Unable to delete &quot; + f.getPath()+&quot; - files in dir: &quot;+Arrays.asList(files));</span>
<span class="nc" id="L271">                throw new IOException(&quot;Unable to delete &quot; + f.getPath());</span>
            }
        }
<span class="fc" id="L274">    }</span>

    /**
     * Makes the given file writable by any means possible.
     */
    private static void makeWritable(@Nonnull File f) {
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (f.setWritable(true)) {</span>
<span class="fc" id="L281">            return;</span>
        }
        // TODO do we still need to try anything else?

        // try chmod. this becomes no-op if this is not Unix.
        try {
<span class="fc" id="L287">            Chmod chmod = new Chmod();</span>
<span class="fc" id="L288">            chmod.setProject(new Project());</span>
<span class="fc" id="L289">            chmod.setFile(f);</span>
<span class="fc" id="L290">            chmod.setPerm(&quot;u+w&quot;);</span>
<span class="fc" id="L291">            chmod.execute();</span>
<span class="pc" id="L292">        } catch (BuildException e) {</span>
<span class="nc" id="L293">            LOGGER.log(Level.INFO,&quot;Failed to chmod &quot;+f,e);</span>
        }

        try {// try libc chmod
<span class="fc" id="L297">            POSIX posix = PosixAPI.jnr();</span>
<span class="fc" id="L298">            String path = f.getAbsolutePath();</span>
<span class="fc" id="L299">            FileStat stat = posix.stat(path);</span>
<span class="fc" id="L300">            posix.chmod(path, stat.mode()|0200); // u+w</span>
<span class="pc" id="L301">        } catch (Throwable t) {</span>
<span class="nc" id="L302">            LOGGER.log(Level.FINE,&quot;Failed to chmod(2) &quot;+f,t);</span>
        }

<span class="fc" id="L305">    }</span>

    public static void deleteRecursive(@Nonnull File dir) throws IOException {
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if(!isSymlink(dir))</span>
<span class="fc" id="L309">            deleteContentsRecursive(dir);</span>
        try {
<span class="fc" id="L311">            deleteFile(dir);</span>
<span class="fc" id="L312">        } catch (IOException e) {</span>
            // if some of the child directories are big, it might take long enough to delete that
            // it allows others to create new files, causing problemsl ike JENKINS-10113
            // so give it one more attempt before we give up.
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if(!isSymlink(dir))</span>
<span class="fc" id="L317">                deleteContentsRecursive(dir);</span>
<span class="nc" id="L318">            deleteFile(dir);</span>
        }
<span class="fc" id="L320">    }</span>

    /*
     * Copyright 2001-2004 The Apache Software Foundation.
     *
     * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Checks if the given file represents a symlink.
     */
    //Taken from http://svn.apache.org/viewvc/maven/shared/trunk/file-management/src/main/java/org/apache/maven/shared/model/fileset/util/FileSetManager.java?view=markup
    public static boolean isSymlink(@Nonnull File file) throws IOException {
<span class="fc" id="L342">        Boolean r = isSymlinkJava7(file);</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        if (r != null) {</span>
<span class="fc" id="L344">            return r;</span>
        }
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (Functions.isWindows()) {</span>
            try {
<span class="nc" id="L348">                return Kernel32Utils.isJunctionOrSymlink(file);</span>
<span class="nc" id="L349">            } catch (UnsupportedOperationException e) {</span>
                // fall through
<span class="nc" id="L351">            } catch (LinkageError e) {</span>
                // fall through
            }
        }
<span class="nc" id="L355">        String name = file.getName();</span>
<span class="nc bnc" id="L356" title="All 4 branches missed.">        if (name.equals(&quot;.&quot;) || name.equals(&quot;..&quot;))</span>
<span class="nc" id="L357">            return false;</span>

        File fileInCanonicalParent;
<span class="nc" id="L360">        File parentDir = file.getParentFile();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if ( parentDir == null ) {</span>
<span class="nc" id="L362">            fileInCanonicalParent = file;</span>
<span class="nc" id="L363">        } else {</span>
<span class="nc" id="L364">            fileInCanonicalParent = new File( parentDir.getCanonicalPath(), name );</span>
        }
<span class="nc bnc" id="L366" title="All 2 branches missed.">        return !fileInCanonicalParent.getCanonicalFile().equals( fileInCanonicalParent.getAbsoluteFile() );</span>
    }

    @SuppressWarnings(&quot;NP_BOOLEAN_RETURN_NULL&quot;)
    private static Boolean isSymlinkJava7(@Nonnull File file) throws IOException {
        try {
<span class="fc" id="L372">            Object path = File.class.getMethod(&quot;toPath&quot;).invoke(file);</span>
<span class="fc" id="L373">            return (Boolean) Class.forName(&quot;java.nio.file.Files&quot;).getMethod(&quot;isSymbolicLink&quot;, Class.forName(&quot;java.nio.file.Path&quot;)).invoke(null, path);</span>
<span class="nc" id="L374">        } catch (NoSuchMethodException x) {</span>
<span class="nc" id="L375">            return null; // fine, Java 6</span>
<span class="nc" id="L376">        } catch (Exception x) {</span>
<span class="nc" id="L377">            throw (IOException) new IOException(x.toString()).initCause(x);</span>
        }
    }

    /**
     * A mostly accurate check of whether a path is a relative path or not. This is designed to take a path against
     * an unknown operating system so may give invalid results.
     *
     * @param path the path.
     * @return {@code true} if the path looks relative.
     * @since 1.606
     */
    public static boolean isRelativePath(String path) {
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (path.startsWith(&quot;/&quot;))</span>
<span class="fc" id="L391">            return false;</span>
<span class="pc bpc" id="L392" title="1 of 6 branches missed.">        if (path.startsWith(&quot;\\\\&quot;) &amp;&amp; path.length() &gt; 3 &amp;&amp; path.indexOf('\\', 3) != -1)</span>
<span class="fc" id="L393">            return false; // a UNC path which is the most absolute you can get on windows</span>
<span class="fc bfc" id="L394" title="All 4 branches covered.">        if (path.length() &gt;= 3 &amp;&amp; ':' == path.charAt(1)) {</span>
            // never mind that the drive mappings can be changed between sessions, we just want to
            // know if the 3rd character is a `\` (or a '/' is acceptable too)
<span class="fc" id="L397">            char p = path.charAt(0);</span>
<span class="pc bpc" id="L398" title="4 of 8 branches missed.">            if (('A' &lt;= p &amp;&amp; p &lt;= 'Z') || ('a' &lt;= p &amp;&amp; p &lt;= 'z')) {</span>
<span class="fc bfc" id="L399" title="All 4 branches covered.">                return path.charAt(2) != '\\' &amp;&amp; path.charAt(2) != '/';</span>
            }
        }
<span class="fc" id="L402">        return true;</span>
    }

    /**
     * Creates a new temporary directory.
     */
    public static File createTempDir() throws IOException {
<span class="fc" id="L409">        File tmp = File.createTempFile(&quot;hudson&quot;, &quot;tmp&quot;);</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">        if(!tmp.delete())</span>
<span class="nc" id="L411">            throw new IOException(&quot;Failed to delete &quot;+tmp);</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if(!tmp.mkdirs())</span>
<span class="nc" id="L413">            throw new IOException(&quot;Failed to create a new directory &quot;+tmp);</span>
<span class="fc" id="L414">        return tmp;</span>
    }

<span class="fc" id="L417">    private static final Pattern errorCodeParser = Pattern.compile(&quot;.*CreateProcess.*error=([0-9]+).*&quot;);</span>

    /**
     * On Windows, error messages for IOException aren't very helpful.
     * This method generates additional user-friendly error message to the listener
     */
    public static void displayIOException(@Nonnull IOException e, @Nonnull TaskListener listener ) {
<span class="nc" id="L424">        String msg = getWin32ErrorMessage(e);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if(msg!=null)</span>
<span class="nc" id="L426">            listener.getLogger().println(msg);</span>
<span class="nc" id="L427">    }</span>

    @CheckForNull
    public static String getWin32ErrorMessage(@Nonnull IOException e) {
<span class="nc" id="L431">        return getWin32ErrorMessage((Throwable)e);</span>
    }

    /**
     * Extracts the Win32 error message from {@link Throwable} if possible.
     *
     * @return
     *      null if there seems to be no error code or if the platform is not Win32.
     */
    @CheckForNull
    public static String getWin32ErrorMessage(Throwable e) {
<span class="nc" id="L442">        String msg = e.getMessage();</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        if(msg!=null) {</span>
<span class="nc" id="L444">            Matcher m = errorCodeParser.matcher(msg);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if(m.matches()) {</span>
                try {
<span class="nc" id="L447">                    ResourceBundle rb = ResourceBundle.getBundle(&quot;/hudson/win32errors&quot;);</span>
<span class="nc" id="L448">                    return rb.getString(&quot;error&quot;+m.group(1));</span>
<span class="nc" id="L449">                } catch (Exception _) {</span>
                    // silently recover from resource related failures
                }
            }
        }

<span class="nc bnc" id="L455" title="All 2 branches missed.">        if(e.getCause()!=null)</span>
<span class="nc" id="L456">            return getWin32ErrorMessage(e.getCause());</span>
<span class="nc" id="L457">        return null; // no message</span>
    }

    /**
     * Gets a human readable message for the given Win32 error code.
     *
     * @return
     *      null if no such message is available.
     */
    @CheckForNull
    public static String getWin32ErrorMessage(int n) {
        try {
<span class="nc" id="L469">            ResourceBundle rb = ResourceBundle.getBundle(&quot;/hudson/win32errors&quot;);</span>
<span class="nc" id="L470">            return rb.getString(&quot;error&quot;+n);</span>
<span class="nc" id="L471">        } catch (MissingResourceException e) {</span>
<span class="nc" id="L472">            LOGGER.log(Level.WARNING,&quot;Failed to find resource bundle&quot;,e);</span>
<span class="nc" id="L473">            return null;</span>
        }
    }

    /**
     * Guesses the current host name.
     */
    @Nonnull
    public static String getHostName() {
        try {
<span class="nc" id="L483">            return InetAddress.getLocalHost().getHostName();</span>
<span class="nc" id="L484">        } catch (UnknownHostException e) {</span>
<span class="nc" id="L485">            return &quot;localhost&quot;;</span>
        }
    }

    public static void copyStream(@Nonnull InputStream in,@Nonnull OutputStream out) throws IOException {
<span class="fc" id="L490">        byte[] buf = new byte[8192];</span>
        int len;
<span class="fc bfc" id="L492" title="All 2 branches covered.">        while((len=in.read(buf))&gt;=0)</span>
<span class="fc" id="L493">            out.write(buf,0,len);</span>
<span class="fc" id="L494">    }</span>

    public static void copyStream(@Nonnull Reader in, @Nonnull Writer out) throws IOException {
<span class="nc" id="L497">        char[] buf = new char[8192];</span>
        int len;
<span class="nc bnc" id="L499" title="All 2 branches missed.">        while((len=in.read(buf))&gt;0)</span>
<span class="nc" id="L500">            out.write(buf,0,len);</span>
<span class="nc" id="L501">    }</span>

    public static void copyStreamAndClose(@Nonnull InputStream in, @Nonnull OutputStream out) throws IOException {
        try {
<span class="nc" id="L505">            copyStream(in,out);</span>
<span class="nc" id="L506">        } finally {</span>
<span class="nc" id="L507">            IOUtils.closeQuietly(in);</span>
<span class="nc" id="L508">            IOUtils.closeQuietly(out);</span>
<span class="nc" id="L509">        }</span>
<span class="nc" id="L510">    }</span>

    public static void copyStreamAndClose(@Nonnull Reader in, @Nonnull Writer out) throws IOException {
        try {
<span class="nc" id="L514">            copyStream(in,out);</span>
<span class="nc" id="L515">        } finally {</span>
<span class="nc" id="L516">            IOUtils.closeQuietly(in);</span>
<span class="nc" id="L517">            IOUtils.closeQuietly(out);</span>
<span class="nc" id="L518">        }</span>
<span class="nc" id="L519">    }</span>

    /**
     * Tokenizes the text separated by delimiters.
     *
     * &lt;p&gt;
     * In 1.210, this method was changed to handle quotes like Unix shell does.
     * Before that, this method just used {@link StringTokenizer}.
     *
     * @since 1.145
     * @see QuotedStringTokenizer
     */
    @Nonnull
    public static String[] tokenize(@Nonnull String s, @CheckForNull String delimiter) {
<span class="fc" id="L533">        return QuotedStringTokenizer.tokenize(s,delimiter);</span>
    }

    @Nonnull
    public static String[] tokenize(@Nonnull String s) {
<span class="nc" id="L538">        return tokenize(s,&quot; \t\n\r\f&quot;);</span>
    }

    /**
     * Converts the map format of the environment variables to the K=V format in the array.
     */
    @Nonnull
    public static String[] mapToEnv(@Nonnull Map&lt;String,String&gt; m) {
<span class="fc" id="L546">        String[] r = new String[m.size()];</span>
<span class="fc" id="L547">        int idx=0;</span>

<span class="fc bfc" id="L549" title="All 2 branches covered.">        for (final Map.Entry&lt;String,String&gt; e : m.entrySet()) {</span>
<span class="fc" id="L550">            r[idx++] = e.getKey() + '=' + e.getValue();</span>
        }
<span class="fc" id="L552">        return r;</span>
    }

    public static int min(int x, @Nonnull int... values) {
<span class="nc bnc" id="L556" title="All 2 branches missed.">        for (int i : values) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            if(i&lt;x)</span>
<span class="nc" id="L558">                x=i;</span>
        }
<span class="nc" id="L560">        return x;</span>
    }

    @CheckForNull
    public static String nullify(@CheckForNull String v) {
<span class="fc" id="L565">        return fixEmpty(v);</span>
    }

    @Nonnull
    public static String removeTrailingSlash(@Nonnull String s) {
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if(s.endsWith(&quot;/&quot;)) return s.substring(0,s.length()-1);</span>
<span class="nc" id="L571">        else                return s;</span>
    }


    /**
     * Ensure string ends with suffix
     *
     * @param subject Examined string
     * @param suffix  Desired suffix
     * @return Original subject in case it already ends with suffix, null in
     *         case subject was null and subject + suffix otherwise.
     * @since 1.505
     */
    @Nullable
    public static String ensureEndsWith(@CheckForNull String subject, @CheckForNull String suffix) {

<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (subject == null) return null;</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (subject.endsWith(suffix)) return subject;</span>

<span class="nc" id="L591">        return subject + suffix;</span>
    }

    /**
     * Computes MD5 digest of the given input stream.
     *
     * @param source
     *      The stream will be closed by this method at the end of this method.
     * @return
     *      32-char wide string
     * @see DigestUtils#md5Hex(InputStream)
     */
    @Nonnull
    public static String getDigestOf(@Nonnull InputStream source) throws IOException {
        try {
<span class="fc" id="L606">            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span>

<span class="fc" id="L608">            byte[] buffer = new byte[1024];</span>
<span class="fc" id="L609">            DigestInputStream in =new DigestInputStream(source,md5);</span>
            try {
<span class="fc bfc" id="L611" title="All 2 branches covered.">                while(in.read(buffer)&gt;=0)</span>
                    ; // simply discard the input
<span class="pc" id="L613">            } finally {</span>
<span class="pc" id="L614">                in.close();</span>
<span class="nc" id="L615">            }</span>
<span class="fc" id="L616">            return toHexString(md5.digest());</span>
<span class="nc" id="L617">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L618">            throw new IOException(&quot;MD5 not installed&quot;,e);    // impossible</span>
        }
        /* JENKINS-18178: confuses Maven 2 runner
        try {
            return DigestUtils.md5Hex(source);
        } finally {
            source.close();
        }
        */
    }

    @Nonnull
    public static String getDigestOf(@Nonnull String text) {
        try {
<span class="fc" id="L632">            return getDigestOf(new ByteArrayInputStream(text.getBytes(&quot;UTF-8&quot;)));</span>
<span class="nc" id="L633">        } catch (IOException e) {</span>
<span class="nc" id="L634">            throw new Error(e);</span>
        }
    }

    /**
     * Computes the MD5 digest of a file.
     * @param file a file
     * @return a 32-character string
     * @throws IOException in case reading fails
     * @since 1.525
     */
    @Nonnull
    public static String getDigestOf(@Nonnull File file) throws IOException {
<span class="fc" id="L647">        InputStream is = new FileInputStream(file);</span>
        try {
<span class="fc" id="L649">            return getDigestOf(new BufferedInputStream(is));</span>
<span class="nc" id="L650">        } finally {</span>
<span class="pc" id="L651">            is.close();</span>
<span class="nc" id="L652">        }</span>
    }

    /**
     * Converts a string into 128-bit AES key.
     * @since 1.308
     */
    @Nonnull
    public static SecretKey toAes128Key(@Nonnull String s) {
        try {
            // turn secretKey into 256 bit hash
<span class="nc" id="L663">            MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);</span>
<span class="nc" id="L664">            digest.reset();</span>
<span class="nc" id="L665">            digest.update(s.getBytes(&quot;UTF-8&quot;));</span>

            // Due to the stupid US export restriction JDK only ships 128bit version.
<span class="nc" id="L668">            return new SecretKeySpec(digest.digest(),0,128/8, &quot;AES&quot;);</span>
<span class="nc" id="L669">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L670">            throw new Error(e);</span>
<span class="nc" id="L671">        } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L672">            throw new Error(e);</span>
        }
    }

    @Nonnull
    public static String toHexString(@Nonnull byte[] data, int start, int len) {
<span class="fc" id="L678">        StringBuilder buf = new StringBuilder();</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">        for( int i=0; i&lt;len; i++ ) {</span>
<span class="fc" id="L680">            int b = data[start+i]&amp;0xFF;</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">            if(b&lt;16)    buf.append('0');</span>
<span class="fc" id="L682">            buf.append(Integer.toHexString(b));</span>
        }
<span class="fc" id="L684">        return buf.toString();</span>
    }

    @Nonnull
    public static String toHexString(@Nonnull byte[] bytes) {
<span class="fc" id="L689">        return toHexString(bytes,0,bytes.length);</span>
    }

    @Nonnull
    public static byte[] fromHexString(@Nonnull String data) {
<span class="fc" id="L694">        byte[] r = new byte[data.length() / 2];</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length(); i += 2)</span>
<span class="fc" id="L696">            r[i / 2] = (byte) Integer.parseInt(data.substring(i, i + 2), 16);</span>
<span class="fc" id="L697">        return r;</span>
    }

    /**
     * Returns a human readable text of the time duration, for example &quot;3 minutes 40 seconds&quot;.
     * This version should be used for representing a duration of some activity (like build)
     *
     * @param duration
     *      number of milliseconds.
     */
    @Nonnull
    public static String getTimeSpanString(long duration) {
        // Break the duration up in to units.
<span class="fc" id="L710">        long years = duration / ONE_YEAR_MS;</span>
<span class="fc" id="L711">        duration %= ONE_YEAR_MS;</span>
<span class="fc" id="L712">        long months = duration / ONE_MONTH_MS;</span>
<span class="fc" id="L713">        duration %= ONE_MONTH_MS;</span>
<span class="fc" id="L714">        long days = duration / ONE_DAY_MS;</span>
<span class="fc" id="L715">        duration %= ONE_DAY_MS;</span>
<span class="fc" id="L716">        long hours = duration / ONE_HOUR_MS;</span>
<span class="fc" id="L717">        duration %= ONE_HOUR_MS;</span>
<span class="fc" id="L718">        long minutes = duration / ONE_MINUTE_MS;</span>
<span class="fc" id="L719">        duration %= ONE_MINUTE_MS;</span>
<span class="fc" id="L720">        long seconds = duration / ONE_SECOND_MS;</span>
<span class="fc" id="L721">        duration %= ONE_SECOND_MS;</span>
<span class="fc" id="L722">        long millisecs = duration;</span>

<span class="fc bfc" id="L724" title="All 2 branches covered.">        if (years &gt; 0)</span>
<span class="fc" id="L725">            return makeTimeSpanString(years, Messages.Util_year(years), months, Messages.Util_month(months));</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">        else if (months &gt; 0)</span>
<span class="fc" id="L727">            return makeTimeSpanString(months, Messages.Util_month(months), days, Messages.Util_day(days));</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        else if (days &gt; 0)</span>
<span class="nc" id="L729">            return makeTimeSpanString(days, Messages.Util_day(days), hours, Messages.Util_hour(hours));</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">        else if (hours &gt; 0)</span>
<span class="nc" id="L731">            return makeTimeSpanString(hours, Messages.Util_hour(hours), minutes, Messages.Util_minute(minutes));</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">        else if (minutes &gt; 0)</span>
<span class="fc" id="L733">            return makeTimeSpanString(minutes, Messages.Util_minute(minutes), seconds, Messages.Util_second(seconds));</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">        else if (seconds &gt;= 10)</span>
<span class="fc" id="L735">            return Messages.Util_second(seconds);</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">        else if (seconds &gt;= 1)</span>
<span class="fc" id="L737">            return Messages.Util_second(seconds+(float)(millisecs/100)/10); // render &quot;1.2 sec&quot;</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">        else if(millisecs&gt;=100)</span>
<span class="fc" id="L739">            return Messages.Util_second((float)(millisecs/10)/100); // render &quot;0.12 sec&quot;.</span>
        else
<span class="fc" id="L741">            return Messages.Util_millisecond(millisecs);</span>
    }


    /**
     * Create a string representation of a time duration.  If the quantity of
     * the most significant unit is big (&gt;=10), then we use only that most
     * significant unit in the string representation. If the quantity of the
     * most significant unit is small (a single-digit value), then we also
     * use a secondary, smaller unit for increased precision.
     * So 13 minutes and 43 seconds returns just &quot;13 minutes&quot;, but 3 minutes
     * and 43 seconds is &quot;3 minutes 43 seconds&quot;.
     */
    @Nonnull
    private static String makeTimeSpanString(long bigUnit,
                                             @Nonnull String bigLabel,
                                             long smallUnit,
                                             @Nonnull String smallLabel) {
<span class="fc" id="L759">        String text = bigLabel;</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">        if (bigUnit &lt; 10)</span>
<span class="fc" id="L761">            text += ' ' + smallLabel;</span>
<span class="fc" id="L762">        return text;</span>
    }


    /**
     * Get a human readable string representing strings like &quot;xxx days ago&quot;,
     * which should be used to point to the occurrence of an event in the past.
     */
    @Nonnull
    public static String getPastTimeString(long duration) {
<span class="nc" id="L772">        return Messages.Util_pastTime(getTimeSpanString(duration));</span>
    }


    /**
     * Combines number and unit, with a plural suffix if needed.
     *
     * @deprecated
     *   Use individual localization methods instead.
     *   See {@link Messages#Util_year(Object)} for an example.
     *   Deprecated since 2009-06-24, remove method after 2009-12-24.
     */
    @Nonnull
    @Deprecated
    public static String combine(long n, @Nonnull String suffix) {
<span class="nc" id="L787">        String s = Long.toString(n)+' '+suffix;</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">        if(n!=1)</span>
        	// Just adding an 's' won't work in most natural languages, even English has exception to the rule (e.g. copy/copies).
<span class="nc" id="L790">            s += &quot;s&quot;;</span>
<span class="nc" id="L791">        return s;</span>
    }

    /**
     * Create a sub-list by only picking up instances of the specified type.
     */
    @Nonnull
    public static &lt;T&gt; List&lt;T&gt; createSubList(@Nonnull Collection&lt;?&gt; source, @Nonnull Class&lt;T&gt; type ) {
<span class="nc" id="L799">        List&lt;T&gt; r = new ArrayList&lt;T&gt;();</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">        for (Object item : source) {</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">            if(type.isInstance(item))</span>
<span class="nc" id="L802">                r.add(type.cast(item));</span>
        }
<span class="nc" id="L804">        return r;</span>
    }

    /**
     * Escapes non-ASCII characters in URL.
     *
     * &lt;p&gt;
     * Note that this methods only escapes non-ASCII but leaves other URL-unsafe characters,
     * such as '#'.
     * {@link #rawEncode(String)} should generally be used instead, though be careful to pass only
     * a single path component to that method (it will encode /, but this method does not).
     */
    @Nonnull
    public static String encode(@Nonnull String s) {
        try {
<span class="fc" id="L819">            boolean escaped = false;</span>

<span class="fc" id="L821">            StringBuilder out = new StringBuilder(s.length());</span>

<span class="fc" id="L823">            ByteArrayOutputStream buf = new ByteArrayOutputStream();</span>
<span class="fc" id="L824">            OutputStreamWriter w = new OutputStreamWriter(buf,&quot;UTF-8&quot;);</span>

<span class="fc bfc" id="L826" title="All 2 branches covered.">            for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="fc" id="L827">                int c = s.charAt(i);</span>
<span class="pc bpc" id="L828" title="1 of 4 branches missed.">                if (c&lt;128 &amp;&amp; c!=' ') {</span>
<span class="fc" id="L829">                    out.append((char) c);</span>
<span class="fc" id="L830">                } else {</span>
                    // 1 char -&gt; UTF8
<span class="fc" id="L832">                    w.write(c);</span>
<span class="fc" id="L833">                    w.flush();</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">                    for (byte b : buf.toByteArray()) {</span>
<span class="fc" id="L835">                        out.append('%');</span>
<span class="fc" id="L836">                        out.append(toDigit((b &gt;&gt; 4) &amp; 0xF));</span>
<span class="fc" id="L837">                        out.append(toDigit(b &amp; 0xF));</span>
                    }
<span class="fc" id="L839">                    buf.reset();</span>
<span class="fc" id="L840">                    escaped = true;</span>
                }
            }

<span class="pc bpc" id="L844" title="1 of 2 branches missed.">            return escaped ? out.toString() : s;</span>
<span class="nc" id="L845">        } catch (IOException e) {</span>
<span class="nc" id="L846">            throw new Error(e); // impossible</span>
        }
    }

<span class="fc" id="L850">    private static final boolean[] uriMap = new boolean[123];</span>
    static {
<span class="fc" id="L852">        String raw =</span>
<span class="fc" id="L853">    &quot;!  $ &amp;'()*+,-. 0123456789   =  @ABCDEFGHIJKLMNOPQRSTUVWXYZ    _ abcdefghijklmnopqrstuvwxyz&quot;;</span>
  //  &quot;# %         /          :;&lt; &gt;?                           [\]^ `                          {|}~
  //  ^--so these are encoded
        int i;
        // Encode control chars and space
<span class="fc bfc" id="L858" title="All 2 branches covered.">        for (i = 0; i &lt; 33; i++) uriMap[i] = true;</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">        for (int j = 0; j &lt; raw.length(); i++, j++)</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">            uriMap[i] = (raw.charAt(j) == ' ');</span>
        // If we add encodeQuery() just add a 2nd map to encode &amp;+=
        // queryMap[38] = queryMap[43] = queryMap[61] = true;
    }

    /**
     * Encode a single path component for use in an HTTP URL.
     * Escapes all non-ASCII, general unsafe (space and {@code &quot;#%&lt;&gt;[\]^`{|}~})
     * and HTTP special characters ({@code /;:?}) as specified in RFC1738.
     * (so alphanumeric and {@code !@$&amp;*()-_=+',.} are not encoded)
     * Note that slash ({@code /}) is encoded, so the given string should be a
     * single path component used in constructing a URL.
     * Method name inspired by PHP's rawurlencode.
     */
    @Nonnull
    public static String rawEncode(@Nonnull String s) {
<span class="fc" id="L876">        boolean escaped = false;</span>
<span class="fc" id="L877">        StringBuilder out = null;</span>
<span class="fc" id="L878">        CharsetEncoder enc = null;</span>
<span class="fc" id="L879">        CharBuffer buf = null;</span>
        char c;
<span class="fc bfc" id="L881" title="All 2 branches covered.">        for (int i = 0, m = s.length(); i &lt; m; i++) {</span>
<span class="fc" id="L882">            c = s.charAt(i);</span>
<span class="fc bfc" id="L883" title="All 4 branches covered.">            if (c &gt; 122 || uriMap[c]) {</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">                if (!escaped) {</span>
<span class="fc" id="L885">                    out = new StringBuilder(i + (m - i) * 3);</span>
<span class="fc" id="L886">                    out.append(s.substring(0, i));</span>
<span class="fc" id="L887">                    enc = Charset.forName(&quot;UTF-8&quot;).newEncoder();</span>
<span class="fc" id="L888">                    buf = CharBuffer.allocate(1);</span>
<span class="fc" id="L889">                    escaped = true;</span>
                }
                // 1 char -&gt; UTF8
<span class="fc" id="L892">                buf.put(0,c);</span>
<span class="fc" id="L893">                buf.rewind();</span>
                try {
<span class="fc" id="L895">                    ByteBuffer bytes = enc.encode(buf);</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">                    while (bytes.hasRemaining()) {</span>
<span class="fc" id="L897">                        byte b = bytes.get();</span>
<span class="fc" id="L898">                        out.append('%');</span>
<span class="fc" id="L899">                        out.append(toDigit((b &gt;&gt; 4) &amp; 0xF));</span>
<span class="fc" id="L900">                        out.append(toDigit(b &amp; 0xF));</span>
                    }
<span class="pc" id="L902">                } catch (CharacterCodingException ex) { }</span>
<span class="pc bfc" id="L903" title="All 2 branches covered.">            } else if (escaped) {</span>
<span class="fc" id="L904">                out.append(c);</span>
            }
        }
<span class="fc bfc" id="L907" title="All 2 branches covered.">        return escaped ? out.toString() : s;</span>
    }

    private static char toDigit(int n) {
<span class="fc bfc" id="L911" title="All 2 branches covered.">        return (char)(n &lt; 10 ? '0' + n : 'A' + n - 10);</span>
    }

    /**
     * Surrounds by a single-quote.
     */
    public static String singleQuote(String s) {
<span class="nc" id="L918">        return '\''+s+'\'';</span>
    }

    /**
     * Escapes HTML unsafe characters like &amp;lt;, &amp;amp; to the respective character entities.
     */
    @Nonnull
    public static String escape(@Nonnull String text) {
<span class="pc bpc" id="L926" title="1 of 2 branches missed.">        if (text==null)     return null;</span>
<span class="fc" id="L927">        StringBuilder buf = new StringBuilder(text.length()+64);</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">        for( int i=0; i&lt;text.length(); i++ ) {</span>
<span class="fc" id="L929">            char ch = text.charAt(i);</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">            if(ch=='\n')</span>
<span class="fc" id="L931">                buf.append(&quot;&lt;br&gt;&quot;);</span>
            else
<span class="fc bfc" id="L933" title="All 2 branches covered.">            if(ch=='&lt;')</span>
<span class="fc" id="L934">                buf.append(&quot;&amp;lt;&quot;);</span>
            else
<span class="fc bfc" id="L936" title="All 2 branches covered.">            if(ch=='&gt;')</span>
<span class="fc" id="L937">                buf.append(&quot;&amp;gt;&quot;);</span>
            else
<span class="fc bfc" id="L939" title="All 2 branches covered.">            if(ch=='&amp;')</span>
<span class="fc" id="L940">                buf.append(&quot;&amp;amp;&quot;);</span>
            else
<span class="fc bfc" id="L942" title="All 2 branches covered.">            if(ch=='&quot;')</span>
<span class="fc" id="L943">                buf.append(&quot;&amp;quot;&quot;);</span>
            else
<span class="fc bfc" id="L945" title="All 2 branches covered.">            if(ch=='\'')</span>
<span class="fc" id="L946">                buf.append(&quot;&amp;#039;&quot;);</span>
            else
<span class="fc bfc" id="L948" title="All 2 branches covered.">            if(ch==' ') {</span>
                // All spaces in a block of consecutive spaces are converted to
                // non-breaking space (&amp;nbsp;) except for the last one.  This allows
                // significant whitespace to be retained without prohibiting wrapping.
<span class="fc bfc" id="L952" title="All 2 branches covered.">                char nextCh = i+1 &lt; text.length() ? text.charAt(i+1) : 0;</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">                buf.append(nextCh==' ' ? &quot;&amp;nbsp;&quot; : &quot; &quot;);</span>
<span class="fc" id="L954">            }</span>
            else
<span class="fc" id="L956">                buf.append(ch);</span>
        }
<span class="fc" id="L958">        return buf.toString();</span>
    }

    @Nonnull
    public static String xmlEscape(@Nonnull String text) {
<span class="fc" id="L963">        StringBuilder buf = new StringBuilder(text.length()+64);</span>
<span class="fc bfc" id="L964" title="All 2 branches covered.">        for( int i=0; i&lt;text.length(); i++ ) {</span>
<span class="fc" id="L965">            char ch = text.charAt(i);</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">            if(ch=='&lt;')</span>
<span class="fc" id="L967">                buf.append(&quot;&amp;lt;&quot;);</span>
            else
<span class="fc bfc" id="L969" title="All 2 branches covered.">            if(ch=='&gt;')</span>
<span class="fc" id="L970">                buf.append(&quot;&amp;gt;&quot;);</span>
            else
<span class="fc bfc" id="L972" title="All 2 branches covered.">            if(ch=='&amp;')</span>
<span class="fc" id="L973">                buf.append(&quot;&amp;amp;&quot;);</span>
            else
<span class="fc" id="L975">                buf.append(ch);</span>
        }
<span class="fc" id="L977">        return buf.toString();</span>
    }

    /**
     * Creates an empty file.
     */
    public static void touch(@Nonnull File file) throws IOException {
<span class="nc" id="L984">        new FileOutputStream(file).close();</span>
<span class="nc" id="L985">    }</span>

    /**
     * Copies a single file by using Ant.
     */
    public static void copyFile(@Nonnull File src, @Nonnull File dst) throws BuildException {
<span class="fc" id="L991">        Copy cp = new Copy();</span>
<span class="fc" id="L992">        cp.setProject(new org.apache.tools.ant.Project());</span>
<span class="fc" id="L993">        cp.setTofile(dst);</span>
<span class="fc" id="L994">        cp.setFile(src);</span>
<span class="fc" id="L995">        cp.setOverwrite(true);</span>
<span class="fc" id="L996">        cp.execute();</span>
<span class="fc" id="L997">    }</span>

    /**
     * Convert null to &quot;&quot;.
     */
    @Nonnull
    public static String fixNull(@CheckForNull String s) {
<span class="fc bfc" id="L1004" title="All 2 branches covered.">        if(s==null)     return &quot;&quot;;</span>
<span class="fc" id="L1005">        else            return s;</span>
    }

    /**
     * Convert empty string to null.
     */
    @CheckForNull
    public static String fixEmpty(@CheckForNull String s) {
<span class="fc bfc" id="L1013" title="All 4 branches covered.">        if(s==null || s.length()==0)    return null;</span>
<span class="fc" id="L1014">        return s;</span>
    }

    /**
     * Convert empty string to null, and trim whitespace.
     *
     * @since 1.154
     */
    @CheckForNull
    public static String fixEmptyAndTrim(@CheckForNull String s) {
<span class="fc bfc" id="L1024" title="All 2 branches covered.">        if(s==null)    return null;</span>
<span class="fc" id="L1025">        return fixEmpty(s.trim());</span>
    }

    @Nonnull
    public static &lt;T&gt; List&lt;T&gt; fixNull(@CheckForNull List&lt;T&gt; l) {
<span class="fc bfc" id="L1030" title="All 2 branches covered.">        return l!=null ? l : Collections.&lt;T&gt;emptyList();</span>
    }

    @Nonnull
    public static &lt;T&gt; Set&lt;T&gt; fixNull(@CheckForNull Set&lt;T&gt; l) {
<span class="nc bnc" id="L1035" title="All 2 branches missed.">        return l!=null ? l : Collections.&lt;T&gt;emptySet();</span>
    }

    @Nonnull
    public static &lt;T&gt; Collection&lt;T&gt; fixNull(@CheckForNull Collection&lt;T&gt; l) {
<span class="nc bnc" id="L1040" title="All 2 branches missed.">        return l!=null ? l : Collections.&lt;T&gt;emptySet();</span>
    }

    @Nonnull
    public static &lt;T&gt; Iterable&lt;T&gt; fixNull(@CheckForNull Iterable&lt;T&gt; l) {
<span class="nc bnc" id="L1045" title="All 2 branches missed.">        return l!=null ? l : Collections.&lt;T&gt;emptySet();</span>
    }

    /**
     * Cuts all the leading path portion and get just the file name.
     */
    @Nonnull
    public static String getFileName(@Nonnull String filePath) {
<span class="nc" id="L1053">        int idx = filePath.lastIndexOf('\\');</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        if(idx&gt;=0)</span>
<span class="nc" id="L1055">            return getFileName(filePath.substring(idx+1));</span>
<span class="nc" id="L1056">        idx = filePath.lastIndexOf('/');</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">        if(idx&gt;=0)</span>
<span class="nc" id="L1058">            return getFileName(filePath.substring(idx+1));</span>
<span class="nc" id="L1059">        return filePath;</span>
    }

    /**
     * Concatenate multiple strings by inserting a separator.
     */
    @Nonnull
    public static String join(@Nonnull Collection&lt;?&gt; strings, @Nonnull String separator) {
<span class="fc" id="L1067">        StringBuilder buf = new StringBuilder();</span>
<span class="fc" id="L1068">        boolean first=true;</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        for (Object s : strings) {</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">            if(first)   first=false;</span>
<span class="fc" id="L1071">            else        buf.append(separator);</span>
<span class="fc" id="L1072">            buf.append(s);</span>
        }
<span class="fc" id="L1074">        return buf.toString();</span>
    }

    /**
     * Combines all the given collections into a single list.
     */
    @Nonnull
    public static &lt;T&gt; List&lt;T&gt; join(@Nonnull Collection&lt;? extends T&gt;... items) {
<span class="nc" id="L1082">        int size = 0;</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        for (Collection&lt;? extends T&gt; item : items)</span>
<span class="nc" id="L1084">            size += item.size();</span>
<span class="nc" id="L1085">        List&lt;T&gt; r = new ArrayList&lt;T&gt;(size);</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        for (Collection&lt;? extends T&gt; item : items)</span>
<span class="nc" id="L1087">            r.addAll(item);</span>
<span class="nc" id="L1088">        return r;</span>
    }

    /**
     * Creates Ant {@link FileSet} with the base dir and include pattern.
     *
     * &lt;p&gt;
     * The difference with this and using {@link FileSet#setIncludes(String)}
     * is that this method doesn't treat whitespace as a pattern separator,
     * which makes it impossible to use space in the file path.
     *
     * @param includes
     *      String like &quot;foo/bar/*.xml&quot; Multiple patterns can be separated
     *      by ',', and whitespace can surround ',' (so that you can write
     *      &quot;abc, def&quot; and &quot;abc,def&quot; to mean the same thing.
     * @param excludes
     *      Exclusion pattern. Follows the same format as the 'includes' parameter.
     *      Can be null.
     * @since 1.172
     */
    @Nonnull
    public static FileSet createFileSet(@Nonnull File baseDir, @Nonnull String includes, @CheckForNull String excludes) {
<span class="fc" id="L1110">        FileSet fs = new FileSet();</span>
<span class="fc" id="L1111">        fs.setDir(baseDir);</span>
<span class="fc" id="L1112">        fs.setProject(new Project());</span>

        StringTokenizer tokens;

<span class="fc" id="L1116">        tokens = new StringTokenizer(includes,&quot;,&quot;);</span>
<span class="fc bfc" id="L1117" title="All 2 branches covered.">        while(tokens.hasMoreTokens()) {</span>
<span class="fc" id="L1118">            String token = tokens.nextToken().trim();</span>
<span class="fc" id="L1119">            fs.createInclude().setName(token);</span>
        }
<span class="fc bfc" id="L1121" title="All 2 branches covered.">        if(excludes!=null) {</span>
<span class="fc" id="L1122">            tokens = new StringTokenizer(excludes,&quot;,&quot;);</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">            while(tokens.hasMoreTokens()) {</span>
<span class="fc" id="L1124">                String token = tokens.nextToken().trim();</span>
<span class="fc" id="L1125">                fs.createExclude().setName(token);</span>
            }
        }
<span class="fc" id="L1128">        return fs;</span>
    }

    @Nonnull
    public static FileSet createFileSet(@Nonnull File baseDir, @Nonnull String includes) {
<span class="fc" id="L1133">        return createFileSet(baseDir,includes,null);</span>
    }

    /**
     * Creates a symlink to targetPath at baseDir+symlinkPath.
     * &lt;p&gt;
     * If there's a prior symlink at baseDir+symlinkPath, it will be overwritten.
     *
     * @param baseDir
     *      Base directory to resolve the 'symlinkPath' parameter.
     * @param targetPath
     *      The file that the symlink should point to. Usually relative to the directory of the symlink but may instead be an absolute path.
     * @param symlinkPath
     *      Where to create a symlink in (relative to {@code baseDir})
     */
    public static void createSymlink(@Nonnull File baseDir, @Nonnull String targetPath,
            @Nonnull String symlinkPath, @Nonnull TaskListener listener) throws InterruptedException {
        try {
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">            if (createSymlinkJava7(baseDir, targetPath, symlinkPath)) {</span>
<span class="fc" id="L1152">                return;</span>
            }
<span class="nc bnc" id="L1154" title="All 2 branches missed.">            if (NO_SYMLINK) {</span>
<span class="nc" id="L1155">                return;</span>
            }

<span class="nc" id="L1158">            File symlinkFile = new File(baseDir, symlinkPath);</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">            if (Functions.isWindows()) {</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                if (symlinkFile.exists()) {</span>
<span class="nc" id="L1161">                    symlinkFile.delete();</span>
                }
<span class="nc" id="L1163">                File dst = new File(symlinkFile,&quot;..\\&quot;+targetPath);</span>
                try {
<span class="nc" id="L1165">                    Kernel32Utils.createSymbolicLink(symlinkFile,targetPath,dst.isDirectory());</span>
<span class="nc" id="L1166">                } catch (WinIOException e) {</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">                    if (e.getErrorCode()==1314) {/* ERROR_PRIVILEGE_NOT_HELD */</span>
<span class="nc" id="L1168">                        warnWindowsSymlink();</span>
<span class="nc" id="L1169">                        return;</span>
                    }
<span class="nc" id="L1171">                    throw e;</span>
<span class="nc" id="L1172">                } catch (UnsatisfiedLinkError e) {</span>
                    // not available on this Windows
<span class="nc" id="L1174">                    return;</span>
                }
            } else {
<span class="nc" id="L1177">                String errmsg = &quot;&quot;;</span>
                // if a file or a directory exists here, delete it first.
                // try simple delete first (whether exists() or not, as it may be symlink pointing
                // to non-existent target), but fallback to &quot;rm -rf&quot; to delete non-empty dir.
<span class="nc bnc" id="L1181" title="All 4 branches missed.">                if (!symlinkFile.delete() &amp;&amp; symlinkFile.exists())</span>
                    // ignore a failure.
<span class="nc" id="L1183">                    new LocalProc(new String[]{&quot;rm&quot;,&quot;-rf&quot;, symlinkPath},new String[0],listener.getLogger(), baseDir).join();</span>

<span class="nc" id="L1185">                Integer r=null;</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">                if (!SYMLINK_ESCAPEHATCH) {</span>
                    try {
<span class="nc" id="L1188">                        r = LIBC.symlink(targetPath,symlinkFile.getAbsolutePath());</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">                        if (r!=0) {</span>
<span class="nc" id="L1190">                            r = Native.getLastError();</span>
<span class="nc" id="L1191">                            errmsg = LIBC.strerror(r);</span>
                        }
<span class="nc" id="L1193">                    } catch (LinkageError e) {</span>
                        // if JNA is unavailable, fall back.
                        // we still prefer to try JNA first as PosixAPI supports even smaller platforms.
<span class="nc" id="L1196">                        POSIX posix = PosixAPI.jnr();</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">                        if (posix.isNative()) {</span>
                            // TODO should we rethrow PosixException as IOException here?
<span class="nc" id="L1199">                            r = posix.symlink(targetPath,symlinkFile.getAbsolutePath());</span>
                        }
                    }
                }
<span class="nc bnc" id="L1203" title="All 2 branches missed.">                if (r==null) {</span>
                    // if all else fail, fall back to the most expensive approach of forking a process
                    // TODO is this really necessary? JavaPOSIX should do this automatically
<span class="nc" id="L1206">                    r = new LocalProc(new String[]{</span>
<span class="nc" id="L1207">                        &quot;ln&quot;,&quot;-s&quot;, targetPath, symlinkPath},</span>
<span class="nc" id="L1208">                        new String[0],listener.getLogger(), baseDir).join();</span>
                }
<span class="nc bnc" id="L1210" title="All 2 branches missed.">                if (r!=0)</span>
<span class="nc" id="L1211">                    listener.getLogger().println(String.format(&quot;ln -s %s %s failed: %d %s&quot;,targetPath, symlinkFile, r, errmsg));</span>
            }
<span class="nc" id="L1213">        } catch (IOException e) {</span>
<span class="nc" id="L1214">            PrintStream log = listener.getLogger();</span>
<span class="nc" id="L1215">            log.printf(&quot;ln %s %s failed%n&quot;,targetPath, new File(baseDir, symlinkPath));</span>
<span class="nc" id="L1216">            Util.displayIOException(e,listener);</span>
<span class="nc" id="L1217">            e.printStackTrace( log );</span>
        }
<span class="nc" id="L1219">    }</span>

    private static boolean createSymlinkJava7(@Nonnull File baseDir, @Nonnull String targetPath, @Nonnull String symlinkPath) throws IOException {
        try {
<span class="fc" id="L1223">            Object path = File.class.getMethod(&quot;toPath&quot;).invoke(new File(baseDir, symlinkPath));</span>
<span class="fc" id="L1224">            Object target = Class.forName(&quot;java.nio.file.Paths&quot;).getMethod(&quot;get&quot;, String.class, String[].class).invoke(null, targetPath, new String[0]);</span>
<span class="fc" id="L1225">            Class&lt;?&gt; filesC = Class.forName(&quot;java.nio.file.Files&quot;);</span>
<span class="fc" id="L1226">            Class&lt;?&gt; pathC = Class.forName(&quot;java.nio.file.Path&quot;);</span>
<span class="fc" id="L1227">            Class&lt;?&gt; fileAlreadyExistsExceptionC = Class.forName(&quot;java.nio.file.FileAlreadyExistsException&quot;);</span>

<span class="fc" id="L1229">            Object noAttrs = Array.newInstance(Class.forName(&quot;java.nio.file.attribute.FileAttribute&quot;), 0);</span>
<span class="fc" id="L1230">            final int maxNumberOfTries = 4;</span>
<span class="fc" id="L1231">            final int timeInMillis = 100;</span>
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">            for (int tryNumber = 1; tryNumber &lt;= maxNumberOfTries; tryNumber++) {</span>
<span class="fc" id="L1233">                filesC.getMethod(&quot;deleteIfExists&quot;, pathC).invoke(null, path);</span>
                try {
<span class="nc" id="L1235">                    filesC.getMethod(&quot;createSymbolicLink&quot;, pathC, pathC, noAttrs.getClass()).invoke(null, path, target, noAttrs);</span>
<span class="nc" id="L1236">                    break;</span>
                }
<span class="fc" id="L1238">                catch (Exception x) {</span>
<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">                    if (fileAlreadyExistsExceptionC.isInstance(x)) {</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">                        if(tryNumber &lt; maxNumberOfTries) {</span>
<span class="nc" id="L1241">                            TimeUnit.MILLISECONDS.sleep(timeInMillis); //trying to defeat likely ongoing race condition</span>
<span class="nc" id="L1242">                            continue;</span>
                        }
<span class="nc" id="L1244">                        LOGGER.warning(&quot;symlink FileAlreadyExistsException thrown &quot;+maxNumberOfTries+&quot; times =&gt; cannot createSymbolicLink&quot;);</span>
                    }
<span class="fc" id="L1246">                    throw x;</span>
                }
            }
<span class="nc" id="L1249">            return true;</span>
<span class="nc" id="L1250">        } catch (NoSuchMethodException x) {</span>
<span class="nc" id="L1251">            return false; // fine, Java 6</span>
<span class="fc" id="L1252">        } catch (InvocationTargetException x) {</span>
<span class="fc" id="L1253">            Throwable x2 = x.getCause();</span>
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">            if (x2 instanceof UnsupportedOperationException) {</span>
<span class="nc" id="L1255">                return true; // no symlinks on this platform</span>
            }
<span class="pc bpc" id="L1257" title="2 of 4 branches missed.">            if (Functions.isWindows() &amp;&amp; String.valueOf(x2).contains(&quot;java.nio.file.FileSystemException&quot;)) {</span>
<span class="fc" id="L1258">                warnWindowsSymlink();</span>
<span class="fc" id="L1259">                return true;</span>
            }
<span class="nc bnc" id="L1261" title="All 2 branches missed.">            if (x2 instanceof IOException) {</span>
<span class="nc" id="L1262">                throw (IOException) x2;</span>
            }
<span class="nc" id="L1264">            throw (IOException) new IOException(x.toString()).initCause(x);</span>
<span class="nc" id="L1265">        } catch (Exception x) {</span>
<span class="nc" id="L1266">            throw (IOException) new IOException(x.toString()).initCause(x);</span>
        }
    }

<span class="fc" id="L1270">    private static final AtomicBoolean warnedSymlinks = new AtomicBoolean();</span>
    private static void warnWindowsSymlink() {
<span class="fc bfc" id="L1272" title="All 2 branches covered.">        if (warnedSymlinks.compareAndSet(false, true)) {</span>
<span class="fc" id="L1273">            LOGGER.warning(&quot;Symbolic links enabled on this platform but disabled for this user; run as administrator or use Local Security Policy &gt; Security Settings &gt; Local Policies &gt; User Rights Assignment &gt; Create symbolic links&quot;);</span>
        }
<span class="fc" id="L1275">    }</span>

    /**
     * @deprecated as of 1.456
     *      Use {@link #resolveSymlink(File)}
     */
    @Deprecated
    public static String resolveSymlink(File link, TaskListener listener) throws InterruptedException, IOException {
<span class="nc" id="L1283">        return resolveSymlink(link);</span>
    }

    /**
     * Resolves a symlink to the {@link File} that points to.
     *
     * @return null
     *      if the specified file is not a symlink.
     */
    @CheckForNull
    public static File resolveSymlinkToFile(@Nonnull File link) throws InterruptedException, IOException {
<span class="nc" id="L1294">        String target = resolveSymlink(link);</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">        if (target==null)   return null;</span>

<span class="nc" id="L1297">        File f = new File(target);</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">        if (f.isAbsolute()) return f;   // absolute symlink</span>
<span class="nc" id="L1299">        return new File(link.getParentFile(),target);   // relative symlink</span>
    }

    /**
     * Resolves symlink, if the given file is a symlink. Otherwise return null.
     * &lt;p&gt;
     * If the resolution fails, report an error.
     *
     * @return
     *      null if the given file is not a symlink.
     *      If the symlink is absolute, the returned string is an absolute path.
     *      If the symlink is relative, the returned string is that relative representation.
     *      The relative path is meant to be resolved from the location of the symlink.
     */
    @CheckForNull
    public static String resolveSymlink(@Nonnull File link) throws InterruptedException, IOException {
        try { // Java 7
<span class="fc" id="L1316">            Object path = File.class.getMethod(&quot;toPath&quot;).invoke(link);</span>
<span class="nc" id="L1317">            return Class.forName(&quot;java.nio.file.Files&quot;).getMethod(&quot;readSymbolicLink&quot;, Class.forName(&quot;java.nio.file.Path&quot;)).invoke(null, path).toString();</span>
<span class="nc" id="L1318">        } catch (NoSuchMethodException x) {</span>
            // fine, Java 6; fall through
<span class="fc" id="L1320">        } catch (InvocationTargetException x) {</span>
<span class="fc" id="L1321">            Throwable x2 = x.getCause();</span>
<span class="pc bpc" id="L1322" title="1 of 2 branches missed.">            if (x2 instanceof UnsupportedOperationException) {</span>
<span class="nc" id="L1323">                return null; // no symlinks on this platform</span>
            }
            try {
<span class="pc bpc" id="L1326" title="1 of 2 branches missed.">                if (Class.forName(&quot;java.nio.file.NotLinkException&quot;).isInstance(x2)) {</span>
<span class="fc" id="L1327">                    return null;</span>
                }
<span class="nc" id="L1329">            } catch (ClassNotFoundException x3) {</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">                assert false : x3; // should be Java 7+ here</span>
            }
<span class="nc bnc" id="L1332" title="All 2 branches missed.">            if (x2.getClass().getName().equals(&quot;java.nio.file.FileSystemException&quot;)) {</span>
                // Thrown (&quot;Incorrect function.&quot;) on JDK 7u21 in Windows 2012 when called on a non-symlink, rather than NotLinkException, contrary to documentation. Maybe only when not on NTFS?
<span class="nc" id="L1334">                return null;</span>
            }
<span class="nc bnc" id="L1336" title="All 2 branches missed.">            if (x2 instanceof IOException) {</span>
<span class="nc" id="L1337">                throw (IOException) x2;</span>
            }
<span class="nc" id="L1339">            throw (IOException) new IOException(x.toString()).initCause(x);</span>
<span class="nc" id="L1340">        } catch (Exception x) {</span>
<span class="nc" id="L1341">            throw (IOException) new IOException(x.toString()).initCause(x);</span>
        }

<span class="nc bnc" id="L1344" title="All 2 branches missed.">        if(Functions.isWindows())     return null;</span>

<span class="nc" id="L1346">        String filename = link.getAbsolutePath();</span>
        try {
<span class="nc bnc" id="L1348" title="All 2 branches missed.">            for (int sz=512; sz &lt; 65536; sz*=2) {</span>
<span class="nc" id="L1349">                Memory m = new Memory(sz);</span>
<span class="nc" id="L1350">                int r = LIBC.readlink(filename,m,new NativeLong(sz));</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">                if (r&lt;0) {</span>
<span class="nc" id="L1352">                    int err = Native.getLastError();</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">                    if (err==22/*EINVAL --- but is this really portable?*/)</span>
<span class="nc" id="L1354">                        return null; // this means it's not a symlink</span>
<span class="nc" id="L1355">                    throw new IOException(&quot;Failed to readlink &quot;+link+&quot; error=&quot;+ err+&quot; &quot;+ LIBC.strerror(err));</span>
                }
<span class="nc bnc" id="L1357" title="All 2 branches missed.">                if (r==sz)</span>
<span class="nc" id="L1358">                    continue;   // buffer too small</span>

<span class="nc" id="L1360">                byte[] buf = new byte[r];</span>
<span class="nc" id="L1361">                m.read(0,buf,0,r);</span>
<span class="nc" id="L1362">                return new String(buf);</span>
            }
            // something is wrong. It can't be this long!
<span class="nc" id="L1365">            throw new IOException(&quot;Symlink too long: &quot;+link);</span>
<span class="nc" id="L1366">        } catch (LinkageError e) {</span>
            // if JNA is unavailable, fall back.
            // we still prefer to try JNA first as PosixAPI supports even smaller platforms.
<span class="nc" id="L1369">            return PosixAPI.jnr().readlink(filename);</span>
        }
    }

    /**
     * Encodes the URL by RFC 2396.
     *
     * I thought there's another spec that refers to UTF-8 as the encoding,
     * but don't remember it right now.
     *
     * @since 1.204
     * @deprecated since 2008-05-13. This method is broken (see ISSUE#1666). It should probably
     * be removed but I'm not sure if it is considered part of the public API
     * that needs to be maintained for backwards compatibility.
     * Use {@link #encode(String)} instead.
     */
    @Deprecated
    public static String encodeRFC2396(String url) {
        try {
<span class="nc" id="L1388">            return new URI(null,url,null).toASCIIString();</span>
<span class="nc" id="L1389">        } catch (URISyntaxException e) {</span>
<span class="nc" id="L1390">            LOGGER.warning(&quot;Failed to encode &quot;+url);    // could this ever happen?</span>
<span class="nc" id="L1391">            return url;</span>
        }
    }

    /**
     * Wraps with the error icon and the CSS class to render error message.
     * @since 1.173
     */
    @Nonnull
    public static String wrapToErrorSpan(@Nonnull String s) {
<span class="nc" id="L1401">        s = &quot;&lt;span class=error style='display:inline-block'&gt;&quot;+s+&quot;&lt;/span&gt;&quot;;</span>
<span class="nc" id="L1402">        return s;</span>
    }

    /**
     * Returns the parsed string if parsed successful; otherwise returns the default number.
     * If the string is null, empty or a ParseException is thrown then the defaultNumber
     * is returned.
     * @param numberStr string to parse
     * @param defaultNumber number to return if the string can not be parsed
     * @return returns the parsed string; otherwise the default number
     */
    @CheckForNull
    public static Number tryParseNumber(@CheckForNull String numberStr, @CheckForNull Number defaultNumber) {
<span class="fc bfc" id="L1415" title="All 4 branches covered.">        if ((numberStr == null) || (numberStr.length() == 0)) {</span>
<span class="fc" id="L1416">            return defaultNumber;</span>
        }
        try {
<span class="fc" id="L1419">            return NumberFormat.getNumberInstance().parse(numberStr);</span>
<span class="fc" id="L1420">        } catch (ParseException e) {</span>
<span class="fc" id="L1421">            return defaultNumber;</span>
        }
    }

    /**
     * Checks if the method defined on the base type with the given arguments
     * is overridden in the given derived type.
     */
    public static boolean isOverridden(@Nonnull Class base, @Nonnull Class derived, @Nonnull String methodName, @Nonnull Class... types) {
<span class="fc bfc" id="L1430" title="All 2 branches covered.">        return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));</span>
    }

    private static Method getMethod(@Nonnull Class clazz, @Nonnull String methodName, @Nonnull Class... types) {
<span class="fc" id="L1434">        Method res = null;</span>
        try {
<span class="fc" id="L1436">            res = clazz.getDeclaredMethod(methodName, types);</span>
            // private, static or final methods can not be overridden
<span class="pc bpc" id="L1438" title="2 of 6 branches missed.">            if (res != null &amp;&amp; (Modifier.isPrivate(res.getModifiers()) || Modifier.isFinal(res.getModifiers()) </span>
<span class="pc bpc" id="L1439" title="1 of 2 branches missed.">                    || Modifier.isStatic(res.getModifiers()))) {</span>
<span class="fc" id="L1440">                res = null;</span>
            }
<span class="fc" id="L1442">        } catch (NoSuchMethodException e) {</span>
            // Method not found in clazz, let's search in superclasses
<span class="fc" id="L1444">            Class superclass = clazz.getSuperclass();</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">            if (superclass != null) {</span>
<span class="fc" id="L1446">                res = getMethod(superclass, methodName, types);</span>
            }
<span class="nc" id="L1448">        } catch (SecurityException e) {</span>
<span class="nc" id="L1449">            throw new AssertionError(e);</span>
        }
<span class="fc bfc" id="L1451" title="All 2 branches covered.">        if (res == null) {</span>
<span class="fc" id="L1452">            throw new IllegalArgumentException(</span>
<span class="fc" id="L1453">                    String.format(&quot;Method %s not found in %s (or it is private, final or static)&quot;, methodName, clazz.getName()));</span>
        }
<span class="fc" id="L1455">        return res;</span>
    }

    /**
     * Returns a file name by changing its extension.
     *
     * @param ext
     *      For example, &quot;.zip&quot;
     */
    @Nonnull
    public static File changeExtension(@Nonnull File dst, @Nonnull String ext) {
<span class="nc" id="L1466">        String p = dst.getPath();</span>
<span class="nc" id="L1467">        int pos = p.lastIndexOf('.');</span>
<span class="nc bnc" id="L1468" title="All 2 branches missed.">        if (pos&lt;0)  return new File(p+ext);</span>
<span class="nc" id="L1469">        else        return new File(p.substring(0,pos)+ext);</span>
    }

    /**
     * Null-safe String intern method.
     * @return A canonical representation for the string object. Null for null input strings
     */
    @Nullable
    public static String intern(@CheckForNull String s) {
<span class="nc bnc" id="L1478" title="All 2 branches missed.">        return s==null ? s : s.intern();</span>
    }

    /**
     * Return true if the systemId denotes an absolute URI .
     *
     * The same algorithm can be seen in {@link URI}, but
     * implementing this by ourselves allow it to be more lenient about
     * escaping of URI.
     */
    public static boolean isAbsoluteUri(@Nonnull String uri) {
<span class="fc" id="L1489">        int idx = uri.indexOf(':');</span>
<span class="fc bfc" id="L1490" title="All 2 branches covered.">        if (idx&lt;0)  return false;   // no ':'. can't be absolute</span>

        // #, ?, and / must not be before ':'
<span class="fc bfc" id="L1493" title="All 6 branches covered.">        return idx&lt;_indexOf(uri, '#') &amp;&amp; idx&lt;_indexOf(uri,'?') &amp;&amp; idx&lt;_indexOf(uri,'/');</span>
    }

    /**
     * Works like {@link String#indexOf(int)} but 'not found' is returned as s.length(), not -1.
     * This enables more straight-forward comparison.
     */
    private static int _indexOf(@Nonnull String s, char ch) {
<span class="fc" id="L1501">        int idx = s.indexOf(ch);</span>
<span class="fc bfc" id="L1502" title="All 2 branches covered.">        if (idx&lt;0)  return s.length();</span>
<span class="fc" id="L1503">        return idx;</span>
    }

    /**
     * Loads a key/value pair string as {@link Properties}
     * @since 1.392
     */
    @Nonnull
    public static Properties loadProperties(@Nonnull String properties) throws IOException {
<span class="fc" id="L1512">        Properties p = new Properties();</span>
<span class="fc" id="L1513">        p.load(new StringReader(properties));</span>
<span class="fc" id="L1514">        return p;</span>
    }

<span class="fc" id="L1517">    public static final FastDateFormat XS_DATETIME_FORMATTER = FastDateFormat.getInstance(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;,new SimpleTimeZone(0,&quot;GMT&quot;));</span>

    // Note: RFC822 dates must not be localized!
<span class="fc" id="L1520">    public static final FastDateFormat RFC822_DATETIME_FORMATTER</span>
<span class="fc" id="L1521">            = FastDateFormat.getInstance(&quot;EEE, dd MMM yyyy HH:mm:ss Z&quot;, Locale.US);</span>

<span class="fc" id="L1523">    private static final Logger LOGGER = Logger.getLogger(Util.class.getName());</span>

    /**
     * On Unix environment that cannot run &quot;ln&quot;, set this to true.
     */
<span class="fc" id="L1528">    public static boolean NO_SYMLINK = Boolean.getBoolean(Util.class.getName()+&quot;.noSymLink&quot;);</span>

<span class="fc" id="L1530">    public static boolean SYMLINK_ESCAPEHATCH = Boolean.getBoolean(Util.class.getName()+&quot;.symlinkEscapeHatch&quot;);</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>jenkins-core (22-mrt-2016 21:51:03)</div></body></html>