<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Functions.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">jenkins-core (22-mrt-2016 21:51:03)</a> &gt; <a href="../../index.html" class="el_group">jenkins-core</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">hudson</a> &gt; <span class="el_source">Functions.java</span></div><h1>Functions.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/*</span>
 * The MIT License
 * 
 * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi,
 * Yahoo! Inc., Stephen Connolly, Tom Huybrechts, Alan Harder, Manufacture
 * Francaise des Pneumatiques Michelin, Romain Seguy
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package hudson;

import hudson.cli.CLICommand;
import hudson.console.ConsoleAnnotationDescriptor;
import hudson.console.ConsoleAnnotatorFactory;
import hudson.init.InitMilestone;
import hudson.model.AbstractProject;
import hudson.model.Action;
import hudson.model.Describable;
import hudson.model.Descriptor;
import hudson.model.DescriptorVisibilityFilter;
import hudson.model.Hudson;
import hudson.model.Item;
import hudson.model.ItemGroup;
import hudson.model.Items;
import hudson.model.JDK;
import hudson.model.Job;
import hudson.model.JobPropertyDescriptor;
import hudson.model.ModelObject;
import hudson.model.Node;
import hudson.model.PageDecorator;
import hudson.model.PaneStatusProperties;
import hudson.model.ParameterDefinition;
import hudson.model.ParameterDefinition.ParameterDescriptor;
import hudson.model.Run;
import hudson.model.TopLevelItem;
import hudson.model.User;
import hudson.model.View;
import hudson.scm.SCM;
import hudson.scm.SCMDescriptor;
import hudson.search.SearchableModelObject;
import hudson.security.AccessControlled;
import hudson.security.AuthorizationStrategy;
import hudson.security.GlobalSecurityConfiguration;
import hudson.security.Permission;
import hudson.security.SecurityRealm;
import hudson.security.captcha.CaptchaSupport;
import hudson.security.csrf.CrumbIssuer;
import hudson.slaves.Cloud;
import hudson.slaves.ComputerLauncher;
import hudson.slaves.NodeProperty;
import hudson.slaves.NodePropertyDescriptor;
import hudson.slaves.RetentionStrategy;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.BuildWrapper;
import hudson.tasks.BuildWrappers;
import hudson.tasks.Builder;
import hudson.tasks.Publisher;
import hudson.tasks.UserAvatarResolver;
import hudson.util.Area;
import hudson.util.FormValidation.CheckMethod;
import hudson.util.Iterators;
import hudson.util.jna.GNUCLibrary;
import hudson.util.Secret;
import hudson.views.MyViewsTabBar;
import hudson.views.ViewsTabBar;
import hudson.widgets.RenderOnDemandClosure;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.lang.management.LockInfo;
import java.lang.management.ManagementFactory;
import java.lang.management.MonitorInfo;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLDecoder;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.regex.Pattern;

import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import jenkins.model.GlobalConfiguration;
import jenkins.model.GlobalConfigurationCategory;
import jenkins.model.GlobalConfigurationCategory.Unclassified;
import jenkins.model.Jenkins;
import jenkins.model.ModelObjectWithChildren;
import jenkins.model.ModelObjectWithContextMenu;

import org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;
import org.apache.commons.jelly.JellyContext;
import org.apache.commons.jelly.JellyTagException;
import org.apache.commons.jelly.Script;
import org.apache.commons.jelly.XMLOutput;
import org.apache.commons.jexl.parser.ASTSizeFunction;
import org.apache.commons.jexl.util.Introspector;
import org.apache.commons.lang.StringUtils;
import org.jenkins.ui.icon.IconSet;
import org.jvnet.tiger_types.Types;
import org.kohsuke.stapler.Ancestor;
import org.kohsuke.stapler.Stapler;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import org.kohsuke.stapler.jelly.InternationalizedStringExpression.RawHtmlArgument;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import hudson.util.RunList;
import java.util.concurrent.atomic.AtomicLong;
import javax.annotation.CheckForNull;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;

/**
 * Utility functions used in views.
 *
 * &lt;p&gt;
 * An instance of this class is created for each request and made accessible
 * from view pages via the variable 'h' (h stands for Hudson.)
 *
 * @author Kohsuke Kawaguchi
 */
@SuppressWarnings(&quot;rawtypes&quot;)
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">public class Functions {</span>
<span class="fc" id="L171">    private static final AtomicLong iota = new AtomicLong();</span>

<span class="nc" id="L173">    public Functions() {</span>
<span class="nc" id="L174">    }</span>

    /**
     * Generates an unique ID.
     */
    public String generateId() {
<span class="nc" id="L180">        return &quot;id&quot; + iota.getAndIncrement();</span>
    }

    public static boolean isModel(Object o) {
<span class="nc" id="L184">        return o instanceof ModelObject;</span>
    }

    public static boolean isModelWithContextMenu(Object o) {
<span class="nc" id="L188">        return o instanceof ModelObjectWithContextMenu;</span>
    }

    public static boolean isModelWithChildren(Object o) {
<span class="nc" id="L192">        return o instanceof ModelObjectWithChildren;</span>
    }
    
    @Deprecated
    public static boolean isMatrixProject(Object o) {
<span class="nc bnc" id="L197" title="All 4 branches missed.">        return o != null &amp;&amp; o.getClass().getName().equals(&quot;hudson.matrix.MatrixProject&quot;);</span>
    }

    public static String xsDate(Calendar cal) {
<span class="nc" id="L201">        return Util.XS_DATETIME_FORMATTER.format(cal.getTime());</span>
    }

    public static String rfc822Date(Calendar cal) {
<span class="nc" id="L205">        return Util.RFC822_DATETIME_FORMATTER.format(cal.getTime());</span>
    }

    /**
     * During Jenkins start-up, before {@link InitMilestone#PLUGINS_STARTED} the extensions lists will be empty
     * and they are not guaranteed to be fully populated until after {@link InitMilestone#EXTENSIONS_AUGMENTED}.
     * If you attempt to access the extensions list from a UI thread while the extensions are being loaded you will
     * hit a big honking great monitor lock that will block until the effective extension list has been determined
     * (as if a plugin fails to start, all of the failed plugin's extensions and any dependent plugins' extensions
     * will have to be evicted from the list of extensions. In practical terms this only affects the
     * &quot;Jenkins is loading&quot; screen, but as that screen uses the generic layouts we provide this utility method
     * so that the generic layouts can avoid iterating extension lists while Jenkins is starting up.
     *
     * @return {@code true} if the extensions lists have been populated.
     * @since 1.607
     */
    public static boolean isExtensionsAvailable() {
<span class="nc" id="L222">        final Jenkins jenkins = Jenkins.getInstance();</span>
<span class="nc bnc" id="L223" title="All 4 branches missed.">        return jenkins != null &amp;&amp; jenkins.getInitLevel().compareTo(InitMilestone.EXTENSIONS_AUGMENTED) &gt;= 0;</span>
    }

    public static void initPageVariables(JellyContext context) {
<span class="nc" id="L227">        StaplerRequest currentRequest = Stapler.getCurrentRequest();</span>
<span class="nc" id="L228">        String rootURL = currentRequest.getContextPath();</span>

<span class="nc" id="L230">        Functions h = new Functions();</span>
<span class="nc" id="L231">        context.setVariable(&quot;h&quot;, h);</span>


        // The path starts with a &quot;/&quot; character but does not end with a &quot;/&quot; character.
<span class="nc" id="L235">        context.setVariable(&quot;rootURL&quot;, rootURL);</span>

        /*
            load static resources from the path dedicated to a specific version.
            This &quot;/static/VERSION/abc/def.ghi&quot; path is interpreted by stapler to be
            the same thing as &quot;/abc/def.ghi&quot;, but this avoids the stale cache
            problem when the user upgrades to new Jenkins. Stapler also sets a long
            future expiration dates for such static resources.

            see https://wiki.jenkins-ci.org/display/JENKINS/Hyperlinks+in+HTML
         */
<span class="nc" id="L246">        context.setVariable(&quot;resURL&quot;,rootURL+getResourcePath());</span>
<span class="nc" id="L247">        context.setVariable(&quot;imagesURL&quot;,rootURL+getResourcePath()+&quot;/images&quot;);</span>

<span class="nc" id="L249">        context.setVariable(&quot;userAgent&quot;, currentRequest.getHeader(&quot;User-Agent&quot;));</span>
<span class="nc" id="L250">        IconSet.initPageVariables(context);</span>
<span class="nc" id="L251">    }</span>

    /**
     * Given {@code c=MyList (extends ArrayList&lt;Foo&gt;), base=List}, compute the parameterization of 'base'
     * that's assignable from 'c' (in this case {@code List&lt;Foo&gt;}), and return its n-th type parameter
     * (n=0 would return {@code Foo}).
     *
     * &lt;p&gt;
     * This method is useful for doing type arithmetic.
     *
     * @throws AssertionError
     *      if c' is not parameterized.
     */
    public static &lt;B&gt; Class getTypeParameter(Class&lt;? extends B&gt; c, Class&lt;B&gt; base, int n) {
<span class="nc" id="L265">        Type parameterization = Types.getBaseClass(c,base);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (parameterization instanceof ParameterizedType) {</span>
<span class="nc" id="L267">            ParameterizedType pt = (ParameterizedType) parameterization;</span>
<span class="nc" id="L268">            return Types.erasure(Types.getTypeArgument(pt,n));</span>
        } else {
<span class="nc" id="L270">            throw new AssertionError(c+&quot; doesn't properly parameterize &quot;+base);</span>
        }
    }

    public JDK.DescriptorImpl getJDKDescriptor() {
<span class="nc" id="L275">        return Jenkins.getInstance().getDescriptorByType(JDK.DescriptorImpl.class);</span>
    }

    /**
     * Prints the integer as a string that represents difference,
     * like &quot;-5&quot;, &quot;+/-0&quot;, &quot;+3&quot;.
     */
    public static String getDiffString(int i) {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if(i==0)    return &quot;Â±0&quot;;</span>
<span class="nc" id="L284">        String s = Integer.toString(i);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if(i&gt;0)     return &quot;+&quot;+s;</span>
<span class="nc" id="L286">        else        return s;</span>
    }

    /**
     * {@link #getDiffString(int)} that doesn't show anything for +/-0
     */
    public static String getDiffString2(int i) {
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if(i==0)    return &quot;&quot;;</span>
<span class="nc" id="L294">        String s = Integer.toString(i);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if(i&gt;0)     return &quot;+&quot;+s;</span>
<span class="nc" id="L296">        else        return s;</span>
    }

    /**
     * {@link #getDiffString2(int)} that puts the result into prefix and suffix
     * if there's something to print
     */
    public static String getDiffString2(String prefix, int i, String suffix) {
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if(i==0)    return &quot;&quot;;</span>
<span class="nc" id="L305">        String s = Integer.toString(i);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if(i&gt;0)     return prefix+&quot;+&quot;+s+suffix;</span>
<span class="nc" id="L307">        else        return prefix+s+suffix;</span>
    }

    /**
     * Adds the proper suffix.
     */
    public static String addSuffix(int n, String singular, String plural) {
<span class="nc" id="L314">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L315">        buf.append(n).append(' ');</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if(n==1)</span>
<span class="nc" id="L317">            buf.append(singular);</span>
        else
<span class="nc" id="L319">            buf.append(plural);</span>
<span class="nc" id="L320">        return buf.toString();</span>
    }

    public static RunUrl decompose(StaplerRequest req) {
<span class="nc" id="L324">        List&lt;Ancestor&gt; ancestors = req.getAncestors();</span>

        // find the first and last Run instances
<span class="nc" id="L327">        Ancestor f=null,l=null;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        for (Ancestor anc : ancestors) {</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            if(anc.getObject() instanceof Run) {</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">                if(f==null) f=anc;</span>
<span class="nc" id="L331">                l=anc;</span>
            }
        }
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if(l==null) return null;    // there was no Run object</span>

<span class="nc" id="L336">        String head = f.getPrev().getUrl()+'/';</span>
<span class="nc" id="L337">        String base = l.getUrl();</span>

<span class="nc" id="L339">        String reqUri = req.getOriginalRequestURI();</span>
        // Find &quot;rest&quot; or URI by removing N path components.
        // Not using reqUri.substring(f.getUrl().length()) to avoid mismatches due to
        // url-encoding or extra slashes.  Former may occur in Tomcat (despite the spec saying
        // this string is not decoded, Tomcat apparently decodes this string. You see ' '
        // instead of '%20', which is what the browser has sent), latter may occur in some
        // proxy or URL-rewriting setups where extra slashes are inadvertently added.
<span class="nc" id="L346">        String furl = f.getUrl();</span>
<span class="nc" id="L347">        int slashCount = 0;</span>
        // Count components in ancestor URL
<span class="nc bnc" id="L349" title="All 2 branches missed.">        for (int i = furl.indexOf('/'); i &gt;= 0; i = furl.indexOf('/', i + 1)) slashCount++;</span>
        // Remove that many from request URL, ignoring extra slashes
<span class="nc" id="L351">        String rest = reqUri.replaceFirst(&quot;(?:/+[^/]*){&quot; + slashCount + &quot;}&quot;, &quot;&quot;);</span>

<span class="nc" id="L353">        return new RunUrl( (Run) f.getObject(), head, base, rest);</span>
    }

    /**
     * If we know the user's screen resolution, return it. Otherwise null.
     * @since 1.213
     */
    public static Area getScreenResolution() {
<span class="nc" id="L361">        Cookie res = Functions.getCookie(Stapler.getCurrentRequest(),&quot;screenResolution&quot;);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if(res!=null)</span>
<span class="nc" id="L363">            return Area.parse(res.getValue());</span>
<span class="nc" id="L364">        return null;</span>
    }

    /**
     * URL decomposed for easier computation of relevant URLs.
     *
     * &lt;p&gt;
     * The decomposed URL will be of the form:
     * &lt;pre&gt;
     * aaaaaa/524/bbbbb/cccc
     * -head-| N |---rest---
     * ----- base -----|
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * The head portion is the part of the URL from the {@link jenkins.model.Jenkins}
     * object to the first {@link Run} subtype. When &quot;next/prev build&quot;
     * is chosen, this part remains intact.
     *
     * &lt;p&gt;
     * The &lt;tt&gt;524&lt;/tt&gt; is the path from {@link Job} to {@link Run}.
     *
     * &lt;p&gt;
     * The &lt;tt&gt;bbb&lt;/tt&gt; portion is the path after that till the last
     * {@link Run} subtype. The &lt;tt&gt;ccc&lt;/tt&gt; portion is the part
     * after that.
     */
    public static final class RunUrl {
        private final String head, base, rest;
        private final Run run;


<span class="nc" id="L396">        public RunUrl(Run run, String head, String base, String rest) {</span>
<span class="nc" id="L397">            this.run = run;</span>
<span class="nc" id="L398">            this.head = head;</span>
<span class="nc" id="L399">            this.base = base;</span>
<span class="nc" id="L400">            this.rest = rest;</span>
<span class="nc" id="L401">        }</span>

        public String getBaseUrl() {
<span class="nc" id="L404">            return base;</span>
        }

        /**
         * Returns the same page in the next build.
         */
        public String getNextBuildUrl() {
<span class="nc" id="L411">            return getUrl(run.getNextBuild());</span>
        }

        /**
         * Returns the same page in the previous build.
         */
        public String getPreviousBuildUrl() {
<span class="nc" id="L418">            return getUrl(run.getPreviousBuild());</span>
        }

        private String getUrl(Run n) {
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if(n ==null)</span>
<span class="nc" id="L423">                return null;</span>
            else {
<span class="nc" id="L425">                return head+n.getNumber()+rest;</span>
            }
        }
    }

    public static Node.Mode[] getNodeModes() {
<span class="nc" id="L431">        return Node.Mode.values();</span>
    }

    public static String getProjectListString(List&lt;AbstractProject&gt; projects) {
<span class="nc" id="L435">        return Items.toNameList(projects);</span>
    }

    /**
     * @deprecated as of 1.294
     *      JEXL now supports the real ternary operator &quot;x?y:z&quot;, so this work around
     *      is no longer necessary.
     */
    @Deprecated
    public static Object ifThenElse(boolean cond, Object thenValue, Object elseValue) {
<span class="nc bnc" id="L445" title="All 2 branches missed.">        return cond ? thenValue : elseValue;</span>
    }

    public static String appendIfNotNull(String text, String suffix, String nullText) {
<span class="nc bnc" id="L449" title="All 2 branches missed.">        return text == null ? nullText : text + suffix;</span>
    }

    public static Map getSystemProperties() {
<span class="nc" id="L453">        return new TreeMap&lt;Object,Object&gt;(System.getProperties());</span>
    }

    public static Map getEnvVars() {
<span class="nc" id="L457">        return new TreeMap&lt;String,String&gt;(EnvVars.masterEnvVars);</span>
    }

    public static boolean isWindows() {
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        return File.pathSeparatorChar==';';</span>
    }
    
    public static boolean isGlibcSupported() {
        try {
<span class="nc" id="L466">            GNUCLibrary.LIBC.getpid();</span>
<span class="nc" id="L467">            return true;</span>
<span class="nc" id="L468">        } catch(Throwable t) {</span>
<span class="nc" id="L469">            return false;</span>
        }
    }

    public static List&lt;LogRecord&gt; getLogRecords() {
<span class="nc" id="L474">        return Jenkins.logRecords;</span>
    }

    public static String printLogRecord(LogRecord r) {
<span class="nc" id="L478">        return formatter.format(r);</span>
    }

    @Restricted(NoExternalUse.class)
    public static String[] printLogRecordHtml(LogRecord r, LogRecord prior) {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        String[] oldParts = prior == null ? new String[4] : logRecordPreformat(prior);</span>
<span class="nc" id="L484">        String[] newParts = logRecordPreformat(r);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">        for (int i = 0; i &lt; /* not 4 */3; i++) {</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            newParts[i] = &quot;&lt;span class='&quot; + (newParts[i].equals(oldParts[i]) ? &quot;logrecord-metadata-old&quot; : &quot;logrecord-metadata-new&quot;) + &quot;'&gt;&quot; + newParts[i] + &quot;&lt;/span&gt;&quot;;</span>
        }
<span class="nc" id="L488">        newParts[3] = Util.xmlEscape(newParts[3]);</span>
<span class="nc" id="L489">        return newParts;</span>
    }
    /**
     * Partially formats a log record.
     * @return date, source, level, message+thrown
     * @see SimpleFormatter#format(LogRecord)
     */
    private static String[] logRecordPreformat(LogRecord r) {
        String source;
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (r.getSourceClassName() == null) {</span>
<span class="nc" id="L499">            source = r.getLoggerName();</span>
<span class="nc" id="L500">        } else {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">            if (r.getSourceMethodName() == null) {</span>
<span class="nc" id="L502">                source = r.getSourceClassName();</span>
<span class="nc" id="L503">            } else {</span>
<span class="nc" id="L504">                source = r.getSourceClassName() + &quot; &quot; + r.getSourceMethodName();</span>
            }
        }
<span class="nc" id="L507">        String message = new SimpleFormatter().formatMessage(r) + &quot;\n&quot;;</span>
<span class="nc" id="L508">        Throwable x = r.getThrown();</span>
<span class="nc" id="L509">        return new String[] {</span>
<span class="nc" id="L510">            String.format(&quot;%1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp&quot;, new Date(r.getMillis())),</span>
<span class="nc" id="L511">            source,</span>
<span class="nc" id="L512">            r.getLevel().getLocalizedName(),</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">            x == null ? message : message + printThrowable(x) + &quot;\n&quot;</span>
        };
    }

    /**
     * Reverses a collection so that it can be easily walked in reverse order.
     * @since 1.525
     */
    public static &lt;T&gt; Iterable&lt;T&gt; reverse(Collection&lt;T&gt; collection) {
<span class="nc" id="L522">        List&lt;T&gt; list = new ArrayList&lt;T&gt;(collection);</span>
<span class="nc" id="L523">        Collections.reverse(list);</span>
<span class="nc" id="L524">        return list;</span>
    }

    public static Cookie getCookie(HttpServletRequest req,String name) {
<span class="nc" id="L528">        Cookie[] cookies = req.getCookies();</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">        if(cookies!=null) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">            for (Cookie cookie : cookies) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                if(cookie.getName().equals(name)) {</span>
<span class="nc" id="L532">                    return cookie;</span>
                }
            }
        }
<span class="nc" id="L536">        return null;</span>
    }

    public static String getCookie(HttpServletRequest req,String name, String defaultValue) {
<span class="nc" id="L540">        Cookie c = getCookie(req, name);</span>
<span class="nc bnc" id="L541" title="All 4 branches missed.">        if(c==null || c.getValue()==null) return defaultValue;</span>
<span class="nc" id="L542">        return c.getValue();</span>
    }

<span class="fc" id="L545">    private static final Pattern ICON_SIZE = Pattern.compile(&quot;\\d+x\\d+&quot;);</span>
    @Restricted(NoExternalUse.class)
    public static String validateIconSize(String iconSize) throws SecurityException {
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (!ICON_SIZE.matcher(iconSize).matches()) {</span>
<span class="nc" id="L549">            throw new SecurityException(&quot;invalid iconSize&quot;);</span>
        }
<span class="nc" id="L551">        return iconSize;</span>
    }

    /**
     * Gets the suffix to use for YUI JavaScript.
     */
    public static String getYuiSuffix() {
<span class="nc bnc" id="L558" title="All 2 branches missed.">        return DEBUG_YUI ? &quot;debug&quot; : &quot;min&quot;;</span>
    }

    /**
     * Set to true if you need to use the debug version of YUI.
     */
<span class="fc" id="L564">    public static boolean DEBUG_YUI = Boolean.getBoolean(&quot;debug.YUI&quot;);</span>

    /**
     * Creates a sub map by using the given range (both ends inclusive).
     */
    public static &lt;V&gt; SortedMap&lt;Integer,V&gt; filter(SortedMap&lt;Integer,V&gt; map, String from, String to) {
<span class="nc bnc" id="L570" title="All 4 branches missed.">        if(from==null &amp;&amp; to==null)      return map;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if(to==null)</span>
<span class="nc" id="L572">            return map.headMap(Integer.parseInt(from)-1);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if(from==null)</span>
<span class="nc" id="L574">            return map.tailMap(Integer.parseInt(to));</span>

<span class="nc" id="L576">        return map.subMap(Integer.parseInt(to),Integer.parseInt(from)-1);</span>
    }

    /**
     * Creates a sub map by using the given range (upper end inclusive).
     */
    @Restricted(NoExternalUse.class)
    public static &lt;V&gt; SortedMap&lt;Integer,V&gt; filterExcludingFrom(SortedMap&lt;Integer,V&gt; map, String from, String to) {
<span class="nc bnc" id="L584" title="All 4 branches missed.">        if(from==null &amp;&amp; to==null)      return map;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if(to==null)</span>
<span class="nc" id="L586">            return map.headMap(Integer.parseInt(from));</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if(from==null)</span>
<span class="nc" id="L588">            return map.tailMap(Integer.parseInt(to));</span>

<span class="nc" id="L590">        return map.subMap(Integer.parseInt(to),Integer.parseInt(from));</span>
    }

<span class="fc" id="L593">    private static final SimpleFormatter formatter = new SimpleFormatter();</span>

    /**
     * Used by &lt;tt&gt;layout.jelly&lt;/tt&gt; to control the auto refresh behavior.
     *
     * @param noAutoRefresh
     *      On certain pages, like a page with forms, will have annoying interference
     *      with auto refresh. On those pages, disable auto-refresh.
     */
    public static void configureAutoRefresh(HttpServletRequest request, HttpServletResponse response, boolean noAutoRefresh) {
<span class="nc bnc" id="L603" title="All 2 branches missed.">        if(noAutoRefresh)</span>
<span class="nc" id="L604">            return;</span>

<span class="nc" id="L606">        String param = request.getParameter(&quot;auto_refresh&quot;);</span>
<span class="nc" id="L607">        boolean refresh = isAutoRefresh(request);</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (param != null) {</span>
<span class="nc" id="L609">            refresh = Boolean.parseBoolean(param);</span>
<span class="nc" id="L610">            Cookie c = new Cookie(&quot;hudson_auto_refresh&quot;, Boolean.toString(refresh));</span>
            // Need to set path or it will not stick from e.g. a project page to the dashboard.
            // Using request.getContextPath() might work but it seems simpler to just use the hudson_ prefix
            // to avoid conflicts with any other web apps that might be on the same machine.
<span class="nc" id="L614">            c.setPath(&quot;/&quot;);</span>
<span class="nc" id="L615">            c.setMaxAge(60*60*24*30); // persist it roughly for a month</span>
<span class="nc" id="L616">            response.addCookie(c);</span>
        }
<span class="nc bnc" id="L618" title="All 2 branches missed.">        if (refresh) {</span>
<span class="nc" id="L619">            response.addHeader(&quot;Refresh&quot;, System.getProperty(&quot;hudson.Functions.autoRefreshSeconds&quot;, &quot;10&quot;));</span>
        }
<span class="nc" id="L621">    }</span>

    public static boolean isAutoRefresh(HttpServletRequest request) {
<span class="nc" id="L624">        String param = request.getParameter(&quot;auto_refresh&quot;);</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">        if (param != null) {</span>
<span class="nc" id="L626">            return Boolean.parseBoolean(param);</span>
        }
<span class="nc" id="L628">        Cookie[] cookies = request.getCookies();</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">        if(cookies==null)</span>
<span class="nc" id="L630">            return false; // when API design messes it up, we all suffer</span>

<span class="nc bnc" id="L632" title="All 2 branches missed.">        for (Cookie c : cookies) {</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">            if (c.getName().equals(&quot;hudson_auto_refresh&quot;)) {</span>
<span class="nc" id="L634">                return Boolean.parseBoolean(c.getValue());</span>
            }
        }
<span class="nc" id="L637">        return false;</span>
    }

    public static boolean isCollapsed(String paneId) {
<span class="nc" id="L641">    	return PaneStatusProperties.forCurrentUser().isCollapsed(paneId);</span>
    }
    
    /**
     * Finds the given object in the ancestor list and returns its URL.
     * This is used to determine the &quot;current&quot; URL assigned to the given object,
     * so that one can compute relative URLs from it.
     */
    public static String getNearestAncestorUrl(StaplerRequest req,Object it) {
<span class="nc" id="L650">        List list = req.getAncestors();</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">        for( int i=list.size()-1; i&gt;=0; i-- ) {</span>
<span class="nc" id="L652">            Ancestor anc = (Ancestor) list.get(i);</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">            if(anc.getObject()==it)</span>
<span class="nc" id="L654">                return anc.getUrl();</span>
        }
<span class="nc" id="L656">        return null;</span>
    }

    /**
     * Finds the inner-most {@link SearchableModelObject} in scope.
     */
    public static String getSearchURL() {
<span class="nc" id="L663">        List list = Stapler.getCurrentRequest().getAncestors();</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">        for( int i=list.size()-1; i&gt;=0; i-- ) {</span>
<span class="nc" id="L665">            Ancestor anc = (Ancestor) list.get(i);</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">            if(anc.getObject() instanceof SearchableModelObject)</span>
<span class="nc" id="L667">                return anc.getUrl()+&quot;/search/&quot;;</span>
        }
<span class="nc" id="L669">        return null;</span>
    }

    public static String appendSpaceIfNotNull(String n) {
<span class="nc bnc" id="L673" title="All 2 branches missed.">        if(n==null) return null;</span>
<span class="nc" id="L674">        else        return n+' ';</span>
    }

    /**
     * One nbsp per 10 pixels in given size, which may be a plain number or &quot;NxN&quot;
     * (like an iconSize).  Useful in a sortable table heading.
     */
    public static String nbspIndent(String size) {
<span class="nc" id="L682">        int i = size.indexOf('x');</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        i = Integer.parseInt(i &gt; 0 ? size.substring(0, i) : size) / 10;</span>
<span class="nc" id="L684">        StringBuilder buf = new StringBuilder(30);</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">        for (int j = 0; j &lt; i; j++)</span>
<span class="nc" id="L686">            buf.append(&quot;&amp;nbsp;&quot;);</span>
<span class="nc" id="L687">        return buf.toString();</span>
    }

    public static String getWin32ErrorMessage(IOException e) {
<span class="nc" id="L691">        return Util.getWin32ErrorMessage(e);</span>
    }

    public static boolean isMultiline(String s) {
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if(s==null)     return false;</span>
<span class="nc bnc" id="L696" title="All 4 branches missed.">        return s.indexOf('\r')&gt;=0 || s.indexOf('\n')&gt;=0;</span>
    }

    public static String encode(String s) {
<span class="nc" id="L700">        return Util.encode(s);</span>
    }

    public static String escape(String s) {
<span class="nc" id="L704">        return Util.escape(s);</span>
    }

    public static String xmlEscape(String s) {
<span class="nc" id="L708">        return Util.xmlEscape(s);</span>
    }

    public static String xmlUnescape(String s) {
<span class="nc" id="L712">        return s.replace(&quot;&amp;lt;&quot;,&quot;&lt;&quot;).replace(&quot;&amp;gt;&quot;,&quot;&gt;&quot;).replace(&quot;&amp;amp;&quot;,&quot;&amp;&quot;);</span>
    }

    public static String htmlAttributeEscape(String text) {
<span class="nc" id="L716">        StringBuilder buf = new StringBuilder(text.length()+64);</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">        for( int i=0; i&lt;text.length(); i++ ) {</span>
<span class="nc" id="L718">            char ch = text.charAt(i);</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">            if(ch=='&lt;')</span>
<span class="nc" id="L720">                buf.append(&quot;&amp;lt;&quot;);</span>
            else
<span class="nc bnc" id="L722" title="All 2 branches missed.">            if(ch=='&gt;')</span>
<span class="nc" id="L723">                buf.append(&quot;&amp;gt;&quot;);</span>
            else
<span class="nc bnc" id="L725" title="All 2 branches missed.">            if(ch=='&amp;')</span>
<span class="nc" id="L726">                buf.append(&quot;&amp;amp;&quot;);</span>
            else
<span class="nc bnc" id="L728" title="All 2 branches missed.">            if(ch=='&quot;')</span>
<span class="nc" id="L729">                buf.append(&quot;&amp;quot;&quot;);</span>
            else
<span class="nc bnc" id="L731" title="All 2 branches missed.">            if(ch=='\'')</span>
<span class="nc" id="L732">                buf.append(&quot;&amp;#39;&quot;);</span>
            else
<span class="nc" id="L734">                buf.append(ch);</span>
        }
<span class="nc" id="L736">        return buf.toString();</span>
    }

    public static void checkPermission(Permission permission) throws IOException, ServletException {
<span class="nc" id="L740">        checkPermission(Jenkins.getInstance(),permission);</span>
<span class="nc" id="L741">    }</span>

    public static void checkPermission(AccessControlled object, Permission permission) throws IOException, ServletException {
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (permission != null) {</span>
<span class="nc" id="L745">            object.checkPermission(permission);</span>
        }
<span class="nc" id="L747">    }</span>

    /**
     * This version is so that the 'checkPermission' on &lt;tt&gt;layout.jelly&lt;/tt&gt;
     * degrades gracefully if &quot;it&quot; is not an {@link AccessControlled} object.
     * Otherwise it will perform no check and that problem is hard to notice.
     */
    public static void checkPermission(Object object, Permission permission) throws IOException, ServletException {
<span class="nc bnc" id="L755" title="All 2 branches missed.">        if (permission == null)</span>
<span class="nc" id="L756">            return;</span>
        
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (object instanceof AccessControlled)</span>
<span class="nc" id="L759">            checkPermission((AccessControlled) object,permission);</span>
        else {
<span class="nc" id="L761">            List&lt;Ancestor&gt; ancs = Stapler.getCurrentRequest().getAncestors();</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">            for(Ancestor anc : Iterators.reverse(ancs)) {</span>
<span class="nc" id="L763">                Object o = anc.getObject();</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">                if (o instanceof AccessControlled) {</span>
<span class="nc" id="L765">                    checkPermission((AccessControlled) o,permission);</span>
<span class="nc" id="L766">                    return;</span>
                }
            }
<span class="nc" id="L769">            checkPermission(Jenkins.getInstance(),permission);</span>
        }
<span class="nc" id="L771">    }</span>

    /**
     * Returns true if the current user has the given permission.
     *
     * @param permission
     *      If null, returns true. This defaulting is convenient in making the use of this method terse.
     */
    public static boolean hasPermission(Permission permission) throws IOException, ServletException {
<span class="nc" id="L780">        return hasPermission(Jenkins.getInstance(),permission);</span>
    }

    /**
     * This version is so that the 'hasPermission' can degrade gracefully
     * if &quot;it&quot; is not an {@link AccessControlled} object.
     */
    public static boolean hasPermission(Object object, Permission permission) throws IOException, ServletException {
<span class="nc bnc" id="L788" title="All 2 branches missed.">        if (permission == null)</span>
<span class="nc" id="L789">            return true;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">        if (object instanceof AccessControlled)</span>
<span class="nc" id="L791">            return ((AccessControlled)object).hasPermission(permission);</span>
        else {
<span class="nc" id="L793">            List&lt;Ancestor&gt; ancs = Stapler.getCurrentRequest().getAncestors();</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">            for(Ancestor anc : Iterators.reverse(ancs)) {</span>
<span class="nc" id="L795">                Object o = anc.getObject();</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">                if (o instanceof AccessControlled) {</span>
<span class="nc" id="L797">                    return ((AccessControlled)o).hasPermission(permission);</span>
                }
            }
<span class="nc" id="L800">            return Jenkins.getInstance().hasPermission(permission);</span>
        }
    }

    public static void adminCheck(StaplerRequest req, StaplerResponse rsp, Object required, Permission permission) throws IOException, ServletException {
        // this is legacy --- all views should be eventually converted to
        // the permission based model.
<span class="nc bnc" id="L807" title="All 4 branches missed.">        if(required!=null &amp;&amp; !Hudson.adminCheck(req, rsp)) {</span>
            // check failed. commit the FORBIDDEN response, then abort.
<span class="nc" id="L809">            rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);</span>
<span class="nc" id="L810">            rsp.getOutputStream().close();</span>
<span class="nc" id="L811">            throw new ServletException(&quot;Unauthorized access&quot;);</span>
        }

        // make sure the user owns the necessary permission to access this page.
<span class="nc bnc" id="L815" title="All 2 branches missed.">        if(permission!=null)</span>
<span class="nc" id="L816">            checkPermission(permission);</span>
<span class="nc" id="L817">    }</span>

    /**
     * Infers the hudson installation URL from the given request.
     */
    public static String inferHudsonURL(StaplerRequest req) {
<span class="nc" id="L823">        String rootUrl = Jenkins.getInstance().getRootUrl();</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">        if(rootUrl !=null)</span>
            // prefer the one explicitly configured, to work with load-balancer, frontend, etc.
<span class="nc" id="L826">            return rootUrl;</span>
<span class="nc" id="L827">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L828">        buf.append(req.getScheme()).append(&quot;://&quot;);</span>
<span class="nc" id="L829">        buf.append(req.getServerName());</span>
<span class="nc bnc" id="L830" title="All 8 branches missed.">        if(! (req.getScheme().equals(&quot;http&quot;) &amp;&amp; req.getLocalPort()==80 || req.getScheme().equals(&quot;https&quot;) &amp;&amp; req.getLocalPort()==443))</span>
<span class="nc" id="L831">            buf.append(':').append(req.getLocalPort());</span>
<span class="nc" id="L832">        buf.append(req.getContextPath()).append('/');</span>
<span class="nc" id="L833">        return buf.toString();</span>
    }

    /**
     * Returns the link to be displayed in the footer of the UI.
     */
    public static String getFooterURL() {
<span class="nc bnc" id="L840" title="All 2 branches missed.">        if(footerURL == null) {</span>
<span class="nc" id="L841">            footerURL = System.getProperty(&quot;hudson.footerURL&quot;);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">            if(StringUtils.isBlank(footerURL)) {</span>
<span class="nc" id="L843">                footerURL = &quot;http://jenkins-ci.org/&quot;;</span>
            }
        }
<span class="nc" id="L846">        return footerURL;</span>
    }
<span class="fc" id="L848">    private static String footerURL = null;</span>

    public static List&lt;JobPropertyDescriptor&gt; getJobPropertyDescriptors(Class&lt;? extends Job&gt; clazz) {
<span class="nc" id="L851">        return JobPropertyDescriptor.getPropertyDescriptors(clazz);</span>
    }

    public static List&lt;JobPropertyDescriptor&gt; getJobPropertyDescriptors(Job job) {
<span class="nc" id="L855">        return DescriptorVisibilityFilter.apply(job, JobPropertyDescriptor.getPropertyDescriptors(job.getClass()));</span>
    }

    public static List&lt;Descriptor&lt;BuildWrapper&gt;&gt; getBuildWrapperDescriptors(AbstractProject&lt;?,?&gt; project) {
<span class="nc" id="L859">        return BuildWrappers.getFor(project);</span>
    }

    public static List&lt;Descriptor&lt;SecurityRealm&gt;&gt; getSecurityRealmDescriptors() {
<span class="nc" id="L863">        return SecurityRealm.all();</span>
    }

    public static List&lt;Descriptor&lt;AuthorizationStrategy&gt;&gt; getAuthorizationStrategyDescriptors() {
<span class="nc" id="L867">        return AuthorizationStrategy.all();</span>
    }

    public static List&lt;Descriptor&lt;Builder&gt;&gt; getBuilderDescriptors(AbstractProject&lt;?,?&gt; project) {
<span class="nc" id="L871">        return BuildStepDescriptor.filter(Builder.all(), project.getClass());</span>
    }

    public static List&lt;Descriptor&lt;Publisher&gt;&gt; getPublisherDescriptors(AbstractProject&lt;?,?&gt; project) {
<span class="nc" id="L875">        return BuildStepDescriptor.filter(Publisher.all(), project.getClass());</span>
    }

    public static List&lt;SCMDescriptor&lt;?&gt;&gt; getSCMDescriptors(AbstractProject&lt;?,?&gt; project) {
<span class="nc" id="L879">        return SCM._for(project);</span>
    }

    public static List&lt;Descriptor&lt;ComputerLauncher&gt;&gt; getComputerLauncherDescriptors() {
<span class="nc" id="L883">        return Jenkins.getInstance().&lt;ComputerLauncher,Descriptor&lt;ComputerLauncher&gt;&gt;getDescriptorList(ComputerLauncher.class);</span>
    }

    public static List&lt;Descriptor&lt;RetentionStrategy&lt;?&gt;&gt;&gt; getRetentionStrategyDescriptors() {
<span class="nc" id="L887">        return RetentionStrategy.all();</span>
    }

    public static List&lt;ParameterDescriptor&gt; getParameterDescriptors() {
<span class="nc" id="L891">        return ParameterDefinition.all();</span>
    }

    public static List&lt;Descriptor&lt;CaptchaSupport&gt;&gt; getCaptchaSupportDescriptors() {
<span class="nc" id="L895">        return CaptchaSupport.all();</span>
    }

    public static List&lt;Descriptor&lt;ViewsTabBar&gt;&gt; getViewsTabBarDescriptors() {
<span class="nc" id="L899">        return ViewsTabBar.all();</span>
    }

    public static List&lt;Descriptor&lt;MyViewsTabBar&gt;&gt; getMyViewsTabBarDescriptors() {
<span class="nc" id="L903">        return MyViewsTabBar.all();</span>
    }

    public static List&lt;NodePropertyDescriptor&gt; getNodePropertyDescriptors(Class&lt;? extends Node&gt; clazz) {
<span class="nc" id="L907">        List&lt;NodePropertyDescriptor&gt; result = new ArrayList&lt;NodePropertyDescriptor&gt;();</span>
<span class="nc" id="L908">        Collection&lt;NodePropertyDescriptor&gt; list = (Collection) Jenkins.getInstance().getDescriptorList(NodeProperty.class);</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">        for (NodePropertyDescriptor npd : list) {</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (npd.isApplicable(clazz)) {</span>
<span class="nc" id="L911">                result.add(npd);</span>
            }
        }
<span class="nc" id="L914">        return result;</span>
    }

    /**
     * Returns those node properties which can be configured as global node properties.
     *
     * @since 1.520
     */
    public static List&lt;NodePropertyDescriptor&gt; getGlobalNodePropertyDescriptors() {
<span class="nc" id="L923">        List&lt;NodePropertyDescriptor&gt; result = new ArrayList&lt;NodePropertyDescriptor&gt;();</span>
<span class="nc" id="L924">        Collection&lt;NodePropertyDescriptor&gt; list = (Collection) Jenkins.getInstance().getDescriptorList(NodeProperty.class);</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">        for (NodePropertyDescriptor npd : list) {</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">            if (npd.isApplicableAsGlobal()) {</span>
<span class="nc" id="L927">                result.add(npd);</span>
            }
        }
<span class="nc" id="L930">        return result;</span>
    }

    /**
     * Gets all the descriptors sorted by their inheritance tree of {@link Describable}
     * so that descriptors of similar types come nearby.
     *
     * &lt;p&gt;
     * We sort them by {@link Extension#ordinal()} but only for {@link GlobalConfiguration}s,
     * as the value is normally used to compare similar kinds of extensions, and we needed
     * {@link GlobalConfiguration}s to be able to position themselves in a layer above.
     * This however creates some asymmetry between regular {@link Descriptor}s and {@link GlobalConfiguration}s.
     * Perhaps it is better to introduce another annotation element? But then,
     * extensions shouldn't normally concern themselves about ordering too much, and the only reason
     * we needed this for {@link GlobalConfiguration}s are for backward compatibility.
     *
     * @param predicate
     *      Filter the descriptors based on {@link GlobalConfigurationCategory}
     * @since 1.494
     */
    public static Collection&lt;Descriptor&gt; getSortedDescriptorsForGlobalConfig(Predicate&lt;GlobalConfigurationCategory&gt; predicate) {
<span class="nc" id="L951">        ExtensionList&lt;Descriptor&gt; exts = ExtensionList.lookup(Descriptor.class);</span>
<span class="nc" id="L952">        List&lt;Tag&gt; r = new ArrayList&lt;Tag&gt;(exts.size());</span>

<span class="nc bnc" id="L954" title="All 2 branches missed.">        for (ExtensionComponent&lt;Descriptor&gt; c : exts.getComponents()) {</span>
<span class="nc" id="L955">            Descriptor d = c.getInstance();</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">            if (d.getGlobalConfigPage()==null)  continue;</span>

<span class="nc bnc" id="L958" title="All 2 branches missed.">            if (d instanceof GlobalConfiguration) {</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">                if (predicate.apply(((GlobalConfiguration)d).getCategory()))</span>
<span class="nc" id="L960">                    r.add(new Tag(c.ordinal(), d));</span>
<span class="nc" id="L961">            } else {</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                if (predicate.apply(GlobalConfigurationCategory.get(Unclassified.class)))</span>
<span class="nc" id="L963">                    r.add(new Tag(0, d));</span>
            }
        }
<span class="nc" id="L966">        Collections.sort(r);</span>

<span class="nc" id="L968">        List&lt;Descriptor&gt; answer = new ArrayList&lt;Descriptor&gt;(r.size());</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">        for (Tag d : r) answer.add(d.d);</span>

<span class="nc" id="L971">        return DescriptorVisibilityFilter.apply(Jenkins.getInstance(),answer);</span>
    }

    /**
     * Like {@link #getSortedDescriptorsForGlobalConfig(Predicate)} but with a constant truth predicate, to include all descriptors.
     */
    public static Collection&lt;Descriptor&gt; getSortedDescriptorsForGlobalConfig() {
<span class="nc" id="L978">        return getSortedDescriptorsForGlobalConfig(Predicates.&lt;GlobalConfigurationCategory&gt;alwaysTrue());</span>
    }

    /**
     * @deprecated This is rather meaningless.
     */
    @Deprecated
    public static Collection&lt;Descriptor&gt; getSortedDescriptorsForGlobalConfigNoSecurity() {
<span class="nc" id="L986">        return getSortedDescriptorsForGlobalConfig(Predicates.not(GlobalSecurityConfiguration.FILTER));</span>
    }

    /**
     * Like {@link #getSortedDescriptorsForGlobalConfig(Predicate)} but for unclassified descriptors only.
     * @since 1.506
     */
    public static Collection&lt;Descriptor&gt; getSortedDescriptorsForGlobalConfigUnclassified() {
<span class="nc" id="L994">        return getSortedDescriptorsForGlobalConfig(new Predicate&lt;GlobalConfigurationCategory&gt;() {</span>
            public boolean apply(GlobalConfigurationCategory cat) {
<span class="nc" id="L996">                return cat instanceof GlobalConfigurationCategory.Unclassified;</span>
            }
        });
    }
    
    private static class Tag implements Comparable&lt;Tag&gt; {
        double ordinal;
        String hierarchy;
        Descriptor d;

<span class="nc" id="L1006">        Tag(double ordinal, Descriptor d) {</span>
<span class="nc" id="L1007">            this.ordinal = ordinal;</span>
<span class="nc" id="L1008">            this.d = d;</span>
<span class="nc" id="L1009">            this.hierarchy = buildSuperclassHierarchy(d.clazz, new StringBuilder()).toString();</span>
<span class="nc" id="L1010">        }</span>

        private StringBuilder buildSuperclassHierarchy(Class c, StringBuilder buf) {
<span class="nc" id="L1013">            Class sc = c.getSuperclass();</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">            if (sc!=null)   buildSuperclassHierarchy(sc,buf).append(':');</span>
<span class="nc" id="L1015">            return buf.append(c.getName());</span>
        }

        public int compareTo(Tag that) {
<span class="nc" id="L1019">            int r = Double.compare(this.ordinal, that.ordinal);</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">            if (r!=0)   return -r; // descending for ordinal</span>
<span class="nc" id="L1021">            return this.hierarchy.compareTo(that.hierarchy);</span>
        }
    }
    /**
     * Computes the path to the icon of the given action
     * from the context path.
     */
    public static String getIconFilePath(Action a) {
<span class="nc" id="L1029">        String name = a.getIconFileName();</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (name==null)     return null;</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        if (name.startsWith(&quot;/&quot;))</span>
<span class="nc" id="L1032">            return name.substring(1);</span>
        else
<span class="nc" id="L1034">            return &quot;images/24x24/&quot;+name;</span>
    }

    /**
     * Works like JSTL build-in size(x) function,
     * but handle null gracefully.
     */
    public static int size2(Object o) throws Exception {
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        if(o==null) return 0;</span>
<span class="nc" id="L1043">        return ASTSizeFunction.sizeOf(o,Introspector.getUberspect());</span>
    }

    /**
     * Computes the relative path from the current page to the given item.
     */
    public static String getRelativeLinkTo(Item p) {
<span class="nc" id="L1050">        Map&lt;Object,String&gt; ancestors = new HashMap&lt;Object,String&gt;();</span>
<span class="nc" id="L1051">        View view=null;</span>

<span class="nc" id="L1053">        StaplerRequest request = Stapler.getCurrentRequest();</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        for( Ancestor a : request.getAncestors() ) {</span>
<span class="nc" id="L1055">            ancestors.put(a.getObject(),a.getRelativePath());</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">            if(a.getObject() instanceof View)</span>
<span class="nc" id="L1057">                view = (View) a.getObject();</span>
        }

<span class="nc" id="L1060">        String path = ancestors.get(p);</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">        if(path!=null) {</span>
<span class="nc" id="L1062">            return normalizeURI(path + '/');</span>
        }

<span class="nc" id="L1065">        Item i=p;</span>
<span class="nc" id="L1066">        String url = &quot;&quot;;</span>
<span class="nc" id="L1067">        while(true) {</span>
<span class="nc" id="L1068">            ItemGroup ig = i.getParent();</span>
<span class="nc" id="L1069">            url = i.getShortUrl()+url;</span>

<span class="nc bnc" id="L1071" title="All 6 branches missed.">            if(ig== Jenkins.getInstance() || (view != null &amp;&amp; ig == view.getOwnerItemGroup())) {</span>
<span class="nc bnc" id="L1072" title="All 4 branches missed.">                assert i instanceof TopLevelItem;</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                if (view != null) {</span>
                    // assume p and the current page belong to the same view, so return a relative path
                    // (even if they did not, View.getItem does not by default verify ownership)
<span class="nc" id="L1076">                    return normalizeURI(ancestors.get(view)+'/'+url);</span>
                } else {
                    // otherwise return a path from the root Hudson
<span class="nc" id="L1079">                    return normalizeURI(request.getContextPath()+'/'+p.getUrl());</span>
                }
            }

<span class="nc" id="L1083">            path = ancestors.get(ig);</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">            if(path!=null) {</span>
<span class="nc" id="L1085">                return normalizeURI(path+'/'+url);</span>
            }

<span class="nc bnc" id="L1088" title="All 4 branches missed.">            assert ig instanceof Item; // if not, ig must have been the Hudson instance</span>
<span class="nc" id="L1089">            i = (Item) ig;</span>
        }
    }
    
    private static String normalizeURI(String uri) {
<span class="nc" id="L1094">        return URI.create(uri).normalize().toString();</span>
    }
    
    /**
     * Gets all the {@link TopLevelItem}s recursively in the {@link ItemGroup} tree.
     * 
     * @since 1.512
     */
    public static List&lt;TopLevelItem&gt; getAllTopLevelItems(ItemGroup root) {
<span class="nc" id="L1103">      return Items.getAllItems(root, TopLevelItem.class);</span>
    }
    
    /**
     * Gets the relative name or display name to the given item from the specified group.
     *
     * @since 1.515
     * @param p the Item we want the relative display name
     * @param g the ItemGroup used as point of reference for the item
     * @param useDisplayName if true, returns a display name, otherwise returns a name
     * @return
     *      String like &quot;foo Â» bar&quot;
     */
    public static String getRelativeNameFrom(Item p, ItemGroup g, boolean useDisplayName) {
<span class="nc bnc" id="L1117" title="All 2 branches missed.">        if (p == null) return null;</span>
<span class="nc bnc" id="L1118" title="All 4 branches missed.">        if (g == null) return useDisplayName ? p.getFullDisplayName() : p.getFullName();</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">        String separationString = useDisplayName ? &quot; Â» &quot; : &quot;/&quot;;</span>
        
        // first list up all the parents
<span class="nc" id="L1122">        Map&lt;ItemGroup,Integer&gt; parents = new HashMap&lt;ItemGroup,Integer&gt;();</span>
<span class="nc" id="L1123">        int depth=0;</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">        while (g!=null) {</span>
<span class="nc" id="L1125">            parents.put(g, depth++);</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">            if (g instanceof Item)</span>
<span class="nc" id="L1127">                g = ((Item)g).getParent();</span>
            else
<span class="nc" id="L1129">                g = null;</span>
        }

<span class="nc" id="L1132">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L1133">        Item i=p;</span>
        while (true) {
<span class="nc bnc" id="L1135" title="All 2 branches missed.">            if (buf.length()&gt;0) buf.insert(0,separationString);</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">            buf.insert(0,useDisplayName ? i.getDisplayName() : i.getName());</span>
<span class="nc" id="L1137">            ItemGroup gr = i.getParent();</span>

<span class="nc" id="L1139">            Integer d = parents.get(gr);</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">            if (d!=null) {</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">                for (int j=d; j&gt;0; j--) {</span>
<span class="nc" id="L1142">                    buf.insert(0,separationString);</span>
<span class="nc" id="L1143">                    buf.insert(0,&quot;..&quot;);</span>
                }
<span class="nc" id="L1145">                return buf.toString();</span>
            }

<span class="nc bnc" id="L1148" title="All 2 branches missed.">            if (gr instanceof Item)</span>
<span class="nc" id="L1149">                i = (Item)gr;</span>
            else
<span class="nc" id="L1151">                return null;</span>
        }
    }
    
    /**
     * Gets the name to the given item relative to given group.
     *
     * @since 1.515
     * @param p the Item we want the relative display name
     * @param g the ItemGroup used as point of reference for the item
     * @return
     *      String like &quot;foo/bar&quot;
     */
    public static String getRelativeNameFrom(Item p, ItemGroup g) {
<span class="nc" id="L1165">        return getRelativeNameFrom(p, g, false);</span>
    }    
    
    
    /**
     * Gets the relative display name to the given item from the specified group.
     *
     * @since 1.512
     * @param p the Item we want the relative display name
     * @param g the ItemGroup used as point of reference for the item
     * @return
     *      String like &quot;Foo Â» Bar&quot;
     */
    public static String getRelativeDisplayNameFrom(Item p, ItemGroup g) {
<span class="nc" id="L1179">        return getRelativeNameFrom(p, g, true);</span>
    }

    public static Map&lt;Thread,StackTraceElement[]&gt; dumpAllThreads() {
<span class="nc" id="L1183">        Map&lt;Thread,StackTraceElement[]&gt; sorted = new TreeMap&lt;Thread,StackTraceElement[]&gt;(new ThreadSorter());</span>
<span class="nc" id="L1184">        sorted.putAll(Thread.getAllStackTraces());</span>
<span class="nc" id="L1185">        return sorted;</span>
    }

    public static ThreadInfo[] getThreadInfos() {
<span class="nc" id="L1189">        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();</span>
<span class="nc" id="L1190">        return mbean.dumpAllThreads(mbean.isObjectMonitorUsageSupported(),mbean.isSynchronizerUsageSupported());</span>
    }

    public static ThreadGroupMap sortThreadsAndGetGroupMap(ThreadInfo[] list) {
<span class="nc" id="L1194">        ThreadGroupMap sorter = new ThreadGroupMap();</span>
<span class="nc" id="L1195">        Arrays.sort(list, sorter);</span>
<span class="nc" id="L1196">        return sorter;</span>
    }

    // Common code for sorting Threads/ThreadInfos by ThreadGroup
    private static class ThreadSorterBase {
<span class="nc" id="L1201">        protected Map&lt;Long,String&gt; map = new HashMap&lt;Long,String&gt;();</span>

<span class="nc" id="L1203">        private ThreadSorterBase() {</span>
<span class="nc" id="L1204">            ThreadGroup tg = Thread.currentThread().getThreadGroup();</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">            while (tg.getParent() != null) tg = tg.getParent();</span>
<span class="nc" id="L1206">            Thread[] threads = new Thread[tg.activeCount()*2];</span>
<span class="nc" id="L1207">            int threadsLen = tg.enumerate(threads, true);</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">            for (int i = 0; i &lt; threadsLen; i++) {</span>
<span class="nc" id="L1209">                ThreadGroup group = threads[i].getThreadGroup();</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">                map.put(threads[i].getId(), group != null ? group.getName() : null);</span>
            }
<span class="nc" id="L1212">        }</span>

        protected int compare(long idA, long idB) {
<span class="nc" id="L1215">            String tga = map.get(idA), tgb = map.get(idB);</span>
<span class="nc bnc" id="L1216" title="All 4 branches missed.">            int result = (tga!=null?-1:0) + (tgb!=null?1:0);  // Will be non-zero if only one is null</span>
<span class="nc bnc" id="L1217" title="All 4 branches missed.">            if (result==0 &amp;&amp; tga!=null)</span>
<span class="nc" id="L1218">                result = tga.compareToIgnoreCase(tgb);</span>
<span class="nc" id="L1219">            return result;</span>
        }
    }

<span class="nc" id="L1223">    public static class ThreadGroupMap extends ThreadSorterBase implements Comparator&lt;ThreadInfo&gt; {</span>

        /**
         * @return ThreadGroup name or null if unknown
         */
        public String getThreadGroup(ThreadInfo ti) {
<span class="nc" id="L1229">            return map.get(ti.getThreadId());</span>
        }

        public int compare(ThreadInfo a, ThreadInfo b) {
<span class="nc" id="L1233">            int result = compare(a.getThreadId(), b.getThreadId());</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">            if (result == 0)</span>
<span class="nc" id="L1235">                result = a.getThreadName().compareToIgnoreCase(b.getThreadName());</span>
<span class="nc" id="L1236">            return result;</span>
        }
    }

<span class="nc" id="L1240">    private static class ThreadSorter extends ThreadSorterBase implements Comparator&lt;Thread&gt; {</span>

        public int compare(Thread a, Thread b) {
<span class="nc" id="L1243">            int result = compare(a.getId(), b.getId());</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">            if (result == 0)</span>
<span class="nc" id="L1245">                result = a.getName().compareToIgnoreCase(b.getName());</span>
<span class="nc" id="L1246">            return result;</span>
        }
    }

    /**
     * @deprecated Now always true.
     */
    @Deprecated
    public static boolean isMustangOrAbove() {
<span class="nc" id="L1255">        return true;</span>
    }

    // ThreadInfo.toString() truncates the stack trace by first 8, so needed my own version
    public static String dumpThreadInfo(ThreadInfo ti, ThreadGroupMap map) {
<span class="nc" id="L1260">        String grp = map.getThreadGroup(ti);</span>
<span class="nc" id="L1261">        StringBuilder sb = new StringBuilder(&quot;\&quot;&quot; + ti.getThreadName() + &quot;\&quot;&quot; +</span>
<span class="nc" id="L1262">                                             &quot; Id=&quot; + ti.getThreadId() + &quot; Group=&quot; +</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">                                             (grp != null ? grp : &quot;?&quot;) + &quot; &quot; +</span>
<span class="nc" id="L1264">                                             ti.getThreadState());</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">        if (ti.getLockName() != null) {</span>
<span class="nc" id="L1266">            sb.append(&quot; on &quot; + ti.getLockName());</span>
        }
<span class="nc bnc" id="L1268" title="All 2 branches missed.">        if (ti.getLockOwnerName() != null) {</span>
<span class="nc" id="L1269">            sb.append(&quot; owned by \&quot;&quot; + ti.getLockOwnerName() +</span>
<span class="nc" id="L1270">                      &quot;\&quot; Id=&quot; + ti.getLockOwnerId());</span>
        }
<span class="nc bnc" id="L1272" title="All 2 branches missed.">        if (ti.isSuspended()) {</span>
<span class="nc" id="L1273">            sb.append(&quot; (suspended)&quot;);</span>
        }
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        if (ti.isInNative()) {</span>
<span class="nc" id="L1276">            sb.append(&quot; (in native)&quot;);</span>
        }
<span class="nc" id="L1278">        sb.append('\n');</span>
<span class="nc" id="L1279">        StackTraceElement[] stackTrace = ti.getStackTrace();</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">        for (int i=0; i &lt; stackTrace.length; i++) {</span>
<span class="nc" id="L1281">            StackTraceElement ste = stackTrace[i];</span>
<span class="nc" id="L1282">            sb.append(&quot;\tat &quot;).append(ste);</span>
<span class="nc" id="L1283">            sb.append('\n');</span>
<span class="nc bnc" id="L1284" title="All 4 branches missed.">            if (i == 0 &amp;&amp; ti.getLockInfo() != null) {</span>
<span class="nc" id="L1285">                Thread.State ts = ti.getThreadState();</span>
<span class="nc bnc" id="L1286" title="All 4 branches missed.">                switch (ts) {</span>
                    case BLOCKED:
<span class="nc" id="L1288">                        sb.append(&quot;\t-  blocked on &quot;).append(ti.getLockInfo());</span>
<span class="nc" id="L1289">                        sb.append('\n');</span>
<span class="nc" id="L1290">                        break;</span>
                    case WAITING:
<span class="nc" id="L1292">                        sb.append(&quot;\t-  waiting on &quot;).append(ti.getLockInfo());</span>
<span class="nc" id="L1293">                        sb.append('\n');</span>
<span class="nc" id="L1294">                        break;</span>
                    case TIMED_WAITING:
<span class="nc" id="L1296">                        sb.append(&quot;\t-  waiting on &quot;).append(ti.getLockInfo());</span>
<span class="nc" id="L1297">                        sb.append('\n');</span>
                        break;
                    default:
                }
            }

<span class="nc bnc" id="L1303" title="All 2 branches missed.">            for (MonitorInfo mi : ti.getLockedMonitors()) {</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">                if (mi.getLockedStackDepth() == i) {</span>
<span class="nc" id="L1305">                    sb.append(&quot;\t-  locked &quot;).append(mi);</span>
<span class="nc" id="L1306">                    sb.append('\n');</span>
                }
            }
       }

<span class="nc" id="L1311">       LockInfo[] locks = ti.getLockedSynchronizers();</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">       if (locks.length &gt; 0) {</span>
<span class="nc" id="L1313">           sb.append(&quot;\n\tNumber of locked synchronizers = &quot; + locks.length);</span>
<span class="nc" id="L1314">           sb.append('\n');</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">           for (LockInfo li : locks) {</span>
<span class="nc" id="L1316">               sb.append(&quot;\t- &quot;).append(li);</span>
<span class="nc" id="L1317">               sb.append('\n');</span>
           }
       }
<span class="nc" id="L1320">       sb.append('\n');</span>
<span class="nc" id="L1321">       return sb.toString();</span>
    }

    public static &lt;T&gt; Collection&lt;T&gt; emptyList() {
<span class="nc" id="L1325">        return Collections.emptyList();</span>
    }

    public static String jsStringEscape(String s) {
<span class="nc" id="L1329">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">        for( int i=0; i&lt;s.length(); i++ ) {</span>
<span class="nc" id="L1331">            char ch = s.charAt(i);</span>
<span class="nc bnc" id="L1332" title="All 4 branches missed.">            switch(ch) {</span>
            case '\'':
<span class="nc" id="L1334">                buf.append(&quot;\\'&quot;);</span>
<span class="nc" id="L1335">                break;</span>
            case '\\':
<span class="nc" id="L1337">                buf.append(&quot;\\\\&quot;);</span>
<span class="nc" id="L1338">                break;</span>
            case '&quot;':
<span class="nc" id="L1340">                buf.append(&quot;\\\&quot;&quot;);</span>
<span class="nc" id="L1341">                break;</span>
            default:
<span class="nc" id="L1343">                buf.append(ch);</span>
            }
        }
<span class="nc" id="L1346">        return buf.toString();</span>
    }

    /**
     * Converts &quot;abc&quot; to &quot;Abc&quot;.
     */
    public static String capitalize(String s) {
<span class="nc bnc" id="L1353" title="All 4 branches missed.">        if(s==null || s.length()==0) return s;</span>
<span class="nc" id="L1354">        return Character.toUpperCase(s.charAt(0))+s.substring(1);</span>
    }

    public static String getVersion() {
<span class="nc" id="L1358">        return Jenkins.VERSION;</span>
    }

    /**
     * Resoruce path prefix.
     */
    public static String getResourcePath() {
<span class="nc" id="L1365">        return Jenkins.RESOURCE_PATH;</span>
    }

    public static String getViewResource(Object it, String path) {
<span class="nc" id="L1369">        Class clazz = it.getClass();</span>

<span class="nc bnc" id="L1371" title="All 2 branches missed.">        if(it instanceof Class)</span>
<span class="nc" id="L1372">            clazz = (Class)it;</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">        if(it instanceof Descriptor)</span>
<span class="nc" id="L1374">            clazz = ((Descriptor)it).clazz;</span>

<span class="nc" id="L1376">        StringBuilder buf = new StringBuilder(Stapler.getCurrentRequest().getContextPath());</span>
<span class="nc" id="L1377">        buf.append(Jenkins.VIEW_RESOURCE_PATH).append('/');</span>
<span class="nc" id="L1378">        buf.append(clazz.getName().replace('.','/').replace('$','/'));</span>
<span class="nc" id="L1379">        buf.append('/').append(path);</span>

<span class="nc" id="L1381">        return buf.toString();</span>
    }

    public static boolean hasView(Object it, String path) throws IOException {
<span class="nc bnc" id="L1385" title="All 2 branches missed.">        if(it==null)    return false;</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">        return Stapler.getCurrentRequest().getView(it,path)!=null;</span>
    }

    /**
     * Can be used to check a checkbox by default.
     * Used from views like {@code h.defaultToTrue(scm.useUpdate)}.
     * The expression will evaluate to true if scm is null.
     */
    public static boolean defaultToTrue(Boolean b) {
<span class="nc bnc" id="L1395" title="All 2 branches missed.">        if(b==null) return true;</span>
<span class="nc" id="L1396">        return b;</span>
    }

    /**
     * If the value exists, return that value. Otherwise return the default value.
     * &lt;p&gt;
     * Starting 1.294, JEXL supports the elvis operator &quot;x?:y&quot; that supersedes this.
     *
     * @since 1.150
     */
    public static &lt;T&gt; T defaulted(T value, T defaultValue) {
<span class="nc bnc" id="L1407" title="All 2 branches missed.">        return value!=null ? value : defaultValue;</span>
    }

    /**
     * Gets info about the specified {@link Throwable}.
     * @param t Input {@link Throwable}
     * @return If {@link Throwable} is not null, a summary info with the 
     *      stacktrace will be returned. Otherwise, the method returns a default
     *      &amp;quot;No exception details&amp;quot; string.
     */
    public static String printThrowable(@CheckForNull Throwable t) {
<span class="pc bpc" id="L1418" title="1 of 2 branches missed.">        if (t == null) {</span>
<span class="nc" id="L1419">            return Messages.Functions_NoExceptionDetails();</span>
        }
<span class="fc" id="L1421">        StringWriter sw = new StringWriter();</span>
<span class="fc" id="L1422">        t.printStackTrace(new PrintWriter(sw));</span>
<span class="fc" id="L1423">        return sw.toString();</span>
    }

    /**
     * Counts the number of rows needed for textarea to fit the content.
     * Minimum 5 rows.
     */
    public static int determineRows(String s) {
<span class="nc bnc" id="L1431" title="All 2 branches missed.">        if(s==null)     return 5;</span>
<span class="nc" id="L1432">        return Math.max(5,LINE_END.split(s).length);</span>
    }

    /**
     * Converts the Hudson build status to CruiseControl build status,
     * which is either Success, Failure, Exception, or Unknown.
     */
    public static String toCCStatus(Item i) {
<span class="nc bnc" id="L1440" title="All 2 branches missed.">        if (i instanceof Job) {</span>
<span class="nc" id="L1441">            Job j = (Job) i;</span>
<span class="nc bnc" id="L1442" title="All 4 branches missed.">            switch (j.getIconColor()) {</span>
            case ABORTED:
            case ABORTED_ANIME:
            case RED:
            case RED_ANIME:
            case YELLOW:
            case YELLOW_ANIME:
<span class="nc" id="L1449">                return &quot;Failure&quot;;</span>
            case BLUE:
            case BLUE_ANIME:
<span class="nc" id="L1452">                return &quot;Success&quot;;</span>
            case DISABLED:
            case DISABLED_ANIME:
            case GREY:
            case GREY_ANIME:
            case NOTBUILT:
            case NOTBUILT_ANIME:
<span class="nc" id="L1459">                return &quot;Unknown&quot;;</span>
            }
        }
<span class="nc" id="L1462">        return &quot;Unknown&quot;;</span>
    }

<span class="fc" id="L1465">    private static final Pattern LINE_END = Pattern.compile(&quot;\r?\n&quot;);</span>

    /**
     * Checks if the current user is anonymous.
     */
    public static boolean isAnonymous() {
<span class="nc" id="L1471">        return Jenkins.getAuthentication() instanceof AnonymousAuthenticationToken;</span>
    }

    /**
     * When called from within JEXL expression evaluation,
     * this method returns the current {@link JellyContext} used
     * to evaluate the script.
     *
     * @since 1.164
     */
    public static JellyContext getCurrentJellyContext() {
<span class="nc" id="L1482">        JellyContext context = ExpressionFactory2.CURRENT_CONTEXT.get();</span>
<span class="nc bnc" id="L1483" title="All 4 branches missed.">        assert context!=null;</span>
<span class="nc" id="L1484">        return context;</span>
    }

    /**
     * Evaluate a Jelly script and return output as a String.
     *
     * @since 1.267
     */
    public static String runScript(Script script) throws JellyTagException {
<span class="nc" id="L1493">        StringWriter out = new StringWriter();</span>
<span class="nc" id="L1494">        script.run(getCurrentJellyContext(), XMLOutput.createXMLOutput(out));</span>
<span class="nc" id="L1495">        return out.toString();</span>
    }

    /**
     * Returns a sub-list if the given list is bigger than the specified {@code maxSize}.
     * &lt;strong&gt;Warning:&lt;/strong&gt; do not call this with a {@link RunList}, or you will break lazy loading!
     */
    public static &lt;T&gt; List&lt;T&gt; subList(List&lt;T&gt; base, int maxSize) {
<span class="nc bnc" id="L1503" title="All 2 branches missed.">        if(maxSize&lt;base.size())</span>
<span class="nc" id="L1504">            return base.subList(0,maxSize);</span>
        else
<span class="nc" id="L1506">            return base;</span>
    }

    /**
     * Combine path components via '/' while handling leading/trailing '/' to avoid duplicates.
     */
    public static String joinPath(String... components) {
<span class="nc" id="L1513">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">        for (String s : components) {</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">            if (s.length()==0)  continue;</span>

<span class="nc bnc" id="L1517" title="All 2 branches missed.">            if (buf.length()&gt;0) {</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">                if (buf.charAt(buf.length()-1)!='/')</span>
<span class="nc" id="L1519">                    buf.append('/');</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">                if (s.charAt(0)=='/')   s=s.substring(1);</span>
            }
<span class="nc" id="L1522">            buf.append(s);</span>
        }
<span class="nc" id="L1524">        return buf.toString();</span>
    }

    /**
     * Computes the hyperlink to actions, to handle the situation when the {@link Action#getUrlName()}
     * returns absolute URL.
     */
    public static String getActionUrl(String itUrl,Action action) {
<span class="nc" id="L1532">        String urlName = action.getUrlName();</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">        if(urlName==null)   return null;    // to avoid NPE and fail to render the whole page</span>
        try {
<span class="nc bnc" id="L1535" title="All 2 branches missed.">            if (new URI(urlName).isAbsolute()) {</span>
<span class="nc" id="L1536">                return urlName;</span>
            }
<span class="nc" id="L1538">        } catch (URISyntaxException x) {</span>
<span class="nc" id="L1539">            Logger.getLogger(Functions.class.getName()).log(Level.WARNING, &quot;Failed to parse URL for {0}: {1}&quot;, new Object[] {action, x});</span>
<span class="nc" id="L1540">            return null;</span>
        }
<span class="nc bnc" id="L1542" title="All 2 branches missed.">        if(urlName.startsWith(&quot;/&quot;))</span>
<span class="nc" id="L1543">            return joinPath(Stapler.getCurrentRequest().getContextPath(),urlName);</span>
        else
            // relative URL name
<span class="nc" id="L1546">            return joinPath(Stapler.getCurrentRequest().getContextPath()+'/'+itUrl,urlName);</span>
    }

    /**
     * Escapes the character unsafe for e-mail address.
     * See http://en.wikipedia.org/wiki/E-mail_address for the details,
     * but here the vocabulary is even more restricted.
     */
    public static String toEmailSafeString(String projectName) {
        // TODO: escape non-ASCII characters
<span class="nc" id="L1556">        StringBuilder buf = new StringBuilder(projectName.length());</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">        for( int i=0; i&lt;projectName.length(); i++ ) {</span>
<span class="nc" id="L1558">            char ch = projectName.charAt(i);</span>
<span class="nc bnc" id="L1559" title="All 4 branches missed.">            if(('a'&lt;=ch &amp;&amp; ch&lt;='z')</span>
<span class="nc bnc" id="L1560" title="All 4 branches missed.">            || ('z'&lt;=ch &amp;&amp; ch&lt;='Z')</span>
<span class="nc bnc" id="L1561" title="All 4 branches missed.">            || ('0'&lt;=ch &amp;&amp; ch&lt;='9')</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">            || &quot;-_.&quot;.indexOf(ch)&gt;=0)</span>
<span class="nc" id="L1563">                buf.append(ch);</span>
            else
<span class="nc" id="L1565">                buf.append('_');    // escape</span>
        }
<span class="nc" id="L1567">        return projectName;</span>
    }

    public String getSystemProperty(String key) {
<span class="nc" id="L1571">        return System.getProperty(key);</span>
    }

    /**
     * Obtains the host name of the Hudson server that clients can use to talk back to.
     * &lt;p&gt;
     * This is primarily used in &lt;tt&gt;slave-agent.jnlp.jelly&lt;/tt&gt; to specify the destination
     * that the slaves talk to.
     */
    public String getServerName() {
        // Try to infer this from the configured root URL.
        // This makes it work correctly when Hudson runs behind a reverse proxy.
<span class="nc" id="L1583">        String url = Jenkins.getInstance().getRootUrl();</span>
        try {
<span class="nc bnc" id="L1585" title="All 2 branches missed.">            if(url!=null) {</span>
<span class="nc" id="L1586">                String host = new URL(url).getHost();</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">                if(host!=null)</span>
<span class="nc" id="L1588">                    return host;</span>
            }
<span class="nc" id="L1590">        } catch (MalformedURLException e) {</span>
            // fall back to HTTP request
        }
<span class="nc" id="L1593">        return Stapler.getCurrentRequest().getServerName();</span>
    }

    /**
     * Determines the form validation check URL. See textbox.jelly
     *
     * @deprecated
     *      Use {@link #calcCheckUrl}
     */
    @Deprecated
    public String getCheckUrl(String userDefined, Object descriptor, String field) {
<span class="nc bnc" id="L1604" title="All 4 branches missed.">        if(userDefined!=null || field==null)   return userDefined;</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">        if (descriptor instanceof Descriptor) {</span>
<span class="nc" id="L1606">            Descriptor d = (Descriptor) descriptor;</span>
<span class="nc" id="L1607">            return d.getCheckUrl(field);</span>
        }
<span class="nc" id="L1609">        return null;</span>
    }

    /**
     * Determines the parameters that client-side needs for a form validation check. See prepareDatabinding.jelly
     * @since 1.528
     */
    public void calcCheckUrl(Map attributes, String userDefined, Object descriptor, String field) {
<span class="nc bnc" id="L1617" title="All 4 branches missed.">        if(userDefined!=null || field==null)   return;</span>

<span class="nc bnc" id="L1619" title="All 2 branches missed.">        if (descriptor instanceof Descriptor) {</span>
<span class="nc" id="L1620">            Descriptor d = (Descriptor) descriptor;</span>
<span class="nc" id="L1621">            CheckMethod m = d.getCheckMethod(field);</span>
<span class="nc" id="L1622">            attributes.put(&quot;checkUrl&quot;,m.toStemUrl());</span>
<span class="nc" id="L1623">            attributes.put(&quot;checkDependsOn&quot;,m.getDependsOn());</span>
        }
<span class="nc" id="L1625">    }</span>

    /**
     * If the given href link is matching the current page, return true.
     *
     * Used in &lt;tt&gt;task.jelly&lt;/tt&gt; to decide if the page should be highlighted.
     */
    public boolean hyperlinkMatchesCurrentPage(String href) throws UnsupportedEncodingException {
<span class="nc" id="L1633">        String url = Stapler.getCurrentRequest().getRequestURL().toString();</span>
<span class="nc bnc" id="L1634" title="All 8 branches missed.">        if (href == null || href.length() &lt;= 1) return &quot;.&quot;.equals(href) &amp;&amp; url.endsWith(&quot;/&quot;);</span>
<span class="nc" id="L1635">        url = URLDecoder.decode(url,&quot;UTF-8&quot;);</span>
<span class="nc" id="L1636">        href = URLDecoder.decode(href,&quot;UTF-8&quot;);</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">        if (url.endsWith(&quot;/&quot;)) url = url.substring(0, url.length() - 1);</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">        if (href.endsWith(&quot;/&quot;)) href = href.substring(0, href.length() - 1);</span>

<span class="nc" id="L1640">        return url.endsWith(href);</span>
    }

    public &lt;T&gt; List&lt;T&gt; singletonList(T t) {
<span class="nc" id="L1644">        return Collections.singletonList(t);</span>
    }

    /**
     * Gets all the {@link PageDecorator}s.
     */
    public static List&lt;PageDecorator&gt; getPageDecorators() {
        // this method may be called to render start up errors, at which point Hudson doesn't exist yet. see HUDSON-3608 
<span class="nc bnc" id="L1652" title="All 2 branches missed.">        if(Jenkins.getInstance()==null)  return Collections.emptyList();</span>
<span class="nc" id="L1653">        return PageDecorator.all();</span>
    }
    
    public static List&lt;Descriptor&lt;Cloud&gt;&gt; getCloudDescriptors() {
<span class="nc" id="L1657">        return Cloud.all();</span>
    }

    /**
     * Prepend a prefix only when there's the specified body.
     */
    public String prepend(String prefix, String body) {
<span class="nc bnc" id="L1664" title="All 4 branches missed.">        if(body!=null &amp;&amp; body.length()&gt;0)</span>
<span class="nc" id="L1665">            return prefix+body;</span>
<span class="nc" id="L1666">        return body;</span>
    }

    public static List&lt;Descriptor&lt;CrumbIssuer&gt;&gt; getCrumbIssuerDescriptors() {
<span class="nc" id="L1670">        return CrumbIssuer.all();</span>
    }

    public static String getCrumb(StaplerRequest req) {
<span class="nc" id="L1674">        Jenkins h = Jenkins.getInstance();</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">        CrumbIssuer issuer = h != null ? h.getCrumbIssuer() : null;</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">        return issuer != null ? issuer.getCrumb(req) : &quot;&quot;;</span>
    }

    public static String getCrumbRequestField() {
<span class="nc" id="L1680">        Jenkins h = Jenkins.getInstance();</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">        CrumbIssuer issuer = h != null ? h.getCrumbIssuer() : null;</span>
<span class="nc bnc" id="L1682" title="All 2 branches missed.">        return issuer != null ? issuer.getDescriptor().getCrumbRequestField() : &quot;&quot;;</span>
    }

    public static Date getCurrentTime() {
<span class="nc" id="L1686">        return new Date();</span>
    }

    public static Locale getCurrentLocale() {
<span class="nc" id="L1690">        Locale locale=null;</span>
<span class="nc" id="L1691">        StaplerRequest req = Stapler.getCurrentRequest();</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">        if(req!=null)</span>
<span class="nc" id="L1693">            locale = req.getLocale();</span>
<span class="nc bnc" id="L1694" title="All 2 branches missed.">        if(locale==null)</span>
<span class="nc" id="L1695">            locale = Locale.getDefault();</span>
<span class="nc" id="L1696">        return locale;</span>
    }

    /**
     * Generate a series of &amp;lt;script&gt; tags to include &lt;tt&gt;script.js&lt;/tt&gt;
     * from {@link ConsoleAnnotatorFactory}s and {@link ConsoleAnnotationDescriptor}s.
     */
    public static String generateConsoleAnnotationScriptAndStylesheet() {
<span class="nc" id="L1704">        String cp = Stapler.getCurrentRequest().getContextPath();</span>
<span class="nc" id="L1705">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L1706" title="All 2 branches missed.">        for (ConsoleAnnotatorFactory f : ConsoleAnnotatorFactory.all()) {</span>
<span class="nc" id="L1707">            String path = cp + &quot;/extensionList/&quot; + ConsoleAnnotatorFactory.class.getName() + &quot;/&quot; + f.getClass().getName();</span>
<span class="nc bnc" id="L1708" title="All 2 branches missed.">            if (f.hasScript())</span>
<span class="nc" id="L1709">                buf.append(&quot;&lt;script src='&quot;).append(path).append(&quot;/script.js'&gt;&lt;/script&gt;&quot;);</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">            if (f.hasStylesheet())</span>
<span class="nc" id="L1711">                buf.append(&quot;&lt;link rel='stylesheet' type='text/css' href='&quot;).append(path).append(&quot;/style.css' /&gt;&quot;);</span>
        }
<span class="nc bnc" id="L1713" title="All 2 branches missed.">        for (ConsoleAnnotationDescriptor d : ConsoleAnnotationDescriptor.all()) {</span>
<span class="nc" id="L1714">            String path = cp+&quot;/descriptor/&quot;+d.clazz.getName();</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">            if (d.hasScript())</span>
<span class="nc" id="L1716">                buf.append(&quot;&lt;script src='&quot;).append(path).append(&quot;/script.js'&gt;&lt;/script&gt;&quot;);</span>
<span class="nc bnc" id="L1717" title="All 2 branches missed.">            if (d.hasStylesheet())</span>
<span class="nc" id="L1718">                buf.append(&quot;&lt;link rel='stylesheet' type='text/css' href='&quot;).append(path).append(&quot;/style.css' /&gt;&quot;);</span>
        }
<span class="nc" id="L1720">        return buf.toString();</span>
    }

    /**
     * Work around for bug 6935026.
     */
    public List&lt;String&gt; getLoggerNames() {
<span class="nc" id="L1727">        while (true) {</span>
            try {
<span class="nc" id="L1729">                List&lt;String&gt; r = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1730">                Enumeration&lt;String&gt; e = LogManager.getLogManager().getLoggerNames();</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                while (e.hasMoreElements())</span>
<span class="nc" id="L1732">                    r.add(e.nextElement());</span>
<span class="nc" id="L1733">                return r;</span>
<span class="nc" id="L1734">            } catch (ConcurrentModificationException e) {</span>
                // retry
            }
        }
    }

    /**
     * Used by &amp;lt;f:password/&gt; so that we send an encrypted value to the client.
     */
    public String getPasswordValue(Object o) {
<span class="nc bnc" id="L1744" title="All 2 branches missed.">        if (o==null)    return null;</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">        if (o instanceof Secret)    return ((Secret)o).getEncryptedValue();</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">        if (getIsUnitTest()) {</span>
<span class="nc" id="L1747">            throw new SecurityException(&quot;attempted to render plaintext â&quot; + o + &quot;â in password field; use a getter of type Secret instead&quot;);</span>
        }
<span class="nc" id="L1749">        return o.toString();</span>
    }

    public List filterDescriptors(Object context, Iterable descriptors) {
<span class="nc" id="L1753">        return DescriptorVisibilityFilter.apply(context,descriptors);</span>
    }
    
    /**
     * Returns true if we are running unit tests.
     */
    public static boolean getIsUnitTest() {
<span class="nc" id="L1760">        return Main.isUnitTest;</span>
    }

    /**
     * Returns {@code true} if the {@link Run#ARTIFACTS} permission is enabled,
     * {@code false} otherwise.
     *
     * &lt;p&gt;When the {@link Run#ARTIFACTS} permission is not turned on using the
     * {@code hudson.security.ArtifactsPermission} system property, this
     * permission must not be considered to be set to {@code false} for every
     * user. It must rather be like if the permission doesn't exist at all
     * (which means that every user has to have an access to the artifacts but
     * the permission can't be configured in the security screen). Got it?&lt;/p&gt;
     */
    public static boolean isArtifactsPermissionEnabled() {
<span class="fc" id="L1775">        return Boolean.getBoolean(&quot;hudson.security.ArtifactsPermission&quot;);</span>
    }

    /**
     * Returns {@code true} if the {@link Item#WIPEOUT} permission is enabled,
     * {@code false} otherwise.
     *
     * &lt;p&gt;The &quot;Wipe Out Workspace&quot; action available on jobs is controlled by the
     * {@link Item#BUILD} permission. For some specific projects, however, it is
     * not acceptable to let users have this possibility, even it they can
     * trigger builds. As such, when enabling the {@code hudson.security.WipeOutPermission}
     * system property, a new &quot;WipeOut&quot; permission will allow to have greater
     * control on the &quot;Wipe Out Workspace&quot; action.&lt;/p&gt;
     */
    public static boolean isWipeOutPermissionEnabled() {
<span class="fc" id="L1790">        return Boolean.getBoolean(&quot;hudson.security.WipeOutPermission&quot;);</span>
    }

    public static String createRenderOnDemandProxy(JellyContext context, String attributesToCapture) {
<span class="nc" id="L1794">        return Stapler.getCurrentRequest().createJavaScriptProxy(new RenderOnDemandClosure(context,attributesToCapture));</span>
    }

    public static String getCurrentDescriptorByNameUrl() {
<span class="nc" id="L1798">        return Descriptor.getCurrentDescriptorByNameUrl();</span>
    }
    
    public static String setCurrentDescriptorByNameUrl(String value) {
<span class="nc" id="L1802">        String o = getCurrentDescriptorByNameUrl();</span>
<span class="nc" id="L1803">        Stapler.getCurrentRequest().setAttribute(&quot;currentDescriptorByNameUrl&quot;, value);</span>

<span class="nc" id="L1805">        return o;</span>
    }

    public static void restoreCurrentDescriptorByNameUrl(String old) {
<span class="nc" id="L1809">        Stapler.getCurrentRequest().setAttribute(&quot;currentDescriptorByNameUrl&quot;, old);</span>
<span class="nc" id="L1810">    }</span>

    public static List&lt;String&gt; getRequestHeaders(String name) {
<span class="nc" id="L1813">        List&lt;String&gt; r = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1814">        Enumeration e = Stapler.getCurrentRequest().getHeaders(name);</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">        while (e.hasMoreElements()) {</span>
<span class="nc" id="L1816">            r.add(e.nextElement().toString());</span>
        }
<span class="nc" id="L1818">        return r;</span>
    }

    /**
     * Used for arguments to internationalized expressions to avoid escape
     */
    public static Object rawHtml(Object o) {
<span class="nc bnc" id="L1825" title="All 2 branches missed.">        return o==null ? null : new RawHtmlArgument(o);</span>
    }

    public static ArrayList&lt;CLICommand&gt; getCLICommands() {
<span class="nc" id="L1829">        ArrayList&lt;CLICommand&gt; all = new ArrayList&lt;CLICommand&gt;(CLICommand.all());</span>
<span class="nc" id="L1830">        Collections.sort(all, new Comparator&lt;CLICommand&gt;() {</span>
            public int compare(CLICommand cliCommand, CLICommand cliCommand1) {
<span class="nc" id="L1832">                return cliCommand.getName().compareTo(cliCommand1.getName());</span>
            }
        });
<span class="nc" id="L1835">        return all;</span>
    }

    /**
     * Returns an avatar image URL for the specified user and preferred image size
     * @param user the user
     * @param avatarSize the preferred size of the avatar image
     * @return a URL string
     * @since 1.433
     */
    public static String getAvatar(User user, String avatarSize) {
<span class="nc" id="L1846">        return UserAvatarResolver.resolve(user, avatarSize);</span>
    }

    /**
     * @deprecated as of 1.451
     *      Use {@link #getAvatar}
     */
    @Deprecated
    public String getUserAvatar(User user, String avatarSize) {
<span class="nc" id="L1855">        return getAvatar(user,avatarSize);</span>
    }
    
    
    /**
     * Returns human readable information about file size
     * 
     * @param size file size in bytes
     * @return file size in appropriate unit
     */
    public static String humanReadableByteSize(long size){
<span class="nc" id="L1866">        String measure = &quot;B&quot;;</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">        if(size &lt; 1024){</span>
<span class="nc" id="L1868">            return size + &quot; &quot; + measure;</span>
        }
<span class="nc" id="L1870">        Double number = new Double(size);</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">        if(number&gt;=1024){</span>
<span class="nc" id="L1872">            number = number/1024;</span>
<span class="nc" id="L1873">            measure = &quot;KB&quot;;</span>
<span class="nc bnc" id="L1874" title="All 2 branches missed.">            if(number&gt;=1024){</span>
<span class="nc" id="L1875">                number = number/1024;</span>
<span class="nc" id="L1876">                measure = &quot;MB&quot;;</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">                if(number&gt;=1024){</span>
<span class="nc" id="L1878">                    number=number/1024;</span>
<span class="nc" id="L1879">                    measure = &quot;GB&quot;;</span>
                }
            }
        }
<span class="nc" id="L1883">        DecimalFormat format = new DecimalFormat(&quot;#0.00&quot;);</span>
<span class="nc" id="L1884">        return format.format(number) + &quot; &quot; + measure;</span>
    }

    /**
     * Get a string that can be safely broken to several lines when necessary.
     *
     * This implementation inserts &amp;lt;wbr&gt; tags into string. It allows browsers
     * to wrap line before any sequence of punctuation characters or anywhere
     * in the middle of prolonged sequences of word characters.
     *
     * @since 1.517
     */
    public static String breakableString(final String plain) {
<span class="nc bnc" id="L1897" title="All 2 branches missed.">        if (plain == null) {</span>
<span class="nc" id="L1898">            return null;</span>
        }
<span class="nc" id="L1900">        return plain.replaceAll(&quot;([\\p{Punct}&amp;&amp;[^;]]+\\w)&quot;, &quot;&lt;wbr&gt;$1&quot;)</span>
<span class="nc" id="L1901">                .replaceAll(&quot;([^\\p{Punct}\\s-]{20})(?=[^\\p{Punct}\\s-]{10})&quot;, &quot;$1&lt;wbr&gt;&quot;)</span>
        ;
    }

    /**
     * Advertises the minimum set of HTTP headers that assist programmatic
     * discovery of Jenkins.
     */
    public static void advertiseHeaders(HttpServletResponse rsp) {
<span class="nc" id="L1910">        Jenkins j = Jenkins.getInstance();</span>
<span class="nc bnc" id="L1911" title="All 2 branches missed.">        if (j!=null) {</span>
<span class="nc" id="L1912">            rsp.setHeader(&quot;X-Hudson&quot;,&quot;1.395&quot;);</span>
<span class="nc" id="L1913">            rsp.setHeader(&quot;X-Jenkins&quot;, Jenkins.VERSION);</span>
<span class="nc" id="L1914">            rsp.setHeader(&quot;X-Jenkins-Session&quot;, Jenkins.SESSION_HASH);</span>

<span class="nc" id="L1916">            TcpSlaveAgentListener tal = j.tcpSlaveAgentListener;</span>
<span class="nc bnc" id="L1917" title="All 2 branches missed.">            if (tal !=null) {</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">                int p = TcpSlaveAgentListener.CLI_PORT !=null ? TcpSlaveAgentListener.CLI_PORT : tal.getPort();</span>
<span class="nc" id="L1919">                rsp.setIntHeader(&quot;X-Hudson-CLI-Port&quot;, p);</span>
<span class="nc" id="L1920">                rsp.setIntHeader(&quot;X-Jenkins-CLI-Port&quot;, p);</span>
<span class="nc" id="L1921">                rsp.setIntHeader(&quot;X-Jenkins-CLI2-Port&quot;, p);</span>
<span class="nc" id="L1922">                rsp.setHeader(&quot;X-Jenkins-CLI-Host&quot;, TcpSlaveAgentListener.CLI_HOST_NAME);</span>
            }
        }
<span class="nc" id="L1925">    }</span>

    @Restricted(NoExternalUse.class) // for actions.jelly and ContextMenu.add
    public static boolean isContextMenuVisible(Action a) {
<span class="nc bnc" id="L1929" title="All 2 branches missed.">        if (a instanceof ModelObjectWithContextMenu.ContextMenuVisibility) {</span>
<span class="nc" id="L1930">            return ((ModelObjectWithContextMenu.ContextMenuVisibility) a).isVisible();</span>
        } else {
<span class="nc" id="L1932">            return true;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>jenkins-core (22-mrt-2016 21:51:03)</div></body></html>