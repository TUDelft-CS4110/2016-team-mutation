<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>ExtensionFinder.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">jenkins-core (22-mrt-2016 21:51:03)</a> &gt; <a href="../../index.html" class="el_group">jenkins-core</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">hudson</a> &gt; <span class="el_source">ExtensionFinder.java</span></div><h1>ExtensionFinder.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/*</span>
 * The MIT License
 *
 * Copyright (c) 2004-2010, Sun Microsystems, Inc., InfraDNA, Inc., CloudBees, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package hudson;

import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.inject.AbstractModule;
import com.google.inject.Binding;
import com.google.inject.Guice;
import com.google.inject.Injector;
import com.google.inject.Key;
import com.google.inject.Module;
import com.google.inject.Provider;
import com.google.inject.Scope;
import com.google.inject.Scopes;
import com.google.inject.name.Names;
import com.google.common.collect.ImmutableList;
import hudson.init.InitMilestone;
import hudson.model.Descriptor;
import hudson.model.Hudson;
import jenkins.ExtensionComponentSet;
import jenkins.ExtensionFilter;
import jenkins.ExtensionRefreshException;
import jenkins.ProxyInjector;
import jenkins.model.Jenkins;
import net.java.sezpoz.Index;
import net.java.sezpoz.IndexItem;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;

import java.lang.annotation.Annotation;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.List;
import java.util.ArrayList;
import java.util.Collection;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * Discovers the implementations of an extension point.
 *
 * &lt;p&gt;
 * This extension point allows you to write your implementations of {@link ExtensionPoint}s
 * in arbitrary DI containers, and have Hudson discover them.
 *
 * &lt;p&gt;
 * {@link ExtensionFinder} itself is an extension point, but to avoid infinite recursion,
 * Jenkins discovers {@link ExtensionFinder}s through {@link Sezpoz} and that alone.
 *
 * @author Kohsuke Kawaguchi
 * @since 1.286
 * @see ExtensionFilter
 */
<span class="nc" id="L82">public abstract class ExtensionFinder implements ExtensionPoint {</span>
    /**
     * @deprecated as of 1.356
     *      Use and implement {@link #find(Class,Hudson)} that allows us to put some metadata.
     */
    @Restricted(NoExternalUse.class)
    @Deprecated
    public &lt;T&gt; Collection&lt;T&gt; findExtensions(Class&lt;T&gt; type, Hudson hudson) {
<span class="nc" id="L90">        return Collections.emptyList();</span>
    }

    /**
     * Returns true if this extension finder supports the {@link #refresh()} operation.
     */
    public boolean isRefreshable() {
        try {
<span class="nc bnc" id="L98" title="All 2 branches missed.">            return getClass().getMethod(&quot;refresh&quot;).getDeclaringClass()!=ExtensionFinder.class;</span>
<span class="nc" id="L99">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L100">            return false;</span>
        }
    }

    /**
     * Rebuilds the internal index, if any, so that future {@link #find(Class, Hudson)} calls
     * will discover components newly added to {@link PluginManager#uberClassLoader}.
     *
     * &lt;p&gt;
     * The point of the refresh operation is not to disrupt instances of already loaded {@link ExtensionComponent}s,
     * and only instantiate those that are new. Otherwise this will break the singleton semantics of various
     * objects, such as {@link Descriptor}s.
     *
     * &lt;p&gt;
     * The behaviour is undefined if {@link #isRefreshable()} is returning false.
     *
     * @since 1.442
     * @see #isRefreshable()
     * @return never null
     */
    public abstract ExtensionComponentSet refresh() throws ExtensionRefreshException;

    /**
     * Discover extensions of the given type.
     *
     * &lt;p&gt;
     * This method is called only once per the given type after all the plugins are loaded,
     * so implementations need not worry about caching.
     *
     * &lt;p&gt;
     * This method should return all the known components at the time of the call, including
     * those that are discovered later via {@link #refresh()}, even though those components
     * are separately returned in {@link ExtensionComponentSet}.
     *
     * @param &lt;T&gt;
     *      The type of the extension points. This is not bound to {@link ExtensionPoint} because
     *      of {@link Descriptor}, which by itself doesn't implement {@link ExtensionPoint} for
     *      a historical reason.
     * @param jenkins
     *      Jenkins whose behalf this extension finder is performing lookup.
     * @return
     *      Can be empty but never null.
     * @since 1.356
     *      Older implementations provide {@link #findExtensions(Class,Hudson)}
     */
    public abstract &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; find(Class&lt;T&gt; type, Hudson jenkins);

    @Deprecated
    public &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; _find(Class&lt;T&gt; type, Hudson hudson) {
<span class="nc" id="L149">        return find(type, hudson);</span>
    }

    /**
     * Performs class initializations without creating instances. 
     *
     * If two threads try to initialize classes in the opposite order, a dead lock will ensue,
     * and we can get into a similar situation with {@link ExtensionFinder}s.
     *
     * &lt;p&gt;
     * That is, one thread can try to list extensions, which results in {@link ExtensionFinder}
     * loading and initializing classes. This happens inside a context of a lock, so that
     * another thread that tries to list the same extensions don't end up creating different
     * extension instances. So this activity locks extension list first, then class initialization next.
     *
     * &lt;p&gt;
     * In the mean time, another thread can load and initialize a class, and that initialization
     * can eventually results in listing up extensions, for example through static initializer.
     * Such activity locks class initialization first, then locks extension list.
     *
     * &lt;p&gt;
     * This inconsistent locking order results in a dead lock, you see.
     *
     * &lt;p&gt;
     * So to reduce the likelihood, this method is called in prior to {@link #find(Class,Hudson)} invocation,
     * but from outside the lock. The implementation is expected to perform all the class initialization activities
     * from here.
     *
     * &lt;p&gt;
     * See https://bugs.openjdk.java.net/browse/JDK-4993813 for how to force a class initialization.
     * Also see http://kohsuke.org/2010/09/01/deadlock-that-you-cant-avoid/ for how class initialization
     * can results in a dead lock.
     */
    public void scout(Class extensionType, Hudson hudson) {
<span class="nc" id="L183">    }</span>

    @Extension
    public static final class DefaultGuiceExtensionAnnotation extends GuiceExtensionAnnotation&lt;Extension&gt; {
        public DefaultGuiceExtensionAnnotation() {
<span class="nc" id="L188">            super(Extension.class);</span>
<span class="nc" id="L189">        }</span>

        @Override
        protected boolean isOptional(Extension annotation) {
<span class="nc" id="L193">            return annotation.optional();</span>
        }

        @Override
        protected double getOrdinal(Extension annotation) {
<span class="nc" id="L198">            return annotation.ordinal();</span>
        }

        @Override
        protected boolean isActive(AnnotatedElement e) {
<span class="nc" id="L203">            return true;</span>
        }
    }


    /**
     * Captures information about the annotation that we use to mark Guice-instantiated components.
     */
    public static abstract class GuiceExtensionAnnotation&lt;T extends Annotation&gt; {
        public final Class&lt;T&gt; annotationType;

<span class="nc" id="L214">        protected GuiceExtensionAnnotation(Class&lt;T&gt; annotationType) {</span>
<span class="nc" id="L215">            this.annotationType = annotationType;</span>
<span class="nc" id="L216">        }</span>

        protected abstract double getOrdinal(T annotation);

        /**
         * Hook to enable subtypes to control which ones to pick up and which ones to ignore.
         */
        protected abstract boolean isActive(AnnotatedElement e);

        protected abstract boolean isOptional(T annotation);
    }
    
    /**
     * Discovers components via sezpoz but instantiates them by using Guice.
     */
    @Extension
    public static class GuiceFinder extends ExtensionFinder {
        /**
         * Injector that we find components from.
         * &lt;p&gt;
         * To support refresh when Guice doesn't let us alter the bindings, we'll create
         * a child container to house newly discovered components. This field points to the
         * youngest such container.
         */
        private volatile Injector container;

        /**
         * Sezpoz index we are currently using in {@link #container} (and its ancestors.)
         * Needed to compute delta.
         */
        private List&lt;IndexItem&lt;?,Object&gt;&gt; sezpozIndex;

<span class="nc" id="L248">        private final Map&lt;Key,Annotation&gt; annotations = new HashMap&lt;&gt;();</span>
<span class="nc" id="L249">        private final Sezpoz moduleFinder = new Sezpoz();</span>

        /**
         * Map from {@link GuiceExtensionAnnotation#annotationType} to {@link GuiceExtensionAnnotation}
         */
<span class="nc" id="L254">        private Map&lt;Class&lt;? extends Annotation&gt;,GuiceExtensionAnnotation&lt;?&gt;&gt; extensionAnnotations = Maps.newHashMap();</span>

<span class="nc" id="L256">        public GuiceFinder() {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            for (ExtensionComponent&lt;GuiceExtensionAnnotation&gt; ec : moduleFinder.find(GuiceExtensionAnnotation.class, Hudson.getInstance())) {</span>
<span class="nc" id="L258">                GuiceExtensionAnnotation gea = ec.getInstance();</span>
<span class="nc" id="L259">                extensionAnnotations.put(gea.annotationType,gea);</span>
            }

<span class="nc" id="L262">            sezpozIndex = loadSezpozIndices(Jenkins.getInstance().getPluginManager().uberClassLoader);</span>

<span class="nc" id="L264">            List&lt;Module&gt; modules = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L265">            modules.add(new AbstractModule() {</span>
                @Override
                protected void configure() {
<span class="nc" id="L268">                    Jenkins j = Jenkins.getInstance();</span>
<span class="nc" id="L269">                    bind(Jenkins.class).toInstance(j);</span>
<span class="nc" id="L270">                    bind(PluginManager.class).toInstance(j.getPluginManager());</span>
<span class="nc" id="L271">                }</span>
            });
<span class="nc" id="L273">            modules.add(new SezpozModule(sezpozIndex));</span>

<span class="nc bnc" id="L275" title="All 2 branches missed.">            for (ExtensionComponent&lt;Module&gt; ec : moduleFinder.find(Module.class, Hudson.getInstance())) {</span>
<span class="nc" id="L276">                modules.add(ec.getInstance());</span>
            }

            try {
<span class="nc" id="L280">                container = Guice.createInjector(modules);</span>
<span class="nc" id="L281">            } catch (Throwable e) {</span>
<span class="nc" id="L282">                LOGGER.log(Level.SEVERE, &quot;Failed to create Guice container from all the plugins&quot;,e);</span>
                // failing to load all bindings are disastrous, so recover by creating minimum that works
                // by just including the core
                // TODO this recovery is pretty much useless; startup crashes anyway
<span class="nc" id="L286">                container = Guice.createInjector(new SezpozModule(loadSezpozIndices(Jenkins.class.getClassLoader())));</span>
            }

            // expose Injector via lookup mechanism for interop with non-Guice clients
<span class="nc" id="L290">            Jenkins.getInstance().lookup.set(Injector.class,new ProxyInjector() {</span>
                protected Injector resolve() {
<span class="nc" id="L292">                    return getContainer();</span>
                }
            });
<span class="nc" id="L295">        }</span>

        private ImmutableList&lt;IndexItem&lt;?, Object&gt;&gt; loadSezpozIndices(ClassLoader classLoader) {
<span class="nc" id="L298">            List&lt;IndexItem&lt;?,Object&gt;&gt; indices = Lists.newArrayList();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">            for (GuiceExtensionAnnotation&lt;?&gt; gea : extensionAnnotations.values()) {</span>
<span class="nc" id="L300">                Iterables.addAll(indices, Index.load(gea.annotationType, Object.class, classLoader));</span>
            }
<span class="nc" id="L302">            return ImmutableList.copyOf(indices);</span>
        }

        public Injector getContainer() {
<span class="nc" id="L306">            return container;</span>
        }

        /**
         * The basic idea is:
         *
         * &lt;ul&gt;
         *     &lt;li&gt;List up delta as a series of modules
         *     &lt;li&gt;
         * &lt;/ul&gt;
         */
        @Override
        public synchronized ExtensionComponentSet refresh() throws ExtensionRefreshException {
            // figure out newly discovered sezpoz components
<span class="nc" id="L320">            List&lt;IndexItem&lt;?, Object&gt;&gt; delta = Lists.newArrayList();</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            for (Class&lt;? extends Annotation&gt; annotationType : extensionAnnotations.keySet()) {</span>
<span class="nc" id="L322">                delta.addAll(Sezpoz.listDelta(annotationType,sezpozIndex));</span>
            }
<span class="nc" id="L324">            List&lt;IndexItem&lt;?, Object&gt;&gt; l = Lists.newArrayList(sezpozIndex);</span>
<span class="nc" id="L325">            l.addAll(delta);</span>
<span class="nc" id="L326">            sezpozIndex = l;</span>

<span class="nc" id="L328">            List&lt;Module&gt; modules = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L329">            modules.add(new SezpozModule(delta));</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            for (ExtensionComponent&lt;Module&gt; ec : moduleFinder.refresh().find(Module.class)) {</span>
<span class="nc" id="L331">                modules.add(ec.getInstance());</span>
            }

            try {
<span class="nc" id="L335">                final Injector child = container.createChildInjector(modules);</span>
<span class="nc" id="L336">                container = child;</span>

<span class="nc" id="L338">                return new ExtensionComponentSet() {</span>
                    @Override
                    public &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; find(Class&lt;T&gt; type) {
<span class="nc" id="L341">                        List&lt;ExtensionComponent&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L342">                        _find(type, result, child);</span>
<span class="nc" id="L343">                        return result;</span>
                    }
                };
<span class="nc" id="L346">            } catch (Throwable e) {</span>
<span class="nc" id="L347">                LOGGER.log(Level.SEVERE, &quot;Failed to create Guice container from newly added plugins&quot;,e);</span>
<span class="nc" id="L348">                throw new ExtensionRefreshException(e);</span>
            }
        }

        private Object instantiate(IndexItem&lt;?,Object&gt; item) {
            try {
<span class="nc" id="L354">                return item.instance();</span>
<span class="nc" id="L355">            } catch (LinkageError | Exception e) {</span>
                // sometimes the instantiation fails in an indirect classloading failure,
                // which results in a LinkageError
<span class="nc bnc" id="L358" title="All 2 branches missed.">                LOGGER.log(isOptional(item.annotation()) ? Level.FINE : Level.WARNING,</span>
<span class="nc" id="L359">                           &quot;Failed to load &quot;+item.className(), e);</span>
            }
<span class="nc" id="L361">            return null;</span>
        }

        private boolean isOptional(Annotation annotation) {
<span class="nc" id="L365">            GuiceExtensionAnnotation gea = extensionAnnotations.get(annotation.annotationType());</span>
<span class="nc" id="L366">            return gea.isOptional(annotation);</span>
        }

        private boolean isActive(Annotation annotation, AnnotatedElement e) {
<span class="nc" id="L370">            GuiceExtensionAnnotation gea = extensionAnnotations.get(annotation.annotationType());</span>
<span class="nc" id="L371">            return gea.isActive(e);</span>
        }

        public &lt;U&gt; Collection&lt;ExtensionComponent&lt;U&gt;&gt; find(Class&lt;U&gt; type, Hudson jenkins) {
            // the find method contract requires us to traverse all known components
<span class="nc" id="L376">            List&lt;ExtensionComponent&lt;U&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            for (Injector i=container; i!=null; i=i.getParent()) {</span>
<span class="nc" id="L378">                _find(type, result, i);</span>
            }
<span class="nc" id="L380">            return result;</span>
        }

        private &lt;U&gt; void _find(Class&lt;U&gt; type, List&lt;ExtensionComponent&lt;U&gt;&gt; result, Injector container) {
<span class="nc bnc" id="L384" title="All 2 branches missed.">            for (Entry&lt;Key&lt;?&gt;, Binding&lt;?&gt;&gt; e : container.getBindings().entrySet()) {</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">                if (type.isAssignableFrom(e.getKey().getTypeLiteral().getRawType())) {</span>
<span class="nc" id="L386">                    Annotation a = annotations.get(e.getKey());</span>
<span class="nc" id="L387">                    Object o = e.getValue().getProvider().get();</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">                    if (o!=null) {</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                        GuiceExtensionAnnotation gea = a!=null ? extensionAnnotations.get(a.annotationType()) : null;</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                        result.add(new ExtensionComponent&lt;&gt;(type.cast(o), gea != null ? gea.getOrdinal(a) : 0));</span>
                    }
                }
            }
<span class="nc" id="L394">        }</span>

        /**
         * TODO: need to learn more about concurrent access to {@link Injector} and how it interacts
         * with classloading.
         */
        @Override
        public void scout(Class extensionType, Hudson hudson) {
<span class="nc" id="L402">        }</span>

        /**
         * {@link Scope} that allows a failure to create a component,
         * and change the value to null.
         *
         * &lt;p&gt;
         * This is necessary as a failure to load one plugin shouldn't fail the startup of the entire Jenkins.
         * Instead, we should just drop the failing plugins.
         */
<span class="nc" id="L412">        public static final Scope FAULT_TOLERANT_SCOPE = new FaultTolerantScope(true);</span>
<span class="nc" id="L413">        private static final Scope QUIET_FAULT_TOLERANT_SCOPE = new FaultTolerantScope(false);</span>
        
        private static final class FaultTolerantScope implements Scope {
            private final boolean verbose;
<span class="nc" id="L417">            FaultTolerantScope(boolean verbose) {</span>
<span class="nc" id="L418">                this.verbose = verbose;</span>
<span class="nc" id="L419">            }</span>
            public &lt;T&gt; Provider&lt;T&gt; scope(final Key&lt;T&gt; key, final Provider&lt;T&gt; unscoped) {
<span class="nc" id="L421">                final Provider&lt;T&gt; base = Scopes.SINGLETON.scope(key,unscoped);</span>
<span class="nc" id="L422">                return new Provider&lt;T&gt;() {</span>
                    public T get() {
                        try {
<span class="nc" id="L425">                            return base.get();</span>
<span class="nc" id="L426">                        } catch (Exception e) {</span>
<span class="nc" id="L427">                            error(key, e);</span>
<span class="nc" id="L428">                            return null;</span>
<span class="nc" id="L429">                        } catch (LinkageError e) {</span>
<span class="nc" id="L430">                            error(key, e);</span>
<span class="nc" id="L431">                            return null;</span>
                        }
                    }
                    void error(Key&lt;T&gt; key, Throwable x) {
<span class="nc bnc" id="L435" title="All 2 branches missed.">                        if (verbose) {</span>
<span class="nc" id="L436">                            LOGGER.log(Level.WARNING, &quot;Failed to instantiate &quot; + key + &quot;; skipping this component&quot;, x);</span>
<span class="nc" id="L437">                        } else {</span>
<span class="nc" id="L438">                            LOGGER.log(Level.WARNING, &quot;Failed to instantiate optional component {0}; skipping&quot;, key.getTypeLiteral());</span>
<span class="nc" id="L439">                            LOGGER.log(Level.FINE, key.toString(), x);</span>
                        }
<span class="nc" id="L441">                    }</span>
                };
            }
        }

<span class="nc" id="L446">        private static final Logger LOGGER = Logger.getLogger(GuiceFinder.class.getName());</span>

        /**
         * {@link Module} that finds components via sezpoz index.
         * Instead of using SezPoz to instantiate, we'll instantiate them by using Guice,
         * so that we can take advantage of dependency injection.
         */
        private class SezpozModule extends AbstractModule {
            private final List&lt;IndexItem&lt;?,Object&gt;&gt; index;

<span class="nc" id="L456">            public SezpozModule(List&lt;IndexItem&lt;?,Object&gt;&gt; index) {</span>
<span class="nc" id="L457">                this.index = index;</span>
<span class="nc" id="L458">            }</span>

            /**
             * Guice performs various reflection operations on the class to figure out the dependency graph,
             * and that process can cause additional classloading problems, which will fail the injector creation,
             * which in turn has disastrous effect on the startup.
             *
             * &lt;p&gt;
             * Ultimately I'd like to isolate problems to plugins and selectively disable them, allowing
             * Jenkins to start with plugins that work, but I haven't figured out how.
             *
             * So this is an attempt to detect subset of problems eagerly, by invoking various reflection
             * operations and try to find non-existent classes early.
             */
            private void resolve(Class c) {
                try {
<span class="nc" id="L474">                    c.getGenericSuperclass();</span>
<span class="nc" id="L475">                    c.getGenericInterfaces();</span>
<span class="nc" id="L476">                    ClassLoader ecl = c.getClassLoader();</span>
<span class="nc" id="L477">                    Method m = ClassLoader.class.getDeclaredMethod(&quot;resolveClass&quot;, Class.class);</span>
<span class="nc" id="L478">                    m.setAccessible(true);</span>
<span class="nc" id="L479">                    m.invoke(ecl, c);</span>
<span class="nc" id="L480">                    c.getConstructors();</span>
<span class="nc" id="L481">                    c.getMethods();</span>
<span class="nc" id="L482">                    c.getFields();</span>
<span class="nc" id="L483">                    LOGGER.log(Level.FINER, &quot;{0} looks OK&quot;, c);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                    while (c != Object.class) {</span>
<span class="nc" id="L485">                        c.getGenericSuperclass();</span>
<span class="nc" id="L486">                        c = c.getSuperclass();</span>
                    }
<span class="nc" id="L488">                } catch (Exception x) {</span>
<span class="nc" id="L489">                    throw (LinkageError)new LinkageError(&quot;Failed to resolve &quot;+c).initCause(x);</span>
                }
<span class="nc" id="L491">            }</span>

            @SuppressWarnings({&quot;unchecked&quot;, &quot;ChainOfInstanceofChecks&quot;})
            @Override
            protected void configure() {
<span class="nc" id="L496">                int id=0;</span>

<span class="nc bnc" id="L498" title="All 2 branches missed.">                for (final IndexItem&lt;?,Object&gt; item : index) {</span>
<span class="nc" id="L499">                    id++;</span>
<span class="nc" id="L500">                    boolean optional = isOptional(item.annotation());</span>
                    try {
<span class="nc" id="L502">                        AnnotatedElement e = item.element();</span>
<span class="nc" id="L503">                        Annotation a = item.annotation();</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                        if (!isActive(a,e))   continue;</span>

<span class="nc bnc" id="L506" title="All 2 branches missed.">                        Scope scope = optional ? QUIET_FAULT_TOLERANT_SCOPE : FAULT_TOLERANT_SCOPE;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                        if (e instanceof Class) {</span>
<span class="nc" id="L508">                            Key key = Key.get((Class)e);</span>
<span class="nc" id="L509">                            resolve((Class)e);</span>
<span class="nc" id="L510">                            annotations.put(key,a);</span>
<span class="nc" id="L511">                            bind(key).in(scope);</span>
<span class="nc" id="L512">                        } else {</span>
                            Class extType;
<span class="nc bnc" id="L514" title="All 2 branches missed.">                            if (e instanceof Field) {</span>
<span class="nc" id="L515">                                extType = ((Field)e).getType();</span>
<span class="nc" id="L516">                            } else</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                            if (e instanceof Method) {</span>
<span class="nc" id="L518">                                extType = ((Method)e).getReturnType();</span>
<span class="nc" id="L519">                            } else</span>
<span class="nc" id="L520">                                throw new AssertionError();</span>

<span class="nc" id="L522">                            resolve(extType);</span>

                            // use arbitrary id to make unique key, because Guice wants that.
<span class="nc" id="L525">                            Key key = Key.get(extType, Names.named(String.valueOf(id)));</span>
<span class="nc" id="L526">                            annotations.put(key,a);</span>
<span class="nc" id="L527">                            bind(key).toProvider(new Provider() {</span>
                                    public Object get() {
<span class="nc" id="L529">                                        return instantiate(item);</span>
                                    }
<span class="nc" id="L531">                                }).in(scope);</span>
                        }
<span class="nc" id="L533">                    } catch (Exception|LinkageError e) {</span>
                        // sometimes the instantiation fails in an indirect classloading failure,
                        // which results in a LinkageError
<span class="nc bnc" id="L536" title="All 2 branches missed.">                        LOGGER.log(optional ? Level.FINE : Level.WARNING,</span>
<span class="nc" id="L537">                                   &quot;Failed to load &quot;+item.className(), e);</span>
                    }
                }
<span class="nc" id="L540">            }</span>
        }
    }

    /**
     * The bootstrap implementation that looks for the {@link Extension} marker.
     *
     * &lt;p&gt;
     * Uses Sezpoz as the underlying mechanism.
     */
<span class="nc" id="L550">    public static final class Sezpoz extends ExtensionFinder {</span>

        private volatile List&lt;IndexItem&lt;Extension,Object&gt;&gt; indices;

        /**
         * Loads indices (ideally once but as few times as possible), then reuse them later.
         * {@link ExtensionList#ensureLoaded()} guarantees that this method won't be called until
         * {@link InitMilestone#PLUGINS_PREPARED} is attained, so this method is guaranteed to
         * see all the classes and indices.
         */
        private List&lt;IndexItem&lt;Extension,Object&gt;&gt; getIndices() {
            // this method cannot be synchronized because of a dead lock possibility in the following order of events:
            // 1. thread X can start listing indices, locking this object 'SZ'
            // 2. thread Y starts loading a class, locking a classloader 'CL'
            // 3. thread X needs to load a class, now blocked on CL
            // 4. thread Y decides to load extensions, now blocked on SZ.
            // 5. dead lock
<span class="nc bnc" id="L567" title="All 2 branches missed.">            if (indices==null) {</span>
<span class="nc" id="L568">                ClassLoader cl = Jenkins.getInstance().getPluginManager().uberClassLoader;</span>
<span class="nc" id="L569">                indices = ImmutableList.copyOf(Index.load(Extension.class, Object.class, cl));</span>
            }
<span class="nc" id="L571">            return indices;</span>
        }

        /**
         * {@inheritDoc}
         *
         * &lt;p&gt;
         * SezPoz implements value-equality of {@link IndexItem}, so
         */
        @Override
        public synchronized ExtensionComponentSet refresh() {
<span class="nc" id="L582">            final List&lt;IndexItem&lt;Extension,Object&gt;&gt; old = indices;</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (old==null)      return ExtensionComponentSet.EMPTY; // we haven't loaded anything</span>

<span class="nc" id="L585">            final List&lt;IndexItem&lt;Extension, Object&gt;&gt; delta = listDelta(Extension.class,old);</span>

<span class="nc" id="L587">            List&lt;IndexItem&lt;Extension,Object&gt;&gt; r = Lists.newArrayList(old);</span>
<span class="nc" id="L588">            r.addAll(delta);</span>
<span class="nc" id="L589">            indices = ImmutableList.copyOf(r);</span>

<span class="nc" id="L591">            return new ExtensionComponentSet() {</span>
                @Override
                public &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; find(Class&lt;T&gt; type) {
<span class="nc" id="L594">                    return _find(type,delta);</span>
                }
            };
        }

        static &lt;T extends Annotation&gt; List&lt;IndexItem&lt;T,Object&gt;&gt; listDelta(Class&lt;T&gt; annotationType, List&lt;? extends IndexItem&lt;?,Object&gt;&gt; old) {
            // list up newly discovered components
<span class="nc" id="L601">            final List&lt;IndexItem&lt;T,Object&gt;&gt; delta = Lists.newArrayList();</span>
<span class="nc" id="L602">            ClassLoader cl = Jenkins.getInstance().getPluginManager().uberClassLoader;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">            for (IndexItem&lt;T,Object&gt; ii : Index.load(annotationType, Object.class, cl)) {</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">                if (!old.contains(ii)) {</span>
<span class="nc" id="L605">                    delta.add(ii);</span>
                }
            }
<span class="nc" id="L608">            return delta;</span>
        }

        public &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; find(Class&lt;T&gt; type, Hudson jenkins) {
<span class="nc" id="L612">            return _find(type,getIndices());</span>
        }

        /**
         * Finds all the matching {@link IndexItem}s that match the given type and instantiate them.
         */
        private &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; _find(Class&lt;T&gt; type, List&lt;IndexItem&lt;Extension,Object&gt;&gt; indices) {
<span class="nc" id="L619">            List&lt;ExtensionComponent&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L621" title="All 2 branches missed.">            for (IndexItem&lt;Extension,Object&gt; item : indices) {</span>
                try {
<span class="nc" id="L623">                    AnnotatedElement e = item.element();</span>
                    Class&lt;?&gt; extType;
<span class="nc bnc" id="L625" title="All 2 branches missed.">                    if (e instanceof Class) {</span>
<span class="nc" id="L626">                        extType = (Class) e;</span>
<span class="nc" id="L627">                    } else</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">                    if (e instanceof Field) {</span>
<span class="nc" id="L629">                        extType = ((Field)e).getType();</span>
<span class="nc" id="L630">                    } else</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                    if (e instanceof Method) {</span>
<span class="nc" id="L632">                        extType = ((Method)e).getReturnType();</span>
<span class="nc" id="L633">                    } else</span>
<span class="nc" id="L634">                        throw new AssertionError();</span>

<span class="nc bnc" id="L636" title="All 2 branches missed.">                    if(type.isAssignableFrom(extType)) {</span>
<span class="nc" id="L637">                        Object instance = item.instance();</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">                        if(instance!=null)</span>
<span class="nc" id="L639">                            result.add(new ExtensionComponent&lt;&gt;(type.cast(instance),item.annotation()));</span>
                    }
<span class="nc" id="L641">                } catch (LinkageError|Exception e) {</span>
                    // sometimes the instantiation fails in an indirect classloading failure,
                    // which results in a LinkageError
<span class="nc" id="L644">                    LOGGER.log(logLevel(item), &quot;Failed to load &quot;+item.className(), e);</span>
                }
            }

<span class="nc" id="L648">            return result;</span>
        }

        @Override
        public void scout(Class extensionType, Hudson hudson) {
<span class="nc bnc" id="L653" title="All 2 branches missed.">            for (IndexItem&lt;Extension,Object&gt; item : getIndices()) {</span>
                try {
                    // we might end up having multiple threads concurrently calling into element(),
                    // but we can't synchronize this --- if we do, the one thread that's supposed to load a class
                    // can block while other threads wait for the entry into the element call().
                    // looking at the sezpoz code, it should be safe to do so
<span class="nc" id="L659">                    AnnotatedElement e = item.element();</span>
                    Class&lt;?&gt; extType;
<span class="nc bnc" id="L661" title="All 2 branches missed.">                    if (e instanceof Class) {</span>
<span class="nc" id="L662">                        extType = (Class) e;</span>
<span class="nc" id="L663">                    } else</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">                    if (e instanceof Field) {</span>
<span class="nc" id="L665">                        extType = ((Field)e).getType();</span>
<span class="nc" id="L666">                    } else</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                    if (e instanceof Method) {</span>
<span class="nc" id="L668">                        extType = ((Method)e).getReturnType();</span>
<span class="nc" id="L669">                    } else</span>
<span class="nc" id="L670">                        throw new AssertionError();</span>
                    // according to JDK-4993813 this is the only way to force class initialization
<span class="nc" id="L672">                    Class.forName(extType.getName(),true,extType.getClassLoader());</span>
<span class="nc" id="L673">                } catch (Exception | LinkageError e) {</span>
<span class="nc" id="L674">                    LOGGER.log(logLevel(item), &quot;Failed to scout &quot;+item.className(), e);</span>
                }
            }
<span class="nc" id="L677">        }</span>

        private Level logLevel(IndexItem&lt;Extension, Object&gt; item) {
<span class="nc bnc" id="L680" title="All 2 branches missed.">            return item.annotation().optional() ? Level.FINE : Level.WARNING;</span>
        }
    }

<span class="nc" id="L684">    private static final Logger LOGGER = Logger.getLogger(ExtensionFinder.class.getName());</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>jenkins-core (22-mrt-2016 21:51:03)</div></body></html>