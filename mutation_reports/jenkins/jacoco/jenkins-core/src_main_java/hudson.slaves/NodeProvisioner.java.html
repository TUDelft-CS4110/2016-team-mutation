<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>NodeProvisioner.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">jenkins-core (22-mrt-2016 21:51:03)</a> &gt; <a href="../../index.html" class="el_group">jenkins-core</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">hudson.slaves</a> &gt; <span class="el_source">NodeProvisioner.java</span></div><h1>NodeProvisioner.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/*</span>
 * The MIT License
 *
 * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package hudson.slaves;

import hudson.ExtensionPoint;
import hudson.model.*;
import jenkins.model.Jenkins;

import static hudson.model.LoadStatistics.DECAY;
import hudson.model.MultiStageTimeSeries.TimeScale;
import hudson.Extension;

import javax.annotation.Nonnull;
import javax.annotation.concurrent.GuardedBy;
import java.awt.Color;
import java.util.Arrays;
import java.util.concurrent.Future;
import java.util.concurrent.ExecutionException;
import java.util.List;
import java.util.Collection;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.io.IOException;

/**
 * Uses the {@link LoadStatistics} and determines when we need to allocate
 * new {@link Node}s through {@link Cloud}.
 *
 * @author Kohsuke Kawaguchi
 */
public class NodeProvisioner {
    /**
     * The node addition activity in progress.
     */
    public static class PlannedNode {
        /**
         * Used to display this planned node to UI. Should ideally include the identifier unique to the node
         * being provisioned (like the instance ID), but if such an identifier doesn't readily exist, this
         * can be just a name of the template being provisioned (like the machine image ID.)
         */
        public final String displayName;

        /**
         * Used to launch and return a {@link Node} object. {@link NodeProvisioner} will check
         * this {@link Future}'s isDone() method to determine when to finalize this object.
         */
        public final Future&lt;Node&gt; future;

        /**
         * The number of executors that will be provided by the {@link Node} launched by
         * this object. This is used for capacity planning in {@link NodeProvisioner#update}.
         */
        public final int numExecutors;

        /**
         * Construct a PlannedNode instance without {@link Cloud} callback for finalization.
         *
         * @param displayName Used to display this object in the UI.
         * @param future Used to launch a @{link Node} object.
         * @param numExecutors The number of executors that will be provided by the launched {@link Node}.
         */
<span class="nc" id="L89">        public PlannedNode(String displayName, Future&lt;Node&gt; future, int numExecutors) {</span>
<span class="nc bnc" id="L90" title="All 6 branches missed.">            if(displayName==null || future==null || numExecutors&lt;1)  throw new IllegalArgumentException();</span>
<span class="nc" id="L91">            this.displayName = displayName;</span>
<span class="nc" id="L92">            this.future = future;</span>
<span class="nc" id="L93">            this.numExecutors = numExecutors;</span>
<span class="nc" id="L94">        }</span>

        /**
         * Indicate that this {@link PlannedNode} is being finalized.
         *
         * &lt;p&gt;
         * {@link NodeProvisioner} will call this method when it's done with {@link PlannedNode}.
         * This indicates that the {@link PlannedNode}'s work has been completed
         * (successfully or otherwise) and it is about to be removed from the list of pending
         * {@link Node}s to be launched.
         *
         * &lt;p&gt;
         * Create a subtype of this class and override this method to add any necessary behaviour.
         *
         * @since 1.503
         */
        public void spent() {
<span class="nc" id="L111">        }</span>
    }

    /**
     * Load for the label.
     */
    private final LoadStatistics stat;

    /**
     * For which label are we working?
     * Null if this {@link NodeProvisioner} is working for the entire Hudson,
     * for jobs that are unassigned to any particular node.
     */
    private final Label label;

<span class="nc" id="L126">    private final AtomicReference&lt;List&lt;PlannedNode&gt;&gt; pendingLaunches</span>
<span class="nc" id="L127">            = new AtomicReference&lt;List&lt;PlannedNode&gt;&gt;(new ArrayList&lt;PlannedNode&gt;());</span>

<span class="nc" id="L129">    private final Lock provisioningLock = new ReentrantLock();</span>

    @GuardedBy(&quot;provisioningLock&quot;)
<span class="nc" id="L132">    private StrategyState provisioningState = null;</span>

    private transient volatile long lastSuggestedReview;

    /**
     * Exponential moving average of the &quot;planned capacity&quot; over time, which is the number of
     * additional executors being brought up.
     *
     * This is used to filter out high-frequency components from the planned capacity, so that
     * the comparison with other low-frequency only variables won't leave spikes.
     */
<span class="nc" id="L143">    private final MultiStageTimeSeries plannedCapacitiesEMA =</span>
<span class="nc" id="L144">            new MultiStageTimeSeries(Messages._NodeProvisioner_EmptyString(),Color.WHITE,0,DECAY);</span>

<span class="nc" id="L146">    public NodeProvisioner(Label label, LoadStatistics loadStatistics) {</span>
<span class="nc" id="L147">        this.label = label;</span>
<span class="nc" id="L148">        this.stat = loadStatistics;</span>
<span class="nc" id="L149">    }</span>

    /**
     * Nodes that are being launched.
     *
     * @return
     *      Can be empty but never null
     * @since 1.401
     */
    public List&lt;PlannedNode&gt; getPendingLaunches() {
<span class="nc" id="L159">        return new ArrayList&lt;PlannedNode&gt;(pendingLaunches.get());</span>
    }

    /**
     * Give the {@link NodeProvisioner} a hint that now would be a good time to think about provisioning some nodes.
     * The hint will be ignored if subjected to excessive pestering by callers.
     *
     * @since 1.415
     */
    public void suggestReviewNow() {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (System.currentTimeMillis() &gt; lastSuggestedReview + TimeUnit.SECONDS.toMillis(1)) {</span>
<span class="nc" id="L170">            lastSuggestedReview = System.currentTimeMillis();</span>
<span class="nc" id="L171">            Computer.threadPoolForRemoting.submit(new Runnable() {</span>
                public void run() {
<span class="nc" id="L173">                    update();</span>
<span class="nc" id="L174">                }</span>
            });
        }
<span class="nc" id="L177">    }</span>

    /**
     * Periodically invoked to keep track of the load.
     * Launches additional nodes if necessary.
     *
     * Note: This method will obtain a lock on {@link #provisioningLock} first (to ensure that one and only one
     * instance of this provisioner is running at a time) and then a lock on {@link Queue#lock}
     */
    private void update() {
<span class="nc" id="L187">        provisioningLock.lock();</span>
        try {
<span class="nc" id="L189">            lastSuggestedReview = System.currentTimeMillis();</span>

            // We need to get the lock on Queue for two reasons:
            // 1. We will potentially adding a lot of nodes and we don't want to fight with Queue#maintain to acquire
            //    the Queue#lock in order to add each node. Much better is to hold the Queue#lock until all nodes
            //    that were provisioned since last we checked have been added.
            // 2. We want to know the idle executors count, which can only be measured if you hold the Queue#lock
            //    Strictly speaking we don't need an accurate measure for this, but as we had to get the Queue#lock
            //    anyway, we might as well get an accurate measure.
            //
            // We do not need the Queue#lock to get the count of items in the queue as that is a lock-free call
            // Since adding a node should not (in principle) confuse Queue#maintain (it is only removal of nodes
            // that causes issues in Queue#maintain) we should be able to remove the need for Queue#lock
            //
            // TODO once Nodes#addNode is made lock free, we should be able to remove the requirement for Queue#lock
<span class="nc" id="L204">            Queue.withLock(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L207">                    Jenkins jenkins = Jenkins.getInstance();</span>
                    // clean up the cancelled launch activity, then count the # of executors that we are about to
                    // bring up.

<span class="nc" id="L211">                    int plannedCapacitySnapshot = 0;</span>

<span class="nc" id="L213">                    List&lt;PlannedNode&gt; snapPendingLaunches = new ArrayList&lt;PlannedNode&gt;(pendingLaunches.get());</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                    for (Iterator&lt;PlannedNode&gt; itr = snapPendingLaunches.iterator(); itr.hasNext(); ) {</span>
<span class="nc" id="L215">                        PlannedNode f = itr.next();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                        if (f.future.isDone()) {</span>
                            try {
<span class="nc" id="L218">                                Node node = f.future.get();</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                                for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</span>
<span class="nc" id="L220">                                    cl.onComplete(f, node);</span>
                                }
    
<span class="nc" id="L223">                                jenkins.addNode(node);</span>
<span class="nc" id="L224">                                LOGGER.log(Level.INFO,</span>
<span class="nc" id="L225">                                        &quot;{0} provisioning successfully completed. &quot; </span>
                                                + &quot;We have now {1,number,integer} computer(s)&quot;,
<span class="nc" id="L227">                                        new Object[]{f.displayName, jenkins.getComputers().length});</span>
<span class="nc" id="L228">                            } catch (InterruptedException e) {</span>
<span class="nc" id="L229">                                throw new AssertionError(e); // since we confirmed that the future is already done</span>
<span class="nc" id="L230">                            } catch (ExecutionException e) {</span>
<span class="nc" id="L231">                                LOGGER.log(Level.WARNING, &quot;Provisioned slave &quot; + f.displayName + &quot; failed to launch&quot;,</span>
<span class="nc" id="L232">                                        e.getCause());</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                                for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</span>
<span class="nc" id="L234">                                    cl.onFailure(f, e.getCause());</span>
                                }
<span class="nc" id="L236">                            } catch (IOException e) {</span>
<span class="nc" id="L237">                                LOGGER.log(Level.WARNING, &quot;Provisioned slave &quot; + f.displayName + &quot; failed to launch&quot;, </span>
<span class="nc" id="L238">                                        e);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                                for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</span>
<span class="nc" id="L240">                                    cl.onFailure(f, e);</span>
                                }
<span class="nc" id="L242">                            } catch (Error e) {</span>
                                // we are not supposed to try and recover from Errors
<span class="nc" id="L244">                                throw e;</span>
<span class="nc" id="L245">                            } catch (Throwable e) {</span>
<span class="nc" id="L246">                                LOGGER.log(Level.SEVERE, &quot;Unexpected uncaught exception encountered while &quot; </span>
<span class="nc" id="L247">                                        + &quot;processing provisioned slave &quot; + f.displayName, e);</span>
<span class="nc" id="L248">                            } finally {</span>
                                while (true) {
<span class="nc" id="L250">                                    List&lt;PlannedNode&gt; orig = pendingLaunches.get();</span>
<span class="nc" id="L251">                                    List&lt;PlannedNode&gt; repl = new ArrayList&lt;PlannedNode&gt;(orig);</span>
                                    // the contract for List.remove(o) is that the first element i where
                                    // (o==null ? get(i)==null : o.equals(get(i)))
                                    // is true will be removed from the list
                                    // since PlannedNode.equals(o) is not final and we cannot assume
                                    // that subclasses do not override with an equals which does not
                                    // assure object identity comparison, we need to manually
                                    // do the removal based on instance identity not equality
<span class="nc" id="L259">                                    boolean changed = false;</span>
<span class="nc bnc" id="L260" title="All 10 branches missed.">                                    for (Iterator&lt;PlannedNode&gt; iterator = repl.iterator(); iterator.hasNext(); ) {</span>
<span class="nc" id="L261">                                        PlannedNode p = iterator.next();</span>
<span class="nc bnc" id="L262" title="All 10 branches missed.">                                        if (p == f) {</span>
<span class="nc" id="L263">                                            iterator.remove();</span>
<span class="nc" id="L264">                                            changed = true;</span>
<span class="nc" id="L265">                                            break;</span>
                                        }
                                    }
<span class="nc bnc" id="L268" title="All 20 branches missed.">                                    if (!changed || pendingLaunches.compareAndSet(orig, repl)) {</span>
                                        break;
                                    }
                                }
<span class="nc" id="L272">                                f.spent();</span>
<span class="nc" id="L273">                            }</span>
<span class="nc" id="L274">                        } else {</span>
<span class="nc" id="L275">                            plannedCapacitySnapshot += f.numExecutors;</span>
                        }
                    }

<span class="nc" id="L279">                    float plannedCapacity = plannedCapacitySnapshot;</span>
<span class="nc" id="L280">                    plannedCapacitiesEMA.update(plannedCapacity);</span>

<span class="nc" id="L282">                    final LoadStatistics.LoadStatisticsSnapshot snapshot = stat.computeSnapshot();</span>

<span class="nc" id="L284">                    int availableSnapshot = snapshot.getAvailableExecutors();</span>
<span class="nc" id="L285">                    int queueLengthSnapshot = snapshot.getQueueLength();</span>

<span class="nc bnc" id="L287" title="All 2 branches missed.">                    if (queueLengthSnapshot &lt;= availableSnapshot) {</span>
<span class="nc" id="L288">                        LOGGER.log(Level.FINER,</span>
<span class="nc" id="L289">                                &quot;Queue length {0} is less than the available capacity {1}. No provisioning strategy required&quot;,</span>
<span class="nc" id="L290">                                new Object[]{queueLengthSnapshot, availableSnapshot});</span>
<span class="nc" id="L291">                        provisioningState = null;</span>
<span class="nc" id="L292">                    } else {</span>
<span class="nc" id="L293">                        provisioningState = new StrategyState(snapshot, label, plannedCapacitySnapshot);;</span>
                    }
<span class="nc" id="L295">                }</span>
            });

<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (provisioningState != null) {</span>
<span class="nc" id="L299">                List&lt;Strategy&gt; strategies = Jenkins.getInstance().getExtensionList(Strategy.class);</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">                for (Strategy strategy : strategies.isEmpty()</span>
<span class="nc" id="L301">                        ? Arrays.&lt;Strategy&gt;asList(new StandardStrategyImpl())</span>
<span class="nc" id="L302">                        : strategies) {</span>
<span class="nc" id="L303">                    LOGGER.log(Level.FINER, &quot;Consulting {0} provisioning strategy with state {1}&quot;,</span>
<span class="nc" id="L304">                            new Object[]{strategy, provisioningState});</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                    if (StrategyDecision.PROVISIONING_COMPLETED == strategy.apply(provisioningState)) {</span>
<span class="nc" id="L306">                        LOGGER.log(Level.FINER, &quot;Provisioning strategy {0} declared provisioning complete&quot;,</span>
<span class="nc" id="L307">                                strategy);</span>
<span class="nc" id="L308">                        break;</span>
                    }
                }
            }
<span class="nc" id="L312">        } finally {</span>
<span class="nc" id="L313">            provisioningLock.unlock();</span>
<span class="nc" id="L314">        }</span>
<span class="nc" id="L315">    }</span>


    /**
     * Represents the decision taken by an individual {@link hudson.slaves.NodeProvisioner.Strategy}.
     * @since 1.588
     */
<span class="nc" id="L322">    public static enum StrategyDecision {</span>
<span class="nc" id="L323">        /**</span>
         * This decision is the default decision and indicates that the {@link hudson.slaves.NodeProvisioner.Strategy}
         * either could not provision sufficient resources or did not take any action. Any remaining strategies
         * will be able to contribute to the ultimate decision.
         */
<span class="nc" id="L328">        CONSULT_REMAINING_STRATEGIES,</span>
<span class="nc" id="L329">        /**</span>
         * This decision indicates that the {@link hudson.slaves.NodeProvisioner.Strategy} has taken sufficient
         * action so as to ensure that the required resources are available, and therefore there is no requirement
         * to consult the remaining strategies. Only return this decision when you are certain that there is no
         * need for additional provisioning actions (i.e. you detected an excess workload and have provisioned enough
         * for that excess workload).
         */
<span class="nc" id="L336">        PROVISIONING_COMPLETED</span>
    }

    /**
     * Extension point for node provisioning strategies.
     * @since 1.588
     */
<span class="nc" id="L343">    public static abstract class Strategy implements ExtensionPoint {</span>

        /**
         * Called by {@link NodeProvisioner#update()} to apply this strategy against the specified state.
         * Any provisioning activities should be recorded by calling
         * {@link hudson.slaves.NodeProvisioner.StrategyState#recordPendingLaunches(java.util.Collection)}
         * This method will be called by a thread that is holding {@link hudson.slaves.NodeProvisioner#provisioningLock}
         * @param state the current state.
         * @return the decision.
         */
        @Nonnull
        @GuardedBy(&quot;NodeProvisioner.this&quot;)
        public abstract StrategyDecision apply(@Nonnull StrategyState state);

    }

    /**
     * Parameter object for {@link hudson.slaves.NodeProvisioner.Strategy}.
     * Intentionally non-static as we need to reference some fields in {@link hudson.slaves.NodeProvisioner}
     * @since 1.588
     */
    public final class StrategyState {
        /**
         * The label under consideration.
         */
        private final Label label;
        /**
         * The planned capacity for this {@link #label}.
         */
        private final int plannedCapacitySnapshot;
        /**
         * The current statistics snapshot for this {@link #label}.
         */
        private final LoadStatistics.LoadStatisticsSnapshot snapshot;
        /**
         * The additional planned capacity for this {@link #label} and provisioned by previous strategies during the
         * current updating of the {@link NodeProvisioner}.
         */
        @GuardedBy(&quot;this&quot;)
        private int additionalPlannedCapacity;

        /**
         * Should only be instantiated by {@link NodeProvisioner#update()}
         * @param label the label.
         * @param plannedCapacitySnapshot the planned executor count.
         */
<span class="nc" id="L389">        private StrategyState(LoadStatistics.LoadStatisticsSnapshot snapshot, Label label, int plannedCapacitySnapshot) {</span>
<span class="nc" id="L390">            this.snapshot = snapshot;</span>
<span class="nc" id="L391">            this.label = label;</span>
<span class="nc" id="L392">            this.plannedCapacitySnapshot = plannedCapacitySnapshot;</span>
<span class="nc" id="L393">        }</span>

        /**
         * The label under consideration.
         */
        public Label getLabel() {
<span class="nc" id="L399">            return label;</span>
        }

        /**
         * The current snapshot of the load statistics for this {@link #getLabel()}.
         * @since 1.607
         */
        public LoadStatistics.LoadStatisticsSnapshot getSnapshot() {
<span class="nc" id="L407">            return snapshot;</span>
        }

        /**
         * The number of items in the queue requiring this {@link #getLabel()}.
         * @deprecated use {@link #getSnapshot()}, {@link LoadStatistics.LoadStatisticsSnapshot#getQueueLength()}
         */
        @Deprecated
        public int getQueueLengthSnapshot() {
<span class="nc" id="L416">            return snapshot.getQueueLength();</span>
        }

        /**
         * The planned capacity for this {@link #getLabel()}.
         */
        public int getPlannedCapacitySnapshot() {
<span class="nc" id="L423">            return plannedCapacitySnapshot;</span>
        }

        /**
         * The number of idle executors for this {@link #getLabel()}
         * @deprecated use {@link #getSnapshot()}, {@link LoadStatistics.LoadStatisticsSnapshot#getAvailableExecutors()}
         */
        @Deprecated
        public int getIdleSnapshot() {
<span class="nc" id="L432">            return snapshot.getAvailableExecutors();</span>
        }

        /**
         * The total number of executors for this {@link #getLabel()}
         * @deprecated use {@link #getSnapshot()}, {@link LoadStatistics.LoadStatisticsSnapshot#getOnlineExecutors()}
         */
        @Deprecated
        public int getTotalSnapshot() {
<span class="nc" id="L441">            return snapshot.getOnlineExecutors();</span>
        }

        /**
         * The additional planned capacity for this {@link #getLabel()} and provisioned by previous strategies during
         * the current updating of the {@link NodeProvisioner}.
         */
        public synchronized int getAdditionalPlannedCapacity() {
<span class="nc" id="L449">            return additionalPlannedCapacity;</span>
        }

        /**
         * The time series average number of items in the queue requiring this {@link #getLabel()}.
         */
        public float getQueueLengthLatest() {
<span class="nc" id="L456">            return stat.queueLength.getLatest(TIME_SCALE);</span>
        }

        /**
         * The time series average planned capacity for this {@link #getLabel()}.
         */
        public float getPlannedCapacityLatest() {
<span class="nc" id="L463">            return plannedCapacitiesEMA.getLatest(TIME_SCALE);</span>
        }

        /**
         * The time series average number of idle executors for this {@link #getLabel()}
         * @deprecated use {@link #getAvailableExecutorsLatest()}
         */
        @Deprecated
        public float getIdleLatest() {
<span class="nc" id="L472">            return getAvailableExecutorsLatest();</span>
        }

        /**
         * The time series average total number of executors for this {@link #getLabel()}
         * @deprecated use {@link #getOnlineExecutorsLatest()}
         */
        @Deprecated
        public float getTotalLatest() {
<span class="nc" id="L481">            return getOnlineExecutorsLatest();</span>
        }

        /**
         * The time series average number of defined executors for this {@link #getLabel()}
         * @since 1.607
         */
        public float getDefinedExecutorsLatest() {
<span class="nc" id="L489">            return stat.definedExecutors.getLatest(TIME_SCALE);</span>
        }

        /**
         * The time series average number of online executors for this {@link #getLabel()}
         * @since 1.607
         */
        public float getOnlineExecutorsLatest() {
<span class="nc" id="L497">            return stat.onlineExecutors.getLatest(TIME_SCALE);</span>
        }

        /**
         * The time series average number of connecting executors for this {@link #getLabel()}
         * @since 1.607
         */
        public float getConnectingExecutorsLatest() {
<span class="nc" id="L505">            return stat.connectingExecutors.getLatest(TIME_SCALE);</span>
        }

        /**
         * The time series average number of busy executors for this {@link #getLabel()}
         * @since 1.607
         */
        public float getBusyExecutorsLatest() {
<span class="nc" id="L513">            return stat.busyExecutors.getLatest(TIME_SCALE);</span>
        }

        /**
         * The time series average number of idle executors for this {@link #getLabel()}
         * @since 1.607
         */
        public float getIdleExecutorsLatest() {
<span class="nc" id="L521">            return stat.idleExecutors.getLatest(TIME_SCALE);</span>
        }

        /**
         * The time series average number of available executors for this {@link #getLabel()}
         * @since 1.607
         */
        public float getAvailableExecutorsLatest() {
<span class="nc" id="L529">            return stat.availableExecutors.getLatest(TIME_SCALE);</span>
        }

        /**
         * If a {@link hudson.slaves.NodeProvisioner.Strategy} takes some provisioning action, it should record
         * and {@link hudson.slaves.NodeProvisioner.PlannedNode} instances by calling this method.
         *
         * @param plannedNodes the {@link hudson.slaves.NodeProvisioner.PlannedNode} instances.
         */
        public void recordPendingLaunches(PlannedNode... plannedNodes) {
<span class="nc" id="L539">            recordPendingLaunches(Arrays.asList(plannedNodes));</span>
<span class="nc" id="L540">        }</span>

        /**
         * If a {@link hudson.slaves.NodeProvisioner.Strategy} takes some provisioning action, it should record
         * and {@link hudson.slaves.NodeProvisioner.PlannedNode} instances by calling this method.
         *
         * @param plannedNodes the {@link hudson.slaves.NodeProvisioner.PlannedNode} instances.
         */
        public void recordPendingLaunches(Collection&lt;PlannedNode&gt; plannedNodes) {
<span class="nc" id="L549">            int additionalPlannedCapacity = 0;</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">            for (PlannedNode f : plannedNodes) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">                if (f.future.isDone()) {</span>
                    // if done we should use the actual delivered capacity
                    try {
<span class="nc" id="L554">                        Node node = f.future.get();</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">                        if (node != null) {</span>
<span class="nc" id="L556">                            additionalPlannedCapacity += node.getNumExecutors();</span>
                        }
<span class="nc" id="L558">                    } catch (InterruptedException e) {</span>
                        // should never happen as we were told the future was done
<span class="nc" id="L560">                    } catch (ExecutionException e) {</span>
                        // ignore, this will be caught by others later
                    }
<span class="nc" id="L563">                } else {</span>
<span class="nc" id="L564">                    additionalPlannedCapacity += f.numExecutors;</span>
                }
            }
<span class="nc bnc" id="L567" title="All 2 branches missed.">            while (!plannedNodes.isEmpty()) {</span>
<span class="nc" id="L568">                List&lt;PlannedNode&gt; orig = pendingLaunches.get();</span>
<span class="nc" id="L569">                List&lt;PlannedNode&gt; repl = new ArrayList&lt;PlannedNode&gt;(orig);</span>
<span class="nc" id="L570">                repl.addAll(plannedNodes);</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                if (pendingLaunches.compareAndSet(orig, repl)) {</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">                    if (additionalPlannedCapacity &gt; 0) {</span>
<span class="nc" id="L573">                        synchronized (this) {</span>
<span class="nc" id="L574">                            this.additionalPlannedCapacity += additionalPlannedCapacity;</span>
                        }
                    }
                    break;
                }
            }
<span class="nc" id="L580">        }</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L587">            final StringBuilder sb = new StringBuilder(&quot;StrategyState{&quot;);</span>
<span class="nc" id="L588">            sb.append(&quot;label=&quot;).append(label);</span>
<span class="nc" id="L589">            sb.append(&quot;, snapshot=&quot;).append(snapshot);</span>
<span class="nc" id="L590">            sb.append(&quot;, plannedCapacitySnapshot=&quot;).append(plannedCapacitySnapshot);</span>
<span class="nc" id="L591">            sb.append(&quot;, additionalPlannedCapacity=&quot;).append(additionalPlannedCapacity);</span>
<span class="nc" id="L592">            sb.append('}');</span>
<span class="nc" id="L593">            return sb.toString();</span>
        }
    }

    /**
     * The default strategy.
     *
     * @since 1.588
     */
    @Extension
<span class="nc" id="L603">    public static class StandardStrategyImpl extends Strategy {</span>

        /** {@inheritDoc} */
        @Nonnull
        @Override
        public StrategyDecision apply(@Nonnull StrategyState state) {
        /*
            Here we determine how many additional slaves we need to keep up with the load (if at all),
            which involves a simple math.

            Broadly speaking, first we check that all the executors are fully utilized before attempting
            to start any new slave (this also helps to ignore the temporary gap between different numbers,
            as changes in them are not necessarily synchronized --- for example, there's a time lag between
            when a slave launches (thus bringing the planned capacity down) and the time when its executors
            pick up builds (thus bringing the queue length down.)

            Once we confirm that, we compare the # of buildable items against the additional slaves
            that are being brought online. If we have more jobs than our executors can handle, we'll launch a new slave.

            So this computation involves three stats:

              1. # of idle executors
              2. # of jobs that are starving for executors
              3. # of additional slaves being provisioned (planned capacities.)

            To ignore a temporary surge/drop, we make conservative estimates on each one of them. That is,
            we take the current snapshot value, and we take the current exponential moving average (EMA) value,
            and use the max/min.

            This is another measure to be robust against temporary surge/drop in those indicators, and helps
            us avoid over-reacting to stats.

            If we only use the snapshot value or EMA value, tests confirmed that the gap creates phantom
            excessive loads and Hudson ends up firing excessive capacities. In a static system, over the time
            EMA and the snapshot value becomes the same, so this makes sure that in a long run this conservative
            estimate won't create a starvation.
         */

<span class="nc" id="L641">            final LoadStatistics.LoadStatisticsSnapshot snapshot = state.getSnapshot();</span>
<span class="nc bnc" id="L642" title="All 4 branches missed.">            boolean needSomeWhenNoneAtAll = (snapshot.getAvailableExecutors() + snapshot.getConnectingExecutors() == 0)</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                    &amp;&amp; (snapshot.getOnlineExecutors() + state.getPlannedCapacitySnapshot() + state.getAdditionalPlannedCapacity() == 0)</span>
<span class="nc" id="L644">                    &amp;&amp; (snapshot.getQueueLength() &gt; 0);</span>
<span class="nc" id="L645">            float available = Math.max(snapshot.getAvailableExecutors(), state.getAvailableExecutorsLatest());</span>
<span class="nc bnc" id="L646" title="All 4 branches missed.">            if (available &lt; MARGIN || needSomeWhenNoneAtAll) {</span>
                // make sure the system is fully utilized before attempting any new launch.

                // this is the amount of work left to be done
<span class="nc" id="L650">                float qlen = Math.min(state.getQueueLengthLatest(), snapshot.getQueueLength());</span>

<span class="nc" id="L652">                float connectingCapacity = Math.min(state.getConnectingExecutorsLatest(), snapshot.getConnectingExecutors());</span>

                // ... and this is the additional executors we've already provisioned.
<span class="nc" id="L655">                float plannedCapacity = Math.max(state.getPlannedCapacityLatest(), state.getPlannedCapacitySnapshot())</span>
<span class="nc" id="L656">                        + state.getAdditionalPlannedCapacity();</span>

<span class="nc" id="L658">                float excessWorkload = qlen - plannedCapacity - connectingCapacity;</span>
<span class="nc bnc" id="L659" title="All 4 branches missed.">                if (needSomeWhenNoneAtAll &amp;&amp; excessWorkload &lt; 1) {</span>
                    // in this specific exceptional case we should just provision right now
                    // the exponential smoothing will delay the build unnecessarily
<span class="nc" id="L662">                    excessWorkload = 1;</span>
                }
<span class="nc" id="L664">                float m = calcThresholdMargin(state.getTotalSnapshot());</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">                if (excessWorkload &gt; 1 - m) {// and there's more work to do...</span>
<span class="nc" id="L666">                    LOGGER.log(Level.FINE, &quot;Excess workload {0,number,#.###} detected. &quot;</span>
                                    + &quot;(planned capacity={1,number,#.###},connecting capacity={7,number,#.###},&quot;
                                    + &quot;Qlen={2,number,#.###},available={3,number,#.###}&amp;{4,number,integer},&quot;
                                    + &quot;online={5,number,integer},m={6,number,#.###})&quot;,
<span class="nc" id="L670">                            new Object[]{</span>
<span class="nc" id="L671">                                    excessWorkload, plannedCapacity, qlen, available, snapshot.getAvailableExecutors(),</span>
<span class="nc" id="L672">                                    snapshot.getOnlineExecutors(), m , snapshot.getConnectingExecutors()</span>
                            });

                    CLOUD:
<span class="nc bnc" id="L676" title="All 2 branches missed.">                    for (Cloud c : Jenkins.getInstance().clouds) {</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">                        if (excessWorkload &lt; 0) {</span>
<span class="nc" id="L678">                            break;  // enough slaves allocated</span>
                        }

                        // Make sure this cloud actually can provision for this label.
<span class="nc bnc" id="L682" title="All 2 branches missed.">                        if (c.canProvision(state.getLabel())) {</span>
                            // provisioning a new node should be conservative --- for example if excessWorkload is 1.4,
                            // we don't want to allocate two nodes but just one.
                            // OTOH, because of the exponential decay, even when we need one slave,
                            // excess workload is always
                            // something like 0.95, in which case we want to allocate one node.
                            // so the threshold here is 1-MARGIN, and hence floor(excessWorkload+MARGIN) is needed to
                            // handle this.

<span class="nc" id="L691">                            int workloadToProvision = (int) Math.round(Math.floor(excessWorkload + m));</span>

<span class="nc bnc" id="L693" title="All 2 branches missed.">                            for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                                if (cl.canProvision(c, state.getLabel(), workloadToProvision) != null) {</span>
                                    // consider displaying reasons in a future cloud ux
<span class="nc" id="L696">                                    continue CLOUD;</span>
                                }
                            }

<span class="nc" id="L700">                            Collection&lt;PlannedNode&gt; additionalCapacities =</span>
<span class="nc" id="L701">                                    c.provision(state.getLabel(), workloadToProvision);</span>

<span class="nc bnc" id="L703" title="All 2 branches missed.">                            for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</span>
<span class="nc" id="L704">                                cl.onStarted(c, state.getLabel(), additionalCapacities);</span>
                            }

<span class="nc bnc" id="L707" title="All 2 branches missed.">                            for (PlannedNode ac : additionalCapacities) {</span>
<span class="nc" id="L708">                                excessWorkload -= ac.numExecutors;</span>
<span class="nc" id="L709">                                LOGGER.log(Level.INFO, &quot;Started provisioning {0} from {1} with {2,number,integer} &quot;</span>
                                                + &quot;executors. Remaining excess workload: {3,number,#.###}&quot;,
<span class="nc" id="L711">                                        new Object[]{ac.displayName, c.name, ac.numExecutors, excessWorkload});</span>
                            }
<span class="nc" id="L713">                            state.recordPendingLaunches(additionalCapacities);</span>
                        }
                    }
                    // we took action, only pass on to other strategies if our action was insufficient
<span class="nc bnc" id="L717" title="All 2 branches missed.">                    return excessWorkload &gt; 1 - m ? StrategyDecision.CONSULT_REMAINING_STRATEGIES : StrategyDecision.PROVISIONING_COMPLETED;</span>
                }
            }
            // if we reach here then the standard strategy obviously decided to do nothing, so let any other strategies
            // take their considerations.
<span class="nc" id="L722">            return StrategyDecision.CONSULT_REMAINING_STRATEGIES;</span>
        }

        /**
         * Computes the threshold for triggering an allocation.
         * &lt;p/&gt;
         * &lt;p/&gt;
         * Because the excessive workload value is EMA, even when the snapshot value of the excessive
         * workload is 1, the value never really gets to 1. So we need to introduce a notion of the margin M,
         * where we provision a new node if the EMA of the excessive workload goes beyond 1-M (where M is a small value
         * in the (0,1) range.)
         * &lt;p/&gt;
         * &lt;p/&gt;
         * M effectively controls how long Hudson waits until allocating a new node, in the face of workload.
         * This delay is justified for absorbing temporary ups and downs, and can be interpreted as Hudson
         * holding off provisioning in the hope that one of the existing nodes will become available.
         * &lt;p/&gt;
         * &lt;p/&gt;
         * M can be a constant value, but there's a benefit in adjusting M based on the total current capacity,
         * based on the above justification; that is, if there's no existing capacity at all, holding off
         * an allocation doesn't make much sense, as there won't be any executors available no matter how long we wait.
         * On the other hand, if we have a large number of existing executors, chances are good that some
         * of them become available &amp;mdash; the chance gets better and better as the number of current total
         * capacity increases.
         * &lt;p/&gt;
         * &lt;p/&gt;
         * Therefore, we compute the threshold margin as follows:
         * &lt;p/&gt;
         * &lt;pre&gt;
         *   M(t) = M* + (M0 - M*) alpha ^ t
         * &lt;/pre&gt;
         * &lt;p/&gt;
         * ... where:
         * &lt;p/&gt;
         * &lt;ul&gt;
         * &lt;li&gt;M* is the ultimate margin value that M(t) converges to with t-&gt;inf,
         * &lt;li&gt;M0 is the value of M(0), the initial value.
         * &lt;li&gt;alpha is the decay factor in (0,1). M(t) converges to M* faster if alpha is smaller.
         * &lt;/ul&gt;
         */
        private float calcThresholdMargin(int totalSnapshot) {
<span class="nc" id="L763">            float f = (float) (MARGIN + (MARGIN0 - MARGIN) * Math.pow(MARGIN_DECAY, totalSnapshot));</span>
            // defensively ensure that the threshold margin is in (0,1)
<span class="nc" id="L765">            f = Math.max(f, 0);</span>
<span class="nc" id="L766">            f = Math.min(f, 1);</span>
<span class="nc" id="L767">            return f;</span>
        }
    }

    /**
     * Periodically invoke NodeProvisioners
     */
    @Extension
<span class="nc" id="L775">    public static class NodeProvisionerInvoker extends PeriodicWork {</span>
        /**
         * Give some initial warm up time so that statically connected slaves
         * can be brought online before we start allocating more.
         */
<span class="nc" id="L780">    	 public static int INITIALDELAY = Integer.getInteger(NodeProvisioner.class.getName()+&quot;.initialDelay&quot;,LoadStatistics.CLOCK*10);</span>
<span class="nc" id="L781">    	 public static int RECURRENCEPERIOD = Integer.getInteger(NodeProvisioner.class.getName()+&quot;.recurrencePeriod&quot;,LoadStatistics.CLOCK);</span>

        @Override
        public long getInitialDelay() {
<span class="nc" id="L785">            return INITIALDELAY;</span>
        }

        public long getRecurrencePeriod() {
<span class="nc" id="L789">            return RECURRENCEPERIOD;</span>
        }

        @Override
        protected void doRun() {
<span class="nc" id="L794">            Jenkins h = Jenkins.getInstance();</span>
<span class="nc" id="L795">            h.unlabeledNodeProvisioner.update();</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">            for( Label l : h.getLabels() )</span>
<span class="nc" id="L797">                l.nodeProvisioner.update();</span>
<span class="nc" id="L798">        }</span>
    }

<span class="nc" id="L801">    private static final Logger LOGGER = Logger.getLogger(NodeProvisioner.class.getName());</span>
<span class="nc" id="L802">    private static final float MARGIN = Integer.getInteger(NodeProvisioner.class.getName()+&quot;.MARGIN&quot;,10)/100f;</span>
<span class="nc" id="L803">    private static final float MARGIN0 = Math.max(MARGIN, getFloatSystemProperty(NodeProvisioner.class.getName()+&quot;.MARGIN0&quot;,0.5f));</span>
<span class="nc" id="L804">    private static final float MARGIN_DECAY = getFloatSystemProperty(NodeProvisioner.class.getName()+&quot;.MARGIN_DECAY&quot;,0.5f);</span>

    // TODO: picker should be selectable
<span class="nc" id="L807">    private static final TimeScale TIME_SCALE = TimeScale.SEC10;</span>

    private static float getFloatSystemProperty(String propName, float defaultValue) {
<span class="nc" id="L810">        String v = System.getProperty(propName);</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (v!=null)</span>
            try {
<span class="nc" id="L813">                return Float.parseFloat(v);</span>
<span class="nc" id="L814">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L815">                LOGGER.warning(&quot;Failed to parse a float value from system property &quot;+propName+&quot;. value was &quot;+v);</span>
            }
<span class="nc" id="L817">        return defaultValue;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>jenkins-core (22-mrt-2016 21:51:03)</div></body></html>