<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>FilePathTest.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">jenkins-core (22-mrt-2016 21:51:03)</a> &gt; <a href="../../index.html" class="el_group">jenkins-core</a> &gt; <a href="../index.html" class="el_bundle">src/test/java</a> &gt; <a href="index.source.html" class="el_package">hudson</a> &gt; <span class="el_source">FilePathTest.java</span></div><h1>FilePathTest.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">/*</span>
 * The MIT License
 * 
 * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi, Alan Harder
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package hudson;

import hudson.FilePath.TarCompression;
import hudson.model.TaskListener;
import hudson.remoting.VirtualChannel;
import hudson.util.NullStream;
import hudson.util.StreamTaskListener;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.ConnectException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.output.NullOutputStream;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Chmod;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;
import static org.junit.Assume.assumeFalse;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import org.jvnet.hudson.test.Issue;
import org.mockito.Mockito;
import static org.mockito.Mockito.*;

/**
 * @author Kohsuke Kawaguchi
 */
<span class="fc" id="L74">public class FilePathTest {</span>

<span class="fc" id="L76">    @Rule public ChannelRule channels = new ChannelRule();</span>
<span class="fc" id="L77">    @Rule public TemporaryFolder temp = new TemporaryFolder();</span>

    @Test public void copyTo() throws Exception {
<span class="fc" id="L80">        File tmp = temp.newFile();</span>
<span class="fc" id="L81">        FilePath f = new FilePath(channels.french, tmp.getPath());</span>
<span class="fc" id="L82">        f.copyTo(new NullStream());</span>
<span class="fc" id="L83">        assertTrue(&quot;target does not exist&quot;, tmp.exists());</span>
<span class="fc" id="L84">        assertTrue(&quot;could not delete target &quot; + tmp.getPath(), tmp.delete());</span>
<span class="fc" id="L85">    }</span>

    /**
     * An attempt to reproduce the file descriptor leak.
     * If this operation leaks a file descriptor, 2500 should be enough, I think.
     */
    // TODO: this test is much too slow to be a traditional unit test. Should be extracted into some stress test
    // which is no part of the default test harness?
    @Test public void noFileLeakInCopyTo() throws Exception {
<span class="fc bfc" id="L94" title="All 2 branches covered.">        for (int j=0; j&lt;2500; j++) {</span>
<span class="fc" id="L95">            File tmp = temp.newFile();</span>
<span class="fc" id="L96">            FilePath f = new FilePath(tmp);</span>
<span class="fc" id="L97">            File tmp2 = temp.newFile();</span>
<span class="fc" id="L98">            FilePath f2 = new FilePath(channels.british, tmp2.getPath());</span>

<span class="fc" id="L100">            f.copyTo(f2);</span>

<span class="fc" id="L102">            f.delete();</span>
<span class="fc" id="L103">            f2.delete();</span>
        }
<span class="fc" id="L105">    }</span>

    /**
     * As we moved the I/O handling to another thread, there's a race condition in
     * {@link FilePath#copyTo(OutputStream)} &amp;mdash; this method can return before
     * all the writes are delivered to {@link OutputStream}.
     *
     * &lt;p&gt;
     * To reproduce that problem, we use a large number of threads, so that we can
     * maximize the chance of out-of-order execution, and make sure we are
     * seeing the right byte count at the end.
     *
     * Also see JENKINS-7897
     */
    @Issue(&quot;JENKINS-7871&quot;)
    @Test public void noRaceConditionInCopyTo() throws Exception {
<span class="fc" id="L121">        final File tmp = temp.newFile();</span>

<span class="fc" id="L123">           int fileSize = 90000;</span>
        
<span class="fc" id="L125">            givenSomeContentInFile(tmp, fileSize);</span>
        
<span class="fc" id="L127">            List&lt;Future&lt;Integer&gt;&gt; results = whenFileIsCopied100TimesConcurrently(tmp);</span>

            // THEN copied count was always equal the expected size
<span class="fc bfc" id="L130" title="All 2 branches covered.">            for (Future&lt;Integer&gt; f : results)</span>
<span class="fc" id="L131">                assertEquals(fileSize,f.get().intValue());</span>
<span class="fc" id="L132">    }</span>

    private void givenSomeContentInFile(File file, int size) throws IOException {
<span class="fc" id="L135">        FileOutputStream os = new FileOutputStream(file);</span>
<span class="fc" id="L136">        byte[] buf = new byte[size];</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        for (int i=0; i&lt;buf.length; i++)</span>
<span class="fc" id="L138">            buf[i] = (byte)(i%256);</span>
<span class="fc" id="L139">        os.write(buf);</span>
<span class="fc" id="L140">        os.close();</span>
<span class="fc" id="L141">    }</span>
    
    private List&lt;Future&lt;Integer&gt;&gt; whenFileIsCopied100TimesConcurrently(final File file) throws InterruptedException {
<span class="fc" id="L144">        List&lt;Callable&lt;Integer&gt;&gt; r = new ArrayList&lt;Callable&lt;Integer&gt;&gt;();</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        for (int i=0; i&lt;100; i++) {</span>
<span class="fc" id="L146">            r.add(new Callable&lt;Integer&gt;() {</span>
                public Integer call() throws Exception {
<span class="fc" id="L148">                    class Sink extends OutputStream {</span>
                        private Exception closed;
                        private volatile int count;

                        private void checkNotClosed() throws IOException {
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">                            if (closed != null)</span>
<span class="nc" id="L154">                                throw new IOException(closed);</span>
<span class="fc" id="L155">                        }</span>

                        @Override
                        public void write(int b) throws IOException {
<span class="nc" id="L159">                            count++;</span>
<span class="nc" id="L160">                            checkNotClosed();</span>
<span class="nc" id="L161">                        }</span>

                        @Override
                        public void write(byte[] b) throws IOException {
<span class="fc" id="L165">                            count+=b.length;</span>
<span class="fc" id="L166">                            checkNotClosed();</span>
<span class="fc" id="L167">                        }</span>

                        @Override
                        public void write(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L171">                            count+=len;</span>
<span class="nc" id="L172">                            checkNotClosed();</span>
<span class="nc" id="L173">                        }</span>

                        @Override
                        public void close() throws IOException {
<span class="fc" id="L177">                            closed = new Exception();</span>
                            //if (size!=count)
                            //    fail();
<span class="fc" id="L180">                        }</span>
                    }

<span class="fc" id="L183">                    FilePath f = new FilePath(channels.french, file.getPath());</span>
<span class="fc" id="L184">                    Sink sink = new Sink();</span>
<span class="fc" id="L185">                    f.copyTo(sink);</span>
<span class="fc" id="L186">                    return sink.count;</span>
                }
            });
        }

<span class="fc" id="L191">        ExecutorService es = Executors.newFixedThreadPool(100);</span>
        try {
<span class="fc" id="L193">            return es.invokeAll(r);</span>
<span class="nc" id="L194">        } finally {</span>
<span class="pc" id="L195">            es.shutdown();</span>
<span class="nc" id="L196">        }</span>
    }

    @Test public void repeatCopyRecursiveTo() throws Exception {
        // local-&gt;local copy used to return 0 if all files were &quot;up to date&quot;
        // should return number of files processed, whether or not they were copied or already current
<span class="fc" id="L202">        File src = temp.newFolder(&quot;src&quot;);</span>
<span class="fc" id="L203">        File dst = temp.newFolder(&quot;dst&quot;);</span>
<span class="fc" id="L204">            File.createTempFile(&quot;foo&quot;, &quot;.tmp&quot;, src);</span>
<span class="fc" id="L205">            FilePath fp = new FilePath(src);</span>
<span class="fc" id="L206">            assertEquals(1, fp.copyRecursiveTo(new FilePath(dst)));</span>
            // copy again should still report 1
<span class="fc" id="L208">            assertEquals(1, fp.copyRecursiveTo(new FilePath(dst)));</span>
<span class="fc" id="L209">    }</span>

    @Issue(&quot;JENKINS-9540&quot;)
    @Test public void errorMessageInRemoteCopyRecursive() throws Exception {
<span class="fc" id="L213">        File src = temp.newFolder(&quot;src&quot;);</span>
<span class="fc" id="L214">        File dst = temp.newFolder(&quot;dst&quot;);</span>
<span class="fc" id="L215">            FilePath from = new FilePath(src);</span>
<span class="fc" id="L216">            FilePath to = new FilePath(channels.british, dst.getAbsolutePath());</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            for (int i = 0; i &lt; 10000; i++) {</span>
                // TODO is there a simpler way to force the TarOutputStream to be flushed and the reader to start?
                // Have not found a way to make the failure guaranteed.
<span class="fc" id="L220">                OutputStream os = from.child(&quot;content&quot; + i).write();</span>
                try {
<span class="fc bfc" id="L222" title="All 2 branches covered.">                    for (int j = 0; j &lt; 1024; j++) {</span>
<span class="fc" id="L223">                        os.write('.');</span>
                    }
<span class="pc" id="L225">                } finally {</span>
<span class="pc" id="L226">                    os.close();</span>
<span class="nc" id="L227">                }</span>
            }
<span class="fc" id="L229">            FilePath toF = to.child(&quot;content0&quot;);</span>
<span class="fc" id="L230">            toF.write().close();</span>
<span class="fc" id="L231">            toF.chmod(0400);</span>
            try {
<span class="fc" id="L233">                from.copyRecursiveTo(to);</span>
                // on Windows this may just succeed; OK, test did not prove anything then
<span class="pc" id="L235">            } catch (IOException x) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">                if (Functions.printThrowable(x).contains(&quot;content0&quot;)) {</span>
                    // Fine, error message talks about permission denied.
                } else {
<span class="nc" id="L239">                    throw x;</span>
                }
<span class="nc" id="L241">            } finally {</span>
<span class="pc" id="L242">                toF.chmod(700);</span>
<span class="nc" id="L243">            }</span>
<span class="fc" id="L244">    }</span>

    @Issue(&quot;JENKINS-4039&quot;)
    @Test public void archiveBug() throws Exception {
<span class="fc" id="L248">            FilePath d = new FilePath(channels.french, temp.getRoot().getPath());</span>
<span class="fc" id="L249">            d.child(&quot;test&quot;).touch(0);</span>
<span class="fc" id="L250">            d.zip(new NullOutputStream());</span>
<span class="fc" id="L251">            d.zip(new NullOutputStream(),&quot;**/*&quot;);</span>
<span class="fc" id="L252">    }</span>

    @Test public void normalization() throws Exception {
<span class="fc" id="L255">        compare(&quot;abc/def\\ghi&quot;,&quot;abc/def\\ghi&quot;); // allow mixed separators</span>

        {// basic '.' trimming
<span class="fc" id="L258">            compare(&quot;./abc/def&quot;,&quot;abc/def&quot;);</span>
<span class="fc" id="L259">            compare(&quot;abc/./def&quot;,&quot;abc/def&quot;);</span>
<span class="fc" id="L260">            compare(&quot;abc/def/.&quot;,&quot;abc/def&quot;);</span>

<span class="fc" id="L262">            compare(&quot;.\\abc\\def&quot;,&quot;abc\\def&quot;);</span>
<span class="fc" id="L263">            compare(&quot;abc\\.\\def&quot;,&quot;abc\\def&quot;);</span>
<span class="fc" id="L264">            compare(&quot;abc\\def\\.&quot;,&quot;abc\\def&quot;);</span>
        }

<span class="fc" id="L267">        compare(&quot;abc/../def&quot;,&quot;def&quot;);</span>
<span class="fc" id="L268">        compare(&quot;abc/def/../../ghi&quot;,&quot;ghi&quot;);</span>
<span class="fc" id="L269">        compare(&quot;abc/./def/../././../ghi&quot;,&quot;ghi&quot;);   // interleaving . and ..</span>

<span class="fc" id="L271">        compare(&quot;../abc/def&quot;,&quot;../abc/def&quot;);     // uncollapsible ..</span>
<span class="fc" id="L272">        compare(&quot;abc/def/..&quot;,&quot;abc&quot;);</span>

<span class="fc" id="L274">        compare(&quot;c:\\abc\\..&quot;,&quot;c:\\&quot;);      // we want c:\\, not c:</span>
<span class="fc" id="L275">        compare(&quot;c:\\abc\\def\\..&quot;,&quot;c:\\abc&quot;);</span>

<span class="fc" id="L277">        compare(&quot;/abc/../&quot;,&quot;/&quot;);</span>
<span class="fc" id="L278">        compare(&quot;abc/..&quot;,&quot;.&quot;);</span>
<span class="fc" id="L279">        compare(&quot;.&quot;,&quot;.&quot;);</span>

        // @Issue(&quot;JENKINS-5951&quot;)
<span class="fc" id="L282">        compare(&quot;C:\\Hudson\\jobs\\foo\\workspace/../../otherjob/workspace/build.xml&quot;,</span>
<span class="fc" id="L283">                &quot;C:\\Hudson\\jobs/otherjob/workspace/build.xml&quot;);</span>
        // Other cases that failed before
<span class="fc" id="L285">        compare(&quot;../../abc/def&quot;,&quot;../../abc/def&quot;);</span>
<span class="fc" id="L286">        compare(&quot;..\\..\\abc\\def&quot;,&quot;..\\..\\abc\\def&quot;);</span>
<span class="fc" id="L287">        compare(&quot;/abc//../def&quot;,&quot;/def&quot;);</span>
<span class="fc" id="L288">        compare(&quot;c:\\abc\\\\..\\def&quot;,&quot;c:\\def&quot;);</span>
<span class="fc" id="L289">        compare(&quot;/../abc/def&quot;,&quot;/abc/def&quot;);</span>
<span class="fc" id="L290">        compare(&quot;c:\\..\\abc\\def&quot;,&quot;c:\\abc\\def&quot;);</span>
<span class="fc" id="L291">        compare(&quot;abc/def/&quot;,&quot;abc/def&quot;);</span>
<span class="fc" id="L292">        compare(&quot;abc\\def\\&quot;,&quot;abc\\def&quot;);</span>
        // The new code can collapse extra separator chars
<span class="fc" id="L294">        compare(&quot;abc//def/\\//\\ghi&quot;,&quot;abc/def/ghi&quot;);</span>
<span class="fc" id="L295">        compare(&quot;\\\\host\\\\abc\\\\\\def&quot;,&quot;\\\\host\\abc\\def&quot;); // don't collapse for \\ prefix</span>
<span class="fc" id="L296">        compare(&quot;\\\\\\foo&quot;,&quot;\\\\foo&quot;);</span>
<span class="fc" id="L297">        compare(&quot;//foo&quot;,&quot;/foo&quot;);</span>
        // Other edge cases
<span class="fc" id="L299">        compare(&quot;abc/def/../../../ghi&quot;,&quot;../ghi&quot;);</span>
<span class="fc" id="L300">        compare(&quot;\\abc\\def\\..\\..\\..\\ghi\\&quot;,&quot;\\ghi&quot;);</span>
<span class="fc" id="L301">    }</span>

    private void compare(String original, String answer) {
<span class="fc" id="L304">        assertEquals(answer,new FilePath((VirtualChannel)null,original).getRemote());</span>
<span class="fc" id="L305">    }</span>

    @Issue(&quot;JENKINS-6494&quot;)
    @Test public void getParent() throws Exception {
<span class="fc" id="L309">        FilePath fp = new FilePath((VirtualChannel)null, &quot;/abc/def&quot;);</span>
<span class="fc" id="L310">        assertEquals(&quot;/abc&quot;, (fp = fp.getParent()).getRemote());</span>
<span class="fc" id="L311">        assertEquals(&quot;/&quot;, (fp = fp.getParent()).getRemote());</span>
<span class="fc" id="L312">        assertNull(fp.getParent());</span>

<span class="fc" id="L314">        fp = new FilePath((VirtualChannel)null, &quot;abc/def\\ghi&quot;);</span>
<span class="fc" id="L315">        assertEquals(&quot;abc/def&quot;, (fp = fp.getParent()).getRemote());</span>
<span class="fc" id="L316">        assertEquals(&quot;abc&quot;, (fp = fp.getParent()).getRemote());</span>
<span class="fc" id="L317">        assertNull(fp.getParent());</span>

<span class="fc" id="L319">        fp = new FilePath((VirtualChannel)null, &quot;C:\\abc\\def&quot;);</span>
<span class="fc" id="L320">        assertEquals(&quot;C:\\abc&quot;, (fp = fp.getParent()).getRemote());</span>
<span class="fc" id="L321">        assertEquals(&quot;C:\\&quot;, (fp = fp.getParent()).getRemote());</span>
<span class="fc" id="L322">        assertNull(fp.getParent());</span>
<span class="fc" id="L323">    }</span>

    private FilePath createFilePath(final File base, final String... path) throws IOException {
<span class="fc" id="L326">        File building = base;</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (final String component : path) {</span>
<span class="fc" id="L328">            building = new File(building, component);</span>
        }
<span class="fc" id="L330">        FileUtils.touch(building);</span>
<span class="fc" id="L331">        return new FilePath(building);</span>
    }
    
    /**
     * Performs round-trip archiving for Tar handling methods.
     * @throws Exception test failure
     */
    @Test public void compressTarUntarRoundTrip() throws Exception {
<span class="fc" id="L339">        checkTarUntarRoundTrip(&quot;compressTarUntarRoundTrip_zero&quot;, 0);   </span>
<span class="fc" id="L340">        checkTarUntarRoundTrip(&quot;compressTarUntarRoundTrip_small&quot;, 100); </span>
<span class="fc" id="L341">        checkTarUntarRoundTrip(&quot;compressTarUntarRoundTrip_medium&quot;, 50000); </span>
<span class="fc" id="L342">    }</span>
            
    /**
     * Checks that big files (&gt;8GB) can be archived and then unpacked.
     * This test is disabled by default due the impact on RAM.
     * The actual file size limit is 8589934591 bytes.
     * @throws Exception test failure
     */
    @Issue(&quot;JENKINS-10629&quot;)
    @Ignore
    @Test public void archiveBigFile() throws Exception {
<span class="nc" id="L353">        final long largeFileSize = 9000000000L; // &gt;8589934591 bytes</span>
<span class="nc" id="L354">        final String filePrefix = &quot;JENKINS-10629&quot;;</span>
<span class="nc" id="L355">        checkTarUntarRoundTrip(filePrefix, largeFileSize);</span>
<span class="nc" id="L356">    }</span>
     
    private void checkTarUntarRoundTrip(String filePrefix, long fileSize) throws Exception {
<span class="fc" id="L359">        final File tmpDir = temp.newFolder(filePrefix);</span>
<span class="fc" id="L360">        final File tempFile =  new File(tmpDir, filePrefix + &quot;.log&quot;);</span>
<span class="fc" id="L361">        RandomAccessFile file = new RandomAccessFile(tempFile, &quot;rw&quot;);</span>
<span class="fc" id="L362">        final File tarFile = new File(tmpDir, filePrefix + &quot;.tar&quot;);</span>

<span class="fc" id="L364">        file.setLength(fileSize);</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">        assumeTrue(fileSize == file.length());</span>
<span class="fc" id="L366">        file.close();</span>

        // Compress archive
<span class="fc" id="L369">        final FilePath tmpDirPath = new FilePath(tmpDir);</span>
<span class="fc" id="L370">        int tar = tmpDirPath.tar(new FileOutputStream(tarFile), tempFile.getName());</span>
<span class="fc" id="L371">        assertEquals(&quot;One file should have been compressed&quot;, 1, tar);</span>

        // Decompress
<span class="fc" id="L374">        FilePath outDir = new FilePath(temp.newFolder(filePrefix + &quot;_out&quot;));</span>
<span class="fc" id="L375">        final FilePath outFile = outDir.child(tempFile.getName());</span>
<span class="fc" id="L376">        tmpDirPath.child(tarFile.getName()).untar(outDir, TarCompression.NONE);</span>
<span class="fc" id="L377">        assertEquals(&quot;Result file after the roundtrip differs from the initial file&quot;,</span>
<span class="fc" id="L378">                new FilePath(tempFile).digest(), outFile.digest());</span>
<span class="fc" id="L379">    }</span>

    @Test public void list() throws Exception {
<span class="fc" id="L382">        File baseDir = temp.getRoot();</span>
<span class="fc" id="L383">            final Set&lt;FilePath&gt; expected = new HashSet&lt;FilePath&gt;();</span>
<span class="fc" id="L384">            expected.add(createFilePath(baseDir, &quot;top&quot;, &quot;sub&quot;, &quot;app.log&quot;));</span>
<span class="fc" id="L385">            expected.add(createFilePath(baseDir, &quot;top&quot;, &quot;sub&quot;, &quot;trace.log&quot;));</span>
<span class="fc" id="L386">            expected.add(createFilePath(baseDir, &quot;top&quot;, &quot;db&quot;, &quot;db.log&quot;));</span>
<span class="fc" id="L387">            expected.add(createFilePath(baseDir, &quot;top&quot;, &quot;db&quot;, &quot;trace.log&quot;));</span>
<span class="fc" id="L388">            final FilePath[] result = new FilePath(baseDir).list(&quot;**&quot;);</span>
<span class="fc" id="L389">            assertEquals(expected, new HashSet&lt;FilePath&gt;(Arrays.asList(result)));</span>
<span class="fc" id="L390">    }</span>

    @Test public void listWithExcludes() throws Exception {
<span class="fc" id="L393">        File baseDir = temp.getRoot();</span>
<span class="fc" id="L394">            final Set&lt;FilePath&gt; expected = new HashSet&lt;FilePath&gt;();</span>
<span class="fc" id="L395">            expected.add(createFilePath(baseDir, &quot;top&quot;, &quot;sub&quot;, &quot;app.log&quot;));</span>
<span class="fc" id="L396">            createFilePath(baseDir, &quot;top&quot;, &quot;sub&quot;, &quot;trace.log&quot;);</span>
<span class="fc" id="L397">            expected.add(createFilePath(baseDir, &quot;top&quot;, &quot;db&quot;, &quot;db.log&quot;));</span>
<span class="fc" id="L398">            createFilePath(baseDir, &quot;top&quot;, &quot;db&quot;, &quot;trace.log&quot;);</span>
<span class="fc" id="L399">            final FilePath[] result = new FilePath(baseDir).list(&quot;**&quot;, &quot;**/trace.log&quot;);</span>
<span class="fc" id="L400">            assertEquals(expected, new HashSet&lt;FilePath&gt;(Arrays.asList(result)));</span>
<span class="fc" id="L401">    }</span>

    @Test public void listWithDefaultExcludes() throws Exception {
<span class="fc" id="L404">        File baseDir = temp.getRoot();</span>
<span class="fc" id="L405">            final Set&lt;FilePath&gt; expected = new HashSet&lt;FilePath&gt;();</span>
<span class="fc" id="L406">            expected.add(createFilePath(baseDir, &quot;top&quot;, &quot;sub&quot;, &quot;backup~&quot;));</span>
<span class="fc" id="L407">            expected.add(createFilePath(baseDir, &quot;top&quot;, &quot;CVS&quot;, &quot;somefile,v&quot;));</span>
<span class="fc" id="L408">            expected.add(createFilePath(baseDir, &quot;top&quot;, &quot;.git&quot;, &quot;config&quot;));</span>
            // none of the files are included by default (default includes true)
<span class="fc" id="L410">            assertEquals(0, new FilePath(baseDir).list(&quot;**&quot;, &quot;&quot;).length);</span>
<span class="fc" id="L411">            final FilePath[] result = new FilePath(baseDir).list(&quot;**&quot;, &quot;&quot;, false);</span>
<span class="fc" id="L412">            assertEquals(expected, new HashSet&lt;FilePath&gt;(Arrays.asList(result)));</span>
<span class="fc" id="L413">    }</span>

    @Issue(&quot;JENKINS-11073&quot;)
    @Test public void isUnix() {
<span class="fc" id="L417">        VirtualChannel dummy = Mockito.mock(VirtualChannel.class);</span>
<span class="fc" id="L418">        FilePath winPath = new FilePath(dummy,</span>
<span class="fc" id="L419">                &quot; c:\\app\\hudson\\workspace\\3.8-jelly-db\\jdk/jdk1.6.0_21/label/sqlserver/profile/sqlserver\\acceptance-tests\\distribution.zip&quot;);</span>
<span class="fc" id="L420">        assertFalse(winPath.isUnix());</span>

<span class="fc" id="L422">        FilePath base = new FilePath(dummy,</span>
<span class="fc" id="L423">                &quot;c:\\app\\hudson\\workspace\\3.8-jelly-db&quot;);</span>
<span class="fc" id="L424">        FilePath middle = new FilePath(base, &quot;jdk/jdk1.6.0_21/label/sqlserver/profile/sqlserver&quot;);</span>
<span class="fc" id="L425">        FilePath full = new FilePath(middle, &quot;acceptance-tests\\distribution.zip&quot;);</span>
<span class="fc" id="L426">        assertFalse(full.isUnix());</span>
        
        
<span class="fc" id="L429">        FilePath unixPath = new FilePath(dummy,</span>
<span class="fc" id="L430">                &quot;/home/test&quot;);</span>
<span class="fc" id="L431">        assertTrue(unixPath.isUnix());</span>
<span class="fc" id="L432">    }</span>
    
    /**
     * Tests that permissions are kept when using {@link FilePath#copyToWithPermission(FilePath)}.
     * Also tries to check that a problem with setting the last-modified date on Windows doesn't fail the whole copy
     * - well at least when running this test on a Windows OS. See JENKINS-11073
     */
    @Test public void copyToWithPermission() throws IOException, InterruptedException {
<span class="fc" id="L440">        File tmp = temp.getRoot();</span>
<span class="fc" id="L441">            File child = new File(tmp,&quot;child&quot;);</span>
<span class="fc" id="L442">            FilePath childP = new FilePath(child);</span>
<span class="fc" id="L443">            childP.touch(4711);</span>
            
<span class="fc" id="L445">            Chmod chmodTask = new Chmod();</span>
<span class="fc" id="L446">            chmodTask.setProject(new Project());</span>
<span class="fc" id="L447">            chmodTask.setFile(child);</span>
<span class="fc" id="L448">            chmodTask.setPerm(&quot;0400&quot;);</span>
<span class="fc" id="L449">            chmodTask.execute();</span>
            
<span class="fc" id="L451">            FilePath copy = new FilePath(channels.british, tmp.getPath()).child(&quot;copy&quot;);</span>
<span class="fc" id="L452">            childP.copyToWithPermission(copy);</span>
            
<span class="fc" id="L454">            assertEquals(childP.mode(),copy.mode());</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">            if (!Functions.isWindows()) {</span>
<span class="nc" id="L456">                assertEquals(childP.lastModified(),copy.lastModified());</span>
            }
            
            // JENKINS-11073:
            // Windows seems to have random failures when setting the timestamp on newly generated
            // files. So test that:
<span class="fc bfc" id="L462" title="All 2 branches covered.">            for (int i=0; i&lt;100; i++) {</span>
<span class="fc" id="L463">                copy = new FilePath(channels.british, tmp.getPath()).child(&quot;copy&quot;+i);</span>
<span class="fc" id="L464">                childP.copyToWithPermission(copy);</span>
            }
<span class="fc" id="L466">    }</span>

    @Test public void symlinkInTar() throws Exception {
<span class="nc" id="L469">        assumeFalse(&quot;can't test on Windows&quot;, Functions.isWindows());</span>

<span class="nc" id="L471">        FilePath tmp = new FilePath(temp.getRoot());</span>
<span class="nc" id="L472">            FilePath in = tmp.child(&quot;in&quot;);</span>
<span class="nc" id="L473">            in.mkdirs();</span>
<span class="nc" id="L474">            in.child(&quot;c&quot;).touch(0);</span>
<span class="nc" id="L475">            in.child(&quot;b&quot;).symlinkTo(&quot;c&quot;, TaskListener.NULL);</span>
                        
<span class="nc" id="L477">            FilePath tar = tmp.child(&quot;test.tar&quot;);</span>
<span class="nc" id="L478">            in.tar(tar.write(), &quot;**/*&quot;);</span>

<span class="nc" id="L480">            FilePath dst = in.child(&quot;dst&quot;);</span>
<span class="nc" id="L481">            tar.untar(dst, TarCompression.NONE);</span>

<span class="nc" id="L483">            assertEquals(&quot;c&quot;,dst.child(&quot;b&quot;).readLink());</span>
<span class="nc" id="L484">    }</span>

    @Issue(&quot;JENKINS-13649&quot;)
    @Test public void multiSegmentRelativePaths() throws Exception {
<span class="fc" id="L488">        VirtualChannel d = Mockito.mock(VirtualChannel.class);</span>
<span class="fc" id="L489">        FilePath winPath = new FilePath(d, &quot;c:\\app\\jenkins\\workspace&quot;);</span>
<span class="fc" id="L490">        FilePath nixPath = new FilePath(d, &quot;/opt/jenkins/workspace&quot;);</span>

<span class="fc" id="L492">        assertEquals(&quot;c:\\app\\jenkins\\workspace\\foo\\bar\\manchu&quot;, new FilePath(winPath, &quot;foo/bar/manchu&quot;).getRemote());</span>
<span class="fc" id="L493">        assertEquals(&quot;c:\\app\\jenkins\\workspace\\foo\\bar\\manchu&quot;, new FilePath(winPath, &quot;foo\\bar/manchu&quot;).getRemote());</span>
<span class="fc" id="L494">        assertEquals(&quot;c:\\app\\jenkins\\workspace\\foo\\bar\\manchu&quot;, new FilePath(winPath, &quot;foo\\bar\\manchu&quot;).getRemote());</span>
<span class="fc" id="L495">        assertEquals(&quot;/opt/jenkins/workspace/foo/bar/manchu&quot;, new FilePath(nixPath, &quot;foo\\bar\\manchu&quot;).getRemote());</span>
<span class="fc" id="L496">        assertEquals(&quot;/opt/jenkins/workspace/foo/bar/manchu&quot;, new FilePath(nixPath, &quot;foo/bar\\manchu&quot;).getRemote());</span>
<span class="fc" id="L497">        assertEquals(&quot;/opt/jenkins/workspace/foo/bar/manchu&quot;, new FilePath(nixPath, &quot;foo/bar/manchu&quot;).getRemote());</span>
<span class="fc" id="L498">    }</span>

    @Test public void validateAntFileMask() throws Exception {
<span class="fc" id="L501">        File tmp = temp.getRoot();</span>
<span class="fc" id="L502">            FilePath d = new FilePath(channels.french, tmp.getPath());</span>
<span class="fc" id="L503">            d.child(&quot;d1/d2/d3&quot;).mkdirs();</span>
<span class="fc" id="L504">            d.child(&quot;d1/d2/d3/f.txt&quot;).touch(0);</span>
<span class="fc" id="L505">            d.child(&quot;d1/d2/d3/f.html&quot;).touch(0);</span>
<span class="fc" id="L506">            d.child(&quot;d1/d2/f.txt&quot;).touch(0);</span>
<span class="fc" id="L507">            assertValidateAntFileMask(null, d, &quot;**/*.txt&quot;);</span>
<span class="fc" id="L508">            assertValidateAntFileMask(null, d, &quot;d1/d2/d3/f.txt&quot;);</span>
<span class="fc" id="L509">            assertValidateAntFileMask(null, d, &quot;**/*.html&quot;);</span>
<span class="fc" id="L510">            assertValidateAntFileMask(Messages.FilePath_validateAntFileMask_portionMatchButPreviousNotMatchAndSuggest(&quot;**/*.js&quot;, &quot;**&quot;, &quot;**/*.js&quot;), d, &quot;**/*.js&quot;);</span>
<span class="fc" id="L511">            assertValidateAntFileMask(Messages.FilePath_validateAntFileMask_doesntMatchAnything(&quot;index.htm&quot;), d, &quot;index.htm&quot;);</span>
<span class="fc" id="L512">            assertValidateAntFileMask(Messages.FilePath_validateAntFileMask_doesntMatchAndSuggest(&quot;f.html&quot;, &quot;d1/d2/d3/f.html&quot;), d, &quot;f.html&quot;);</span>
            // TODO lots more to test, e.g. multiple patterns separated by commas; ought to have full code coverage for this method
<span class="fc" id="L514">    }</span>

    @SuppressWarnings(&quot;deprecation&quot;)
    private static void assertValidateAntFileMask(String expected, FilePath d, String fileMasks) throws Exception {
<span class="fc" id="L518">        assertEquals(expected, d.validateAntFileMask(fileMasks));</span>
<span class="fc" id="L519">    }</span>

    @Issue(&quot;JENKINS-7214&quot;)
    @SuppressWarnings(&quot;deprecation&quot;)
    @Test public void validateAntFileMaskBounded() throws Exception {
<span class="fc" id="L524">        File tmp = temp.getRoot();</span>
<span class="fc" id="L525">            FilePath d = new FilePath(channels.french, tmp.getPath());</span>
<span class="fc" id="L526">            FilePath d2 = d.child(&quot;d1/d2&quot;);</span>
<span class="fc" id="L527">            d2.mkdirs();</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">            for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L529">                FilePath d3 = d2.child(&quot;d&quot; + i);</span>
<span class="fc" id="L530">                d3.mkdirs();</span>
<span class="fc" id="L531">                d3.child(&quot;f.txt&quot;).touch(0);</span>
            }
<span class="fc" id="L533">            assertEquals(null, d.validateAntFileMask(&quot;d1/d2/**/f.txt&quot;));</span>
<span class="fc" id="L534">            assertEquals(null, d.validateAntFileMask(&quot;d1/d2/**/f.txt&quot;, 10));</span>
<span class="fc" id="L535">            assertEquals(Messages.FilePath_validateAntFileMask_portionMatchButPreviousNotMatchAndSuggest(&quot;**/*.js&quot;, &quot;**&quot;, &quot;**/*.js&quot;), d.validateAntFileMask(&quot;**/*.js&quot;, 1000));</span>
            try {
<span class="nc" id="L537">                d.validateAntFileMask(&quot;**/*.js&quot;, 10);</span>
<span class="nc" id="L538">                fail();</span>
<span class="pc" id="L539">            } catch (InterruptedException x) {</span>
                // good
            }
<span class="fc" id="L542">    }</span>
    
    @Issue(&quot;JENKINS-5253&quot;)
    public void testValidateCaseSensitivity() throws Exception {
<span class="nc" id="L546">        File tmp = Util.createTempDir();</span>
        try {
<span class="nc" id="L548">            FilePath d = new FilePath(channels.french, tmp.getPath());</span>
<span class="nc" id="L549">            d.child(&quot;d1/d2/d3&quot;).mkdirs();</span>
<span class="nc" id="L550">            d.child(&quot;d1/d2/d3/f.txt&quot;).touch(0);</span>
<span class="nc" id="L551">            d.child(&quot;d1/d2/d3/f.html&quot;).touch(0);</span>
<span class="nc" id="L552">            d.child(&quot;d1/d2/f.txt&quot;).touch(0);</span>
            
<span class="nc" id="L554">            assertEquals(null, d.validateAntFileMask(&quot;**/d1/**/f.*&quot;, FilePath.VALIDATE_ANT_FILE_MASK_BOUND, true));</span>
<span class="nc" id="L555">            assertEquals(null, d.validateAntFileMask(&quot;**/d1/**/f.*&quot;, FilePath.VALIDATE_ANT_FILE_MASK_BOUND, false));</span>
<span class="nc" id="L556">            assertEquals(Messages.FilePath_validateAntFileMask_matchWithCaseInsensitive(&quot;**/D1/**/F.*&quot;), d.validateAntFileMask(&quot;**/D1/**/F.*&quot;, FilePath.VALIDATE_ANT_FILE_MASK_BOUND, true));</span>
<span class="nc" id="L557">            assertEquals(null, d.validateAntFileMask(&quot;**/D1/**/F.*&quot;, FilePath.VALIDATE_ANT_FILE_MASK_BOUND, false));</span>
<span class="nc" id="L558">        } finally {</span>
<span class="nc" id="L559">            Util.deleteRecursive(tmp);</span>
<span class="nc" id="L560">        }</span>
<span class="nc" id="L561">    }</span>
   
    @Issue(&quot;JENKINS-15418&quot;)
    @Test public void deleteLongPathOnWindows() throws Exception {
<span class="fc" id="L565">        File tmp = temp.getRoot();</span>
<span class="fc" id="L566">            FilePath d = new FilePath(channels.french, tmp.getPath());</span>
            
            // construct a very long path
<span class="fc" id="L569">            StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">            while(sb.length() + tmp.getPath().length() &lt; 260 - &quot;very/&quot;.length()) {</span>
<span class="fc" id="L571">                sb.append(&quot;very/&quot;);</span>
            }
<span class="fc" id="L573">            sb.append(&quot;pivot/very/very/long/path&quot;);</span>
            
<span class="fc" id="L575">            FilePath longPath = d.child(sb.toString()); </span>
<span class="fc" id="L576">            longPath.mkdirs();</span>
<span class="fc" id="L577">            FilePath childInLongPath = longPath.child(&quot;file.txt&quot;);</span>
<span class="fc" id="L578">            childInLongPath.touch(0);</span>
            
<span class="fc" id="L580">            File firstDirectory = new File(tmp.getAbsolutePath() + &quot;/very&quot;);</span>
<span class="fc" id="L581">            Util.deleteRecursive(firstDirectory);</span>
            
<span class="fc" id="L583">            assertFalse(&quot;Could not delete directory!&quot;, firstDirectory.exists());</span>
<span class="fc" id="L584">    }</span>

    @Issue(&quot;JENKINS-16215&quot;)
    @Test public void installIfNecessaryAvoidsExcessiveDownloadsByUsingIfModifiedSince() throws Exception {
<span class="fc" id="L588">        File tmp = temp.getRoot();</span>
<span class="fc" id="L589">            final FilePath d = new FilePath(tmp);</span>

<span class="fc" id="L591">            d.child(&quot;.timestamp&quot;).touch(123000);</span>

<span class="fc" id="L593">            final HttpURLConnection con = mock(HttpURLConnection.class);</span>
<span class="fc" id="L594">            final URL url = someUrlToZipFile(con);</span>

<span class="fc" id="L596">            when(con.getResponseCode())</span>
<span class="fc" id="L597">                .thenReturn(HttpURLConnection.HTTP_NOT_MODIFIED);</span>

<span class="fc" id="L599">            assertFalse(d.installIfNecessaryFrom(url, null, null));</span>

<span class="fc" id="L601">            verify(con).setIfModifiedSince(123000);</span>
<span class="fc" id="L602">    }</span>

    @Issue(&quot;JENKINS-16215&quot;)
    @Test public void installIfNecessaryPerformsInstallation() throws Exception {
<span class="fc" id="L606">        File tmp = temp.getRoot();</span>
<span class="fc" id="L607">            final FilePath d = new FilePath(tmp);</span>

<span class="fc" id="L609">            final HttpURLConnection con = mock(HttpURLConnection.class);</span>
<span class="fc" id="L610">            final URL url = someUrlToZipFile(con);</span>

<span class="fc" id="L612">            when(con.getResponseCode())</span>
<span class="fc" id="L613">              .thenReturn(HttpURLConnection.HTTP_OK);</span>

<span class="fc" id="L615">            when(con.getInputStream())</span>
<span class="fc" id="L616">              .thenReturn(someZippedContent());</span>

<span class="fc" id="L618">            assertTrue(d.installIfNecessaryFrom(url, null, null));</span>
<span class="fc" id="L619">    }</span>

    @Issue(&quot;JENKINS-26196&quot;)
    @Test public void installIfNecessarySkipsDownloadWhenErroneous() throws Exception {
<span class="fc" id="L623">        File tmp = temp.getRoot();</span>
<span class="fc" id="L624">        final FilePath d = new FilePath(tmp);</span>
<span class="fc" id="L625">        d.child(&quot;.timestamp&quot;).touch(123000);</span>
<span class="fc" id="L626">        final HttpURLConnection con = mock(HttpURLConnection.class);</span>
<span class="fc" id="L627">        final URL url = someUrlToZipFile(con);</span>
<span class="fc" id="L628">        when(con.getResponseCode()).thenReturn(HttpURLConnection.HTTP_GATEWAY_TIMEOUT);</span>
<span class="fc" id="L629">        when(con.getResponseMessage()).thenReturn(&quot;Gateway Timeout&quot;);</span>
<span class="fc" id="L630">        when(con.getInputStream()).thenThrow(new ConnectException());</span>
<span class="fc" id="L631">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L632">        String message = &quot;going ahead&quot;;</span>
<span class="fc" id="L633">        assertFalse(d.installIfNecessaryFrom(url, new StreamTaskListener(baos), message));</span>
<span class="fc" id="L634">        verify(con).setIfModifiedSince(123000);</span>
<span class="fc" id="L635">        String log = baos.toString();</span>
<span class="fc" id="L636">        assertFalse(log, log.contains(message));</span>
<span class="fc" id="L637">        assertTrue(log, log.contains(&quot;504 Gateway Timeout&quot;));</span>
<span class="fc" id="L638">    }</span>

    private URL someUrlToZipFile(final URLConnection con) throws IOException {

<span class="fc" id="L642">        final URLStreamHandler urlHandler = new URLStreamHandler() {</span>
            @Override protected URLConnection openConnection(URL u) throws IOException {
<span class="fc" id="L644">                return con;</span>
            }
        };

<span class="fc" id="L648">        return new URL(&quot;http&quot;, &quot;some-host&quot;, 0, &quot;/some-path.zip&quot;, urlHandler);</span>
    }

    private InputStream someZippedContent() throws IOException {
<span class="fc" id="L652">        final ByteArrayOutputStream buf = new ByteArrayOutputStream();</span>
<span class="fc" id="L653">        final ZipOutputStream zip = new ZipOutputStream(buf);</span>

<span class="fc" id="L655">        zip.putNextEntry(new ZipEntry(&quot;abc&quot;));</span>
<span class="fc" id="L656">        zip.write(&quot;abc&quot;.getBytes());</span>
<span class="fc" id="L657">        zip.close();</span>

<span class="fc" id="L659">        return new ByteArrayInputStream(buf.toByteArray());</span>
    }

    @Issue(&quot;JENKINS-16846&quot;)
    @Test public void moveAllChildrenTo() throws IOException, InterruptedException {
<span class="fc" id="L664">        File tmp = temp.getRoot();</span>
<span class="fc" id="L665">            final String dirname = &quot;sub&quot;;</span>
<span class="fc" id="L666">            final File top = new File(tmp, &quot;test&quot;);</span>
<span class="fc" id="L667">            final File sub = new File(top, dirname);</span>
<span class="fc" id="L668">            final File subsub = new File(sub, dirname);</span>

<span class="fc" id="L670">            subsub.mkdirs();</span>

<span class="fc" id="L672">            final File subFile1 = new File( sub.getAbsolutePath() + &quot;/file1.txt&quot; );</span>
<span class="fc" id="L673">            subFile1.createNewFile();</span>
<span class="fc" id="L674">            final File subFile2 = new File( subsub.getAbsolutePath() + &quot;/file2.txt&quot; );</span>
<span class="fc" id="L675">            subFile2.createNewFile();</span>

<span class="fc" id="L677">            final FilePath src = new FilePath(sub);</span>
<span class="fc" id="L678">            final FilePath dst = new FilePath(top);</span>
            
            // test conflict subdir
<span class="fc" id="L681">            src.moveAllChildrenTo(dst);</span>
<span class="fc" id="L682">    }</span>

    @Issue(&quot;JENKINS-10629&quot;)
    @Test
    public void testEOFbrokenFlush() throws IOException, InterruptedException {
<span class="fc" id="L687">        final File srcFolder = temp.newFolder(&quot;src&quot;);</span>
        // simulate magic structure with magic sizes:
        // |- dir/pom.xml   (2049)
        // |- pom.xml       (2049)
        // \- small.tar     (1537)
<span class="fc" id="L692">        final File smallTar = new File(srcFolder, &quot;small.tar&quot;);</span>
<span class="fc" id="L693">        givenSomeContentInFile(smallTar, 1537);</span>
<span class="fc" id="L694">        final File dir = new File(srcFolder, &quot;dir&quot;);</span>
<span class="fc" id="L695">        dir.mkdirs();</span>
<span class="fc" id="L696">        final File pomFile = new File(dir, &quot;pom.xml&quot;);</span>
<span class="fc" id="L697">        givenSomeContentInFile(pomFile, 2049);</span>
<span class="fc" id="L698">        FileUtils.copyFileToDirectory(pomFile, srcFolder);</span>

<span class="fc" id="L700">        final File archive = temp.newFile(&quot;archive.tar&quot;);</span>

        // Compress archive
<span class="fc" id="L703">        final FilePath tmpDirPath = new FilePath(srcFolder);</span>
<span class="fc" id="L704">        int tarred = tmpDirPath.tar(new FileOutputStream(archive), &quot;**&quot;);</span>
<span class="fc" id="L705">        assertEquals(&quot;One file should have been compressed&quot;, 3, tarred);</span>

        // Decompress
<span class="fc" id="L708">        final File dstFolder = temp.newFolder(&quot;dst&quot;);</span>
<span class="fc" id="L709">        dstFolder.mkdirs();</span>
<span class="fc" id="L710">        FilePath outDir = new FilePath(dstFolder);</span>
        // and now fail when flush is bad!
<span class="fc" id="L712">        tmpDirPath.child(&quot;../&quot; + archive.getName()).untar(outDir, TarCompression.NONE);</span>
<span class="fc" id="L713">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>jenkins-core (22-mrt-2016 21:51:03)</div></body></html>