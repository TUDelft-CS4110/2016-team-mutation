<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Actor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.scenes.scene2d</a> &gt; <span class="el_source">Actor.java</span></div><h1>Actor.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.scenes.scene2d;

import static com.badlogic.gdx.utils.Align.*;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.InputEvent.Type;
import com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.ScissorStack;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.DelayedRemovalArray;
import com.badlogic.gdx.utils.Pools;

/** 2D scene graph node. An actor has a position, rectangular size, origin, scale, rotation, Z index, and color. The position
 * corresponds to the unrotated, unscaled bottom left corner of the actor. The position is relative to the actor's parent. The
 * origin is relative to the position and is used for scale and rotation.
 * &lt;p&gt;
 * An actor has a list of in progress {@link Action actions} that are applied to the actor (often over time). These are generally
 * used to change the presentation of the actor (moving it, resizing it, etc). See {@link #act(float)}, {@link Action} and its
 * many subclasses.
 * &lt;p&gt;
 * An actor has two kinds of listeners associated with it: &quot;capture&quot; and regular. The listeners are notified of events the actor
 * or its children receive. The regular listeners are designed to allow an actor to respond to events that have been delivered.
 * The capture listeners are designed to allow a parent or container actor to handle events before child actors. See {@link #fire}
 * for more details.
 * &lt;p&gt;
 * An {@link InputListener} can receive all the basic input events. More complex listeners (like {@link ClickListener} and
 * {@link ActorGestureListener}) can listen for and combine primitive events and recognize complex interactions like multi-touch
 * or pinch.
 * @author mzechner
 * @author Nathan Sweet */
<span class="nc" id="L56">public class Actor {</span>
	private Stage stage;
	Group parent;
<span class="nc" id="L59">	private final DelayedRemovalArray&lt;EventListener&gt; listeners = new DelayedRemovalArray(0);</span>
<span class="nc" id="L60">	private final DelayedRemovalArray&lt;EventListener&gt; captureListeners = new DelayedRemovalArray(0);</span>
<span class="nc" id="L61">	private final Array&lt;Action&gt; actions = new Array(0);</span>

	private String name;
<span class="nc" id="L64">	private Touchable touchable = Touchable.enabled;</span>
<span class="nc" id="L65">	private boolean visible = true, debug;</span>
	float x, y;
	float width, height;
	float originX, originY;
<span class="nc" id="L69">	float scaleX = 1, scaleY = 1;</span>
	float rotation;
<span class="nc" id="L71">	final Color color = new Color(1, 1, 1, 1);</span>
	private Object userObject;

	/** Draws the actor. The batch is configured to draw in the parent's coordinate system.
	 * {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)
	 * This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on
	 * the batch. If {@link Batch#end()} is called to draw without the batch then {@link Batch#begin()} must be called before the
	 * method returns.
	 * &lt;p&gt;
	 * The default implementation does nothing.
	 * @param parentAlpha Should be multiplied with the actor's alpha, allowing a parent's alpha to affect all children. */
	public void draw (Batch batch, float parentAlpha) {
<span class="nc" id="L83">	}</span>

	/** Updates the actor based on time. Typically this is called each frame by {@link Stage#act(float)}.
	 * &lt;p&gt;
	 * The default implementation calls {@link Action#act(float)} on each action and removes actions that are complete.
	 * @param delta Time in seconds since the last frame. */
	public void act (float delta) {
<span class="nc" id="L90">		Array&lt;Action&gt; actions = this.actions;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">		if (actions.size &gt; 0) {</span>
<span class="nc bnc" id="L92" title="All 4 branches missed.">			if (stage != null &amp;&amp; stage.getActionsRequestRendering()) Gdx.graphics.requestRendering();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">			for (int i = 0; i &lt; actions.size; i++) {</span>
<span class="nc" id="L94">				Action action = actions.get(i);</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">				if (action.act(delta) &amp;&amp; i &lt; actions.size) {</span>
<span class="nc" id="L96">					Action current = actions.get(i);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">					int actionIndex = current == action ? i : actions.indexOf(action, true);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">					if (actionIndex != -1) {</span>
<span class="nc" id="L99">						actions.removeIndex(actionIndex);</span>
<span class="nc" id="L100">						action.setActor(null);</span>
<span class="nc" id="L101">						i--;</span>
					}
				}
			}
		}
<span class="nc" id="L106">	}</span>

	/** Sets this actor as the event {@link Event#setTarget(Actor) target} and propagates the event to this actor and ancestor
	 * actors as necessary. If this actor is not in the stage, the stage must be set before calling this method.
	 * &lt;p&gt;
	 * Events are fired in 2 phases:
	 * &lt;ol&gt;
	 * &lt;li&gt;The first phase (the &quot;capture&quot; phase) notifies listeners on each actor starting at the root and propagating downward to
	 * (and including) this actor.&lt;/li&gt;
	 * &lt;li&gt;The second phase notifies listeners on each actor starting at this actor and, if {@link Event#getBubbles()} is true,
	 * propagating upward to the root.&lt;/li&gt;
	 * &lt;/ol&gt;
	 * If the event is {@link Event#stop() stopped} at any time, it will not propagate to the next actor.
	 * @return true if the event was {@link Event#cancel() cancelled}. */
	public boolean fire (Event event) {
<span class="nc bnc" id="L121" title="All 2 branches missed.">		if (event.getStage() == null) event.setStage(getStage());</span>
<span class="nc" id="L122">		event.setTarget(this);</span>

		// Collect ancestors so event propagation is unaffected by hierarchy changes.
<span class="nc" id="L125">		Array&lt;Group&gt; ancestors = Pools.obtain(Array.class);</span>
<span class="nc" id="L126">		Group parent = this.parent;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">		while (parent != null) {</span>
<span class="nc" id="L128">			ancestors.add(parent);</span>
<span class="nc" id="L129">			parent = parent.parent;</span>
		}

		try {
			// Notify all parent capture listeners, starting at the root. Ancestors may stop an event before children receive it.
<span class="nc" id="L134">			Object[] ancestorsArray = ancestors.items;</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">			for (int i = ancestors.size - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L136">				Group currentTarget = (Group)ancestorsArray[i];</span>
<span class="nc" id="L137">				currentTarget.notify(event, true);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">				if (event.isStopped()) return event.isCancelled();</span>
			}

			// Notify the target capture listeners.
<span class="nc" id="L142">			notify(event, true);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">			if (event.isStopped()) return event.isCancelled();</span>

			// Notify the target listeners.
<span class="nc" id="L146">			notify(event, false);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">			if (!event.getBubbles()) return event.isCancelled();</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">			if (event.isStopped()) return event.isCancelled();</span>

			// Notify all parent listeners, starting at the target. Children may stop an event before ancestors receive it.
<span class="nc bnc" id="L151" title="All 2 branches missed.">			for (int i = 0, n = ancestors.size; i &lt; n; i++) {</span>
<span class="nc" id="L152">				((Group)ancestorsArray[i]).notify(event, false);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">				if (event.isStopped()) return event.isCancelled();</span>
			}

<span class="nc" id="L156">			return event.isCancelled();</span>
		} finally {
<span class="nc" id="L158">			ancestors.clear();</span>
<span class="nc" id="L159">			Pools.free(ancestors);</span>
		}
	}

	/** Notifies this actor's listeners of the event. The event is not propagated to any parents. Before notifying the listeners,
	 * this actor is set as the {@link Event#getListenerActor() listener actor}. The event {@link Event#setTarget(Actor) target}
	 * must be set before calling this method. If this actor is not in the stage, the stage must be set before calling this method.
	 * @param capture If true, the capture listeners will be notified instead of the regular listeners.
	 * @return true of the event was {@link Event#cancel() cancelled}. */
	public boolean notify (Event event, boolean capture) {
<span class="nc bnc" id="L169" title="All 2 branches missed.">		if (event.getTarget() == null) throw new IllegalArgumentException(&quot;The event target cannot be null.&quot;);</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">		DelayedRemovalArray&lt;EventListener&gt; listeners = capture ? captureListeners : this.listeners;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">		if (listeners.size == 0) return event.isCancelled();</span>

<span class="nc" id="L174">		event.setListenerActor(this);</span>
<span class="nc" id="L175">		event.setCapture(capture);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">		if (event.getStage() == null) event.setStage(stage);</span>

<span class="nc" id="L178">		listeners.begin();</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">		for (int i = 0, n = listeners.size; i &lt; n; i++) {</span>
<span class="nc" id="L180">			EventListener listener = listeners.get(i);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">			if (listener.handle(event)) {</span>
<span class="nc" id="L182">				event.handle();</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">				if (event instanceof InputEvent) {</span>
<span class="nc" id="L184">					InputEvent inputEvent = (InputEvent)event;</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">					if (inputEvent.getType() == Type.touchDown) {</span>
<span class="nc" id="L186">						event.getStage().addTouchFocus(listener, this, inputEvent.getTarget(), inputEvent.getPointer(),</span>
							inputEvent.getButton());
					}
				}
			}
		}
<span class="nc" id="L192">		listeners.end();</span>

<span class="nc" id="L194">		return event.isCancelled();</span>
	}

	/** Returns the deepest actor that contains the specified point and is {@link #getTouchable() touchable} and
	 * {@link #isVisible() visible}, or null if no actor was hit. The point is specified in the actor's local coordinate system
	 * (0,0 is the bottom left of the actor and width,height is the upper right).
	 * &lt;p&gt;
	 * This method is used to delegate touchDown, mouse, and enter/exit events. If this method returns null, those events will not
	 * occur on this Actor.
	 * &lt;p&gt;
	 * The default implementation returns this actor if the point is within this actor's bounds.
	 * @param touchable If true, the hit detection will respect the {@link #setTouchable(Touchable) touchability}.
	 * @see Touchable */
	public Actor hit (float x, float y, boolean touchable) {
<span class="nc bnc" id="L208" title="All 4 branches missed.">		if (touchable &amp;&amp; this.touchable != Touchable.enabled) return null;</span>
<span class="nc bnc" id="L209" title="All 8 branches missed.">		return x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height ? this : null;</span>
	}

	/** Removes this actor from its parent, if it has a parent.
	 * @see Group#removeActor(Actor) */
	public boolean remove () {
<span class="nc bnc" id="L215" title="All 2 branches missed.">		if (parent != null) return parent.removeActor(this, true);</span>
<span class="nc" id="L216">		return false;</span>
	}

	/** Add a listener to receive events that {@link #hit(float, float, boolean) hit} this actor. See {@link #fire(Event)}.
	 * @see InputListener
	 * @see ClickListener */
	public boolean addListener (EventListener listener) {
<span class="nc bnc" id="L223" title="All 2 branches missed.">		if (!listeners.contains(listener, true)) {</span>
<span class="nc" id="L224">			listeners.add(listener);</span>
<span class="nc" id="L225">			return true;</span>
		}
<span class="nc" id="L227">		return false;</span>
	}

	public boolean removeListener (EventListener listener) {
<span class="nc" id="L231">		return listeners.removeValue(listener, true);</span>
	}

	public Array&lt;EventListener&gt; getListeners () {
<span class="nc" id="L235">		return listeners;</span>
	}

	/** Adds a listener that is only notified during the capture phase.
	 * @see #fire(Event) */
	public boolean addCaptureListener (EventListener listener) {
<span class="nc bnc" id="L241" title="All 2 branches missed.">		if (!captureListeners.contains(listener, true)) captureListeners.add(listener);</span>
<span class="nc" id="L242">		return true;</span>
	}

	public boolean removeCaptureListener (EventListener listener) {
<span class="nc" id="L246">		return captureListeners.removeValue(listener, true);</span>
	}

	public Array&lt;EventListener&gt; getCaptureListeners () {
<span class="nc" id="L250">		return captureListeners;</span>
	}

	public void addAction (Action action) {
<span class="nc" id="L254">		action.setActor(this);</span>
<span class="nc" id="L255">		actions.add(action);</span>

<span class="nc bnc" id="L257" title="All 4 branches missed.">		if (stage != null &amp;&amp; stage.getActionsRequestRendering()) Gdx.graphics.requestRendering();</span>
<span class="nc" id="L258">	}</span>

	public void removeAction (Action action) {
<span class="nc bnc" id="L261" title="All 2 branches missed.">		if (actions.removeValue(action, true)) action.setActor(null);</span>
<span class="nc" id="L262">	}</span>

	public Array&lt;Action&gt; getActions () {
<span class="nc" id="L265">		return actions;</span>
	}

	/** Returns true if the actor has one or more actions. */
	public boolean hasActions () {
<span class="nc bnc" id="L270" title="All 2 branches missed.">		return actions.size &gt; 0;</span>
	}

	/** Removes all actions on this actor. */
	public void clearActions () {
<span class="nc bnc" id="L275" title="All 2 branches missed.">		for (int i = actions.size - 1; i &gt;= 0; i--)</span>
<span class="nc" id="L276">			actions.get(i).setActor(null);</span>
<span class="nc" id="L277">		actions.clear();</span>
<span class="nc" id="L278">	}</span>

	/** Removes all listeners on this actor. */
	public void clearListeners () {
<span class="nc" id="L282">		listeners.clear();</span>
<span class="nc" id="L283">		captureListeners.clear();</span>
<span class="nc" id="L284">	}</span>

	/** Removes all actions and listeners on this actor. */
	public void clear () {
<span class="nc" id="L288">		clearActions();</span>
<span class="nc" id="L289">		clearListeners();</span>
<span class="nc" id="L290">	}</span>

	/** Returns the stage that this actor is currently in, or null if not in a stage. */
	public Stage getStage () {
<span class="nc" id="L294">		return stage;</span>
	}

	/** Called by the framework when this actor or any parent is added to a group that is in the stage.
	 * @param stage May be null if the actor or any parent is no longer in a stage. */
	protected void setStage (Stage stage) {
<span class="nc" id="L300">		this.stage = stage;</span>
<span class="nc" id="L301">	}</span>

	/** Returns true if this actor is the same as or is the descendant of the specified actor. */
	public boolean isDescendantOf (Actor actor) {
<span class="nc bnc" id="L305" title="All 2 branches missed.">		if (actor == null) throw new IllegalArgumentException(&quot;actor cannot be null.&quot;);</span>
<span class="nc" id="L306">		Actor parent = this;</span>
		while (true) {
<span class="nc bnc" id="L308" title="All 2 branches missed.">			if (parent == null) return false;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">			if (parent == actor) return true;</span>
<span class="nc" id="L310">			parent = parent.parent;</span>
		}
	}

	/** Returns true if this actor is the same as or is the ascendant of the specified actor. */
	public boolean isAscendantOf (Actor actor) {
<span class="nc bnc" id="L316" title="All 2 branches missed.">		if (actor == null) throw new IllegalArgumentException(&quot;actor cannot be null.&quot;);</span>
		while (true) {
<span class="nc bnc" id="L318" title="All 2 branches missed.">			if (actor == null) return false;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">			if (actor == this) return true;</span>
<span class="nc" id="L320">			actor = actor.parent;</span>
		}
	}

	/** Returns true if the actor's parent is not null. */
	public boolean hasParent () {
<span class="nc bnc" id="L326" title="All 2 branches missed.">		return parent != null;</span>
	}

	/** Returns the parent actor, or null if not in a group. */
	public Group getParent () {
<span class="nc" id="L331">		return parent;</span>
	}

	/** Called by the framework when an actor is added to or removed from a group.
	 * @param parent May be null if the actor has been removed from the parent. */
	protected void setParent (Group parent) {
<span class="nc" id="L337">		this.parent = parent;</span>
<span class="nc" id="L338">	}</span>

	/** Returns true if input events are processed by this actor. */
	public boolean isTouchable () {
<span class="nc bnc" id="L342" title="All 2 branches missed.">		return touchable == Touchable.enabled;</span>
	}

	public Touchable getTouchable () {
<span class="nc" id="L346">		return touchable;</span>
	}

	/** Determines how touch events are distributed to this actor. Default is {@link Touchable#enabled}. */
	public void setTouchable (Touchable touchable) {
<span class="nc" id="L351">		this.touchable = touchable;</span>
<span class="nc" id="L352">	}</span>

	public boolean isVisible () {
<span class="nc" id="L355">		return visible;</span>
	}

	/** If false, the actor will not be drawn and will not receive touch events. Default is true. */
	public void setVisible (boolean visible) {
<span class="nc" id="L360">		this.visible = visible;</span>
<span class="nc" id="L361">	}</span>

	/** Returns an application specific object for convenience, or null. */
	public Object getUserObject () {
<span class="nc" id="L365">		return userObject;</span>
	}

	/** Sets an application specific object for convenience. */
	public void setUserObject (Object userObject) {
<span class="nc" id="L370">		this.userObject = userObject;</span>
<span class="nc" id="L371">	}</span>

	/** Returns the X position of the actor's left edge. */
	public float getX () {
<span class="nc" id="L375">		return x;</span>
	}

	/** Returns the X position of the specified {@link Align alignment}. */
	public float getX (int alignment) {
<span class="nc" id="L380">		float x = this.x;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">		if ((alignment &amp; right) != 0)</span>
<span class="nc" id="L382">			x += width;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">		else if ((alignment &amp; left) == 0) //</span>
<span class="nc" id="L384">			x += width / 2;</span>
<span class="nc" id="L385">		return x;</span>
	}

	public void setX (float x) {
<span class="nc bnc" id="L389" title="All 2 branches missed.">		if (this.x != x) {</span>
<span class="nc" id="L390">			this.x = x;</span>
<span class="nc" id="L391">			positionChanged();</span>
		}
<span class="nc" id="L393">	}</span>

	/** Returns the Y position of the actor's bottom edge. */
	public float getY () {
<span class="nc" id="L397">		return y;</span>
	}

	public void setY (float y) {
<span class="nc bnc" id="L401" title="All 2 branches missed.">		if (this.y != y) {</span>
<span class="nc" id="L402">			this.y = y;</span>
<span class="nc" id="L403">			positionChanged();</span>
		}
<span class="nc" id="L405">	}</span>

	/** Returns the Y position of the specified {@link Align alignment}. */
	public float getY (int alignment) {
<span class="nc" id="L409">		float y = this.y;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">		if ((alignment &amp; top) != 0)</span>
<span class="nc" id="L411">			y += height;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">		else if ((alignment &amp; bottom) == 0) //</span>
<span class="nc" id="L413">			y += height / 2;</span>
<span class="nc" id="L414">		return y;</span>
	}

	/** Sets the position of the actor's bottom left corner. */
	public void setPosition (float x, float y) {
<span class="nc bnc" id="L419" title="All 4 branches missed.">		if (this.x != x || this.y != y) {</span>
<span class="nc" id="L420">			this.x = x;</span>
<span class="nc" id="L421">			this.y = y;</span>
<span class="nc" id="L422">			positionChanged();</span>
		}
<span class="nc" id="L424">	}</span>

	/** Sets the position using the specified {@link Align alignment}. Note this may set the position to non-integer
	 * coordinates. */
	public void setPosition (float x, float y, int alignment) {
<span class="nc bnc" id="L429" title="All 2 branches missed.">		if ((alignment &amp; right) != 0)</span>
<span class="nc" id="L430">			x -= width;</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">		else if ((alignment &amp; left) == 0) //</span>
<span class="nc" id="L432">			x -= width / 2;</span>

<span class="nc bnc" id="L434" title="All 2 branches missed.">		if ((alignment &amp; top) != 0)</span>
<span class="nc" id="L435">			y -= height;</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">		else if ((alignment &amp; bottom) == 0) //</span>
<span class="nc" id="L437">			y -= height / 2;</span>

<span class="nc bnc" id="L439" title="All 4 branches missed.">		if (this.x != x || this.y != y) {</span>
<span class="nc" id="L440">			this.x = x;</span>
<span class="nc" id="L441">			this.y = y;</span>
<span class="nc" id="L442">			positionChanged();</span>
		}
<span class="nc" id="L444">	}</span>

	/** Add x and y to current position */
	public void moveBy (float x, float y) {
<span class="nc bnc" id="L448" title="All 4 branches missed.">		if (x != 0 || y != 0) {</span>
<span class="nc" id="L449">			this.x += x;</span>
<span class="nc" id="L450">			this.y += y;</span>
<span class="nc" id="L451">			positionChanged();</span>
		}
<span class="nc" id="L453">	}</span>

	public float getWidth () {
<span class="nc" id="L456">		return width;</span>
	}

	public void setWidth (float width) {
<span class="nc bnc" id="L460" title="All 2 branches missed.">		if (this.width != width) {</span>
<span class="nc" id="L461">			this.width = width;</span>
<span class="nc" id="L462">			sizeChanged();</span>
		}
<span class="nc" id="L464">	}</span>

	public float getHeight () {
<span class="nc" id="L467">		return height;</span>
	}

	public void setHeight (float height) {
<span class="nc bnc" id="L471" title="All 2 branches missed.">		if (this.height != height) {</span>
<span class="nc" id="L472">			this.height = height;</span>
<span class="nc" id="L473">			sizeChanged();</span>
		}
<span class="nc" id="L475">	}</span>

	/** Returns y plus height. */
	public float getTop () {
<span class="nc" id="L479">		return y + height;</span>
	}

	/** Returns x plus width. */
	public float getRight () {
<span class="nc" id="L484">		return x + width;</span>
	}

	/** Called when the actor's position has been changed. */
	protected void positionChanged () {
<span class="nc" id="L489">	}</span>

	/** Called when the actor's size has been changed. */
	protected void sizeChanged () {
<span class="nc" id="L493">	}</span>

	/** Called when the actor's rotation has been changed. */
	protected void rotationChanged () {
<span class="nc" id="L497">	}</span>

	/** Sets the width and height. */
	public void setSize (float width, float height) {
<span class="nc bnc" id="L501" title="All 4 branches missed.">		if (this.width != width || this.height != height) {</span>
<span class="nc" id="L502">			this.width = width;</span>
<span class="nc" id="L503">			this.height = height;</span>
<span class="nc" id="L504">			sizeChanged();</span>
		}
<span class="nc" id="L506">	}</span>

	/** Adds the specified size to the current size. */
	public void sizeBy (float size) {
<span class="nc bnc" id="L510" title="All 2 branches missed.">		if (size != 0) {</span>
<span class="nc" id="L511">			width += size;</span>
<span class="nc" id="L512">			height += size;</span>
<span class="nc" id="L513">			sizeChanged();</span>
		}
<span class="nc" id="L515">	}</span>

	/** Adds the specified size to the current size. */
	public void sizeBy (float width, float height) {
<span class="nc bnc" id="L519" title="All 4 branches missed.">		if (width != 0 || height != 0) {</span>
<span class="nc" id="L520">			this.width += width;</span>
<span class="nc" id="L521">			this.height += height;</span>
<span class="nc" id="L522">			sizeChanged();</span>
		}
<span class="nc" id="L524">	}</span>

	/** Set bounds the x, y, width, and height. */
	public void setBounds (float x, float y, float width, float height) {
<span class="nc bnc" id="L528" title="All 4 branches missed.">		if (this.x != x || this.y != y) {</span>
<span class="nc" id="L529">			this.x = x;</span>
<span class="nc" id="L530">			this.y = y;</span>
<span class="nc" id="L531">			positionChanged();</span>
		}
<span class="nc bnc" id="L533" title="All 4 branches missed.">		if (this.width != width || this.height != height) {</span>
<span class="nc" id="L534">			this.width = width;</span>
<span class="nc" id="L535">			this.height = height;</span>
<span class="nc" id="L536">			sizeChanged();</span>
		}
<span class="nc" id="L538">	}</span>

	public float getOriginX () {
<span class="nc" id="L541">		return originX;</span>
	}

	public void setOriginX (float originX) {
<span class="nc" id="L545">		this.originX = originX;</span>
<span class="nc" id="L546">	}</span>

	public float getOriginY () {
<span class="nc" id="L549">		return originY;</span>
	}

	public void setOriginY (float originY) {
<span class="nc" id="L553">		this.originY = originY;</span>
<span class="nc" id="L554">	}</span>

	/** Sets the origin position which is relative to the actor's bottom left corner. */
	public void setOrigin (float originX, float originY) {
<span class="nc" id="L558">		this.originX = originX;</span>
<span class="nc" id="L559">		this.originY = originY;</span>
<span class="nc" id="L560">	}</span>

	/** Sets the origin position to the specified {@link Align alignment}. */
	public void setOrigin (int alignment) {
<span class="nc bnc" id="L564" title="All 2 branches missed.">		if ((alignment &amp; left) != 0)</span>
<span class="nc" id="L565">			originX = 0;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">		else if ((alignment &amp; right) != 0)</span>
<span class="nc" id="L567">			originX = width;</span>
		else
<span class="nc" id="L569">			originX = width / 2;</span>

<span class="nc bnc" id="L571" title="All 2 branches missed.">		if ((alignment &amp; bottom) != 0)</span>
<span class="nc" id="L572">			originY = 0;</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">		else if ((alignment &amp; top) != 0)</span>
<span class="nc" id="L574">			originY = height;</span>
		else
<span class="nc" id="L576">			originY = height / 2;</span>
<span class="nc" id="L577">	}</span>

	public float getScaleX () {
<span class="nc" id="L580">		return scaleX;</span>
	}

	public void setScaleX (float scaleX) {
<span class="nc" id="L584">		this.scaleX = scaleX;</span>
<span class="nc" id="L585">	}</span>

	public float getScaleY () {
<span class="nc" id="L588">		return scaleY;</span>
	}

	public void setScaleY (float scaleY) {
<span class="nc" id="L592">		this.scaleY = scaleY;</span>
<span class="nc" id="L593">	}</span>

	/** Sets the scale for both X and Y */
	public void setScale (float scaleXY) {
<span class="nc" id="L597">		this.scaleX = scaleXY;</span>
<span class="nc" id="L598">		this.scaleY = scaleXY;</span>
<span class="nc" id="L599">	}</span>

	/** Sets the scale X and scale Y. */
	public void setScale (float scaleX, float scaleY) {
<span class="nc" id="L603">		this.scaleX = scaleX;</span>
<span class="nc" id="L604">		this.scaleY = scaleY;</span>
<span class="nc" id="L605">	}</span>

	/** Adds the specified scale to the current scale. */
	public void scaleBy (float scale) {
<span class="nc" id="L609">		scaleX += scale;</span>
<span class="nc" id="L610">		scaleY += scale;</span>
<span class="nc" id="L611">	}</span>

	/** Adds the specified scale to the current scale. */
	public void scaleBy (float scaleX, float scaleY) {
<span class="nc" id="L615">		this.scaleX += scaleX;</span>
<span class="nc" id="L616">		this.scaleY += scaleY;</span>
<span class="nc" id="L617">	}</span>

	public float getRotation () {
<span class="nc" id="L620">		return rotation;</span>
	}

	public void setRotation (float degrees) {
<span class="nc bnc" id="L624" title="All 2 branches missed.">		if (this.rotation != degrees) {</span>
<span class="nc" id="L625">			this.rotation = degrees;</span>
<span class="nc" id="L626">			rotationChanged();</span>
		}
<span class="nc" id="L628">	}</span>

	/** Adds the specified rotation to the current rotation. */
	public void rotateBy (float amountInDegrees) {
<span class="nc bnc" id="L632" title="All 2 branches missed.">		if (amountInDegrees != 0) {</span>
<span class="nc" id="L633">			rotation += amountInDegrees;</span>
<span class="nc" id="L634">			rotationChanged();</span>
		}
<span class="nc" id="L636">	}</span>

	public void setColor (Color color) {
<span class="nc" id="L639">		this.color.set(color);</span>
<span class="nc" id="L640">	}</span>

	public void setColor (float r, float g, float b, float a) {
<span class="nc" id="L643">		color.set(r, g, b, a);</span>
<span class="nc" id="L644">	}</span>

	/** Returns the color the actor will be tinted when drawn. The returned instance can be modified to change the color. */
	public Color getColor () {
<span class="nc" id="L648">		return color;</span>
	}

	/** @see #setName(String)
	 * @return May be null. */
	public String getName () {
<span class="nc" id="L654">		return name;</span>
	}

	/** Set the actor's name, which is used for identification convenience and by {@link #toString()}.
	 * @param name May be null.
	 * @see Group#findActor(String) */
	public void setName (String name) {
<span class="nc" id="L661">		this.name = name;</span>
<span class="nc" id="L662">	}</span>

	/** Changes the z-order for this actor so it is in front of all siblings. */
	public void toFront () {
<span class="nc" id="L666">		setZIndex(Integer.MAX_VALUE);</span>
<span class="nc" id="L667">	}</span>

	/** Changes the z-order for this actor so it is in back of all siblings. */
	public void toBack () {
<span class="nc" id="L671">		setZIndex(0);</span>
<span class="nc" id="L672">	}</span>

	/** Sets the z-index of this actor. The z-index is the index into the parent's {@link Group#getChildren() children}, where a
	 * lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.
	 * Setting a z-index less than zero is invalid. */
	public void setZIndex (int index) {
<span class="nc bnc" id="L678" title="All 2 branches missed.">		if (index &lt; 0) throw new IllegalArgumentException(&quot;ZIndex cannot be &lt; 0.&quot;);</span>
<span class="nc" id="L679">		Group parent = this.parent;</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">		if (parent == null) return;</span>
<span class="nc" id="L681">		Array&lt;Actor&gt; children = parent.children;</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">		if (children.size == 1) return;</span>
<span class="nc" id="L683">		index = Math.min(index, children.size - 1);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if (index == children.indexOf(this, true)) return;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">		if (!children.removeValue(this, true)) return;</span>
<span class="nc" id="L686">		children.insert(index, this);</span>
<span class="nc" id="L687">	}</span>

	/** Returns the z-index of this actor.
	 * @see #setZIndex(int) */
	public int getZIndex () {
<span class="nc" id="L692">		Group parent = this.parent;</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">		if (parent == null) return -1;</span>
<span class="nc" id="L694">		return parent.children.indexOf(this, true);</span>
	}

	/** Calls {@link #clipBegin(float, float, float, float)} to clip this actor's bounds. */
	public boolean clipBegin () {
<span class="nc" id="L699">		return clipBegin(x, y, width, height);</span>
	}

	/** Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The
	 * transform matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call
	 * to {@link #clipEnd()} if true is returned.
	 * @return false if the clipping area is zero and no drawing should occur.
	 * @see ScissorStack */
	public boolean clipBegin (float x, float y, float width, float height) {
<span class="nc bnc" id="L708" title="All 4 branches missed.">		if (width &lt;= 0 || height &lt;= 0) return false;</span>
<span class="nc" id="L709">		Rectangle tableBounds = Rectangle.tmp;</span>
<span class="nc" id="L710">		tableBounds.x = x;</span>
<span class="nc" id="L711">		tableBounds.y = y;</span>
<span class="nc" id="L712">		tableBounds.width = width;</span>
<span class="nc" id="L713">		tableBounds.height = height;</span>
<span class="nc" id="L714">		Stage stage = this.stage;</span>
<span class="nc" id="L715">		Rectangle scissorBounds = Pools.obtain(Rectangle.class);</span>
<span class="nc" id="L716">		stage.calculateScissors(tableBounds, scissorBounds);</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">		if (ScissorStack.pushScissors(scissorBounds)) return true;</span>
<span class="nc" id="L718">		Pools.free(scissorBounds);</span>
<span class="nc" id="L719">		return false;</span>
	}

	/** Ends clipping begun by {@link #clipBegin(float, float, float, float)}. */
	public void clipEnd () {
<span class="nc" id="L724">		Pools.free(ScissorStack.popScissors());</span>
<span class="nc" id="L725">	}</span>

	/** Transforms the specified point in screen coordinates to the actor's local coordinate system. */
	public Vector2 screenToLocalCoordinates (Vector2 screenCoords) {
<span class="nc" id="L729">		Stage stage = this.stage;</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">		if (stage == null) return screenCoords;</span>
<span class="nc" id="L731">		return stageToLocalCoordinates(stage.screenToStageCoordinates(screenCoords));</span>
	}

	/** Transforms the specified point in the stage's coordinates to the actor's local coordinate system. */
	public Vector2 stageToLocalCoordinates (Vector2 stageCoords) {
<span class="nc bnc" id="L736" title="All 2 branches missed.">		if (parent != null) parent.stageToLocalCoordinates(stageCoords);</span>
<span class="nc" id="L737">		parentToLocalCoordinates(stageCoords);</span>
<span class="nc" id="L738">		return stageCoords;</span>
	}

	/** Transforms the specified point in the actor's coordinates to be in the stage's coordinates.
	 * @see Stage#toScreenCoordinates(Vector2, com.badlogic.gdx.math.Matrix4) */
	public Vector2 localToStageCoordinates (Vector2 localCoords) {
<span class="nc" id="L744">		return localToAscendantCoordinates(null, localCoords);</span>
	}

	/** Transforms the specified point in the actor's coordinates to be in the parent's coordinates. */
	public Vector2 localToParentCoordinates (Vector2 localCoords) {
<span class="nc" id="L749">		final float rotation = -this.rotation;</span>
<span class="nc" id="L750">		final float scaleX = this.scaleX;</span>
<span class="nc" id="L751">		final float scaleY = this.scaleY;</span>
<span class="nc" id="L752">		final float x = this.x;</span>
<span class="nc" id="L753">		final float y = this.y;</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">		if (rotation == 0) {</span>
<span class="nc bnc" id="L755" title="All 4 branches missed.">			if (scaleX == 1 &amp;&amp; scaleY == 1) {</span>
<span class="nc" id="L756">				localCoords.x += x;</span>
<span class="nc" id="L757">				localCoords.y += y;</span>
			} else {
<span class="nc" id="L759">				final float originX = this.originX;</span>
<span class="nc" id="L760">				final float originY = this.originY;</span>
<span class="nc" id="L761">				localCoords.x = (localCoords.x - originX) * scaleX + originX + x;</span>
<span class="nc" id="L762">				localCoords.y = (localCoords.y - originY) * scaleY + originY + y;</span>
<span class="nc" id="L763">			}</span>
		} else {
<span class="nc" id="L765">			final float cos = (float)Math.cos(rotation * MathUtils.degreesToRadians);</span>
<span class="nc" id="L766">			final float sin = (float)Math.sin(rotation * MathUtils.degreesToRadians);</span>
<span class="nc" id="L767">			final float originX = this.originX;</span>
<span class="nc" id="L768">			final float originY = this.originY;</span>
<span class="nc" id="L769">			final float tox = (localCoords.x - originX) * scaleX;</span>
<span class="nc" id="L770">			final float toy = (localCoords.y - originY) * scaleY;</span>
<span class="nc" id="L771">			localCoords.x = (tox * cos + toy * sin) + originX + x;</span>
<span class="nc" id="L772">			localCoords.y = (tox * -sin + toy * cos) + originY + y;</span>
		}
<span class="nc" id="L774">		return localCoords;</span>
	}

	/** Converts coordinates for this actor to those of a parent actor. The ascendant does not need to be a direct parent. */
	public Vector2 localToAscendantCoordinates (Actor ascendant, Vector2 localCoords) {
<span class="nc" id="L779">		Actor actor = this;</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">		while (actor != null) {</span>
<span class="nc" id="L781">			actor.localToParentCoordinates(localCoords);</span>
<span class="nc" id="L782">			actor = actor.parent;</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">			if (actor == ascendant) break;</span>
		}
<span class="nc" id="L785">		return localCoords;</span>
	}

	/** Converts the coordinates given in the parent's coordinate system to this actor's coordinate system. */
	public Vector2 parentToLocalCoordinates (Vector2 parentCoords) {
<span class="nc" id="L790">		final float rotation = this.rotation;</span>
<span class="nc" id="L791">		final float scaleX = this.scaleX;</span>
<span class="nc" id="L792">		final float scaleY = this.scaleY;</span>
<span class="nc" id="L793">		final float childX = x;</span>
<span class="nc" id="L794">		final float childY = y;</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">		if (rotation == 0) {</span>
<span class="nc bnc" id="L796" title="All 4 branches missed.">			if (scaleX == 1 &amp;&amp; scaleY == 1) {</span>
<span class="nc" id="L797">				parentCoords.x -= childX;</span>
<span class="nc" id="L798">				parentCoords.y -= childY;</span>
			} else {
<span class="nc" id="L800">				final float originX = this.originX;</span>
<span class="nc" id="L801">				final float originY = this.originY;</span>
<span class="nc" id="L802">				parentCoords.x = (parentCoords.x - childX - originX) / scaleX + originX;</span>
<span class="nc" id="L803">				parentCoords.y = (parentCoords.y - childY - originY) / scaleY + originY;</span>
<span class="nc" id="L804">			}</span>
		} else {
<span class="nc" id="L806">			final float cos = (float)Math.cos(rotation * MathUtils.degreesToRadians);</span>
<span class="nc" id="L807">			final float sin = (float)Math.sin(rotation * MathUtils.degreesToRadians);</span>
<span class="nc" id="L808">			final float originX = this.originX;</span>
<span class="nc" id="L809">			final float originY = this.originY;</span>
<span class="nc" id="L810">			final float tox = parentCoords.x - childX - originX;</span>
<span class="nc" id="L811">			final float toy = parentCoords.y - childY - originY;</span>
<span class="nc" id="L812">			parentCoords.x = (tox * cos + toy * sin) / scaleX + originX;</span>
<span class="nc" id="L813">			parentCoords.y = (tox * -sin + toy * cos) / scaleY + originY;</span>
		}
<span class="nc" id="L815">		return parentCoords;</span>
	}

	/** Draws this actor's debug lines if {@link #getDebug()} is true. */
	public void drawDebug (ShapeRenderer shapes) {
<span class="nc" id="L820">		drawDebugBounds(shapes);</span>
<span class="nc" id="L821">	}</span>

	/** Draws a rectange for the bounds of this actor if {@link #getDebug()} is true. */
	protected void drawDebugBounds (ShapeRenderer shapes) {
<span class="nc bnc" id="L825" title="All 2 branches missed.">		if (!debug) return;</span>
<span class="nc" id="L826">		shapes.set(ShapeType.Line);</span>
<span class="nc" id="L827">		shapes.setColor(stage.getDebugColor());</span>
<span class="nc" id="L828">		shapes.rect(x, y, originX, originY, width, height, scaleX, scaleY, rotation);</span>
<span class="nc" id="L829">	}</span>

	/** If true, {@link #drawDebug(ShapeRenderer)} will be called for this actor. */
	public void setDebug (boolean enabled) {
<span class="nc" id="L833">		debug = enabled;</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">		if (enabled) Stage.debug = true;</span>
<span class="nc" id="L835">	}</span>

	public boolean getDebug () {
<span class="nc" id="L838">		return debug;</span>
	}

	/** Calls {@link #setDebug(boolean)} with {@code true}. */
	public Actor debug () {
<span class="nc" id="L843">		setDebug(true);</span>
<span class="nc" id="L844">		return this;</span>
	}

	public String toString () {
<span class="nc" id="L848">		String name = this.name;</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">		if (name == null) {</span>
<span class="nc" id="L850">			name = getClass().getName();</span>
<span class="nc" id="L851">			int dotIndex = name.lastIndexOf('.');</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">			if (dotIndex != -1) name = name.substring(dotIndex + 1);</span>
		}
<span class="nc" id="L854">		return name;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>