<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Mesh.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.graphics</a> &gt; <span class="el_source">Mesh.java</span></div><h1>Mesh.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.graphics;

import java.nio.FloatBuffer;
import java.nio.ShortBuffer;
import java.util.HashMap;
import java.util.Map;

import com.badlogic.gdx.Application;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.VertexAttributes.Usage;
import com.badlogic.gdx.graphics.glutils.IndexArray;
import com.badlogic.gdx.graphics.glutils.IndexBufferObject;
import com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData;
import com.badlogic.gdx.graphics.glutils.IndexData;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.graphics.glutils.VertexArray;
import com.badlogic.gdx.graphics.glutils.VertexBufferObject;
import com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData;
import com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO;
import com.badlogic.gdx.graphics.glutils.VertexData;
import com.badlogic.gdx.math.Matrix3;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.math.collision.BoundingBox;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Disposable;
import com.badlogic.gdx.utils.GdxRuntimeException;

/** &lt;p&gt;
 * A Mesh holds vertices composed of attributes specified by a {@link VertexAttributes} instance. The vertices are held either in
 * VRAM in form of vertex buffer objects or in RAM in form of vertex arrays. The former variant is more performant and is
 * preferred over vertex arrays if hardware supports it.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Meshes are automatically managed. If the OpenGL context is lost all vertex buffer objects get invalidated and must be reloaded
 * when the context is recreated. This only happens on Android when a user switches to another application or receives an incoming
 * call. A managed Mesh will be reloaded automagically so you don't have to do this manually.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * A Mesh consists of vertices and optionally indices which specify which vertices define a triangle. Each vertex is composed of
 * attributes such as position, normal, color or texture coordinate. Note that not all of this attributes must be given, except
 * for position which is non-optional. Each attribute has an alias which is used when rendering a Mesh in OpenGL ES 2.0. The alias
 * is used to bind a specific vertex attribute to a shader attribute. The shader source and the alias of the attribute must match
 * exactly for this to work.
 * &lt;/p&gt;
 * 
 * @author mzechner, Dave Clayton &lt;contact@redskyforge.com&gt;, Xoppa */
public class Mesh implements Disposable {
<span class="nc" id="L68">	public enum VertexDataType {</span>
<span class="nc" id="L69">		VertexArray, VertexBufferObject, VertexBufferObjectSubData, VertexBufferObjectWithVAO</span>
	}

	/** list of all meshes **/
<span class="nc" id="L73">	static final Map&lt;Application, Array&lt;Mesh&gt;&gt; meshes = new HashMap&lt;Application, Array&lt;Mesh&gt;&gt;();</span>

	final VertexData vertices;
	final IndexData indices;
<span class="nc" id="L77">	boolean autoBind = true;</span>
	final boolean isVertexArray;

<span class="nc" id="L80">	protected Mesh (VertexData vertices, IndexData indices, boolean isVertexArray) {</span>
<span class="nc" id="L81">		this.vertices = vertices;</span>
<span class="nc" id="L82">		this.indices = indices;</span>
<span class="nc" id="L83">		this.isVertexArray = isVertexArray;</span>

<span class="nc" id="L85">		addManagedMesh(Gdx.app, this);</span>
<span class="nc" id="L86">	}</span>

	/** Creates a new Mesh with the given attributes.
	 * 
	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
	 * @param maxVertices the maximum number of vertices this mesh can hold
	 * @param maxIndices the maximum number of indices this mesh can hold
	 * @param attributes the {@link VertexAttribute}s. Each vertex attribute defines one property of a vertex such as position,
	 *           normal or texture coordinate */
<span class="nc" id="L95">	public Mesh (boolean isStatic, int maxVertices, int maxIndices, VertexAttribute... attributes) {</span>
<span class="nc" id="L96">		vertices = makeVertexBuffer(isStatic, maxVertices, new VertexAttributes(attributes));</span>
<span class="nc" id="L97">		indices = new IndexBufferObject(isStatic, maxIndices);</span>
<span class="nc" id="L98">		isVertexArray = false;</span>

<span class="nc" id="L100">		addManagedMesh(Gdx.app, this);</span>
<span class="nc" id="L101">	}</span>

	/** Creates a new Mesh with the given attributes.
	 * 
	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
	 * @param maxVertices the maximum number of vertices this mesh can hold
	 * @param maxIndices the maximum number of indices this mesh can hold
	 * @param attributes the {@link VertexAttributes}. Each vertex attribute defines one property of a vertex such as position,
	 *           normal or texture coordinate */
<span class="nc" id="L110">	public Mesh (boolean isStatic, int maxVertices, int maxIndices, VertexAttributes attributes) {</span>
<span class="nc" id="L111">		vertices = makeVertexBuffer(isStatic, maxVertices, attributes);</span>
<span class="nc" id="L112">		indices = new IndexBufferObject(isStatic, maxIndices);</span>
<span class="nc" id="L113">		isVertexArray = false;</span>

<span class="nc" id="L115">		addManagedMesh(Gdx.app, this);</span>
<span class="nc" id="L116">	}</span>

	/** by jw: Creates a new Mesh with the given attributes. Adds extra optimizations for dynamic (frequently modified) meshes.
	 * 
	 * @param staticVertices whether vertices of this mesh are static or not. Allows for internal optimizations.
	 * @param staticIndices whether indices of this mesh are static or not. Allows for internal optimizations.
	 * @param maxVertices the maximum number of vertices this mesh can hold
	 * @param maxIndices the maximum number of indices this mesh can hold
	 * @param attributes the {@link VertexAttributes}. Each vertex attribute defines one property of a vertex such as position,
	 *           normal or texture coordinate
	 * 
	 * @author Jaroslaw Wisniewski &lt;j.wisniewski@appsisle.com&gt; **/
<span class="nc" id="L128">	public Mesh (boolean staticVertices, boolean staticIndices, int maxVertices, int maxIndices, VertexAttributes attributes) {</span>
<span class="nc" id="L129">		vertices = makeVertexBuffer(staticVertices, maxVertices, attributes);</span>
<span class="nc" id="L130">		indices = new IndexBufferObject(staticIndices, maxIndices);</span>
<span class="nc" id="L131">		isVertexArray = false;</span>

<span class="nc" id="L133">		addManagedMesh(Gdx.app, this);</span>
<span class="nc" id="L134">	}</span>

	private VertexData makeVertexBuffer (boolean isStatic, int maxVertices, VertexAttributes vertexAttributes) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">		if (Gdx.gl30 != null) {</span>
<span class="nc" id="L138">			return new VertexBufferObjectWithVAO(isStatic, maxVertices, vertexAttributes);</span>
		} else {
<span class="nc" id="L140">			return new VertexBufferObject(isStatic, maxVertices, vertexAttributes);</span>
		}
	}

	/** Creates a new Mesh with the given attributes. This is an expert method with no error checking. Use at your own risk.
	 * 
	 * @param type the {@link VertexDataType} to be used, VBO or VA.
	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
	 * @param maxVertices the maximum number of vertices this mesh can hold
	 * @param maxIndices the maximum number of indices this mesh can hold
	 * @param attributes the {@link VertexAttribute}s. Each vertex attribute defines one property of a vertex such as position,
	 *           normal or texture coordinate */
<span class="nc" id="L152">	public Mesh (VertexDataType type, boolean isStatic, int maxVertices, int maxIndices, VertexAttribute... attributes) {</span>
<span class="nc bnc" id="L153" title="All 4 branches missed.">		switch (type) {</span>
		case VertexBufferObject:
<span class="nc" id="L155">			vertices = new VertexBufferObject(isStatic, maxVertices, attributes);</span>
<span class="nc" id="L156">			indices = new IndexBufferObject(isStatic, maxIndices);</span>
<span class="nc" id="L157">			isVertexArray = false;</span>
<span class="nc" id="L158">			break;</span>
		case VertexBufferObjectSubData:
<span class="nc" id="L160">			vertices = new VertexBufferObjectSubData(isStatic, maxVertices, attributes);</span>
<span class="nc" id="L161">			indices = new IndexBufferObjectSubData(isStatic, maxIndices);</span>
<span class="nc" id="L162">			isVertexArray = false;</span>
<span class="nc" id="L163">			break;</span>
		case VertexBufferObjectWithVAO:
<span class="nc" id="L165">			vertices = new VertexBufferObjectWithVAO(isStatic, maxVertices, attributes);</span>
<span class="nc" id="L166">			indices = new IndexBufferObjectSubData(isStatic, maxIndices);</span>
<span class="nc" id="L167">			isVertexArray = false;</span>
<span class="nc" id="L168">			break;</span>
		case VertexArray:
		default:
<span class="nc" id="L171">			vertices = new VertexArray(maxVertices, attributes);</span>
<span class="nc" id="L172">			indices = new IndexArray(maxIndices);</span>
<span class="nc" id="L173">			isVertexArray = true;</span>
			break;
		}

<span class="nc" id="L177">		addManagedMesh(Gdx.app, this);</span>
<span class="nc" id="L178">	}</span>

	/** Sets the vertices of this Mesh. The attributes are assumed to be given in float format.
	 * 
	 * @param vertices the vertices.
	 * @return the mesh for invocation chaining. */
	public Mesh setVertices (float[] vertices) {
<span class="nc" id="L185">		this.vertices.setVertices(vertices, 0, vertices.length);</span>

<span class="nc" id="L187">		return this;</span>
	}

	/** Sets the vertices of this Mesh. The attributes are assumed to be given in float format.
	 * 
	 * @param vertices the vertices.
	 * @param offset the offset into the vertices array
	 * @param count the number of floats to use
	 * @return the mesh for invocation chaining. */
	public Mesh setVertices (float[] vertices, int offset, int count) {
<span class="nc" id="L197">		this.vertices.setVertices(vertices, offset, count);</span>

<span class="nc" id="L199">		return this;</span>
	}

	/** Update (a portion of) the vertices. Does not resize the backing buffer.
	 * @param targetOffset the offset in number of floats of the mesh part.
	 * @param source the vertex data to update the mesh part with */
	public Mesh updateVertices (int targetOffset, float[] source) {
<span class="nc" id="L206">		return updateVertices(targetOffset, source, 0, source.length);</span>
	}

	/** Update (a portion of) the vertices. Does not resize the backing buffer.
	 * @param targetOffset the offset in number of floats of the mesh part.
	 * @param source the vertex data to update the mesh part with
	 * @param sourceOffset the offset in number of floats within the source array
	 * @param count the number of floats to update */
	public Mesh updateVertices (int targetOffset, float[] source, int sourceOffset, int count) {
<span class="nc" id="L215">		this.vertices.updateVertices(targetOffset, source, sourceOffset, count);</span>
<span class="nc" id="L216">		return this;</span>
	}

	/** Copies the vertices from the Mesh to the float array. The float array must be large enough to hold all the Mesh's vertices.
	 * @param vertices the array to copy the vertices to */
	public float[] getVertices (float[] vertices) {
<span class="nc" id="L222">		return getVertices(0, -1, vertices);</span>
	}

	/** Copies the the remaining vertices from the Mesh to the float array. The float array must be large enough to hold the
	 * remaining vertices.
	 * @param srcOffset the offset (in number of floats) of the vertices in the mesh to copy
	 * @param vertices the array to copy the vertices to */
	public float[] getVertices (int srcOffset, float[] vertices) {
<span class="nc" id="L230">		return getVertices(srcOffset, -1, vertices);</span>
	}

	/** Copies the specified vertices from the Mesh to the float array. The float array must be large enough to hold count vertices.
	 * @param srcOffset the offset (in number of floats) of the vertices in the mesh to copy
	 * @param count the amount of floats to copy
	 * @param vertices the array to copy the vertices to */
	public float[] getVertices (int srcOffset, int count, float[] vertices) {
<span class="nc" id="L238">		return getVertices(srcOffset, count, vertices, 0);</span>
	}

	/** Copies the specified vertices from the Mesh to the float array. The float array must be large enough to hold
	 * destOffset+count vertices.
	 * @param srcOffset the offset (in number of floats) of the vertices in the mesh to copy
	 * @param count the amount of floats to copy
	 * @param vertices the array to copy the vertices to
	 * @param destOffset the offset (in floats) in the vertices array to start copying */
	public float[] getVertices (int srcOffset, int count, float[] vertices, int destOffset) {
		// TODO: Perhaps this method should be vertexSize aware??
<span class="nc" id="L249">		final int max = getNumVertices() * getVertexSize() / 4;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">		if (count == -1) {</span>
<span class="nc" id="L251">			count = max - srcOffset;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">			if (count &gt; vertices.length - destOffset) count = vertices.length - destOffset;</span>
		}
<span class="nc bnc" id="L254" title="All 10 branches missed.">		if (srcOffset &lt; 0 || count &lt;= 0 || (srcOffset + count) &gt; max || destOffset &lt; 0 || destOffset &gt;= vertices.length)</span>
<span class="nc" id="L255">			throw new IndexOutOfBoundsException();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">		if ((vertices.length - destOffset) &lt; count)</span>
<span class="nc" id="L257">			throw new IllegalArgumentException(&quot;not enough room in vertices array, has &quot; + vertices.length + &quot; floats, needs &quot;</span>
				+ count);
<span class="nc" id="L259">		int pos = getVerticesBuffer().position();</span>
<span class="nc" id="L260">		getVerticesBuffer().position(srcOffset);</span>
<span class="nc" id="L261">		getVerticesBuffer().get(vertices, destOffset, count);</span>
<span class="nc" id="L262">		getVerticesBuffer().position(pos);</span>
<span class="nc" id="L263">		return vertices;</span>
	}

	/** Sets the indices of this Mesh
	 * 
	 * @param indices the indices
	 * @return the mesh for invocation chaining. */
	public Mesh setIndices (short[] indices) {
<span class="nc" id="L271">		this.indices.setIndices(indices, 0, indices.length);</span>

<span class="nc" id="L273">		return this;</span>
	}

	/** Sets the indices of this Mesh.
	 * 
	 * @param indices the indices
	 * @param offset the offset into the indices array
	 * @param count the number of indices to copy
	 * @return the mesh for invocation chaining. */
	public Mesh setIndices (short[] indices, int offset, int count) {
<span class="nc" id="L283">		this.indices.setIndices(indices, offset, count);</span>

<span class="nc" id="L285">		return this;</span>
	}

	/** Copies the indices from the Mesh to the short array. The short array must be large enough to hold all the Mesh's indices.
	 * @param indices the array to copy the indices to */
	public void getIndices (short[] indices) {
<span class="nc" id="L291">		getIndices(indices, 0);</span>
<span class="nc" id="L292">	}</span>

	/** Copies the indices from the Mesh to the short array. The short array must be large enough to hold destOffset + all the
	 * Mesh's indices.
	 * @param indices the array to copy the indices to
	 * @param destOffset the offset in the indices array to start copying */
	public void getIndices (short[] indices, int destOffset) {
<span class="nc" id="L299">		getIndices(0, indices, destOffset);</span>
<span class="nc" id="L300">	}</span>

	/** Copies the remaining indices from the Mesh to the short array. The short array must be large enough to hold destOffset + all
	 * the remaining indices.
	 * @param srcOffset the zero-based offset of the first index to fetch
	 * @param indices the array to copy the indices to
	 * @param destOffset the offset in the indices array to start copying */
	public void getIndices (int srcOffset, short[] indices, int destOffset) {
<span class="nc" id="L308">		getIndices(srcOffset, -1, indices, destOffset);</span>
<span class="nc" id="L309">	}</span>

	/** Copies the indices from the Mesh to the short array. The short array must be large enough to hold destOffset + count
	 * indices.
	 * @param srcOffset the zero-based offset of the first index to fetch
	 * @param count the total amount of indices to copy
	 * @param indices the array to copy the indices to
	 * @param destOffset the offset in the indices array to start copying */
	public void getIndices (int srcOffset, int count, short[] indices, int destOffset) {
<span class="nc" id="L318">		int max = getNumIndices();</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">		if (count &lt; 0) count = max - srcOffset;</span>
<span class="nc bnc" id="L320" title="All 6 branches missed.">		if (srcOffset &lt; 0 || srcOffset &gt;= max || srcOffset + count &gt; max)</span>
<span class="nc" id="L321">			throw new IllegalArgumentException(&quot;Invalid range specified, offset: &quot; + srcOffset + &quot;, count: &quot; + count + &quot;, max: &quot;</span>
				+ max);
<span class="nc bnc" id="L323" title="All 2 branches missed.">		if ((indices.length - destOffset) &lt; count)</span>
<span class="nc" id="L324">			throw new IllegalArgumentException(&quot;not enough room in indices array, has &quot; + indices.length + &quot; shorts, needs &quot; + count);</span>
<span class="nc" id="L325">		int pos = getIndicesBuffer().position();</span>
<span class="nc" id="L326">		getIndicesBuffer().position(srcOffset);</span>
<span class="nc" id="L327">		getIndicesBuffer().get(indices, destOffset, count);</span>
<span class="nc" id="L328">		getIndicesBuffer().position(pos);</span>
<span class="nc" id="L329">	}</span>

	/** @return the number of defined indices */
	public int getNumIndices () {
<span class="nc" id="L333">		return indices.getNumIndices();</span>
	}

	/** @return the number of defined vertices */
	public int getNumVertices () {
<span class="nc" id="L338">		return vertices.getNumVertices();</span>
	}

	/** @return the maximum number of vertices this mesh can hold */
	public int getMaxVertices () {
<span class="nc" id="L343">		return vertices.getNumMaxVertices();</span>
	}

	/** @return the maximum number of indices this mesh can hold */
	public int getMaxIndices () {
<span class="nc" id="L348">		return indices.getNumMaxIndices();</span>
	}

	/** @return the size of a single vertex in bytes */
	public int getVertexSize () {
<span class="nc" id="L353">		return vertices.getAttributes().vertexSize;</span>
	}

	/** Sets whether to bind the underlying {@link VertexArray} or {@link VertexBufferObject} automatically on a call to one of the
	 * render methods. Usually you want to use autobind. Manual binding is an expert functionality. There is a driver bug on the
	 * MSM720xa chips that will fuck up memory if you manipulate the vertices and indices of a Mesh multiple times while it is
	 * bound. Keep this in mind.
	 * 
	 * @param autoBind whether to autobind meshes. */
	public void setAutoBind (boolean autoBind) {
<span class="nc" id="L363">		this.autoBind = autoBind;</span>
<span class="nc" id="L364">	}</span>

	/** Binds the underlying {@link VertexBufferObject} and {@link IndexBufferObject} if indices where given. Use this with OpenGL
	 * ES 2.0 and when auto-bind is disabled.
	 * 
	 * @param shader the shader (does not bind the shader) */
	public void bind (final ShaderProgram shader) {
<span class="nc" id="L371">		bind(shader, null);</span>
<span class="nc" id="L372">	}</span>

	/** Binds the underlying {@link VertexBufferObject} and {@link IndexBufferObject} if indices where given. Use this with OpenGL
	 * ES 2.0 and when auto-bind is disabled.
	 * 
	 * @param shader the shader (does not bind the shader)
	 * @param locations array containing the attribute locations. */
	public void bind (final ShaderProgram shader, final int[] locations) {
<span class="nc" id="L380">		vertices.bind(shader, locations);</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">		if (indices.getNumIndices() &gt; 0) indices.bind();</span>
<span class="nc" id="L382">	}</span>

	/** Unbinds the underlying {@link VertexBufferObject} and {@link IndexBufferObject} is indices were given. Use this with OpenGL
	 * ES 1.x and when auto-bind is disabled.
	 * 
	 * @param shader the shader (does not unbind the shader) */
	public void unbind (final ShaderProgram shader) {
<span class="nc" id="L389">		unbind(shader, null);</span>
<span class="nc" id="L390">	}</span>

	/** Unbinds the underlying {@link VertexBufferObject} and {@link IndexBufferObject} is indices were given. Use this with OpenGL
	 * ES 1.x and when auto-bind is disabled.
	 * 
	 * @param shader the shader (does not unbind the shader)
	 * @param locations array containing the attribute locations. */
	public void unbind (final ShaderProgram shader, final int[] locations) {
<span class="nc" id="L398">		vertices.unbind(shader, locations);</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">		if (indices.getNumIndices() &gt; 0) indices.unbind();</span>
<span class="nc" id="L400">	}</span>

	/** &lt;p&gt;
	 * Renders the mesh using the given primitive type. If indices are set for this mesh then getNumIndices() / #vertices per
	 * primitive primitives are rendered. If no indices are set then getNumVertices() / #vertices per primitive are rendered.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * This method will automatically bind each vertex attribute as specified at construction time via {@link VertexAttributes} to
	 * the respective shader attributes. The binding is based on the alias defined for each VertexAttribute.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * This method must only be called after the {@link ShaderProgram#begin()} method has been called!
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * This method is intended for use with OpenGL ES 2.0 and will throw an IllegalStateException when OpenGL ES 1.x is used.
	 * &lt;/p&gt;
	 * 
	 * @param primitiveType the primitive type */
	public void render (ShaderProgram shader, int primitiveType) {
<span class="nc bnc" id="L422" title="All 2 branches missed.">		render(shader, primitiveType, 0, indices.getNumMaxIndices() &gt; 0 ? getNumIndices() : getNumVertices(), autoBind);</span>
<span class="nc" id="L423">	}</span>

	/** &lt;p&gt;
	 * Renders the mesh using the given primitive type. offset specifies the offset into either the vertex buffer or the index
	 * buffer depending on whether indices are defined. count specifies the number of vertices or indices to use thus count /
	 * #vertices per primitive primitives are rendered.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * This method will automatically bind each vertex attribute as specified at construction time via {@link VertexAttributes} to
	 * the respective shader attributes. The binding is based on the alias defined for each VertexAttribute.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * This method must only be called after the {@link ShaderProgram#begin()} method has been called!
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * This method is intended for use with OpenGL ES 2.0 and will throw an IllegalStateException when OpenGL ES 1.x is used.
	 * &lt;/p&gt;
	 * 
	 * @param shader the shader to be used
	 * @param primitiveType the primitive type
	 * @param offset the offset into the vertex or index buffer
	 * @param count number of vertices or indices to use */
	public void render (ShaderProgram shader, int primitiveType, int offset, int count) {
<span class="nc" id="L449">		render(shader, primitiveType, offset, count, autoBind);</span>
<span class="nc" id="L450">	}</span>

	/** &lt;p&gt;
	 * Renders the mesh using the given primitive type. offset specifies the offset into either the vertex buffer or the index
	 * buffer depending on whether indices are defined. count specifies the number of vertices or indices to use thus count /
	 * #vertices per primitive primitives are rendered.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * This method will automatically bind each vertex attribute as specified at construction time via {@link VertexAttributes} to
	 * the respective shader attributes. The binding is based on the alias defined for each VertexAttribute.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * This method must only be called after the {@link ShaderProgram#begin()} method has been called!
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * This method is intended for use with OpenGL ES 2.0 and will throw an IllegalStateException when OpenGL ES 1.x is used.
	 * &lt;/p&gt;
	 * 
	 * @param shader the shader to be used
	 * @param primitiveType the primitive type
	 * @param offset the offset into the vertex or index buffer
	 * @param count number of vertices or indices to use
	 * @param autoBind overrides the autoBind member of this Mesh */
	public void render (ShaderProgram shader, int primitiveType, int offset, int count, boolean autoBind) {
<span class="nc bnc" id="L477" title="All 2 branches missed.">		if (count == 0) return;</span>

<span class="nc bnc" id="L479" title="All 2 branches missed.">		if (autoBind) bind(shader);</span>

<span class="nc bnc" id="L481" title="All 2 branches missed.">		if (isVertexArray) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">			if (indices.getNumIndices() &gt; 0) {</span>
<span class="nc" id="L483">				ShortBuffer buffer = indices.getBuffer();</span>
<span class="nc" id="L484">				int oldPosition = buffer.position();</span>
<span class="nc" id="L485">				int oldLimit = buffer.limit();</span>
<span class="nc" id="L486">				buffer.position(offset);</span>
<span class="nc" id="L487">				buffer.limit(offset + count);</span>
<span class="nc" id="L488">				Gdx.gl20.glDrawElements(primitiveType, count, GL20.GL_UNSIGNED_SHORT, buffer);</span>
<span class="nc" id="L489">				buffer.position(oldPosition);</span>
<span class="nc" id="L490">				buffer.limit(oldLimit);</span>
<span class="nc" id="L491">			} else {</span>
<span class="nc" id="L492">				Gdx.gl20.glDrawArrays(primitiveType, offset, count);</span>
			}
		} else {
<span class="nc bnc" id="L495" title="All 2 branches missed.">			if (indices.getNumIndices() &gt; 0)</span>
<span class="nc" id="L496">				Gdx.gl20.glDrawElements(primitiveType, count, GL20.GL_UNSIGNED_SHORT, offset * 2);</span>
			else
<span class="nc" id="L498">				Gdx.gl20.glDrawArrays(primitiveType, offset, count);</span>
		}

<span class="nc bnc" id="L501" title="All 2 branches missed.">		if (autoBind) unbind(shader);</span>
<span class="nc" id="L502">	}</span>

	/** Frees all resources associated with this Mesh */
	public void dispose () {
<span class="nc bnc" id="L506" title="All 2 branches missed.">		if (meshes.get(Gdx.app) != null) meshes.get(Gdx.app).removeValue(this, true);</span>
<span class="nc" id="L507">		vertices.dispose();</span>
<span class="nc" id="L508">		indices.dispose();</span>
<span class="nc" id="L509">	}</span>

	/** Returns the first {@link VertexAttribute} having the given {@link Usage}.
	 * 
	 * @param usage the Usage.
	 * @return the VertexAttribute or null if no attribute with that usage was found. */
	public VertexAttribute getVertexAttribute (int usage) {
<span class="nc" id="L516">		VertexAttributes attributes = vertices.getAttributes();</span>
<span class="nc" id="L517">		int len = attributes.size();</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">		for (int i = 0; i &lt; len; i++)</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">			if (attributes.get(i).usage == usage) return attributes.get(i);</span>

<span class="nc" id="L521">		return null;</span>
	}

	/** @return the vertex attributes of this Mesh */
	public VertexAttributes getVertexAttributes () {
<span class="nc" id="L526">		return vertices.getAttributes();</span>
	}

	/** @return the backing FloatBuffer holding the vertices. Does not have to be a direct buffer on Android! */
	public FloatBuffer getVerticesBuffer () {
<span class="nc" id="L531">		return vertices.getBuffer();</span>
	}

	/** Calculates the {@link BoundingBox} of the vertices contained in this mesh. In case no vertices are defined yet a
	 * {@link GdxRuntimeException} is thrown. This method creates a new BoundingBox instance.
	 * 
	 * @return the bounding box. */
	public BoundingBox calculateBoundingBox () {
<span class="nc" id="L539">		BoundingBox bbox = new BoundingBox();</span>
<span class="nc" id="L540">		calculateBoundingBox(bbox);</span>
<span class="nc" id="L541">		return bbox;</span>
	}

	/** Calculates the {@link BoundingBox} of the vertices contained in this mesh. In case no vertices are defined yet a
	 * {@link GdxRuntimeException} is thrown.
	 * 
	 * @param bbox the bounding box to store the result in. */
	public void calculateBoundingBox (BoundingBox bbox) {
<span class="nc" id="L549">		final int numVertices = getNumVertices();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">		if (numVertices == 0) throw new GdxRuntimeException(&quot;No vertices defined&quot;);</span>

<span class="nc" id="L552">		final FloatBuffer verts = vertices.getBuffer();</span>
<span class="nc" id="L553">		bbox.inf();</span>
<span class="nc" id="L554">		final VertexAttribute posAttrib = getVertexAttribute(Usage.Position);</span>
<span class="nc" id="L555">		final int offset = posAttrib.offset / 4;</span>
<span class="nc" id="L556">		final int vertexSize = vertices.getAttributes().vertexSize / 4;</span>
<span class="nc" id="L557">		int idx = offset;</span>

<span class="nc bnc" id="L559" title="All 4 branches missed.">		switch (posAttrib.numComponents) {</span>
		case 1:
<span class="nc bnc" id="L561" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L562">				bbox.ext(verts.get(idx), 0, 0);</span>
<span class="nc" id="L563">				idx += vertexSize;</span>
			}
<span class="nc" id="L565">			break;</span>
		case 2:
<span class="nc bnc" id="L567" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L568">				bbox.ext(verts.get(idx), verts.get(idx + 1), 0);</span>
<span class="nc" id="L569">				idx += vertexSize;</span>
			}
<span class="nc" id="L571">			break;</span>
		case 3:
<span class="nc bnc" id="L573" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L574">				bbox.ext(verts.get(idx), verts.get(idx + 1), verts.get(idx + 2));</span>
<span class="nc" id="L575">				idx += vertexSize;</span>
			}
			break;
		}
<span class="nc" id="L579">	}</span>

	/** Calculate the {@link BoundingBox} of the specified part.
	 * @param out the bounding box to store the result in.
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the value specified by out. */
	public BoundingBox calculateBoundingBox (final BoundingBox out, int offset, int count) {
<span class="nc" id="L587">		return extendBoundingBox(out.inf(), offset, count);</span>
	}

	/** Calculate the {@link BoundingBox} of the specified part.
	 * @param out the bounding box to store the result in.
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the value specified by out. */
	public BoundingBox calculateBoundingBox (final BoundingBox out, int offset, int count, final Matrix4 transform) {
<span class="nc" id="L596">		return extendBoundingBox(out.inf(), offset, count, transform);</span>
	}

	/** Extends the specified {@link BoundingBox} with the specified part.
	 * @param out the bounding box to store the result in.
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the value specified by out. */
	public BoundingBox extendBoundingBox (final BoundingBox out, int offset, int count) {
<span class="nc" id="L605">		return extendBoundingBox(out, offset, count, null);</span>
	}

<span class="nc" id="L608">	private final Vector3 tmpV = new Vector3();</span>

	/** Extends the specified {@link BoundingBox} with the specified part.
	 * @param out the bounding box to store the result in.
	 * @param offset the start of the part.
	 * @param count the size of the part.
	 * @return the value specified by out. */
	public BoundingBox extendBoundingBox (final BoundingBox out, int offset, int count, final Matrix4 transform) {
<span class="nc" id="L616">		final int numIndices = getNumIndices();</span>
<span class="nc" id="L617">		final int numVertices = getNumVertices();</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">		final int max = numIndices == 0 ? numVertices : numIndices;</span>
<span class="nc bnc" id="L619" title="All 6 branches missed.">		if (offset &lt; 0 || count &lt; 1 || offset + count &gt; max)</span>
<span class="nc" id="L620">			throw new GdxRuntimeException(&quot;Invalid part specified ( offset=&quot; + offset + &quot;, count=&quot; + count + &quot;, max=&quot; + max + &quot; )&quot;);</span>

<span class="nc" id="L622">		final FloatBuffer verts = vertices.getBuffer();</span>
<span class="nc" id="L623">		final ShortBuffer index = indices.getBuffer();</span>
<span class="nc" id="L624">		final VertexAttribute posAttrib = getVertexAttribute(Usage.Position);</span>
<span class="nc" id="L625">		final int posoff = posAttrib.offset / 4;</span>
<span class="nc" id="L626">		final int vertexSize = vertices.getAttributes().vertexSize / 4;</span>
<span class="nc" id="L627">		final int end = offset + count;</span>

<span class="nc bnc" id="L629" title="All 4 branches missed.">		switch (posAttrib.numComponents) {</span>
		case 1:
<span class="nc bnc" id="L631" title="All 2 branches missed.">			if (numIndices &gt; 0) {</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L633">					final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L634">					tmpV.set(verts.get(idx), 0, 0);</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L636">					out.ext(tmpV);</span>
				}
			} else {
<span class="nc bnc" id="L639" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L640">					final int idx = i * vertexSize + posoff;</span>
<span class="nc" id="L641">					tmpV.set(verts.get(idx), 0, 0);</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L643">					out.ext(tmpV);</span>
				}
			}
<span class="nc" id="L646">			break;</span>
		case 2:
<span class="nc bnc" id="L648" title="All 2 branches missed.">			if (numIndices &gt; 0) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L650">					final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L651">					tmpV.set(verts.get(idx), verts.get(idx + 1), 0);</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L653">					out.ext(tmpV);</span>
				}
			} else {
<span class="nc bnc" id="L656" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L657">					final int idx = i * vertexSize + posoff;</span>
<span class="nc" id="L658">					tmpV.set(verts.get(idx), verts.get(idx + 1), 0);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L660">					out.ext(tmpV);</span>
				}
			}
<span class="nc" id="L663">			break;</span>
		case 3:
<span class="nc bnc" id="L665" title="All 2 branches missed.">			if (numIndices &gt; 0) {</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L667">					final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L668">					tmpV.set(verts.get(idx), verts.get(idx + 1), verts.get(idx + 2));</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L670">					out.ext(tmpV);</span>
				}
			} else {
<span class="nc bnc" id="L673" title="All 2 branches missed.">				for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L674">					final int idx = i * vertexSize + posoff;</span>
<span class="nc" id="L675">					tmpV.set(verts.get(idx), verts.get(idx + 1), verts.get(idx + 2));</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">					if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L677">					out.ext(tmpV);</span>
				}
			}
			break;
		}
<span class="nc" id="L682">		return out;</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param centerX The X coordinate of the center of the bounding sphere
	 * @param centerY The Y coordinate of the center of the bounding sphere
	 * @param centerZ The Z coordinate of the center of the bounding sphere
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadiusSquared (final float centerX, final float centerY, final float centerZ, int offset, int count,
		final Matrix4 transform) {
<span class="nc" id="L694">		int numIndices = getNumIndices();</span>
<span class="nc bnc" id="L695" title="All 6 branches missed.">		if (offset &lt; 0 || count &lt; 1 || offset + count &gt; numIndices) throw new GdxRuntimeException(&quot;Not enough indices&quot;);</span>

<span class="nc" id="L697">		final FloatBuffer verts = vertices.getBuffer();</span>
<span class="nc" id="L698">		final ShortBuffer index = indices.getBuffer();</span>
<span class="nc" id="L699">		final VertexAttribute posAttrib = getVertexAttribute(Usage.Position);</span>
<span class="nc" id="L700">		final int posoff = posAttrib.offset / 4;</span>
<span class="nc" id="L701">		final int vertexSize = vertices.getAttributes().vertexSize / 4;</span>
<span class="nc" id="L702">		final int end = offset + count;</span>

<span class="nc" id="L704">		float result = 0;</span>

<span class="nc bnc" id="L706" title="All 4 branches missed.">		switch (posAttrib.numComponents) {</span>
		case 1:
<span class="nc bnc" id="L708" title="All 2 branches missed.">			for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L709">				final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L710">				tmpV.set(verts.get(idx), 0, 0);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">				if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L712">				final float r = tmpV.sub(centerX, centerY, centerZ).len2();</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">				if (r &gt; result) result = r;</span>
			}
<span class="nc" id="L715">			break;</span>
		case 2:
<span class="nc bnc" id="L717" title="All 2 branches missed.">			for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L718">				final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L719">				tmpV.set(verts.get(idx), verts.get(idx + 1), 0);</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">				if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L721">				final float r = tmpV.sub(centerX, centerY, centerZ).len2();</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">				if (r &gt; result) result = r;</span>
			}
<span class="nc" id="L724">			break;</span>
		case 3:
<span class="nc bnc" id="L726" title="All 2 branches missed.">			for (int i = offset; i &lt; end; i++) {</span>
<span class="nc" id="L727">				final int idx = index.get(i) * vertexSize + posoff;</span>
<span class="nc" id="L728">				tmpV.set(verts.get(idx), verts.get(idx + 1), verts.get(idx + 2));</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">				if (transform != null) tmpV.mul(transform);</span>
<span class="nc" id="L730">				final float r = tmpV.sub(centerX, centerY, centerZ).len2();</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">				if (r &gt; result) result = r;</span>
			}
			break;
		}
<span class="nc" id="L735">		return result;</span>
	}

	/** Calculates the radius of the bounding sphere around the specified center for the specified part.
	 * @param centerX The X coordinate of the center of the bounding sphere
	 * @param centerY The Y coordinate of the center of the bounding sphere
	 * @param centerZ The Z coordinate of the center of the bounding sphere
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the radius of the bounding sphere. */
	public float calculateRadius (final float centerX, final float centerY, final float centerZ, int offset, int count,
		final Matrix4 transform) {
<span class="nc" id="L747">		return (float)Math.sqrt(calculateRadiusSquared(centerX, centerY, centerZ, offset, count, transform));</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param center The center of the bounding sphere
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadius (final Vector3 center, int offset, int count, final Matrix4 transform) {
<span class="nc" id="L756">		return calculateRadius(center.x, center.y, center.z, offset, count, transform);</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param centerX The X coordinate of the center of the bounding sphere
	 * @param centerY The Y coordinate of the center of the bounding sphere
	 * @param centerZ The Z coordinate of the center of the bounding sphere
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadius (final float centerX, final float centerY, final float centerZ, int offset, int count) {
<span class="nc" id="L767">		return calculateRadius(centerX, centerY, centerZ, offset, count, null);</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param center The center of the bounding sphere
	 * @param offset the start index of the part.
	 * @param count the amount of indices the part contains.
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadius (final Vector3 center, int offset, int count) {
<span class="nc" id="L776">		return calculateRadius(center.x, center.y, center.z, offset, count, null);</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param centerX The X coordinate of the center of the bounding sphere
	 * @param centerY The Y coordinate of the center of the bounding sphere
	 * @param centerZ The Z coordinate of the center of the bounding sphere
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadius (final float centerX, final float centerY, final float centerZ) {
<span class="nc" id="L785">		return calculateRadius(centerX, centerY, centerZ, 0, getNumIndices(), null);</span>
	}

	/** Calculates the squared radius of the bounding sphere around the specified center for the specified part.
	 * @param center The center of the bounding sphere
	 * @return the squared radius of the bounding sphere. */
	public float calculateRadius (final Vector3 center) {
<span class="nc" id="L792">		return calculateRadius(center.x, center.y, center.z, 0, getNumIndices(), null);</span>
	}

	/** @return the backing shortbuffer holding the indices. Does not have to be a direct buffer on Android! */
	public ShortBuffer getIndicesBuffer () {
<span class="nc" id="L797">		return indices.getBuffer();</span>
	}

	private static void addManagedMesh (Application app, Mesh mesh) {
<span class="nc" id="L801">		Array&lt;Mesh&gt; managedResources = meshes.get(app);</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">		if (managedResources == null) managedResources = new Array&lt;Mesh&gt;();</span>
<span class="nc" id="L803">		managedResources.add(mesh);</span>
<span class="nc" id="L804">		meshes.put(app, managedResources);</span>
<span class="nc" id="L805">	}</span>

	/** Invalidates all meshes so the next time they are rendered new VBO handles are generated.
	 * @param app */
	public static void invalidateAllMeshes (Application app) {
<span class="nc" id="L810">		Array&lt;Mesh&gt; meshesArray = meshes.get(app);</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">		if (meshesArray == null) return;</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">		for (int i = 0; i &lt; meshesArray.size; i++) {</span>
<span class="nc" id="L813">			meshesArray.get(i).vertices.invalidate();</span>
<span class="nc" id="L814">			meshesArray.get(i).indices.invalidate();</span>
		}
<span class="nc" id="L816">	}</span>

	/** Will clear the managed mesh cache. I wouldn't use this if i was you :) */
	public static void clearAllMeshes (Application app) {
<span class="nc" id="L820">		meshes.remove(app);</span>
<span class="nc" id="L821">	}</span>

	public static String getManagedStatus () {
<span class="nc" id="L824">		StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L825">		int i = 0;</span>
<span class="nc" id="L826">		builder.append(&quot;Managed meshes/app: { &quot;);</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">		for (Application app : meshes.keySet()) {</span>
<span class="nc" id="L828">			builder.append(meshes.get(app).size);</span>
<span class="nc" id="L829">			builder.append(&quot; &quot;);</span>
<span class="nc" id="L830">		}</span>
<span class="nc" id="L831">		builder.append(&quot;}&quot;);</span>
<span class="nc" id="L832">		return builder.toString();</span>
	}

	/** Method to scale the positions in the mesh. Normals will be kept as is. This is a potentially slow operation, use with care.
	 * It will also create a temporary float[] which will be garbage collected.
	 * 
	 * @param scaleX scale on x
	 * @param scaleY scale on y
	 * @param scaleZ scale on z */
	public void scale (float scaleX, float scaleY, float scaleZ) {
<span class="nc" id="L842">		final VertexAttribute posAttr = getVertexAttribute(Usage.Position);</span>
<span class="nc" id="L843">		final int offset = posAttr.offset / 4;</span>
<span class="nc" id="L844">		final int numComponents = posAttr.numComponents;</span>
<span class="nc" id="L845">		final int numVertices = getNumVertices();</span>
<span class="nc" id="L846">		final int vertexSize = getVertexSize() / 4;</span>

<span class="nc" id="L848">		final float[] vertices = new float[numVertices * vertexSize];</span>
<span class="nc" id="L849">		getVertices(vertices);</span>

<span class="nc" id="L851">		int idx = offset;</span>
<span class="nc bnc" id="L852" title="All 4 branches missed.">		switch (numComponents) {</span>
		case 1:
<span class="nc bnc" id="L854" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L855">				vertices[idx] *= scaleX;</span>
<span class="nc" id="L856">				idx += vertexSize;</span>
			}
<span class="nc" id="L858">			break;</span>
		case 2:
<span class="nc bnc" id="L860" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L861">				vertices[idx] *= scaleX;</span>
<span class="nc" id="L862">				vertices[idx + 1] *= scaleY;</span>
<span class="nc" id="L863">				idx += vertexSize;</span>
			}
<span class="nc" id="L865">			break;</span>
		case 3:
<span class="nc bnc" id="L867" title="All 2 branches missed.">			for (int i = 0; i &lt; numVertices; i++) {</span>
<span class="nc" id="L868">				vertices[idx] *= scaleX;</span>
<span class="nc" id="L869">				vertices[idx + 1] *= scaleY;</span>
<span class="nc" id="L870">				vertices[idx + 2] *= scaleZ;</span>
<span class="nc" id="L871">				idx += vertexSize;</span>
			}
			break;
		}

<span class="nc" id="L876">		setVertices(vertices);</span>
<span class="nc" id="L877">	}</span>

	/** Method to transform the positions in the mesh. Normals will be kept as is. This is a potentially slow operation, use with
	 * care. It will also create a temporary float[] which will be garbage collected.
	 * 
	 * @param matrix the transformation matrix */
	public void transform (final Matrix4 matrix) {
<span class="nc" id="L884">		transform(matrix, 0, getNumVertices());</span>
<span class="nc" id="L885">	}</span>

	// TODO: Protected for now, because transforming a portion works but still copies all vertices
	public void transform (final Matrix4 matrix, final int start, final int count) {
<span class="nc" id="L889">		final VertexAttribute posAttr = getVertexAttribute(Usage.Position);</span>
<span class="nc" id="L890">		final int posOffset = posAttr.offset / 4;</span>
<span class="nc" id="L891">		final int stride = getVertexSize() / 4;</span>
<span class="nc" id="L892">		final int numComponents = posAttr.numComponents;</span>
<span class="nc" id="L893">		final int numVertices = getNumVertices();</span>

<span class="nc" id="L895">		final float[] vertices = new float[count * stride];</span>
<span class="nc" id="L896">		getVertices(start * stride, count * stride, vertices);</span>
		// getVertices(0, vertices.length, vertices);
<span class="nc" id="L898">		transform(matrix, vertices, stride, posOffset, numComponents, 0, count);</span>
		// setVertices(vertices, 0, vertices.length);
<span class="nc" id="L900">		updateVertices(start * stride, vertices);</span>
<span class="nc" id="L901">	}</span>

	/** Method to transform the positions in the float array. Normals will be kept as is. This is a potentially slow operation, use
	 * with care.
	 * @param matrix the transformation matrix
	 * @param vertices the float array
	 * @param vertexSize the number of floats in each vertex
	 * @param offset the offset within a vertex to the position
	 * @param dimensions the size of the position
	 * @param start the vertex to start with
	 * @param count the amount of vertices to transform */
	public static void transform (final Matrix4 matrix, final float[] vertices, int vertexSize, int offset, int dimensions,
		int start, int count) {
<span class="nc bnc" id="L914" title="All 6 branches missed.">		if (offset &lt; 0 || dimensions &lt; 1 || (offset + dimensions) &gt; vertexSize) throw new IndexOutOfBoundsException();</span>
<span class="nc bnc" id="L915" title="All 6 branches missed.">		if (start &lt; 0 || count &lt; 1 || ((start + count) * vertexSize) &gt; vertices.length)</span>
<span class="nc" id="L916">			throw new IndexOutOfBoundsException(&quot;start = &quot; + start + &quot;, count = &quot; + count + &quot;, vertexSize = &quot; + vertexSize</span>
				+ &quot;, length = &quot; + vertices.length);

<span class="nc" id="L919">		final Vector3 tmp = new Vector3();</span>

<span class="nc" id="L921">		int idx = offset + (start * vertexSize);</span>
<span class="nc bnc" id="L922" title="All 4 branches missed.">		switch (dimensions) {</span>
		case 1:
<span class="nc bnc" id="L924" title="All 2 branches missed.">			for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L925">				tmp.set(vertices[idx], 0, 0).mul(matrix);</span>
<span class="nc" id="L926">				vertices[idx] = tmp.x;</span>
<span class="nc" id="L927">				idx += vertexSize;</span>
			}
<span class="nc" id="L929">			break;</span>
		case 2:
<span class="nc bnc" id="L931" title="All 2 branches missed.">			for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L932">				tmp.set(vertices[idx], vertices[idx + 1], 0).mul(matrix);</span>
<span class="nc" id="L933">				vertices[idx] = tmp.x;</span>
<span class="nc" id="L934">				vertices[idx + 1] = tmp.y;</span>
<span class="nc" id="L935">				idx += vertexSize;</span>
			}
<span class="nc" id="L937">			break;</span>
		case 3:
<span class="nc bnc" id="L939" title="All 2 branches missed.">			for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L940">				tmp.set(vertices[idx], vertices[idx + 1], vertices[idx + 2]).mul(matrix);</span>
<span class="nc" id="L941">				vertices[idx] = tmp.x;</span>
<span class="nc" id="L942">				vertices[idx + 1] = tmp.y;</span>
<span class="nc" id="L943">				vertices[idx + 2] = tmp.z;</span>
<span class="nc" id="L944">				idx += vertexSize;</span>
			}
			break;
		}
<span class="nc" id="L948">	}</span>

	/** Method to transform the texture coordinates in the mesh. This is a potentially slow operation, use with care. It will also
	 * create a temporary float[] which will be garbage collected.
	 * 
	 * @param matrix the transformation matrix */
	public void transformUV (final Matrix3 matrix) {
<span class="nc" id="L955">		transformUV(matrix, 0, getNumVertices());</span>
<span class="nc" id="L956">	}</span>

	// TODO: Protected for now, because transforming a portion works but still copies all vertices
	protected void transformUV (final Matrix3 matrix, final int start, final int count) {
<span class="nc" id="L960">		final VertexAttribute posAttr = getVertexAttribute(Usage.TextureCoordinates);</span>
<span class="nc" id="L961">		final int offset = posAttr.offset / 4;</span>
<span class="nc" id="L962">		final int vertexSize = getVertexSize() / 4;</span>
<span class="nc" id="L963">		final int numVertices = getNumVertices();</span>

<span class="nc" id="L965">		final float[] vertices = new float[numVertices * vertexSize];</span>
		// TODO: getVertices(vertices, start * vertexSize, count * vertexSize);
<span class="nc" id="L967">		getVertices(0, vertices.length, vertices);</span>
<span class="nc" id="L968">		transformUV(matrix, vertices, vertexSize, offset, start, count);</span>
<span class="nc" id="L969">		setVertices(vertices, 0, vertices.length);</span>
		// TODO: setVertices(start * vertexSize, vertices, 0, vertices.length);
<span class="nc" id="L971">	}</span>

	/** Method to transform the texture coordinates (UV) in the float array. This is a potentially slow operation, use with care.
	 * @param matrix the transformation matrix
	 * @param vertices the float array
	 * @param vertexSize the number of floats in each vertex
	 * @param offset the offset within a vertex to the texture location
	 * @param start the vertex to start with
	 * @param count the amount of vertices to transform */
	public static void transformUV (final Matrix3 matrix, final float[] vertices, int vertexSize, int offset, int start, int count) {
<span class="nc bnc" id="L981" title="All 6 branches missed.">		if (start &lt; 0 || count &lt; 1 || ((start + count) * vertexSize) &gt; vertices.length)</span>
<span class="nc" id="L982">			throw new IndexOutOfBoundsException(&quot;start = &quot; + start + &quot;, count = &quot; + count + &quot;, vertexSize = &quot; + vertexSize</span>
				+ &quot;, length = &quot; + vertices.length);

<span class="nc" id="L985">		final Vector2 tmp = new Vector2();</span>

<span class="nc" id="L987">		int idx = offset + (start * vertexSize);</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">		for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L989">			tmp.set(vertices[idx], vertices[idx + 1]).mul(matrix);</span>
<span class="nc" id="L990">			vertices[idx] = tmp.x;</span>
<span class="nc" id="L991">			vertices[idx + 1] = tmp.y;</span>
<span class="nc" id="L992">			idx += vertexSize;</span>
		}
<span class="nc" id="L994">	}</span>

	/** Copies this mesh optionally removing duplicate vertices and/or reducing the amount of attributes.
	 * @param isStatic whether the new mesh is static or not. Allows for internal optimizations.
	 * @param removeDuplicates whether to remove duplicate vertices if possible. Only the vertices specified by usage are checked.
	 * @param usage which attributes (if available) to copy
	 * @return the copy of this mesh */
	public Mesh copy (boolean isStatic, boolean removeDuplicates, final int[] usage) {
		// TODO move this to a copy constructor?
		// TODO duplicate the buffers without double copying the data if possible.
		// TODO perhaps move this code to JNI if it turns out being too slow.
<span class="nc" id="L1005">		final int vertexSize = getVertexSize() / 4;</span>
<span class="nc" id="L1006">		int numVertices = getNumVertices();</span>
<span class="nc" id="L1007">		float[] vertices = new float[numVertices * vertexSize];</span>
<span class="nc" id="L1008">		getVertices(0, vertices.length, vertices);</span>
<span class="nc" id="L1009">		short[] checks = null;</span>
<span class="nc" id="L1010">		VertexAttribute[] attrs = null;</span>
<span class="nc" id="L1011">		int newVertexSize = 0;</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">		if (usage != null) {</span>
<span class="nc" id="L1013">			int size = 0;</span>
<span class="nc" id="L1014">			int as = 0;</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">			for (int i = 0; i &lt; usage.length; i++)</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">				if (getVertexAttribute(usage[i]) != null) {</span>
<span class="nc" id="L1017">					size += getVertexAttribute(usage[i]).numComponents;</span>
<span class="nc" id="L1018">					as++;</span>
				}
<span class="nc bnc" id="L1020" title="All 2 branches missed.">			if (size &gt; 0) {</span>
<span class="nc" id="L1021">				attrs = new VertexAttribute[as];</span>
<span class="nc" id="L1022">				checks = new short[size];</span>
<span class="nc" id="L1023">				int idx = -1;</span>
<span class="nc" id="L1024">				int ai = -1;</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">				for (int i = 0; i &lt; usage.length; i++) {</span>
<span class="nc" id="L1026">					VertexAttribute a = getVertexAttribute(usage[i]);</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">					if (a == null) continue;</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">					for (int j = 0; j &lt; a.numComponents; j++)</span>
<span class="nc" id="L1029">						checks[++idx] = (short)(a.offset + j);</span>
<span class="nc" id="L1030">					attrs[++ai] = new VertexAttribute(a.usage, a.numComponents, a.alias);</span>
<span class="nc" id="L1031">					newVertexSize += a.numComponents;</span>
				}
			}
		}
<span class="nc bnc" id="L1035" title="All 2 branches missed.">		if (checks == null) {</span>
<span class="nc" id="L1036">			checks = new short[vertexSize];</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">			for (short i = 0; i &lt; vertexSize; i++)</span>
<span class="nc" id="L1038">				checks[i] = i;</span>
<span class="nc" id="L1039">			newVertexSize = vertexSize;</span>
		}

<span class="nc" id="L1042">		int numIndices = getNumIndices();</span>
<span class="nc" id="L1043">		short[] indices = null;</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">		if (numIndices &gt; 0) {</span>
<span class="nc" id="L1045">			indices = new short[numIndices];</span>
<span class="nc" id="L1046">			getIndices(indices);</span>
<span class="nc bnc" id="L1047" title="All 4 branches missed.">			if (removeDuplicates || newVertexSize != vertexSize) {</span>
<span class="nc" id="L1048">				float[] tmp = new float[vertices.length];</span>
<span class="nc" id="L1049">				int size = 0;</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">				for (int i = 0; i &lt; numIndices; i++) {</span>
<span class="nc" id="L1051">					final int idx1 = indices[i] * vertexSize;</span>
<span class="nc" id="L1052">					short newIndex = -1;</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">					if (removeDuplicates) {</span>
<span class="nc bnc" id="L1054" title="All 4 branches missed.">						for (short j = 0; j &lt; size &amp;&amp; newIndex &lt; 0; j++) {</span>
<span class="nc" id="L1055">							final int idx2 = j * newVertexSize;</span>
<span class="nc" id="L1056">							boolean found = true;</span>
<span class="nc bnc" id="L1057" title="All 4 branches missed.">							for (int k = 0; k &lt; checks.length &amp;&amp; found; k++) {</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">								if (tmp[idx2 + k] != vertices[idx1 + checks[k]]) found = false;</span>
							}
<span class="nc bnc" id="L1060" title="All 2 branches missed.">							if (found) newIndex = j;</span>
						}
					}
<span class="nc bnc" id="L1063" title="All 2 branches missed.">					if (newIndex &gt; 0)</span>
<span class="nc" id="L1064">						indices[i] = newIndex;</span>
					else {
<span class="nc" id="L1066">						final int idx = size * newVertexSize;</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">						for (int j = 0; j &lt; checks.length; j++)</span>
<span class="nc" id="L1068">							tmp[idx + j] = vertices[idx1 + checks[j]];</span>
<span class="nc" id="L1069">						indices[i] = (short)size;</span>
<span class="nc" id="L1070">						size++;</span>
					}
				}
<span class="nc" id="L1073">				vertices = tmp;</span>
<span class="nc" id="L1074">				numVertices = size;</span>
			}
		}

		Mesh result;
<span class="nc bnc" id="L1079" title="All 2 branches missed.">		if (attrs == null)</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">			result = new Mesh(isStatic, numVertices, indices == null ? 0 : indices.length, getVertexAttributes());</span>
		else
<span class="nc bnc" id="L1082" title="All 2 branches missed.">			result = new Mesh(isStatic, numVertices, indices == null ? 0 : indices.length, attrs);</span>
<span class="nc" id="L1083">		result.setVertices(vertices, 0, numVertices * newVertexSize);</span>
<span class="nc" id="L1084">		result.setIndices(indices);</span>
<span class="nc" id="L1085">		return result;</span>
	}

	/** Copies this mesh.
	 * @param isStatic whether the new mesh is static or not. Allows for internal optimizations.
	 * @return the copy of this mesh */
	public Mesh copy (boolean isStatic) {
<span class="nc" id="L1092">		return copy(isStatic, false, null);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>