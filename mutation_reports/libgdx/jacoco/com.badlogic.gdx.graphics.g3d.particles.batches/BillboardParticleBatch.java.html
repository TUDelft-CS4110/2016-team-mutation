<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BillboardParticleBatch.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.graphics.g3d.particles.batches</a> &gt; <span class="el_source">BillboardParticleBatch.java</span></div><h1>BillboardParticleBatch.java</h1><pre class="source lang-java linenums">package com.badlogic.gdx.graphics.g3d.particles.batches;

import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Mesh;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.VertexAttribute;
import com.badlogic.gdx.graphics.VertexAttributes;
import com.badlogic.gdx.graphics.VertexAttributes.Usage;
import com.badlogic.gdx.graphics.g3d.Material;
import com.badlogic.gdx.graphics.g3d.Renderable;
import com.badlogic.gdx.graphics.g3d.Shader;
import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.DepthTestAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
import com.badlogic.gdx.graphics.g3d.particles.ParticleShader;
import com.badlogic.gdx.graphics.g3d.particles.ParticleShader.AlignMode;
import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
import com.badlogic.gdx.graphics.g3d.particles.ResourceData.SaveData;
import com.badlogic.gdx.graphics.g3d.particles.renderers.BillboardControllerRenderData;
import com.badlogic.gdx.graphics.g3d.shaders.DefaultShader;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Matrix3;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Pool;


/** This class is used to render billboard particles.
 * @author Inferno */
public class BillboardParticleBatch extends BufferedParticleBatch&lt;BillboardControllerRenderData&gt; {
<span class="nc" id="L35">	protected static final Vector3 TMP_V1 = new Vector3(),</span>
<span class="nc" id="L36">		TMP_V2 = new Vector3(),</span>
<span class="nc" id="L37">		TMP_V3 = new Vector3(),</span>
<span class="nc" id="L38">		TMP_V4 = new Vector3(),</span>
<span class="nc" id="L39">		TMP_V5 = new Vector3(),</span>
<span class="nc" id="L40">		TMP_V6 = new Vector3();</span>
<span class="nc" id="L41">	protected static final Matrix3 TMP_M3 = new Matrix3();</span>
	//Attributes
	protected static final int sizeAndRotationUsage = 1 &lt;&lt; 9, directionUsage = 1 &lt;&lt; 10;
	private static final VertexAttributes
<span class="nc" id="L45">	GPU_ATTRIBUTES = new VertexAttributes(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE),</span>
		new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE+&quot;0&quot;),
		new VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE),
		new VertexAttribute(sizeAndRotationUsage, 4, &quot;a_sizeAndRotation&quot;)),
		/*
		GPU_EXT_ATTRIBUTES = new VertexAttributes(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE),
									new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE+&quot;0&quot;),
									new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE),
									new VertexAttribute(sizeAndRotationUsage, 4, &quot;a_sizeAndRotation&quot;),
									new VertexAttribute(directionUsage, 3, &quot;a_direction&quot;)),
		 */
<span class="nc" id="L56">		CPU_ATTRIBUTES = new VertexAttributes(	new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE),</span>
			new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE+&quot;0&quot;),
			new VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE) );

	//Offsets
<span class="nc" id="L61">	private static final int 	GPU_POSITION_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(Usage.Position).offset/4),</span>
<span class="nc" id="L62">		GPU_UV_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(Usage.TextureCoordinates).offset/4),</span>
<span class="nc" id="L63">		GPU_SIZE_ROTATION_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(sizeAndRotationUsage).offset/4),</span>
<span class="nc" id="L64">		GPU_COLOR_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(Usage.ColorUnpacked).offset/4),</span>
<span class="nc" id="L65">		GPU_VERTEX_SIZE = GPU_ATTRIBUTES.vertexSize/4,</span>

		//Ext
		/*
										GPU_EXT_POSITION_OFFSET = (short)(GPU_EXT_ATTRIBUTES.findByUsage(Usage.Position).offset/4),
										GPU_EXT_UV_OFFSET = (short)(GPU_EXT_ATTRIBUTES.findByUsage(Usage.TextureCoordinates).offset/4),
										GPU_EXT_SIZE_ROTATION_OFFSET = (short)(GPU_EXT_ATTRIBUTES.findByUsage(sizeAndRotationUsage).offset/4),
										GPU_EXT_COLOR_OFFSET = (short)(GPU_EXT_ATTRIBUTES.findByUsage(Usage.Color).offset/4),
										GPU_EXT_DIRECTION_OFFSET = (short)(GPU_EXT_ATTRIBUTES.findByUsage(directionUsage).offset/4),
										GPU_EXT_VERTEX_SIZE = GPU_EXT_ATTRIBUTES.vertexSize/4,
		 */

		//Cpu
<span class="nc" id="L78">		CPU_POSITION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Position).offset/4),</span>
<span class="nc" id="L79">		CPU_UV_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.TextureCoordinates).offset/4),</span>
<span class="nc" id="L80">		CPU_COLOR_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.ColorUnpacked).offset/4),</span>
<span class="nc" id="L81">		CPU_VERTEX_SIZE= CPU_ATTRIBUTES.vertexSize/4;</span>
	private final static int 	MAX_PARTICLES_PER_MESH = Short.MAX_VALUE/4,
		MAX_VERTICES_PER_MESH = MAX_PARTICLES_PER_MESH*4;

	private class RenderablePool extends Pool&lt;Renderable&gt;{
<span class="nc" id="L86">		public RenderablePool () {}</span>

		@Override
		public Renderable newObject () {
<span class="nc" id="L90">			return allocRenderable();</span>
		}
	}

	public static class Config{
<span class="nc" id="L95">		public Config(){}</span>
<span class="nc" id="L96">		public Config (boolean useGPU, AlignMode mode) {</span>
<span class="nc" id="L97">			this.useGPU = useGPU;</span>
<span class="nc" id="L98">			this.mode = mode;</span>
<span class="nc" id="L99">		}</span>
		boolean useGPU;
		AlignMode mode;
	}

	private RenderablePool renderablePool;
	private Array&lt;Renderable&gt; renderables;
	private float[] vertices;
	private short[] indices;
<span class="nc" id="L108">	private int currentVertexSize = 0;</span>
	private VertexAttributes currentAttributes;
<span class="nc" id="L110">	protected boolean useGPU = false;</span>
<span class="nc" id="L111">	protected AlignMode mode = AlignMode.Screen;</span>
	protected Texture texture;
	protected BlendingAttribute blendingAttribute;
	protected DepthTestAttribute depthTestAttribute;
	Shader shader;

	/**
	 * Create a new BillboardParticleBatch
	 * @param mode
	 * @param useGPU Allow to use GPU instead of CPU
	 * @param capacity Max particle displayed
	 * @param blendingAttribute Blending attribute used by the batch
	 * @param depthTestAttribute DepthTest attribute used by the batch
	 */
	public BillboardParticleBatch(AlignMode mode, boolean useGPU, int capacity,
		BlendingAttribute blendingAttribute,
		DepthTestAttribute depthTestAttribute) {
<span class="nc" id="L128">		super(BillboardControllerRenderData.class);</span>
<span class="nc" id="L129">		renderables = new Array&lt;Renderable&gt;();</span>
<span class="nc" id="L130">		renderablePool = new RenderablePool();</span>
<span class="nc" id="L131">		this.blendingAttribute = blendingAttribute;</span>
<span class="nc" id="L132">		this.depthTestAttribute = depthTestAttribute;</span>

<span class="nc bnc" id="L134" title="All 2 branches missed.">		if( this.blendingAttribute == null )</span>
<span class="nc" id="L135">			this.blendingAttribute = new BlendingAttribute(GL20.GL_ONE, GL20.GL_ONE_MINUS_SRC_ALPHA, 1f);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">		if( this.depthTestAttribute == null )</span>
<span class="nc" id="L137">			this.depthTestAttribute = new DepthTestAttribute(GL20.GL_LEQUAL, false);</span>

<span class="nc" id="L139">		allocIndices();</span>
<span class="nc" id="L140">		initRenderData();</span>
<span class="nc" id="L141">		ensureCapacity(capacity);</span>
<span class="nc" id="L142">		setUseGpu(useGPU);</span>
<span class="nc" id="L143">		setAlignMode(mode);</span>
<span class="nc" id="L144">	}</span>

	public BillboardParticleBatch(AlignMode mode, boolean useGPU, int capacity){
<span class="nc" id="L147">		this(mode, useGPU, capacity, null, null);</span>
<span class="nc" id="L148">	}</span>

	public BillboardParticleBatch () {
<span class="nc" id="L151">		this(AlignMode.Screen, false, 100);</span>
<span class="nc" id="L152">	}</span>

	public BillboardParticleBatch (int capacity) {
<span class="nc" id="L155">		this(AlignMode.Screen, false, capacity);</span>
<span class="nc" id="L156">	}</span>

	@Override
	public void allocParticlesData(int capacity){
<span class="nc" id="L160">		vertices = new float[currentVertexSize*4*capacity];</span>
<span class="nc" id="L161">		allocRenderables(capacity);</span>
<span class="nc" id="L162">	}</span>

	protected Renderable allocRenderable(){
<span class="nc" id="L165">		Renderable renderable = new Renderable();</span>
<span class="nc" id="L166">		renderable.meshPart.primitiveType = GL20.GL_TRIANGLES;</span>
<span class="nc" id="L167">		renderable.meshPart.offset = 0;</span>
<span class="nc" id="L168">		renderable.material = new Material(this.blendingAttribute, this.depthTestAttribute,</span>
			TextureAttribute.createDiffuse(texture));
<span class="nc" id="L170">		renderable.meshPart.mesh = new Mesh(false, MAX_VERTICES_PER_MESH, MAX_PARTICLES_PER_MESH*6, currentAttributes);</span>
<span class="nc" id="L171">		renderable.meshPart.mesh.setIndices(indices);</span>
<span class="nc" id="L172">		renderable.shader = shader;</span>
<span class="nc" id="L173">		return renderable;</span>
	}

	private void allocIndices(){
<span class="nc" id="L177">		int indicesCount = MAX_PARTICLES_PER_MESH * 6;</span>
<span class="nc" id="L178">		indices = new short[indicesCount];</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">		for(int i=0, vertex = 0; i &lt; indicesCount; i+=6, vertex+=4){</span>
<span class="nc" id="L180">			indices[i] = (short)vertex;</span>
<span class="nc" id="L181">			indices[i+1] = (short)(vertex+1);</span>
<span class="nc" id="L182">			indices[i+2] = (short)(vertex+2);</span>
<span class="nc" id="L183">			indices[i+3] = (short)(vertex+2);</span>
<span class="nc" id="L184">			indices[i+4] = (short)(vertex+3);</span>
<span class="nc" id="L185">			indices[i+5] = (short)vertex;</span>
		}
<span class="nc" id="L187">	}</span>

	private void allocRenderables(int capacity){
		//Free old meshes
<span class="nc" id="L191">		int 	meshCount = MathUtils.ceil( capacity/MAX_PARTICLES_PER_MESH),</span>
<span class="nc" id="L192">			free = renderablePool.getFree();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">		if(free &lt; meshCount){</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">			for(int i=0, left = meshCount - free; i &lt; left;++i)</span>
<span class="nc" id="L195">				renderablePool.free(renderablePool.newObject());</span>
		}
<span class="nc" id="L197">	}</span>

	private Shader getShader (Renderable renderable) {
<span class="nc bnc" id="L200" title="All 2 branches missed.">		Shader shader = useGPU 	? 	new ParticleShader(renderable, new ParticleShader.Config(mode)) :</span>
			new DefaultShader(renderable);
<span class="nc" id="L202">		shader.init();</span>
<span class="nc" id="L203">		return shader;</span>
	}

	private void allocShader () {
<span class="nc" id="L207">		Renderable newRenderable = allocRenderable();</span>
<span class="nc" id="L208">		shader = newRenderable.shader = getShader(newRenderable);</span>
<span class="nc" id="L209">		renderablePool.free(newRenderable);</span>
<span class="nc" id="L210">	}</span>

	private void clearRenderablesPool(){
<span class="nc" id="L213">		renderablePool.freeAll(renderables);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">		for(int i=0, free = renderablePool.getFree(); i &lt; free; ++i){</span>
<span class="nc" id="L215">			Renderable renderable = renderablePool.obtain();</span>
<span class="nc" id="L216">			renderable.meshPart.mesh.dispose();</span>
		}
<span class="nc" id="L218">		renderables.clear();</span>
<span class="nc" id="L219">	}</span>

	/** Sets vertex attributes and size */
	public void setVertexData(){
<span class="nc bnc" id="L223" title="All 2 branches missed.">		if(useGPU){</span>
<span class="nc" id="L224">			currentAttributes = GPU_ATTRIBUTES;</span>
<span class="nc" id="L225">			currentVertexSize = GPU_VERTEX_SIZE;</span>
			/*
			if(mode == AlignMode.ParticleDirection){
				currentAttributes = GPU_EXT_ATTRIBUTES;
				currentVertexSize = GPU_EXT_VERTEX_SIZE;
			}
			else{
				currentAttributes = GPU_ATTRIBUTES;
				currentVertexSize = GPU_VERTEX_SIZE;
			}
			 */
		}
		else {
<span class="nc" id="L238">			currentAttributes = CPU_ATTRIBUTES;</span>
<span class="nc" id="L239">			currentVertexSize = CPU_VERTEX_SIZE;</span>
		}
<span class="nc" id="L241">	}</span>

	/** Allocates all the require rendering resources like Renderables,Shaders,Meshes
	 *  according to the current batch configuration.*/
	private void initRenderData () {
<span class="nc" id="L246">		setVertexData();</span>
<span class="nc" id="L247">		clearRenderablesPool();</span>
<span class="nc" id="L248">		allocShader();</span>
<span class="nc" id="L249">		resetCapacity();</span>
<span class="nc" id="L250">	}</span>

	/** Sets the current align mode.
	 *  It will reallocate internal data, use only when necessary. */
	public void setAlignMode(AlignMode mode){
<span class="nc bnc" id="L255" title="All 2 branches missed.">		if(mode != this.mode){</span>
<span class="nc" id="L256">			this.mode = mode;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">			if(useGPU){</span>
<span class="nc" id="L258">				initRenderData();</span>
<span class="nc" id="L259">				allocRenderables(bufferedParticlesCount);</span>
			}
		}
<span class="nc" id="L262">	}</span>

	public AlignMode getAlignMode(){
<span class="nc" id="L265">		return mode;</span>
	}

	/** Sets the current align mode.
	 *  It will reallocate internal data, use only when necessary. */
	public void setUseGpu(boolean useGPU){
<span class="nc bnc" id="L271" title="All 2 branches missed.">		if(this.useGPU != useGPU){</span>
<span class="nc" id="L272">			this.useGPU = useGPU;</span>
<span class="nc" id="L273">			initRenderData();</span>
<span class="nc" id="L274">			allocRenderables(bufferedParticlesCount);</span>
		}
<span class="nc" id="L276">	}</span>

	public boolean isUseGPU(){
<span class="nc" id="L279">		return useGPU;</span>
	}

	public void setTexture(Texture texture){
<span class="nc" id="L283">		renderablePool.freeAll(renderables);</span>
<span class="nc" id="L284">		renderables.clear();</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">		for(int i=0, free = renderablePool.getFree(); i &lt; free; ++i){</span>
<span class="nc" id="L286">			Renderable renderable = renderablePool.obtain();</span>
<span class="nc" id="L287">			TextureAttribute attribute = (TextureAttribute) renderable.material.get(TextureAttribute.Diffuse);</span>
<span class="nc" id="L288">			attribute.textureDescription.texture = texture;</span>
		}
<span class="nc" id="L290">		this.texture = texture;</span>
<span class="nc" id="L291">	}</span>

	public Texture getTexture () {
<span class="nc" id="L294">		return texture;</span>
	}

	@Override
	public void begin () {
<span class="nc" id="L299">		super.begin();</span>
<span class="nc" id="L300">		renderablePool.freeAll(renderables);</span>
<span class="nc" id="L301">		renderables.clear();</span>
<span class="nc" id="L302">	}</span>

	//GPU
	//Required + Color + Rotation
	private static void putVertex( float[] vertices,  int offset, float x, float y, float z, float u, float v, float scaleX, float scaleY,  float cosRotation, float sinRotation, float r, float g, float b, float a) {
		//Position
<span class="nc" id="L308">		vertices[offset + GPU_POSITION_OFFSET] = x;</span>
<span class="nc" id="L309">		vertices[offset + GPU_POSITION_OFFSET+1] = y;</span>
<span class="nc" id="L310">		vertices[offset + GPU_POSITION_OFFSET+2] = z;</span>
		//UV
<span class="nc" id="L312">		vertices[offset + GPU_UV_OFFSET] = u;</span>
<span class="nc" id="L313">		vertices[offset + GPU_UV_OFFSET+1] = v;</span>
		//Scale
<span class="nc" id="L315">		vertices[offset + GPU_SIZE_ROTATION_OFFSET] = scaleX;</span>
<span class="nc" id="L316">		vertices[offset + GPU_SIZE_ROTATION_OFFSET+1] = scaleY;</span>
<span class="nc" id="L317">		vertices[offset + GPU_SIZE_ROTATION_OFFSET+2] = cosRotation;</span>
<span class="nc" id="L318">		vertices[offset + GPU_SIZE_ROTATION_OFFSET+3] = sinRotation;</span>
		//Color
<span class="nc" id="L320">		vertices[offset + GPU_COLOR_OFFSET] = r;</span>
<span class="nc" id="L321">		vertices[offset + GPU_COLOR_OFFSET+1] = g;</span>
<span class="nc" id="L322">		vertices[offset + GPU_COLOR_OFFSET+2] = b;</span>
<span class="nc" id="L323">		vertices[offset + GPU_COLOR_OFFSET+3] = a;</span>
<span class="nc" id="L324">	}</span>

	/*
	//Required + Color + Rotation + Direction
	private static void putVertex( float[] vertices,  int offset, float x, float y, float z, float u, float v, float scaleX, float scaleY,  float cosRotation, float sinRotation, float r, float g, float b, float a, Vector3 direction) {
		//Position
		vertices[offset + GPU_EXT_POSITION_OFFSET] = x;
		vertices[offset + GPU_EXT_POSITION_OFFSET+1] = y;
		vertices[offset + GPU_EXT_POSITION_OFFSET+2] = z;
		//UV
		vertices[offset + GPU_EXT_UV_OFFSET] = u;
		vertices[offset + GPU_EXT_UV_OFFSET+1] = v;
		//Scale
		vertices[offset + GPU_EXT_SIZE_ROTATION_OFFSET] = scaleX;
		vertices[offset + GPU_EXT_SIZE_ROTATION_OFFSET+1] = scaleY;
		vertices[offset + GPU_EXT_SIZE_ROTATION_OFFSET+2] = cosRotation;
		vertices[offset + GPU_EXT_SIZE_ROTATION_OFFSET+3] = sinRotation;
		//Color
		vertices[offset + GPU_EXT_COLOR_OFFSET] = r;
		vertices[offset + GPU_EXT_COLOR_OFFSET+1] = g;
		vertices[offset + GPU_EXT_COLOR_OFFSET+2] = b;
		vertices[offset + GPU_EXT_COLOR_OFFSET+3] = a;
		//Direction
		vertices[offset + GPU_EXT_DIRECTION_OFFSET] = direction.x;
		vertices[offset + GPU_EXT_DIRECTION_OFFSET +1] = direction.y;
		vertices[offset + GPU_EXT_DIRECTION_OFFSET +2] = direction.z;
	}
	 */


	//CPU
	//Required
	private static void putVertex(float[] vertices, int offset, Vector3 p, float u, float v, float r, float g, float b, float a) {
		//Position
<span class="nc" id="L358">		vertices[offset + CPU_POSITION_OFFSET] = p.x;</span>
<span class="nc" id="L359">		vertices[offset + CPU_POSITION_OFFSET+1] = p.y;</span>
<span class="nc" id="L360">		vertices[offset + CPU_POSITION_OFFSET+2] = p.z;</span>
		//UV
<span class="nc" id="L362">		vertices[offset + CPU_UV_OFFSET] = u;</span>
<span class="nc" id="L363">		vertices[offset + CPU_UV_OFFSET+1] = v;</span>
		//Color
<span class="nc" id="L365">		vertices[offset + CPU_COLOR_OFFSET] = r;</span>
<span class="nc" id="L366">		vertices[offset + CPU_COLOR_OFFSET+1] = g;</span>
<span class="nc" id="L367">		vertices[offset + CPU_COLOR_OFFSET+2] = b;</span>
<span class="nc" id="L368">		vertices[offset + CPU_COLOR_OFFSET+3] = a;</span>
<span class="nc" id="L369">	}</span>

	private void fillVerticesGPU (int[] particlesOffset) {
<span class="nc" id="L372">		int tp=0;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">		for(BillboardControllerRenderData data : renderData){</span>
<span class="nc" id="L374">			FloatChannel scaleChannel = data.scaleChannel;</span>
<span class="nc" id="L375">			FloatChannel regionChannel = data.regionChannel;</span>
<span class="nc" id="L376">			FloatChannel positionChannel = data.positionChannel;</span>
<span class="nc" id="L377">			FloatChannel colorChannel = data.colorChannel;</span>
<span class="nc" id="L378">			FloatChannel rotationChannel = data.rotationChannel;</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">			for(int p=0, c = data.controller.particles.size; p &lt; c; ++p, ++tp){</span>
<span class="nc" id="L380">				int baseOffset = particlesOffset[tp]*currentVertexSize*4;</span>
<span class="nc" id="L381">				float scale = scaleChannel.data[p* scaleChannel.strideSize];</span>
<span class="nc" id="L382">				int regionOffset = p*regionChannel.strideSize;</span>
<span class="nc" id="L383">				int positionOffset = p*positionChannel.strideSize;</span>
<span class="nc" id="L384">				int colorOffset = p*colorChannel.strideSize;</span>
<span class="nc" id="L385">				int rotationOffset = p*rotationChannel.strideSize;</span>
<span class="nc" id="L386">				float 	px = positionChannel.data[positionOffset + ParticleChannels.XOffset],</span>
<span class="nc" id="L387">					py = positionChannel.data[positionOffset + ParticleChannels.YOffset],</span>
<span class="nc" id="L388">					pz = positionChannel.data[positionOffset + ParticleChannels.ZOffset];</span>
<span class="nc" id="L389">				float u = regionChannel.data[regionOffset +ParticleChannels.UOffset];</span>
<span class="nc" id="L390">				float v = regionChannel.data[regionOffset +ParticleChannels.VOffset];</span>
<span class="nc" id="L391">				float u2 = regionChannel.data[regionOffset +ParticleChannels.U2Offset];</span>
<span class="nc" id="L392">				float v2 = regionChannel.data[regionOffset +ParticleChannels.V2Offset];</span>
<span class="nc" id="L393">				float 	sx = regionChannel.data[regionOffset +ParticleChannels.HalfWidthOffset] * scale,</span>
<span class="nc" id="L394">					sy = regionChannel.data[regionOffset+ParticleChannels.HalfHeightOffset]  * scale;</span>
<span class="nc" id="L395">				float r = colorChannel.data[colorOffset +ParticleChannels.RedOffset];</span>
<span class="nc" id="L396">				float g = colorChannel.data[colorOffset +ParticleChannels.GreenOffset];</span>
<span class="nc" id="L397">				float b = colorChannel.data[colorOffset +ParticleChannels.BlueOffset];</span>
<span class="nc" id="L398">				float a = colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];</span>
<span class="nc" id="L399">				float cosRotation = rotationChannel.data[rotationOffset +ParticleChannels.CosineOffset];</span>
<span class="nc" id="L400">				float sinRotation = rotationChannel.data[rotationOffset +ParticleChannels.SineOffset];</span>

				//bottom left, bottom right, top right, top left
<span class="nc" id="L403">				putVertex(vertices, baseOffset, px, py, pz, u, v2, -sx, -sy, cosRotation, sinRotation, r, g, b, a);</span>
<span class="nc" id="L404">				baseOffset += currentVertexSize;</span>
<span class="nc" id="L405">				putVertex(vertices, baseOffset, px, py, pz, u2, v2, sx, -sy, cosRotation, sinRotation, r, g, b, a);</span>
<span class="nc" id="L406">				baseOffset += currentVertexSize;</span>
<span class="nc" id="L407">				putVertex(vertices, baseOffset, px, py, pz, u2, v, sx, sy, cosRotation, sinRotation, r, g, b, a);</span>
<span class="nc" id="L408">				baseOffset += currentVertexSize;</span>
<span class="nc" id="L409">				putVertex(vertices, baseOffset, px, py, pz, u, v, -sx, sy, cosRotation, sinRotation, r, g, b, a);</span>
<span class="nc" id="L410">				baseOffset += currentVertexSize;</span>
			}
<span class="nc" id="L412">		}</span>
<span class="nc" id="L413">	}</span>

	/*
	private void fillVerticesToParticleDirectionGPU (int[] particlesOffset) {
		int tp=0;
		for(BillboardControllerRenderData data : renderData){
			FloatChannel scaleChannel = data.scaleChannel;
			FloatChannel regionChannel = data.regionChannel;
			FloatChannel positionChannel = data.positionChannel;
			FloatChannel colorChannel = data.colorChannel;
			FloatChannel rotationChannel = data.rotationChannel;

			for(int p=0, c = data.controller.particles.size; p &lt; c; ++p, ++tp){
				int baseOffset = particlesOffset[tp]*currentVertexSize*4;
				float scale = scaleChannel.data[p* scaleChannel.strideSize];
				int regionOffset = p*regionChannel.strideSize;
				int positionOffset = p*positionChannel.strideSize;
				int colorOffset = p*colorChannel.strideSize;
				int rotationOffset = p*rotationChannel.strideSize;
				int velocityOffset = p* velocityChannel.strideSize;
				float 	px = positionChannel.data[positionOffset + ParticleChannels.XOffset],
					py = positionChannel.data[positionOffset + ParticleChannels.YOffset],
					pz = positionChannel.data[positionOffset + ParticleChannels.ZOffset];
				float u = regionChannel.data[regionOffset +ParticleChannels.UOffset];
				float v = regionChannel.data[regionOffset +ParticleChannels.VOffset];
				float u2 = regionChannel.data[regionOffset +ParticleChannels.U2Offset];
				float v2 = regionChannel.data[regionOffset +ParticleChannels.V2Offset];
				float 	sx = regionChannel.data[regionOffset +ParticleChannels.HalfWidthOffset] * scale,
							sy = regionChannel.data[regionOffset+ParticleChannels.HalfHeightOffset]  * scale;
				float r = colorChannel.data[colorOffset +ParticleChannels.RedOffset];
				float g = colorChannel.data[colorOffset +ParticleChannels.GreenOffset];
				float b = colorChannel.data[colorOffset +ParticleChannels.BlueOffset];
				float a = colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];
				float cosRotation = rotationChannel.data[rotationOffset +ParticleChannels.CosineOffset];
				float sinRotation = rotationChannel.data[rotationOffset +ParticleChannels.SineOffset];
				float 	vx = velocityChannel.data[velocityOffset + ParticleChannels.XOffset],
							vy = velocityChannel.data[velocityOffset + ParticleChannels.YOffset],
							vz = velocityChannel.data[velocityOffset + ParticleChannels.ZOffset];

				//bottom left, bottom right, top right, top left
				TMP_V1.set(vx, vy, vz).nor();
				putVertex(vertices, baseOffset, px, py, pz, u, v2, -sx, -sy, cosRotation, sinRotation, r, g, b, a, TMP_V1);
				baseOffset += currentVertexSize;
				putVertex(vertices, baseOffset, px, py, pz, u2, v2, sx, -sy, cosRotation, sinRotation, r, g, b, a, TMP_V1);
				baseOffset += currentVertexSize;
				putVertex(vertices, baseOffset, px, py, pz, u2, v, sx, sy, cosRotation, sinRotation, r, g, b, a, TMP_V1);
				baseOffset += currentVertexSize;
				putVertex(vertices, baseOffset, px, py, pz, u, v, -sx, sy, cosRotation, sinRotation, r, g, b, a, TMP_V1);
			}
		}
	}

	private void fillVerticesToParticleDirectionCPU (int[] particlesOffset) {
		int tp=0;
		for(ParticleController controller : renderData){
			FloatChannel scaleChannel = controller.particles.getChannel(ParticleChannels.Scale);
			FloatChannel regionChannel = controller.particles.getChannel(ParticleChannels.TextureRegion);
			FloatChannel positionChannel = controller.particles.getChannel(ParticleChannels.Position);
			FloatChannel colorChannel = controller.particles.getChannel(ParticleChannels.Color);
			FloatChannel rotationChannel = controller.particles.getChannel(ParticleChannels.Rotation2D);
			FloatChannel velocityChannel = controller.particles.getChannel(ParticleChannels.Accelleration);

			for(int p=0, c = controller.particles.size; p &lt; c; ++p, ++tp){
				int baseOffset = particlesOffset[tp]*currentVertexSize*4;
				float scale = scaleChannel.data[p* scaleChannel.strideSize];
				int regionOffset = p*regionChannel.strideSize;
				int positionOffset = p*positionChannel.strideSize;
				int colorOffset = p*colorChannel.strideSize;
				int rotationOffset = p*rotationChannel.strideSize;
				int velocityOffset = p* velocityChannel.strideSize;
				float 	px = positionChannel.data[positionOffset + ParticleChannels.XOffset],
					py = positionChannel.data[positionOffset + ParticleChannels.YOffset],
					pz = positionChannel.data[positionOffset + ParticleChannels.ZOffset];
				float u = regionChannel.data[regionOffset +ParticleChannels.UOffset];
				float v = regionChannel.data[regionOffset +ParticleChannels.VOffset];
				float u2 = regionChannel.data[regionOffset +ParticleChannels.U2Offset];
				float v2 = regionChannel.data[regionOffset +ParticleChannels.V2Offset];
				float 	sx = regionChannel.data[regionOffset +ParticleChannels.HalfWidthOffset] * scale,
							sy = regionChannel.data[regionOffset+ParticleChannels.HalfHeightOffset]  * scale;
				float r = colorChannel.data[colorOffset +ParticleChannels.RedOffset];
				float g = colorChannel.data[colorOffset +ParticleChannels.GreenOffset];
				float b = colorChannel.data[colorOffset +ParticleChannels.BlueOffset];
				float a = colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];
				float cosRotation = rotationChannel.data[rotationOffset +ParticleChannels.CosineOffset];
				float sinRotation = rotationChannel.data[rotationOffset +ParticleChannels.SineOffset];
				float 	vx = velocityChannel.data[velocityOffset + ParticleChannels.XOffset],
							vy = velocityChannel.data[velocityOffset + ParticleChannels.YOffset],
							vz = velocityChannel.data[velocityOffset + ParticleChannels.ZOffset];
				Vector3 up = TMP_V1.set(vx,vy,vz).nor(),
								look = TMP_V3.set(camera.position).sub(px,py,pz).nor(), //normal
								right = TMP_V2.set(up).crs(look).nor(); //tangent
				look.set(right).crs(up).nor();
				right.scl(sx);
				up.scl(sy);

				if(cosRotation != 1){
					TMP_M3.setToRotation(look, cosRotation, sinRotation);
					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x-TMP_V2.x, -TMP_V1.y-TMP_V2.y, -TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v2, r, g, b, a);
					baseOffset += currentVertexSize;
					putVertex(vertices, baseOffset,TMP_V6.set(TMP_V1.x-TMP_V2.x, TMP_V1.y-TMP_V2.y, TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v2, r, g, b, a);
					baseOffset += currentVertexSize;
					putVertex(vertices, baseOffset,TMP_V6.set(TMP_V1.x+TMP_V2.x, TMP_V1.y+TMP_V2.y, TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v, r, g, b, a);
					baseOffset += currentVertexSize;
					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x, -TMP_V1.y+TMP_V2.y, -TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v, r, g, b, a);
				}
				else {
					putVertex(vertices, baseOffset,TMP_V6.set(-TMP_V1.x-TMP_V2.x+px, -TMP_V1.y-TMP_V2.y+py, -TMP_V1.z-TMP_V2.z+pz), u, v2, r, g, b, a);
					baseOffset += currentVertexSize;
					putVertex(vertices, baseOffset,TMP_V6.set(TMP_V1.x-TMP_V2.x+px, TMP_V1.y-TMP_V2.y+py, TMP_V1.z-TMP_V2.z+pz), u2, v2, r, g, b, a);
					baseOffset += currentVertexSize;
					putVertex(vertices, baseOffset,TMP_V6.set(TMP_V1.x+TMP_V2.x+px, TMP_V1.y+TMP_V2.y+py, TMP_V1.z+TMP_V2.z+pz), u2, v, r, g, b, a);
					baseOffset += currentVertexSize;
					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x+px, -TMP_V1.y+TMP_V2.y+py, -TMP_V1.z+TMP_V2.z+pz), u, v, r, g, b, a);
				}
			}
		}
	}
	 */

	private void fillVerticesToViewPointCPU (int[] particlesOffset) {
<span class="nc" id="L533">		int tp=0;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">		for(BillboardControllerRenderData data : renderData){</span>
<span class="nc" id="L535">			FloatChannel scaleChannel = data.scaleChannel;</span>
<span class="nc" id="L536">			FloatChannel regionChannel = data.regionChannel;</span>
<span class="nc" id="L537">			FloatChannel positionChannel = data.positionChannel;</span>
<span class="nc" id="L538">			FloatChannel colorChannel = data.colorChannel;</span>
<span class="nc" id="L539">			FloatChannel rotationChannel = data.rotationChannel;</span>

<span class="nc bnc" id="L541" title="All 2 branches missed.">			for(int p=0, c = data.controller.particles.size; p &lt; c; ++p, ++tp){</span>
<span class="nc" id="L542">				int baseOffset = particlesOffset[tp]*currentVertexSize*4;</span>
<span class="nc" id="L543">				float scale = scaleChannel.data[p* scaleChannel.strideSize];</span>
<span class="nc" id="L544">				int regionOffset = p*regionChannel.strideSize;</span>
<span class="nc" id="L545">				int positionOffset = p*positionChannel.strideSize;</span>
<span class="nc" id="L546">				int colorOffset = p*colorChannel.strideSize;</span>
<span class="nc" id="L547">				int rotationOffset = p*rotationChannel.strideSize;</span>
<span class="nc" id="L548">				float 	px = positionChannel.data[positionOffset + ParticleChannels.XOffset],</span>
<span class="nc" id="L549">					py = positionChannel.data[positionOffset + ParticleChannels.YOffset],</span>
<span class="nc" id="L550">					pz = positionChannel.data[positionOffset + ParticleChannels.ZOffset];</span>
<span class="nc" id="L551">				float u = regionChannel.data[regionOffset +ParticleChannels.UOffset];</span>
<span class="nc" id="L552">				float v = regionChannel.data[regionOffset +ParticleChannels.VOffset];</span>
<span class="nc" id="L553">				float u2 = regionChannel.data[regionOffset +ParticleChannels.U2Offset];</span>
<span class="nc" id="L554">				float v2 = regionChannel.data[regionOffset +ParticleChannels.V2Offset];</span>
<span class="nc" id="L555">				float 	sx = regionChannel.data[regionOffset +ParticleChannels.HalfWidthOffset] * scale,</span>
<span class="nc" id="L556">					sy = regionChannel.data[regionOffset+ParticleChannels.HalfHeightOffset]  * scale;</span>
<span class="nc" id="L557">				float r = colorChannel.data[colorOffset +ParticleChannels.RedOffset];</span>
<span class="nc" id="L558">				float g = colorChannel.data[colorOffset +ParticleChannels.GreenOffset];</span>
<span class="nc" id="L559">				float b = colorChannel.data[colorOffset +ParticleChannels.BlueOffset];</span>
<span class="nc" id="L560">				float a = colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];</span>
<span class="nc" id="L561">				float cosRotation = rotationChannel.data[rotationOffset +ParticleChannels.CosineOffset];</span>
<span class="nc" id="L562">				float sinRotation = rotationChannel.data[rotationOffset +ParticleChannels.SineOffset];</span>
<span class="nc" id="L563">				Vector3 look = TMP_V3.set(camera.position).sub(px, py, pz).nor(), //normal</span>
<span class="nc" id="L564">					right = TMP_V1.set(camera.up).crs(look).nor(), //tangent</span>
<span class="nc" id="L565">					up = TMP_V2.set(look).crs(right);</span>
<span class="nc" id="L566">				right.scl(sx);</span>
<span class="nc" id="L567">				up.scl(sy);</span>

<span class="nc bnc" id="L569" title="All 2 branches missed.">				if(cosRotation != 1){</span>
<span class="nc" id="L570">					TMP_M3.setToRotation(look, cosRotation, sinRotation);</span>
<span class="nc" id="L571">					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x-TMP_V2.x, -TMP_V1.y-TMP_V2.y, -TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v2, r, g, b, a);</span>
<span class="nc" id="L572">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L573">					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x-TMP_V2.x, TMP_V1.y-TMP_V2.y, TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v2, r, g, b, a);</span>
<span class="nc" id="L574">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L575">					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x+TMP_V2.x, TMP_V1.y+TMP_V2.y, TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v, r, g, b, a);</span>
<span class="nc" id="L576">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L577">					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x, -TMP_V1.y+TMP_V2.y, -TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v, r, g, b, a);</span>
				}
				else {
<span class="nc" id="L580">					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x-TMP_V2.x+px, -TMP_V1.y-TMP_V2.y+py, -TMP_V1.z-TMP_V2.z+pz), u, v2, r, g, b, a);</span>
<span class="nc" id="L581">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L582">					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x-TMP_V2.x+px, TMP_V1.y-TMP_V2.y+py, TMP_V1.z-TMP_V2.z+pz), u2, v2, r, g, b, a);</span>
<span class="nc" id="L583">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L584">					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x+TMP_V2.x+px, TMP_V1.y+TMP_V2.y+py, TMP_V1.z+TMP_V2.z+pz), u2, v, r, g, b, a);</span>
<span class="nc" id="L585">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L586">					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x+px, -TMP_V1.y+TMP_V2.y+py, -TMP_V1.z+TMP_V2.z+pz), u, v, r, g, b, a);</span>
				}
			}
<span class="nc" id="L589">		}</span>
<span class="nc" id="L590">	}</span>

	private void fillVerticesToScreenCPU (int[] particlesOffset) {
<span class="nc" id="L593">		Vector3 look = TMP_V3.set(camera.direction).scl(-1),  //normal</span>
<span class="nc" id="L594">			right = TMP_V4.set(camera.up).crs(look).nor(), //tangent</span>
<span class="nc" id="L595">			up = camera.up;</span>

<span class="nc" id="L597">		int tp=0;</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">		for(BillboardControllerRenderData data : renderData){</span>
<span class="nc" id="L599">			FloatChannel scaleChannel = data.scaleChannel;</span>
<span class="nc" id="L600">			FloatChannel regionChannel = data.regionChannel;</span>
<span class="nc" id="L601">			FloatChannel positionChannel = data.positionChannel;</span>
<span class="nc" id="L602">			FloatChannel colorChannel = data.colorChannel;</span>
<span class="nc" id="L603">			FloatChannel rotationChannel = data.rotationChannel;</span>

<span class="nc bnc" id="L605" title="All 2 branches missed.">			for(int p=0, c = data.controller.particles.size; p &lt; c; ++p, ++tp){</span>
<span class="nc" id="L606">				int baseOffset = particlesOffset[tp]*currentVertexSize*4;</span>
<span class="nc" id="L607">				float scale = scaleChannel.data[p* scaleChannel.strideSize];</span>
<span class="nc" id="L608">				int regionOffset = p*regionChannel.strideSize;</span>
<span class="nc" id="L609">				int positionOffset = p*positionChannel.strideSize;</span>
<span class="nc" id="L610">				int colorOffset = p*colorChannel.strideSize;</span>
<span class="nc" id="L611">				int rotationOffset = p*rotationChannel.strideSize;</span>
<span class="nc" id="L612">				float 	px = positionChannel.data[positionOffset + ParticleChannels.XOffset],</span>
<span class="nc" id="L613">					py = positionChannel.data[positionOffset + ParticleChannels.YOffset],</span>
<span class="nc" id="L614">					pz = positionChannel.data[positionOffset + ParticleChannels.ZOffset];</span>
<span class="nc" id="L615">				float u = regionChannel.data[regionOffset +ParticleChannels.UOffset];</span>
<span class="nc" id="L616">				float v = regionChannel.data[regionOffset +ParticleChannels.VOffset];</span>
<span class="nc" id="L617">				float u2 = regionChannel.data[regionOffset +ParticleChannels.U2Offset];</span>
<span class="nc" id="L618">				float v2 = regionChannel.data[regionOffset +ParticleChannels.V2Offset];</span>
<span class="nc" id="L619">				float 	sx = regionChannel.data[regionOffset +ParticleChannels.HalfWidthOffset] * scale,</span>
<span class="nc" id="L620">					sy = regionChannel.data[regionOffset+ParticleChannels.HalfHeightOffset]  * scale;</span>
<span class="nc" id="L621">				float r = colorChannel.data[colorOffset +ParticleChannels.RedOffset];</span>
<span class="nc" id="L622">				float g = colorChannel.data[colorOffset +ParticleChannels.GreenOffset];</span>
<span class="nc" id="L623">				float b = colorChannel.data[colorOffset +ParticleChannels.BlueOffset];</span>
<span class="nc" id="L624">				float a = colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];</span>
<span class="nc" id="L625">				float cosRotation = rotationChannel.data[rotationOffset +ParticleChannels.CosineOffset];</span>
<span class="nc" id="L626">				float sinRotation = rotationChannel.data[rotationOffset +ParticleChannels.SineOffset];</span>
<span class="nc" id="L627">				TMP_V1.set(right).scl(sx);</span>
<span class="nc" id="L628">				TMP_V2.set(up).scl(sy);</span>

<span class="nc bnc" id="L630" title="All 2 branches missed.">				if(cosRotation != 1){</span>
<span class="nc" id="L631">					TMP_M3.setToRotation(look, cosRotation, sinRotation);</span>
<span class="nc" id="L632">					putVertex( vertices, baseOffset, TMP_V6.set(-TMP_V1.x-TMP_V2.x, -TMP_V1.y-TMP_V2.y, -TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v2, r, g, b, a);</span>
<span class="nc" id="L633">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L634">					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x-TMP_V2.x, TMP_V1.y-TMP_V2.y, TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v2, r, g, b, a);</span>
<span class="nc" id="L635">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L636">					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x+TMP_V2.x, TMP_V1.y+TMP_V2.y, TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v, r, g, b, a);</span>
<span class="nc" id="L637">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L638">					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x, -TMP_V1.y+TMP_V2.y, -TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v, r, g, b, a);</span>
				}
				else {
<span class="nc" id="L641">					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x-TMP_V2.x+px, -TMP_V1.y-TMP_V2.y+py, -TMP_V1.z-TMP_V2.z+pz), u, v2, r, g, b, a);</span>
<span class="nc" id="L642">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L643">					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x-TMP_V2.x+px, TMP_V1.y-TMP_V2.y+py, TMP_V1.z-TMP_V2.z+pz), u2, v2, r, g, b, a);</span>
<span class="nc" id="L644">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L645">					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x+TMP_V2.x+px, TMP_V1.y+TMP_V2.y+py, TMP_V1.z+TMP_V2.z+pz), u2, v, r, g, b, a);</span>
<span class="nc" id="L646">					baseOffset += currentVertexSize;</span>
<span class="nc" id="L647">					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x+px, -TMP_V1.y+TMP_V2.y+py, -TMP_V1.z+TMP_V2.z+pz), u, v, r, g, b, a);</span>
				}
			}
<span class="nc" id="L650">		}</span>
<span class="nc" id="L651">	}</span>

	@Override
	protected void flush(int[] offsets){

		//fill vertices
<span class="nc bnc" id="L657" title="All 2 branches missed.">		if(useGPU){</span>
			//if(mode != AlignMode.ParticleDirection)
<span class="nc" id="L659">			fillVerticesGPU(offsets);</span>
			//else
			//fillVerticesToParticleDirectionGPU(offsets);
		}
		else {
<span class="nc bnc" id="L664" title="All 2 branches missed.">			if(mode == AlignMode.Screen)</span>
<span class="nc" id="L665">				fillVerticesToScreenCPU(offsets);</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">			else if(mode == AlignMode.ViewPoint)</span>
<span class="nc" id="L667">				fillVerticesToViewPointCPU(offsets);</span>
			//else
			//fillVerticesToParticleDirectionCPU(offsets);
		}

		//send vertices to meshes
<span class="nc" id="L673">		int addedVertexCount = 0;</span>
<span class="nc" id="L674">		int vCount = bufferedParticlesCount*4;</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">		for(int v = 0; v &lt; vCount; v += addedVertexCount){</span>
<span class="nc" id="L676">			addedVertexCount = Math.min(vCount-v, MAX_VERTICES_PER_MESH);</span>
<span class="nc" id="L677">			Renderable renderable = renderablePool.obtain();</span>
<span class="nc" id="L678">			renderable.meshPart.size = (addedVertexCount/4)*6;</span>
<span class="nc" id="L679">			renderable.meshPart.mesh.setVertices(vertices, currentVertexSize *v, currentVertexSize * addedVertexCount);</span>
<span class="nc" id="L680">			renderable.meshPart.update();</span>
<span class="nc" id="L681">			renderables.add(renderable);</span>
		}
<span class="nc" id="L683">	}</span>

	@Override
	public void getRenderables (Array&lt;Renderable&gt; renderables, Pool&lt;Renderable&gt; pool) {
<span class="nc bnc" id="L687" title="All 2 branches missed.">		for(Renderable renderable : this.renderables)</span>
<span class="nc" id="L688">			renderables.add(pool.obtain().set(renderable));</span>
<span class="nc" id="L689">	}</span>

	@Override
	public void save (AssetManager manager, ResourceData resources) {
<span class="nc" id="L693">		SaveData data = resources.createSaveData(&quot;billboardBatch&quot;);</span>
<span class="nc" id="L694">		data.save(&quot;cfg&quot;, new Config(useGPU, mode));</span>
<span class="nc" id="L695">		data.saveAsset(manager.getAssetFileName(texture), Texture.class);</span>
<span class="nc" id="L696">	}</span>

	@Override
	public void load (AssetManager manager, ResourceData resources) {
<span class="nc" id="L700">		SaveData data = resources.getSaveData(&quot;billboardBatch&quot;);</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">		if(data != null){</span>
<span class="nc" id="L702">			setTexture((Texture)manager.get(data.loadAsset()));</span>
<span class="nc" id="L703">			Config cfg = (Config)data.load(&quot;cfg&quot;);</span>
<span class="nc" id="L704">			setUseGpu(cfg.useGPU);</span>
<span class="nc" id="L705">			setAlignMode(cfg.mode);</span>
		}
<span class="nc" id="L707">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>