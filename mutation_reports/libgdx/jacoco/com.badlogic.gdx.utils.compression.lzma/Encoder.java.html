<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Encoder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.utils.compression.lzma</a> &gt; <span class="el_source">Encoder.java</span></div><h1>Encoder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.utils.compression.lzma;

import java.io.IOException;

import com.badlogic.gdx.utils.compression.ICodeProgress;
import com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder;

public class Encoder {
	public static final int EMatchFinderTypeBT2 = 0;
	public static final int EMatchFinderTypeBT4 = 1;

	static final int kIfinityPrice = 0xFFFFFFF;

<span class="nc" id="L30">	static byte[] g_FastPos = new byte[1 &lt;&lt; 11];</span>

	static {
<span class="nc" id="L33">		int kFastSlots = 22;</span>
<span class="nc" id="L34">		int c = 2;</span>
<span class="nc" id="L35">		g_FastPos[0] = 0;</span>
<span class="nc" id="L36">		g_FastPos[1] = 1;</span>
<span class="nc bnc" id="L37" title="All 2 branches missed.">		for (int slotFast = 2; slotFast &lt; kFastSlots; slotFast++) {</span>
<span class="nc" id="L38">			int k = (1 &lt;&lt; ((slotFast &gt;&gt; 1) - 1));</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">			for (int j = 0; j &lt; k; j++, c++)</span>
<span class="nc" id="L40">				g_FastPos[c] = (byte)slotFast;</span>
		}
<span class="nc" id="L42">	}</span>

	static int GetPosSlot (int pos) {
<span class="nc bnc" id="L45" title="All 2 branches missed.">		if (pos &lt; (1 &lt;&lt; 11)) return g_FastPos[pos];</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">		if (pos &lt; (1 &lt;&lt; 21)) return (g_FastPos[pos &gt;&gt; 10] + 20);</span>
<span class="nc" id="L47">		return (g_FastPos[pos &gt;&gt; 20] + 40);</span>
	}

	static int GetPosSlot2 (int pos) {
<span class="nc bnc" id="L51" title="All 2 branches missed.">		if (pos &lt; (1 &lt;&lt; 17)) return (g_FastPos[pos &gt;&gt; 6] + 12);</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">		if (pos &lt; (1 &lt;&lt; 27)) return (g_FastPos[pos &gt;&gt; 16] + 32);</span>
<span class="nc" id="L53">		return (g_FastPos[pos &gt;&gt; 26] + 52);</span>
	}

<span class="nc" id="L56">	int _state = Base.StateInit();</span>
	byte _previousByte;
<span class="nc" id="L58">	int[] _repDistances = new int[Base.kNumRepDistances];</span>

	void BaseInit () {
<span class="nc" id="L61">		_state = Base.StateInit();</span>
<span class="nc" id="L62">		_previousByte = 0;</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">		for (int i = 0; i &lt; Base.kNumRepDistances; i++)</span>
<span class="nc" id="L64">			_repDistances[i] = 0;</span>
<span class="nc" id="L65">	}</span>

	static final int kDefaultDictionaryLogSize = 22;
	static final int kNumFastBytesDefault = 0x20;

<span class="nc" id="L70">	class LiteralEncoder {</span>
<span class="nc" id="L71">		class Encoder2 {</span>
<span class="nc" id="L72">			short[] m_Encoders = new short[0x300];</span>

			public void Init () {
<span class="nc" id="L75">				com.badlogic.gdx.utils.compression.rangecoder.Encoder.InitBitModels(m_Encoders);</span>
<span class="nc" id="L76">			}</span>

			public void Encode (com.badlogic.gdx.utils.compression.rangecoder.Encoder rangeEncoder, byte symbol) throws IOException {
<span class="nc" id="L79">				int context = 1;</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">				for (int i = 7; i &gt;= 0; i--) {</span>
<span class="nc" id="L81">					int bit = ((symbol &gt;&gt; i) &amp; 1);</span>
<span class="nc" id="L82">					rangeEncoder.Encode(m_Encoders, context, bit);</span>
<span class="nc" id="L83">					context = (context &lt;&lt; 1) | bit;</span>
				}
<span class="nc" id="L85">			}</span>

			public void EncodeMatched (com.badlogic.gdx.utils.compression.rangecoder.Encoder rangeEncoder, byte matchByte,
				byte symbol) throws IOException {
<span class="nc" id="L89">				int context = 1;</span>
<span class="nc" id="L90">				boolean same = true;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">				for (int i = 7; i &gt;= 0; i--) {</span>
<span class="nc" id="L92">					int bit = ((symbol &gt;&gt; i) &amp; 1);</span>
<span class="nc" id="L93">					int state = context;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">					if (same) {</span>
<span class="nc" id="L95">						int matchBit = ((matchByte &gt;&gt; i) &amp; 1);</span>
<span class="nc" id="L96">						state += ((1 + matchBit) &lt;&lt; 8);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">						same = (matchBit == bit);</span>
					}
<span class="nc" id="L99">					rangeEncoder.Encode(m_Encoders, state, bit);</span>
<span class="nc" id="L100">					context = (context &lt;&lt; 1) | bit;</span>
				}
<span class="nc" id="L102">			}</span>

			public int GetPrice (boolean matchMode, byte matchByte, byte symbol) {
<span class="nc" id="L105">				int price = 0;</span>
<span class="nc" id="L106">				int context = 1;</span>
<span class="nc" id="L107">				int i = 7;</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">				if (matchMode) {</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">					for (; i &gt;= 0; i--) {</span>
<span class="nc" id="L110">						int matchBit = (matchByte &gt;&gt; i) &amp; 1;</span>
<span class="nc" id="L111">						int bit = (symbol &gt;&gt; i) &amp; 1;</span>
<span class="nc" id="L112">						price += com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice(m_Encoders[((1 + matchBit) &lt;&lt; 8)</span>
							+ context], bit);
<span class="nc" id="L114">						context = (context &lt;&lt; 1) | bit;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">						if (matchBit != bit) {</span>
<span class="nc" id="L116">							i--;</span>
<span class="nc" id="L117">							break;</span>
						}
					}
				}
<span class="nc bnc" id="L121" title="All 2 branches missed.">				for (; i &gt;= 0; i--) {</span>
<span class="nc" id="L122">					int bit = (symbol &gt;&gt; i) &amp; 1;</span>
<span class="nc" id="L123">					price += com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice(m_Encoders[context], bit);</span>
<span class="nc" id="L124">					context = (context &lt;&lt; 1) | bit;</span>
				}
<span class="nc" id="L126">				return price;</span>
			}
		}

		Encoder2[] m_Coders;
		int m_NumPrevBits;
		int m_NumPosBits;
		int m_PosMask;

		public void Create (int numPosBits, int numPrevBits) {
<span class="nc bnc" id="L136" title="All 6 branches missed.">			if (m_Coders != null &amp;&amp; m_NumPrevBits == numPrevBits &amp;&amp; m_NumPosBits == numPosBits) return;</span>
<span class="nc" id="L137">			m_NumPosBits = numPosBits;</span>
<span class="nc" id="L138">			m_PosMask = (1 &lt;&lt; numPosBits) - 1;</span>
<span class="nc" id="L139">			m_NumPrevBits = numPrevBits;</span>
<span class="nc" id="L140">			int numStates = 1 &lt;&lt; (m_NumPrevBits + m_NumPosBits);</span>
<span class="nc" id="L141">			m_Coders = new Encoder2[numStates];</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">			for (int i = 0; i &lt; numStates; i++)</span>
<span class="nc" id="L143">				m_Coders[i] = new Encoder2();</span>
<span class="nc" id="L144">		}</span>

		public void Init () {
<span class="nc" id="L147">			int numStates = 1 &lt;&lt; (m_NumPrevBits + m_NumPosBits);</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">			for (int i = 0; i &lt; numStates; i++)</span>
<span class="nc" id="L149">				m_Coders[i].Init();</span>
<span class="nc" id="L150">		}</span>

		public Encoder2 GetSubCoder (int pos, byte prevByte) {
<span class="nc" id="L153">			return m_Coders[((pos &amp; m_PosMask) &lt;&lt; m_NumPrevBits) + ((prevByte &amp; 0xFF) &gt;&gt;&gt; (8 - m_NumPrevBits))];</span>
		}
	}

	class LenEncoder {
<span class="nc" id="L158">		short[] _choice = new short[2];</span>
<span class="nc" id="L159">		BitTreeEncoder[] _lowCoder = new BitTreeEncoder[Base.kNumPosStatesEncodingMax];</span>
<span class="nc" id="L160">		BitTreeEncoder[] _midCoder = new BitTreeEncoder[Base.kNumPosStatesEncodingMax];</span>
<span class="nc" id="L161">		BitTreeEncoder _highCoder = new BitTreeEncoder(Base.kNumHighLenBits);</span>

<span class="nc" id="L163">		public LenEncoder () {</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">			for (int posState = 0; posState &lt; Base.kNumPosStatesEncodingMax; posState++) {</span>
<span class="nc" id="L165">				_lowCoder[posState] = new BitTreeEncoder(Base.kNumLowLenBits);</span>
<span class="nc" id="L166">				_midCoder[posState] = new BitTreeEncoder(Base.kNumMidLenBits);</span>
			}
<span class="nc" id="L168">		}</span>

		public void Init (int numPosStates) {
<span class="nc" id="L171">			com.badlogic.gdx.utils.compression.rangecoder.Encoder.InitBitModels(_choice);</span>

<span class="nc bnc" id="L173" title="All 2 branches missed.">			for (int posState = 0; posState &lt; numPosStates; posState++) {</span>
<span class="nc" id="L174">				_lowCoder[posState].Init();</span>
<span class="nc" id="L175">				_midCoder[posState].Init();</span>
			}
<span class="nc" id="L177">			_highCoder.Init();</span>
<span class="nc" id="L178">		}</span>

		public void Encode (com.badlogic.gdx.utils.compression.rangecoder.Encoder rangeEncoder, int symbol, int posState)
			throws IOException {
<span class="nc bnc" id="L182" title="All 2 branches missed.">			if (symbol &lt; Base.kNumLowLenSymbols) {</span>
<span class="nc" id="L183">				rangeEncoder.Encode(_choice, 0, 0);</span>
<span class="nc" id="L184">				_lowCoder[posState].Encode(rangeEncoder, symbol);</span>
			} else {
<span class="nc" id="L186">				symbol -= Base.kNumLowLenSymbols;</span>
<span class="nc" id="L187">				rangeEncoder.Encode(_choice, 0, 1);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">				if (symbol &lt; Base.kNumMidLenSymbols) {</span>
<span class="nc" id="L189">					rangeEncoder.Encode(_choice, 1, 0);</span>
<span class="nc" id="L190">					_midCoder[posState].Encode(rangeEncoder, symbol);</span>
				} else {
<span class="nc" id="L192">					rangeEncoder.Encode(_choice, 1, 1);</span>
<span class="nc" id="L193">					_highCoder.Encode(rangeEncoder, symbol - Base.kNumMidLenSymbols);</span>
				}
			}
<span class="nc" id="L196">		}</span>

		public void SetPrices (int posState, int numSymbols, int[] prices, int st) {
<span class="nc" id="L199">			int a0 = com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice0(_choice[0]);</span>
<span class="nc" id="L200">			int a1 = com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice1(_choice[0]);</span>
<span class="nc" id="L201">			int b0 = a1 + com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice0(_choice[1]);</span>
<span class="nc" id="L202">			int b1 = a1 + com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice1(_choice[1]);</span>
<span class="nc" id="L203">			int i = 0;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">			for (i = 0; i &lt; Base.kNumLowLenSymbols; i++) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">				if (i &gt;= numSymbols) return;</span>
<span class="nc" id="L206">				prices[st + i] = a0 + _lowCoder[posState].GetPrice(i);</span>
			}
<span class="nc bnc" id="L208" title="All 2 branches missed.">			for (; i &lt; Base.kNumLowLenSymbols + Base.kNumMidLenSymbols; i++) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">				if (i &gt;= numSymbols) return;</span>
<span class="nc" id="L210">				prices[st + i] = b0 + _midCoder[posState].GetPrice(i - Base.kNumLowLenSymbols);</span>
			}
<span class="nc bnc" id="L212" title="All 2 branches missed.">			for (; i &lt; numSymbols; i++)</span>
<span class="nc" id="L213">				prices[st + i] = b1 + _highCoder.GetPrice(i - Base.kNumLowLenSymbols - Base.kNumMidLenSymbols);</span>
<span class="nc" id="L214">		}</span>
	};

	public static final int kNumLenSpecSymbols = Base.kNumLowLenSymbols + Base.kNumMidLenSymbols;

<span class="nc" id="L219">	class LenPriceTableEncoder extends LenEncoder {</span>
<span class="nc" id="L220">		int[] _prices = new int[Base.kNumLenSymbols &lt;&lt; Base.kNumPosStatesBitsEncodingMax];</span>
		int _tableSize;
<span class="nc" id="L222">		int[] _counters = new int[Base.kNumPosStatesEncodingMax];</span>

		public void SetTableSize (int tableSize) {
<span class="nc" id="L225">			_tableSize = tableSize;</span>
<span class="nc" id="L226">		}</span>

		public int GetPrice (int symbol, int posState) {
<span class="nc" id="L229">			return _prices[posState * Base.kNumLenSymbols + symbol];</span>
		}

		void UpdateTable (int posState) {
<span class="nc" id="L233">			SetPrices(posState, _tableSize, _prices, posState * Base.kNumLenSymbols);</span>
<span class="nc" id="L234">			_counters[posState] = _tableSize;</span>
<span class="nc" id="L235">		}</span>

		public void UpdateTables (int numPosStates) {
<span class="nc bnc" id="L238" title="All 2 branches missed.">			for (int posState = 0; posState &lt; numPosStates; posState++)</span>
<span class="nc" id="L239">				UpdateTable(posState);</span>
<span class="nc" id="L240">		}</span>

		public void Encode (com.badlogic.gdx.utils.compression.rangecoder.Encoder rangeEncoder, int symbol, int posState)
			throws IOException {
<span class="nc" id="L244">			super.Encode(rangeEncoder, symbol, posState);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">			if (--_counters[posState] == 0) UpdateTable(posState);</span>
<span class="nc" id="L246">		}</span>
	}

	static final int kNumOpts = 1 &lt;&lt; 12;

<span class="nc" id="L251">	class Optimal {</span>
		public int State;

		public boolean Prev1IsChar;
		public boolean Prev2;

		public int PosPrev2;
		public int BackPrev2;

		public int Price;
		public int PosPrev;
		public int BackPrev;

		public int Backs0;
		public int Backs1;
		public int Backs2;
		public int Backs3;

		public void MakeAsChar () {
<span class="nc" id="L270">			BackPrev = -1;</span>
<span class="nc" id="L271">			Prev1IsChar = false;</span>
<span class="nc" id="L272">		}</span>

		public void MakeAsShortRep () {
<span class="nc" id="L275">			BackPrev = 0;</span>
			;
<span class="nc" id="L277">			Prev1IsChar = false;</span>
<span class="nc" id="L278">		}</span>

		public boolean IsShortRep () {
<span class="nc bnc" id="L281" title="All 2 branches missed.">			return (BackPrev == 0);</span>
		}
	};

<span class="nc" id="L285">	Optimal[] _optimum = new Optimal[kNumOpts];</span>
<span class="nc" id="L286">	com.badlogic.gdx.utils.compression.lz.BinTree _matchFinder = null;</span>
<span class="nc" id="L287">	com.badlogic.gdx.utils.compression.rangecoder.Encoder _rangeEncoder = new com.badlogic.gdx.utils.compression.rangecoder.Encoder();</span>

<span class="nc" id="L289">	short[] _isMatch = new short[Base.kNumStates &lt;&lt; Base.kNumPosStatesBitsMax];</span>
<span class="nc" id="L290">	short[] _isRep = new short[Base.kNumStates];</span>
<span class="nc" id="L291">	short[] _isRepG0 = new short[Base.kNumStates];</span>
<span class="nc" id="L292">	short[] _isRepG1 = new short[Base.kNumStates];</span>
<span class="nc" id="L293">	short[] _isRepG2 = new short[Base.kNumStates];</span>
<span class="nc" id="L294">	short[] _isRep0Long = new short[Base.kNumStates &lt;&lt; Base.kNumPosStatesBitsMax];</span>

<span class="nc" id="L296">	BitTreeEncoder[] _posSlotEncoder = new BitTreeEncoder[Base.kNumLenToPosStates]; // kNumPosSlotBits</span>

<span class="nc" id="L298">	short[] _posEncoders = new short[Base.kNumFullDistances - Base.kEndPosModelIndex];</span>
<span class="nc" id="L299">	BitTreeEncoder _posAlignEncoder = new BitTreeEncoder(Base.kNumAlignBits);</span>

<span class="nc" id="L301">	LenPriceTableEncoder _lenEncoder = new LenPriceTableEncoder();</span>
<span class="nc" id="L302">	LenPriceTableEncoder _repMatchLenEncoder = new LenPriceTableEncoder();</span>

<span class="nc" id="L304">	LiteralEncoder _literalEncoder = new LiteralEncoder();</span>

<span class="nc" id="L306">	int[] _matchDistances = new int[Base.kMatchMaxLen * 2 + 2];</span>

<span class="nc" id="L308">	int _numFastBytes = kNumFastBytesDefault;</span>
	int _longestMatchLength;
	int _numDistancePairs;

	int _additionalOffset;

	int _optimumEndIndex;
	int _optimumCurrentIndex;

	boolean _longestMatchWasFound;

<span class="nc" id="L319">	int[] _posSlotPrices = new int[1 &lt;&lt; (Base.kNumPosSlotBits + Base.kNumLenToPosStatesBits)];</span>
<span class="nc" id="L320">	int[] _distancesPrices = new int[Base.kNumFullDistances &lt;&lt; Base.kNumLenToPosStatesBits];</span>
<span class="nc" id="L321">	int[] _alignPrices = new int[Base.kAlignTableSize];</span>
	int _alignPriceCount;

<span class="nc" id="L324">	int _distTableSize = (kDefaultDictionaryLogSize * 2);</span>

<span class="nc" id="L326">	int _posStateBits = 2;</span>
<span class="nc" id="L327">	int _posStateMask = (4 - 1);</span>
<span class="nc" id="L328">	int _numLiteralPosStateBits = 0;</span>
<span class="nc" id="L329">	int _numLiteralContextBits = 3;</span>

<span class="nc" id="L331">	int _dictionarySize = (1 &lt;&lt; kDefaultDictionaryLogSize);</span>
<span class="nc" id="L332">	int _dictionarySizePrev = -1;</span>
<span class="nc" id="L333">	int _numFastBytesPrev = -1;</span>

	long nowPos64;
	boolean _finished;
	java.io.InputStream _inStream;

<span class="nc" id="L339">	int _matchFinderType = EMatchFinderTypeBT4;</span>
<span class="nc" id="L340">	boolean _writeEndMark = false;</span>

<span class="nc" id="L342">	boolean _needReleaseMFStream = false;</span>

	void Create () {
<span class="nc bnc" id="L345" title="All 2 branches missed.">		if (_matchFinder == null) {</span>
<span class="nc" id="L346">			com.badlogic.gdx.utils.compression.lz.BinTree bt = new com.badlogic.gdx.utils.compression.lz.BinTree();</span>
<span class="nc" id="L347">			int numHashBytes = 4;</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">			if (_matchFinderType == EMatchFinderTypeBT2) numHashBytes = 2;</span>
<span class="nc" id="L349">			bt.SetType(numHashBytes);</span>
<span class="nc" id="L350">			_matchFinder = bt;</span>
		}
<span class="nc" id="L352">		_literalEncoder.Create(_numLiteralPosStateBits, _numLiteralContextBits);</span>

<span class="nc bnc" id="L354" title="All 4 branches missed.">		if (_dictionarySize == _dictionarySizePrev &amp;&amp; _numFastBytesPrev == _numFastBytes) return;</span>
<span class="nc" id="L355">		_matchFinder.Create(_dictionarySize, kNumOpts, _numFastBytes, Base.kMatchMaxLen + 1);</span>
<span class="nc" id="L356">		_dictionarySizePrev = _dictionarySize;</span>
<span class="nc" id="L357">		_numFastBytesPrev = _numFastBytes;</span>
<span class="nc" id="L358">	}</span>

<span class="nc" id="L360">	public Encoder () {</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">		for (int i = 0; i &lt; kNumOpts; i++)</span>
<span class="nc" id="L362">			_optimum[i] = new Optimal();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">		for (int i = 0; i &lt; Base.kNumLenToPosStates; i++)</span>
<span class="nc" id="L364">			_posSlotEncoder[i] = new BitTreeEncoder(Base.kNumPosSlotBits);</span>
<span class="nc" id="L365">	}</span>

	void SetWriteEndMarkerMode (boolean writeEndMarker) {
<span class="nc" id="L368">		_writeEndMark = writeEndMarker;</span>
<span class="nc" id="L369">	}</span>

	void Init () {
<span class="nc" id="L372">		BaseInit();</span>
<span class="nc" id="L373">		_rangeEncoder.Init();</span>

<span class="nc" id="L375">		com.badlogic.gdx.utils.compression.rangecoder.Encoder.InitBitModels(_isMatch);</span>
<span class="nc" id="L376">		com.badlogic.gdx.utils.compression.rangecoder.Encoder.InitBitModels(_isRep0Long);</span>
<span class="nc" id="L377">		com.badlogic.gdx.utils.compression.rangecoder.Encoder.InitBitModels(_isRep);</span>
<span class="nc" id="L378">		com.badlogic.gdx.utils.compression.rangecoder.Encoder.InitBitModels(_isRepG0);</span>
<span class="nc" id="L379">		com.badlogic.gdx.utils.compression.rangecoder.Encoder.InitBitModels(_isRepG1);</span>
<span class="nc" id="L380">		com.badlogic.gdx.utils.compression.rangecoder.Encoder.InitBitModels(_isRepG2);</span>
<span class="nc" id="L381">		com.badlogic.gdx.utils.compression.rangecoder.Encoder.InitBitModels(_posEncoders);</span>

<span class="nc" id="L383">		_literalEncoder.Init();</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">		for (int i = 0; i &lt; Base.kNumLenToPosStates; i++)</span>
<span class="nc" id="L385">			_posSlotEncoder[i].Init();</span>

<span class="nc" id="L387">		_lenEncoder.Init(1 &lt;&lt; _posStateBits);</span>
<span class="nc" id="L388">		_repMatchLenEncoder.Init(1 &lt;&lt; _posStateBits);</span>

<span class="nc" id="L390">		_posAlignEncoder.Init();</span>

<span class="nc" id="L392">		_longestMatchWasFound = false;</span>
<span class="nc" id="L393">		_optimumEndIndex = 0;</span>
<span class="nc" id="L394">		_optimumCurrentIndex = 0;</span>
<span class="nc" id="L395">		_additionalOffset = 0;</span>
<span class="nc" id="L396">	}</span>

	int ReadMatchDistances () throws java.io.IOException {
<span class="nc" id="L399">		int lenRes = 0;</span>
<span class="nc" id="L400">		_numDistancePairs = _matchFinder.GetMatches(_matchDistances);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">		if (_numDistancePairs &gt; 0) {</span>
<span class="nc" id="L402">			lenRes = _matchDistances[_numDistancePairs - 2];</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">			if (lenRes == _numFastBytes)</span>
<span class="nc" id="L404">				lenRes += _matchFinder.GetMatchLen((int)lenRes - 1, _matchDistances[_numDistancePairs - 1], Base.kMatchMaxLen</span>
					- lenRes);
		}
<span class="nc" id="L407">		_additionalOffset++;</span>
<span class="nc" id="L408">		return lenRes;</span>
	}

	void MovePos (int num) throws java.io.IOException {
<span class="nc bnc" id="L412" title="All 2 branches missed.">		if (num &gt; 0) {</span>
<span class="nc" id="L413">			_matchFinder.Skip(num);</span>
<span class="nc" id="L414">			_additionalOffset += num;</span>
		}
<span class="nc" id="L416">	}</span>

	int GetRepLen1Price (int state, int posState) {
<span class="nc" id="L419">		return com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice0(_isRepG0[state])</span>
			+ com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice0(_isRep0Long[(state &lt;&lt; Base.kNumPosStatesBitsMax)
				+ posState]);
	}

	int GetPureRepPrice (int repIndex, int state, int posState) {
		int price;
<span class="nc bnc" id="L426" title="All 2 branches missed.">		if (repIndex == 0) {</span>
<span class="nc" id="L427">			price = com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice0(_isRepG0[state]);</span>
<span class="nc" id="L428">			price += com.badlogic.gdx.utils.compression.rangecoder.Encoder</span>
				.GetPrice1(_isRep0Long[(state &lt;&lt; Base.kNumPosStatesBitsMax) + posState]);
		} else {
<span class="nc" id="L431">			price = com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice1(_isRepG0[state]);</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">			if (repIndex == 1)</span>
<span class="nc" id="L433">				price += com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice0(_isRepG1[state]);</span>
			else {
<span class="nc" id="L435">				price += com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice1(_isRepG1[state]);</span>
<span class="nc" id="L436">				price += com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice(_isRepG2[state], repIndex - 2);</span>
			}
		}
<span class="nc" id="L439">		return price;</span>
	}

	int GetRepPrice (int repIndex, int len, int state, int posState) {
<span class="nc" id="L443">		int price = _repMatchLenEncoder.GetPrice(len - Base.kMatchMinLen, posState);</span>
<span class="nc" id="L444">		return price + GetPureRepPrice(repIndex, state, posState);</span>
	}

	int GetPosLenPrice (int pos, int len, int posState) {
		int price;
<span class="nc" id="L449">		int lenToPosState = Base.GetLenToPosState(len);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">		if (pos &lt; Base.kNumFullDistances)</span>
<span class="nc" id="L451">			price = _distancesPrices[(lenToPosState * Base.kNumFullDistances) + pos];</span>
		else
<span class="nc" id="L453">			price = _posSlotPrices[(lenToPosState &lt;&lt; Base.kNumPosSlotBits) + GetPosSlot2(pos)] + _alignPrices[pos &amp; Base.kAlignMask];</span>
<span class="nc" id="L454">		return price + _lenEncoder.GetPrice(len - Base.kMatchMinLen, posState);</span>
	}

	int Backward (int cur) {
<span class="nc" id="L458">		_optimumEndIndex = cur;</span>
<span class="nc" id="L459">		int posMem = _optimum[cur].PosPrev;</span>
<span class="nc" id="L460">		int backMem = _optimum[cur].BackPrev;</span>
		do {
<span class="nc bnc" id="L462" title="All 2 branches missed.">			if (_optimum[cur].Prev1IsChar) {</span>
<span class="nc" id="L463">				_optimum[posMem].MakeAsChar();</span>
<span class="nc" id="L464">				_optimum[posMem].PosPrev = posMem - 1;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">				if (_optimum[cur].Prev2) {</span>
<span class="nc" id="L466">					_optimum[posMem - 1].Prev1IsChar = false;</span>
<span class="nc" id="L467">					_optimum[posMem - 1].PosPrev = _optimum[cur].PosPrev2;</span>
<span class="nc" id="L468">					_optimum[posMem - 1].BackPrev = _optimum[cur].BackPrev2;</span>
				}
			}
<span class="nc" id="L471">			int posPrev = posMem;</span>
<span class="nc" id="L472">			int backCur = backMem;</span>

<span class="nc" id="L474">			backMem = _optimum[posPrev].BackPrev;</span>
<span class="nc" id="L475">			posMem = _optimum[posPrev].PosPrev;</span>

<span class="nc" id="L477">			_optimum[posPrev].BackPrev = backCur;</span>
<span class="nc" id="L478">			_optimum[posPrev].PosPrev = cur;</span>
<span class="nc" id="L479">			cur = posPrev;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">		} while (cur &gt; 0);</span>
<span class="nc" id="L481">		backRes = _optimum[0].BackPrev;</span>
<span class="nc" id="L482">		_optimumCurrentIndex = _optimum[0].PosPrev;</span>
<span class="nc" id="L483">		return _optimumCurrentIndex;</span>
	}

<span class="nc" id="L486">	int[] reps = new int[Base.kNumRepDistances];</span>
<span class="nc" id="L487">	int[] repLens = new int[Base.kNumRepDistances];</span>
	int backRes;

	int GetOptimum (int position) throws IOException {
<span class="nc bnc" id="L491" title="All 2 branches missed.">		if (_optimumEndIndex != _optimumCurrentIndex) {</span>
<span class="nc" id="L492">			int lenRes = _optimum[_optimumCurrentIndex].PosPrev - _optimumCurrentIndex;</span>
<span class="nc" id="L493">			backRes = _optimum[_optimumCurrentIndex].BackPrev;</span>
<span class="nc" id="L494">			_optimumCurrentIndex = _optimum[_optimumCurrentIndex].PosPrev;</span>
<span class="nc" id="L495">			return lenRes;</span>
		}
<span class="nc" id="L497">		_optimumCurrentIndex = _optimumEndIndex = 0;</span>

		int lenMain, numDistancePairs;
<span class="nc bnc" id="L500" title="All 2 branches missed.">		if (!_longestMatchWasFound) {</span>
<span class="nc" id="L501">			lenMain = ReadMatchDistances();</span>
		} else {
<span class="nc" id="L503">			lenMain = _longestMatchLength;</span>
<span class="nc" id="L504">			_longestMatchWasFound = false;</span>
		}
<span class="nc" id="L506">		numDistancePairs = _numDistancePairs;</span>

<span class="nc" id="L508">		int numAvailableBytes = _matchFinder.GetNumAvailableBytes() + 1;</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">		if (numAvailableBytes &lt; 2) {</span>
<span class="nc" id="L510">			backRes = -1;</span>
<span class="nc" id="L511">			return 1;</span>
		}
<span class="nc bnc" id="L513" title="All 2 branches missed.">		if (numAvailableBytes &gt; Base.kMatchMaxLen) numAvailableBytes = Base.kMatchMaxLen;</span>

<span class="nc" id="L515">		int repMaxIndex = 0;</span>
		int i;
<span class="nc bnc" id="L517" title="All 2 branches missed.">		for (i = 0; i &lt; Base.kNumRepDistances; i++) {</span>
<span class="nc" id="L518">			reps[i] = _repDistances[i];</span>
<span class="nc" id="L519">			repLens[i] = _matchFinder.GetMatchLen(0 - 1, reps[i], Base.kMatchMaxLen);</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">			if (repLens[i] &gt; repLens[repMaxIndex]) repMaxIndex = i;</span>
		}
<span class="nc bnc" id="L522" title="All 2 branches missed.">		if (repLens[repMaxIndex] &gt;= _numFastBytes) {</span>
<span class="nc" id="L523">			backRes = repMaxIndex;</span>
<span class="nc" id="L524">			int lenRes = repLens[repMaxIndex];</span>
<span class="nc" id="L525">			MovePos(lenRes - 1);</span>
<span class="nc" id="L526">			return lenRes;</span>
		}

<span class="nc bnc" id="L529" title="All 2 branches missed.">		if (lenMain &gt;= _numFastBytes) {</span>
<span class="nc" id="L530">			backRes = _matchDistances[numDistancePairs - 1] + Base.kNumRepDistances;</span>
<span class="nc" id="L531">			MovePos(lenMain - 1);</span>
<span class="nc" id="L532">			return lenMain;</span>
		}

<span class="nc" id="L535">		byte currentByte = _matchFinder.GetIndexByte(0 - 1);</span>
<span class="nc" id="L536">		byte matchByte = _matchFinder.GetIndexByte(0 - _repDistances[0] - 1 - 1);</span>

<span class="nc bnc" id="L538" title="All 6 branches missed.">		if (lenMain &lt; 2 &amp;&amp; currentByte != matchByte &amp;&amp; repLens[repMaxIndex] &lt; 2) {</span>
<span class="nc" id="L539">			backRes = -1;</span>
<span class="nc" id="L540">			return 1;</span>
		}

<span class="nc" id="L543">		_optimum[0].State = _state;</span>

<span class="nc" id="L545">		int posState = (position &amp; _posStateMask);</span>

<span class="nc bnc" id="L547" title="All 2 branches missed.">		_optimum[1].Price = com.badlogic.gdx.utils.compression.rangecoder.Encoder</span>
			.GetPrice0(_isMatch[(_state &lt;&lt; Base.kNumPosStatesBitsMax) + posState])
			+ _literalEncoder.GetSubCoder(position, _previousByte).GetPrice(!Base.StateIsCharState(_state), matchByte, currentByte);
<span class="nc" id="L550">		_optimum[1].MakeAsChar();</span>

<span class="nc" id="L552">		int matchPrice = com.badlogic.gdx.utils.compression.rangecoder.Encoder</span>
			.GetPrice1(_isMatch[(_state &lt;&lt; Base.kNumPosStatesBitsMax) + posState]);
<span class="nc" id="L554">		int repMatchPrice = matchPrice + com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice1(_isRep[_state]);</span>

<span class="nc bnc" id="L556" title="All 2 branches missed.">		if (matchByte == currentByte) {</span>
<span class="nc" id="L557">			int shortRepPrice = repMatchPrice + GetRepLen1Price(_state, posState);</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">			if (shortRepPrice &lt; _optimum[1].Price) {</span>
<span class="nc" id="L559">				_optimum[1].Price = shortRepPrice;</span>
<span class="nc" id="L560">				_optimum[1].MakeAsShortRep();</span>
			}
		}

<span class="nc bnc" id="L564" title="All 2 branches missed.">		int lenEnd = ((lenMain &gt;= repLens[repMaxIndex]) ? lenMain : repLens[repMaxIndex]);</span>

<span class="nc bnc" id="L566" title="All 2 branches missed.">		if (lenEnd &lt; 2) {</span>
<span class="nc" id="L567">			backRes = _optimum[1].BackPrev;</span>
<span class="nc" id="L568">			return 1;</span>
		}

<span class="nc" id="L571">		_optimum[1].PosPrev = 0;</span>

<span class="nc" id="L573">		_optimum[0].Backs0 = reps[0];</span>
<span class="nc" id="L574">		_optimum[0].Backs1 = reps[1];</span>
<span class="nc" id="L575">		_optimum[0].Backs2 = reps[2];</span>
<span class="nc" id="L576">		_optimum[0].Backs3 = reps[3];</span>

<span class="nc" id="L578">		int len = lenEnd;</span>
		do
<span class="nc" id="L580">			_optimum[len--].Price = kIfinityPrice;</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">		while (len &gt;= 2);</span>

<span class="nc bnc" id="L583" title="All 2 branches missed.">		for (i = 0; i &lt; Base.kNumRepDistances; i++) {</span>
<span class="nc" id="L584">			int repLen = repLens[i];</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">			if (repLen &lt; 2) continue;</span>
<span class="nc" id="L586">			int price = repMatchPrice + GetPureRepPrice(i, _state, posState);</span>
			do {
<span class="nc" id="L588">				int curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2, posState);</span>
<span class="nc" id="L589">				Optimal optimum = _optimum[repLen];</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">				if (curAndLenPrice &lt; optimum.Price) {</span>
<span class="nc" id="L591">					optimum.Price = curAndLenPrice;</span>
<span class="nc" id="L592">					optimum.PosPrev = 0;</span>
<span class="nc" id="L593">					optimum.BackPrev = i;</span>
<span class="nc" id="L594">					optimum.Prev1IsChar = false;</span>
				}
<span class="nc bnc" id="L596" title="All 2 branches missed.">			} while (--repLen &gt;= 2);</span>
		}

<span class="nc" id="L599">		int normalMatchPrice = matchPrice + com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice0(_isRep[_state]);</span>

<span class="nc bnc" id="L601" title="All 2 branches missed.">		len = ((repLens[0] &gt;= 2) ? repLens[0] + 1 : 2);</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">		if (len &lt;= lenMain) {</span>
<span class="nc" id="L603">			int offs = 0;</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">			while (len &gt; _matchDistances[offs])</span>
<span class="nc" id="L605">				offs += 2;</span>
<span class="nc" id="L606">			for (;; len++) {</span>
<span class="nc" id="L607">				int distance = _matchDistances[offs + 1];</span>
<span class="nc" id="L608">				int curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance, len, posState);</span>
<span class="nc" id="L609">				Optimal optimum = _optimum[len];</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">				if (curAndLenPrice &lt; optimum.Price) {</span>
<span class="nc" id="L611">					optimum.Price = curAndLenPrice;</span>
<span class="nc" id="L612">					optimum.PosPrev = 0;</span>
<span class="nc" id="L613">					optimum.BackPrev = distance + Base.kNumRepDistances;</span>
<span class="nc" id="L614">					optimum.Prev1IsChar = false;</span>
				}
<span class="nc bnc" id="L616" title="All 2 branches missed.">				if (len == _matchDistances[offs]) {</span>
<span class="nc" id="L617">					offs += 2;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">					if (offs == numDistancePairs) break;</span>
				}
			}
		}

<span class="nc" id="L623">		int cur = 0;</span>

		while (true) {
<span class="nc" id="L626">			cur++;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">			if (cur == lenEnd) return Backward(cur);</span>
<span class="nc" id="L628">			int newLen = ReadMatchDistances();</span>
<span class="nc" id="L629">			numDistancePairs = _numDistancePairs;</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">			if (newLen &gt;= _numFastBytes) {</span>

<span class="nc" id="L632">				_longestMatchLength = newLen;</span>
<span class="nc" id="L633">				_longestMatchWasFound = true;</span>
<span class="nc" id="L634">				return Backward(cur);</span>
			}
<span class="nc" id="L636">			position++;</span>
<span class="nc" id="L637">			int posPrev = _optimum[cur].PosPrev;</span>
			int state;
<span class="nc bnc" id="L639" title="All 2 branches missed.">			if (_optimum[cur].Prev1IsChar) {</span>
<span class="nc" id="L640">				posPrev--;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">				if (_optimum[cur].Prev2) {</span>
<span class="nc" id="L642">					state = _optimum[_optimum[cur].PosPrev2].State;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">					if (_optimum[cur].BackPrev2 &lt; Base.kNumRepDistances)</span>
<span class="nc" id="L644">						state = Base.StateUpdateRep(state);</span>
					else
<span class="nc" id="L646">						state = Base.StateUpdateMatch(state);</span>
				} else
<span class="nc" id="L648">					state = _optimum[posPrev].State;</span>
<span class="nc" id="L649">				state = Base.StateUpdateChar(state);</span>
			} else
<span class="nc" id="L651">				state = _optimum[posPrev].State;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">			if (posPrev == cur - 1) {</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">				if (_optimum[cur].IsShortRep())</span>
<span class="nc" id="L654">					state = Base.StateUpdateShortRep(state);</span>
				else
<span class="nc" id="L656">					state = Base.StateUpdateChar(state);</span>
			} else {
				int pos;
<span class="nc bnc" id="L659" title="All 4 branches missed.">				if (_optimum[cur].Prev1IsChar &amp;&amp; _optimum[cur].Prev2) {</span>
<span class="nc" id="L660">					posPrev = _optimum[cur].PosPrev2;</span>
<span class="nc" id="L661">					pos = _optimum[cur].BackPrev2;</span>
<span class="nc" id="L662">					state = Base.StateUpdateRep(state);</span>
				} else {
<span class="nc" id="L664">					pos = _optimum[cur].BackPrev;</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">					if (pos &lt; Base.kNumRepDistances)</span>
<span class="nc" id="L666">						state = Base.StateUpdateRep(state);</span>
					else
<span class="nc" id="L668">						state = Base.StateUpdateMatch(state);</span>
				}
<span class="nc" id="L670">				Optimal opt = _optimum[posPrev];</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">				if (pos &lt; Base.kNumRepDistances) {</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">					if (pos == 0) {</span>
<span class="nc" id="L673">						reps[0] = opt.Backs0;</span>
<span class="nc" id="L674">						reps[1] = opt.Backs1;</span>
<span class="nc" id="L675">						reps[2] = opt.Backs2;</span>
<span class="nc" id="L676">						reps[3] = opt.Backs3;</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">					} else if (pos == 1) {</span>
<span class="nc" id="L678">						reps[0] = opt.Backs1;</span>
<span class="nc" id="L679">						reps[1] = opt.Backs0;</span>
<span class="nc" id="L680">						reps[2] = opt.Backs2;</span>
<span class="nc" id="L681">						reps[3] = opt.Backs3;</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">					} else if (pos == 2) {</span>
<span class="nc" id="L683">						reps[0] = opt.Backs2;</span>
<span class="nc" id="L684">						reps[1] = opt.Backs0;</span>
<span class="nc" id="L685">						reps[2] = opt.Backs1;</span>
<span class="nc" id="L686">						reps[3] = opt.Backs3;</span>
					} else {
<span class="nc" id="L688">						reps[0] = opt.Backs3;</span>
<span class="nc" id="L689">						reps[1] = opt.Backs0;</span>
<span class="nc" id="L690">						reps[2] = opt.Backs1;</span>
<span class="nc" id="L691">						reps[3] = opt.Backs2;</span>
					}
				} else {
<span class="nc" id="L694">					reps[0] = (pos - Base.kNumRepDistances);</span>
<span class="nc" id="L695">					reps[1] = opt.Backs0;</span>
<span class="nc" id="L696">					reps[2] = opt.Backs1;</span>
<span class="nc" id="L697">					reps[3] = opt.Backs2;</span>
				}
			}
<span class="nc" id="L700">			_optimum[cur].State = state;</span>
<span class="nc" id="L701">			_optimum[cur].Backs0 = reps[0];</span>
<span class="nc" id="L702">			_optimum[cur].Backs1 = reps[1];</span>
<span class="nc" id="L703">			_optimum[cur].Backs2 = reps[2];</span>
<span class="nc" id="L704">			_optimum[cur].Backs3 = reps[3];</span>
<span class="nc" id="L705">			int curPrice = _optimum[cur].Price;</span>

<span class="nc" id="L707">			currentByte = _matchFinder.GetIndexByte(0 - 1);</span>
<span class="nc" id="L708">			matchByte = _matchFinder.GetIndexByte(0 - reps[0] - 1 - 1);</span>

<span class="nc" id="L710">			posState = (position &amp; _posStateMask);</span>

<span class="nc bnc" id="L712" title="All 2 branches missed.">			int curAnd1Price = curPrice</span>
				+ com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice0(_isMatch[(state &lt;&lt; Base.kNumPosStatesBitsMax)
					+ posState])
				+ _literalEncoder.GetSubCoder(position, _matchFinder.GetIndexByte(0 - 2)).GetPrice(!Base.StateIsCharState(state),
					matchByte, currentByte);

<span class="nc" id="L718">			Optimal nextOptimum = _optimum[cur + 1];</span>

<span class="nc" id="L720">			boolean nextIsChar = false;</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">			if (curAnd1Price &lt; nextOptimum.Price) {</span>
<span class="nc" id="L722">				nextOptimum.Price = curAnd1Price;</span>
<span class="nc" id="L723">				nextOptimum.PosPrev = cur;</span>
<span class="nc" id="L724">				nextOptimum.MakeAsChar();</span>
<span class="nc" id="L725">				nextIsChar = true;</span>
			}

<span class="nc" id="L728">			matchPrice = curPrice</span>
				+ com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice1(_isMatch[(state &lt;&lt; Base.kNumPosStatesBitsMax)
					+ posState]);
<span class="nc" id="L731">			repMatchPrice = matchPrice + com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice1(_isRep[state]);</span>

<span class="nc bnc" id="L733" title="All 6 branches missed.">			if (matchByte == currentByte &amp;&amp; !(nextOptimum.PosPrev &lt; cur &amp;&amp; nextOptimum.BackPrev == 0)) {</span>
<span class="nc" id="L734">				int shortRepPrice = repMatchPrice + GetRepLen1Price(state, posState);</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">				if (shortRepPrice &lt;= nextOptimum.Price) {</span>
<span class="nc" id="L736">					nextOptimum.Price = shortRepPrice;</span>
<span class="nc" id="L737">					nextOptimum.PosPrev = cur;</span>
<span class="nc" id="L738">					nextOptimum.MakeAsShortRep();</span>
<span class="nc" id="L739">					nextIsChar = true;</span>
				}
			}

<span class="nc" id="L743">			int numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;</span>
<span class="nc" id="L744">			numAvailableBytesFull = Math.min(kNumOpts - 1 - cur, numAvailableBytesFull);</span>
<span class="nc" id="L745">			numAvailableBytes = numAvailableBytesFull;</span>

<span class="nc bnc" id="L747" title="All 2 branches missed.">			if (numAvailableBytes &lt; 2) continue;</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">			if (numAvailableBytes &gt; _numFastBytes) numAvailableBytes = _numFastBytes;</span>
<span class="nc bnc" id="L749" title="All 4 branches missed.">			if (!nextIsChar &amp;&amp; matchByte != currentByte) {</span>
				// try Literal + rep0
<span class="nc" id="L751">				int t = Math.min(numAvailableBytesFull - 1, _numFastBytes);</span>
<span class="nc" id="L752">				int lenTest2 = _matchFinder.GetMatchLen(0, reps[0], t);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">				if (lenTest2 &gt;= 2) {</span>
<span class="nc" id="L754">					int state2 = Base.StateUpdateChar(state);</span>

<span class="nc" id="L756">					int posStateNext = (position + 1) &amp; _posStateMask;</span>
<span class="nc" id="L757">					int nextRepMatchPrice = curAnd1Price</span>
						+ com.badlogic.gdx.utils.compression.rangecoder.Encoder
							.GetPrice1(_isMatch[(state2 &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext])
						+ com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice1(_isRep[state2]);
					{
<span class="nc" id="L762">						int offset = cur + 1 + lenTest2;</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">						while (lenEnd &lt; offset)</span>
<span class="nc" id="L764">							_optimum[++lenEnd].Price = kIfinityPrice;</span>
<span class="nc" id="L765">						int curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);</span>
<span class="nc" id="L766">						Optimal optimum = _optimum[offset];</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">						if (curAndLenPrice &lt; optimum.Price) {</span>
<span class="nc" id="L768">							optimum.Price = curAndLenPrice;</span>
<span class="nc" id="L769">							optimum.PosPrev = cur + 1;</span>
<span class="nc" id="L770">							optimum.BackPrev = 0;</span>
<span class="nc" id="L771">							optimum.Prev1IsChar = true;</span>
<span class="nc" id="L772">							optimum.Prev2 = false;</span>
						}
					}
				}
			}

<span class="nc" id="L778">			int startLen = 2; // speed optimization</span>

<span class="nc bnc" id="L780" title="All 2 branches missed.">			for (int repIndex = 0; repIndex &lt; Base.kNumRepDistances; repIndex++) {</span>
<span class="nc" id="L781">				int lenTest = _matchFinder.GetMatchLen(0 - 1, reps[repIndex], numAvailableBytes);</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">				if (lenTest &lt; 2) continue;</span>
<span class="nc" id="L783">				int lenTestTemp = lenTest;</span>
				do {
<span class="nc bnc" id="L785" title="All 2 branches missed.">					while (lenEnd &lt; cur + lenTest)</span>
<span class="nc" id="L786">						_optimum[++lenEnd].Price = kIfinityPrice;</span>
<span class="nc" id="L787">					int curAndLenPrice = repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState);</span>
<span class="nc" id="L788">					Optimal optimum = _optimum[cur + lenTest];</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">					if (curAndLenPrice &lt; optimum.Price) {</span>
<span class="nc" id="L790">						optimum.Price = curAndLenPrice;</span>
<span class="nc" id="L791">						optimum.PosPrev = cur;</span>
<span class="nc" id="L792">						optimum.BackPrev = repIndex;</span>
<span class="nc" id="L793">						optimum.Prev1IsChar = false;</span>
					}
<span class="nc bnc" id="L795" title="All 2 branches missed.">				} while (--lenTest &gt;= 2);</span>
<span class="nc" id="L796">				lenTest = lenTestTemp;</span>

<span class="nc bnc" id="L798" title="All 2 branches missed.">				if (repIndex == 0) startLen = lenTest + 1;</span>

				// if (_maxMode)
<span class="nc bnc" id="L801" title="All 2 branches missed.">				if (lenTest &lt; numAvailableBytesFull) {</span>
<span class="nc" id="L802">					int t = Math.min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);</span>
<span class="nc" id="L803">					int lenTest2 = _matchFinder.GetMatchLen(lenTest, reps[repIndex], t);</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">					if (lenTest2 &gt;= 2) {</span>
<span class="nc" id="L805">						int state2 = Base.StateUpdateRep(state);</span>

<span class="nc" id="L807">						int posStateNext = (position + lenTest) &amp; _posStateMask;</span>
<span class="nc" id="L808">						int curAndLenCharPrice = repMatchPrice</span>
							+ GetRepPrice(repIndex, lenTest, state, posState)
							+ com.badlogic.gdx.utils.compression.rangecoder.Encoder
								.GetPrice0(_isMatch[(state2 &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext])
							+ _literalEncoder.GetSubCoder(position + lenTest, _matchFinder.GetIndexByte(lenTest - 1 - 1)).GetPrice(true,
								_matchFinder.GetIndexByte(lenTest - 1 - (reps[repIndex] + 1)), _matchFinder.GetIndexByte(lenTest - 1));
<span class="nc" id="L814">						state2 = Base.StateUpdateChar(state2);</span>
<span class="nc" id="L815">						posStateNext = (position + lenTest + 1) &amp; _posStateMask;</span>
<span class="nc" id="L816">						int nextMatchPrice = curAndLenCharPrice</span>
							+ com.badlogic.gdx.utils.compression.rangecoder.Encoder
								.GetPrice1(_isMatch[(state2 &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext]);
<span class="nc" id="L819">						int nextRepMatchPrice = nextMatchPrice</span>
							+ com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice1(_isRep[state2]);

						// for(; lenTest2 &gt;= 2; lenTest2--)
						{
<span class="nc" id="L824">							int offset = lenTest + 1 + lenTest2;</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">							while (lenEnd &lt; cur + offset)</span>
<span class="nc" id="L826">								_optimum[++lenEnd].Price = kIfinityPrice;</span>
<span class="nc" id="L827">							int curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);</span>
<span class="nc" id="L828">							Optimal optimum = _optimum[cur + offset];</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">							if (curAndLenPrice &lt; optimum.Price) {</span>
<span class="nc" id="L830">								optimum.Price = curAndLenPrice;</span>
<span class="nc" id="L831">								optimum.PosPrev = cur + lenTest + 1;</span>
<span class="nc" id="L832">								optimum.BackPrev = 0;</span>
<span class="nc" id="L833">								optimum.Prev1IsChar = true;</span>
<span class="nc" id="L834">								optimum.Prev2 = true;</span>
<span class="nc" id="L835">								optimum.PosPrev2 = cur;</span>
<span class="nc" id="L836">								optimum.BackPrev2 = repIndex;</span>
							}
						}
					}
				}
			}

<span class="nc bnc" id="L843" title="All 2 branches missed.">			if (newLen &gt; numAvailableBytes) {</span>
<span class="nc" id="L844">				newLen = numAvailableBytes;</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">				for (numDistancePairs = 0; newLen &gt; _matchDistances[numDistancePairs]; numDistancePairs += 2)</span>
					;
<span class="nc" id="L847">				_matchDistances[numDistancePairs] = newLen;</span>
<span class="nc" id="L848">				numDistancePairs += 2;</span>
			}
<span class="nc bnc" id="L850" title="All 2 branches missed.">			if (newLen &gt;= startLen) {</span>
<span class="nc" id="L851">				normalMatchPrice = matchPrice + com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice0(_isRep[state]);</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">				while (lenEnd &lt; cur + newLen)</span>
<span class="nc" id="L853">					_optimum[++lenEnd].Price = kIfinityPrice;</span>

<span class="nc" id="L855">				int offs = 0;</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">				while (startLen &gt; _matchDistances[offs])</span>
<span class="nc" id="L857">					offs += 2;</span>

<span class="nc" id="L859">				for (int lenTest = startLen;; lenTest++) {</span>
<span class="nc" id="L860">					int curBack = _matchDistances[offs + 1];</span>
<span class="nc" id="L861">					int curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack, lenTest, posState);</span>
<span class="nc" id="L862">					Optimal optimum = _optimum[cur + lenTest];</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">					if (curAndLenPrice &lt; optimum.Price) {</span>
<span class="nc" id="L864">						optimum.Price = curAndLenPrice;</span>
<span class="nc" id="L865">						optimum.PosPrev = cur;</span>
<span class="nc" id="L866">						optimum.BackPrev = curBack + Base.kNumRepDistances;</span>
<span class="nc" id="L867">						optimum.Prev1IsChar = false;</span>
					}

<span class="nc bnc" id="L870" title="All 2 branches missed.">					if (lenTest == _matchDistances[offs]) {</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">						if (lenTest &lt; numAvailableBytesFull) {</span>
<span class="nc" id="L872">							int t = Math.min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);</span>
<span class="nc" id="L873">							int lenTest2 = _matchFinder.GetMatchLen(lenTest, curBack, t);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">							if (lenTest2 &gt;= 2) {</span>
<span class="nc" id="L875">								int state2 = Base.StateUpdateMatch(state);</span>

<span class="nc" id="L877">								int posStateNext = (position + lenTest) &amp; _posStateMask;</span>
<span class="nc" id="L878">								int curAndLenCharPrice = curAndLenPrice</span>
									+ com.badlogic.gdx.utils.compression.rangecoder.Encoder
										.GetPrice0(_isMatch[(state2 &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext])
									+ _literalEncoder.GetSubCoder(position + lenTest, _matchFinder.GetIndexByte(lenTest - 1 - 1))
										.GetPrice(true, _matchFinder.GetIndexByte(lenTest - (curBack + 1) - 1),
											_matchFinder.GetIndexByte(lenTest - 1));
<span class="nc" id="L884">								state2 = Base.StateUpdateChar(state2);</span>
<span class="nc" id="L885">								posStateNext = (position + lenTest + 1) &amp; _posStateMask;</span>
<span class="nc" id="L886">								int nextMatchPrice = curAndLenCharPrice</span>
									+ com.badlogic.gdx.utils.compression.rangecoder.Encoder
										.GetPrice1(_isMatch[(state2 &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext]);
<span class="nc" id="L889">								int nextRepMatchPrice = nextMatchPrice</span>
									+ com.badlogic.gdx.utils.compression.rangecoder.Encoder.GetPrice1(_isRep[state2]);

<span class="nc" id="L892">								int offset = lenTest + 1 + lenTest2;</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">								while (lenEnd &lt; cur + offset)</span>
<span class="nc" id="L894">									_optimum[++lenEnd].Price = kIfinityPrice;</span>
<span class="nc" id="L895">								curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);</span>
<span class="nc" id="L896">								optimum = _optimum[cur + offset];</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">								if (curAndLenPrice &lt; optimum.Price) {</span>
<span class="nc" id="L898">									optimum.Price = curAndLenPrice;</span>
<span class="nc" id="L899">									optimum.PosPrev = cur + lenTest + 1;</span>
<span class="nc" id="L900">									optimum.BackPrev = 0;</span>
<span class="nc" id="L901">									optimum.Prev1IsChar = true;</span>
<span class="nc" id="L902">									optimum.Prev2 = true;</span>
<span class="nc" id="L903">									optimum.PosPrev2 = cur;</span>
<span class="nc" id="L904">									optimum.BackPrev2 = curBack + Base.kNumRepDistances;</span>
								}
							}
						}
<span class="nc" id="L908">						offs += 2;</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">						if (offs == numDistancePairs) break;</span>
					}
				}
			}
<span class="nc" id="L913">		}</span>
	}

	boolean ChangePair (int smallDist, int bigDist) {
<span class="nc" id="L917">		int kDif = 7;</span>
<span class="nc bnc" id="L918" title="All 4 branches missed.">		return (smallDist &lt; (1 &lt;&lt; (32 - kDif)) &amp;&amp; bigDist &gt;= (smallDist &lt;&lt; kDif));</span>
	}

	void WriteEndMarker (int posState) throws IOException {
<span class="nc bnc" id="L922" title="All 2 branches missed.">		if (!_writeEndMark) return;</span>

<span class="nc" id="L924">		_rangeEncoder.Encode(_isMatch, (_state &lt;&lt; Base.kNumPosStatesBitsMax) + posState, 1);</span>
<span class="nc" id="L925">		_rangeEncoder.Encode(_isRep, _state, 0);</span>
<span class="nc" id="L926">		_state = Base.StateUpdateMatch(_state);</span>
<span class="nc" id="L927">		int len = Base.kMatchMinLen;</span>
<span class="nc" id="L928">		_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);</span>
<span class="nc" id="L929">		int posSlot = (1 &lt;&lt; Base.kNumPosSlotBits) - 1;</span>
<span class="nc" id="L930">		int lenToPosState = Base.GetLenToPosState(len);</span>
<span class="nc" id="L931">		_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);</span>
<span class="nc" id="L932">		int footerBits = 30;</span>
<span class="nc" id="L933">		int posReduced = (1 &lt;&lt; footerBits) - 1;</span>
<span class="nc" id="L934">		_rangeEncoder.EncodeDirectBits(posReduced &gt;&gt; Base.kNumAlignBits, footerBits - Base.kNumAlignBits);</span>
<span class="nc" id="L935">		_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced &amp; Base.kAlignMask);</span>
<span class="nc" id="L936">	}</span>

	void Flush (int nowPos) throws IOException {
<span class="nc" id="L939">		ReleaseMFStream();</span>
<span class="nc" id="L940">		WriteEndMarker(nowPos &amp; _posStateMask);</span>
<span class="nc" id="L941">		_rangeEncoder.FlushData();</span>
<span class="nc" id="L942">		_rangeEncoder.FlushStream();</span>
<span class="nc" id="L943">	}</span>

	public void CodeOneBlock (long[] inSize, long[] outSize, boolean[] finished) throws IOException {
<span class="nc" id="L946">		inSize[0] = 0;</span>
<span class="nc" id="L947">		outSize[0] = 0;</span>
<span class="nc" id="L948">		finished[0] = true;</span>

<span class="nc bnc" id="L950" title="All 2 branches missed.">		if (_inStream != null) {</span>
<span class="nc" id="L951">			_matchFinder.SetStream(_inStream);</span>
<span class="nc" id="L952">			_matchFinder.Init();</span>
<span class="nc" id="L953">			_needReleaseMFStream = true;</span>
<span class="nc" id="L954">			_inStream = null;</span>
		}

<span class="nc bnc" id="L957" title="All 2 branches missed.">		if (_finished) return;</span>
<span class="nc" id="L958">		_finished = true;</span>

<span class="nc" id="L960">		long progressPosValuePrev = nowPos64;</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">		if (nowPos64 == 0) {</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">			if (_matchFinder.GetNumAvailableBytes() == 0) {</span>
<span class="nc" id="L963">				Flush((int)nowPos64);</span>
<span class="nc" id="L964">				return;</span>
			}

<span class="nc" id="L967">			ReadMatchDistances();</span>
<span class="nc" id="L968">			int posState = (int)(nowPos64) &amp; _posStateMask;</span>
<span class="nc" id="L969">			_rangeEncoder.Encode(_isMatch, (_state &lt;&lt; Base.kNumPosStatesBitsMax) + posState, 0);</span>
<span class="nc" id="L970">			_state = Base.StateUpdateChar(_state);</span>
<span class="nc" id="L971">			byte curByte = _matchFinder.GetIndexByte(0 - _additionalOffset);</span>
<span class="nc" id="L972">			_literalEncoder.GetSubCoder((int)(nowPos64), _previousByte).Encode(_rangeEncoder, curByte);</span>
<span class="nc" id="L973">			_previousByte = curByte;</span>
<span class="nc" id="L974">			_additionalOffset--;</span>
<span class="nc" id="L975">			nowPos64++;</span>
		}
<span class="nc bnc" id="L977" title="All 2 branches missed.">		if (_matchFinder.GetNumAvailableBytes() == 0) {</span>
<span class="nc" id="L978">			Flush((int)nowPos64);</span>
<span class="nc" id="L979">			return;</span>
		}
		while (true) {

<span class="nc" id="L983">			int len = GetOptimum((int)nowPos64);</span>
<span class="nc" id="L984">			int pos = backRes;</span>
<span class="nc" id="L985">			int posState = ((int)nowPos64) &amp; _posStateMask;</span>
<span class="nc" id="L986">			int complexState = (_state &lt;&lt; Base.kNumPosStatesBitsMax) + posState;</span>
<span class="nc bnc" id="L987" title="All 4 branches missed.">			if (len == 1 &amp;&amp; pos == -1) {</span>
<span class="nc" id="L988">				_rangeEncoder.Encode(_isMatch, complexState, 0);</span>
<span class="nc" id="L989">				byte curByte = _matchFinder.GetIndexByte((int)(0 - _additionalOffset));</span>
<span class="nc" id="L990">				LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((int)nowPos64, _previousByte);</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">				if (!Base.StateIsCharState(_state)) {</span>
<span class="nc" id="L992">					byte matchByte = _matchFinder.GetIndexByte((int)(0 - _repDistances[0] - 1 - _additionalOffset));</span>
<span class="nc" id="L993">					subCoder.EncodeMatched(_rangeEncoder, matchByte, curByte);</span>
<span class="nc" id="L994">				} else</span>
<span class="nc" id="L995">					subCoder.Encode(_rangeEncoder, curByte);</span>
<span class="nc" id="L996">				_previousByte = curByte;</span>
<span class="nc" id="L997">				_state = Base.StateUpdateChar(_state);</span>
<span class="nc" id="L998">			} else {</span>
<span class="nc" id="L999">				_rangeEncoder.Encode(_isMatch, complexState, 1);</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">				if (pos &lt; Base.kNumRepDistances) {</span>
<span class="nc" id="L1001">					_rangeEncoder.Encode(_isRep, _state, 1);</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">					if (pos == 0) {</span>
<span class="nc" id="L1003">						_rangeEncoder.Encode(_isRepG0, _state, 0);</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">						if (len == 1)</span>
<span class="nc" id="L1005">							_rangeEncoder.Encode(_isRep0Long, complexState, 0);</span>
						else
<span class="nc" id="L1007">							_rangeEncoder.Encode(_isRep0Long, complexState, 1);</span>
					} else {
<span class="nc" id="L1009">						_rangeEncoder.Encode(_isRepG0, _state, 1);</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">						if (pos == 1)</span>
<span class="nc" id="L1011">							_rangeEncoder.Encode(_isRepG1, _state, 0);</span>
						else {
<span class="nc" id="L1013">							_rangeEncoder.Encode(_isRepG1, _state, 1);</span>
<span class="nc" id="L1014">							_rangeEncoder.Encode(_isRepG2, _state, pos - 2);</span>
						}
					}
<span class="nc bnc" id="L1017" title="All 2 branches missed.">					if (len == 1)</span>
<span class="nc" id="L1018">						_state = Base.StateUpdateShortRep(_state);</span>
					else {
<span class="nc" id="L1020">						_repMatchLenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);</span>
<span class="nc" id="L1021">						_state = Base.StateUpdateRep(_state);</span>
					}
<span class="nc" id="L1023">					int distance = _repDistances[pos];</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">					if (pos != 0) {</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">						for (int i = pos; i &gt;= 1; i--)</span>
<span class="nc" id="L1026">							_repDistances[i] = _repDistances[i - 1];</span>
<span class="nc" id="L1027">						_repDistances[0] = distance;</span>
					}
<span class="nc" id="L1029">				} else {</span>
<span class="nc" id="L1030">					_rangeEncoder.Encode(_isRep, _state, 0);</span>
<span class="nc" id="L1031">					_state = Base.StateUpdateMatch(_state);</span>
<span class="nc" id="L1032">					_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);</span>
<span class="nc" id="L1033">					pos -= Base.kNumRepDistances;</span>
<span class="nc" id="L1034">					int posSlot = GetPosSlot(pos);</span>
<span class="nc" id="L1035">					int lenToPosState = Base.GetLenToPosState(len);</span>
<span class="nc" id="L1036">					_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);</span>

<span class="nc bnc" id="L1038" title="All 2 branches missed.">					if (posSlot &gt;= Base.kStartPosModelIndex) {</span>
<span class="nc" id="L1039">						int footerBits = (int)((posSlot &gt;&gt; 1) - 1);</span>
<span class="nc" id="L1040">						int baseVal = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);</span>
<span class="nc" id="L1041">						int posReduced = pos - baseVal;</span>

<span class="nc bnc" id="L1043" title="All 2 branches missed.">						if (posSlot &lt; Base.kEndPosModelIndex)</span>
<span class="nc" id="L1044">							BitTreeEncoder.ReverseEncode(_posEncoders, baseVal - posSlot - 1, _rangeEncoder, footerBits, posReduced);</span>
						else {
<span class="nc" id="L1046">							_rangeEncoder.EncodeDirectBits(posReduced &gt;&gt; Base.kNumAlignBits, footerBits - Base.kNumAlignBits);</span>
<span class="nc" id="L1047">							_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced &amp; Base.kAlignMask);</span>
<span class="nc" id="L1048">							_alignPriceCount++;</span>
						}
					}
<span class="nc" id="L1051">					int distance = pos;</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">					for (int i = Base.kNumRepDistances - 1; i &gt;= 1; i--)</span>
<span class="nc" id="L1053">						_repDistances[i] = _repDistances[i - 1];</span>
<span class="nc" id="L1054">					_repDistances[0] = distance;</span>
<span class="nc" id="L1055">					_matchPriceCount++;</span>
				}
<span class="nc" id="L1057">				_previousByte = _matchFinder.GetIndexByte(len - 1 - _additionalOffset);</span>
			}
<span class="nc" id="L1059">			_additionalOffset -= len;</span>
<span class="nc" id="L1060">			nowPos64 += len;</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">			if (_additionalOffset == 0) {</span>
				// if (!_fastMode)
<span class="nc bnc" id="L1063" title="All 2 branches missed.">				if (_matchPriceCount &gt;= (1 &lt;&lt; 7)) FillDistancesPrices();</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">				if (_alignPriceCount &gt;= Base.kAlignTableSize) FillAlignPrices();</span>
<span class="nc" id="L1065">				inSize[0] = nowPos64;</span>
<span class="nc" id="L1066">				outSize[0] = _rangeEncoder.GetProcessedSizeAdd();</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">				if (_matchFinder.GetNumAvailableBytes() == 0) {</span>
<span class="nc" id="L1068">					Flush((int)nowPos64);</span>
<span class="nc" id="L1069">					return;</span>
				}

<span class="nc bnc" id="L1072" title="All 2 branches missed.">				if (nowPos64 - progressPosValuePrev &gt;= (1 &lt;&lt; 12)) {</span>
<span class="nc" id="L1073">					_finished = false;</span>
<span class="nc" id="L1074">					finished[0] = false;</span>
<span class="nc" id="L1075">					return;</span>
				}
			}
<span class="nc" id="L1078">		}</span>
	}

	void ReleaseMFStream () {
<span class="nc bnc" id="L1082" title="All 4 branches missed.">		if (_matchFinder != null &amp;&amp; _needReleaseMFStream) {</span>
<span class="nc" id="L1083">			_matchFinder.ReleaseStream();</span>
<span class="nc" id="L1084">			_needReleaseMFStream = false;</span>
		}
<span class="nc" id="L1086">	}</span>

	void SetOutStream (java.io.OutputStream outStream) {
<span class="nc" id="L1089">		_rangeEncoder.SetStream(outStream);</span>
<span class="nc" id="L1090">	}</span>

	void ReleaseOutStream () {
<span class="nc" id="L1093">		_rangeEncoder.ReleaseStream();</span>
<span class="nc" id="L1094">	}</span>

	void ReleaseStreams () {
<span class="nc" id="L1097">		ReleaseMFStream();</span>
<span class="nc" id="L1098">		ReleaseOutStream();</span>
<span class="nc" id="L1099">	}</span>

	void SetStreams (java.io.InputStream inStream, java.io.OutputStream outStream, long inSize, long outSize) {
<span class="nc" id="L1102">		_inStream = inStream;</span>
<span class="nc" id="L1103">		_finished = false;</span>
<span class="nc" id="L1104">		Create();</span>
<span class="nc" id="L1105">		SetOutStream(outStream);</span>
<span class="nc" id="L1106">		Init();</span>

		// if (!_fastMode)
		{
<span class="nc" id="L1110">			FillDistancesPrices();</span>
<span class="nc" id="L1111">			FillAlignPrices();</span>
		}

<span class="nc" id="L1114">		_lenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);</span>
<span class="nc" id="L1115">		_lenEncoder.UpdateTables(1 &lt;&lt; _posStateBits);</span>
<span class="nc" id="L1116">		_repMatchLenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);</span>
<span class="nc" id="L1117">		_repMatchLenEncoder.UpdateTables(1 &lt;&lt; _posStateBits);</span>

<span class="nc" id="L1119">		nowPos64 = 0;</span>
<span class="nc" id="L1120">	}</span>

<span class="nc" id="L1122">	long[] processedInSize = new long[1];</span>
<span class="nc" id="L1123">	long[] processedOutSize = new long[1];</span>
<span class="nc" id="L1124">	boolean[] finished = new boolean[1];</span>

	public void Code (java.io.InputStream inStream, java.io.OutputStream outStream, long inSize, long outSize,
		ICodeProgress progress) throws IOException {
<span class="nc" id="L1128">		_needReleaseMFStream = false;</span>
		try {
<span class="nc" id="L1130">			SetStreams(inStream, outStream, inSize, outSize);</span>
			while (true) {

<span class="nc" id="L1133">				CodeOneBlock(processedInSize, processedOutSize, finished);</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">				if (finished[0]) return;</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">				if (progress != null) {</span>
<span class="nc" id="L1136">					progress.SetProgress(processedInSize[0], processedOutSize[0]);</span>
				}
			}
		} finally {
<span class="nc" id="L1140">			ReleaseStreams();</span>
		}
	}

	public static final int kPropSize = 5;
<span class="nc" id="L1145">	byte[] properties = new byte[kPropSize];</span>

	public void WriteCoderProperties (java.io.OutputStream outStream) throws IOException {
<span class="nc" id="L1148">		properties[0] = (byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">		for (int i = 0; i &lt; 4; i++)</span>
<span class="nc" id="L1150">			properties[1 + i] = (byte)(_dictionarySize &gt;&gt; (8 * i));</span>
<span class="nc" id="L1151">		outStream.write(properties, 0, kPropSize);</span>
<span class="nc" id="L1152">	}</span>

<span class="nc" id="L1154">	int[] tempPrices = new int[Base.kNumFullDistances];</span>
	int _matchPriceCount;

	void FillDistancesPrices () {
<span class="nc bnc" id="L1158" title="All 2 branches missed.">		for (int i = Base.kStartPosModelIndex; i &lt; Base.kNumFullDistances; i++) {</span>
<span class="nc" id="L1159">			int posSlot = GetPosSlot(i);</span>
<span class="nc" id="L1160">			int footerBits = (int)((posSlot &gt;&gt; 1) - 1);</span>
<span class="nc" id="L1161">			int baseVal = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);</span>
<span class="nc" id="L1162">			tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders, baseVal - posSlot - 1, footerBits, i - baseVal);</span>
		}

<span class="nc bnc" id="L1165" title="All 2 branches missed.">		for (int lenToPosState = 0; lenToPosState &lt; Base.kNumLenToPosStates; lenToPosState++) {</span>
			int posSlot;
<span class="nc" id="L1167">			BitTreeEncoder encoder = _posSlotEncoder[lenToPosState];</span>

<span class="nc" id="L1169">			int st = (lenToPosState &lt;&lt; Base.kNumPosSlotBits);</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">			for (posSlot = 0; posSlot &lt; _distTableSize; posSlot++)</span>
<span class="nc" id="L1171">				_posSlotPrices[st + posSlot] = encoder.GetPrice(posSlot);</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">			for (posSlot = Base.kEndPosModelIndex; posSlot &lt; _distTableSize; posSlot++)</span>
<span class="nc" id="L1173">				_posSlotPrices[st + posSlot] += ((((posSlot &gt;&gt; 1) - 1) - Base.kNumAlignBits) &lt;&lt; com.badlogic.gdx.utils.compression.rangecoder.Encoder.kNumBitPriceShiftBits);</span>

<span class="nc" id="L1175">			int st2 = lenToPosState * Base.kNumFullDistances;</span>
			int i;
<span class="nc bnc" id="L1177" title="All 2 branches missed.">			for (i = 0; i &lt; Base.kStartPosModelIndex; i++)</span>
<span class="nc" id="L1178">				_distancesPrices[st2 + i] = _posSlotPrices[st + i];</span>
<span class="nc bnc" id="L1179" title="All 2 branches missed.">			for (; i &lt; Base.kNumFullDistances; i++)</span>
<span class="nc" id="L1180">				_distancesPrices[st2 + i] = _posSlotPrices[st + GetPosSlot(i)] + tempPrices[i];</span>
		}
<span class="nc" id="L1182">		_matchPriceCount = 0;</span>
<span class="nc" id="L1183">	}</span>

	void FillAlignPrices () {
<span class="nc bnc" id="L1186" title="All 2 branches missed.">		for (int i = 0; i &lt; Base.kAlignTableSize; i++)</span>
<span class="nc" id="L1187">			_alignPrices[i] = _posAlignEncoder.ReverseGetPrice(i);</span>
<span class="nc" id="L1188">		_alignPriceCount = 0;</span>
<span class="nc" id="L1189">	}</span>

	public boolean SetAlgorithm (int algorithm) {
		/*
		 * _fastMode = (algorithm == 0); _maxMode = (algorithm &gt;= 2);
		 */
<span class="nc" id="L1195">		return true;</span>
	}

	public boolean SetDictionarySize (int dictionarySize) {
<span class="nc" id="L1199">		int kDicLogSizeMaxCompress = 29;</span>
<span class="nc bnc" id="L1200" title="All 4 branches missed.">		if (dictionarySize &lt; (1 &lt;&lt; Base.kDicLogSizeMin) || dictionarySize &gt; (1 &lt;&lt; kDicLogSizeMaxCompress)) return false;</span>
<span class="nc" id="L1201">		_dictionarySize = dictionarySize;</span>
		int dicLogSize;
<span class="nc bnc" id="L1203" title="All 2 branches missed.">		for (dicLogSize = 0; dictionarySize &gt; (1 &lt;&lt; dicLogSize); dicLogSize++)</span>
			;
<span class="nc" id="L1205">		_distTableSize = dicLogSize * 2;</span>
<span class="nc" id="L1206">		return true;</span>
	}

	public boolean SetNumFastBytes (int numFastBytes) {
<span class="nc bnc" id="L1210" title="All 4 branches missed.">		if (numFastBytes &lt; 5 || numFastBytes &gt; Base.kMatchMaxLen) return false;</span>
<span class="nc" id="L1211">		_numFastBytes = numFastBytes;</span>
<span class="nc" id="L1212">		return true;</span>
	}

	public boolean SetMatchFinder (int matchFinderIndex) {
<span class="nc bnc" id="L1216" title="All 4 branches missed.">		if (matchFinderIndex &lt; 0 || matchFinderIndex &gt; 2) return false;</span>
<span class="nc" id="L1217">		int matchFinderIndexPrev = _matchFinderType;</span>
<span class="nc" id="L1218">		_matchFinderType = matchFinderIndex;</span>
<span class="nc bnc" id="L1219" title="All 4 branches missed.">		if (_matchFinder != null &amp;&amp; matchFinderIndexPrev != _matchFinderType) {</span>
<span class="nc" id="L1220">			_dictionarySizePrev = -1;</span>
<span class="nc" id="L1221">			_matchFinder = null;</span>
		}
<span class="nc" id="L1223">		return true;</span>
	}

	public boolean SetLcLpPb (int lc, int lp, int pb) {
<span class="nc bnc" id="L1227" title="All 12 branches missed.">		if (lp &lt; 0 || lp &gt; Base.kNumLitPosStatesBitsEncodingMax || lc &lt; 0 || lc &gt; Base.kNumLitContextBitsMax || pb &lt; 0</span>
<span class="nc" id="L1228">			|| pb &gt; Base.kNumPosStatesBitsEncodingMax) return false;</span>
<span class="nc" id="L1229">		_numLiteralPosStateBits = lp;</span>
<span class="nc" id="L1230">		_numLiteralContextBits = lc;</span>
<span class="nc" id="L1231">		_posStateBits = pb;</span>
<span class="nc" id="L1232">		_posStateMask = ((1) &lt;&lt; _posStateBits) - 1;</span>
<span class="nc" id="L1233">		return true;</span>
	}

	public void SetEndMarkerMode (boolean endMarkerMode) {
<span class="nc" id="L1237">		_writeEndMark = endMarkerMode;</span>
<span class="nc" id="L1238">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>