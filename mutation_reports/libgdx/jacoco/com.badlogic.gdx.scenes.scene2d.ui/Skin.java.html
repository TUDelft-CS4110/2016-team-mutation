<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Skin.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.scenes.scene2d.ui</a> &gt; <span class="el_source">Skin.java</span></div><h1>Skin.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.scenes.scene2d.ui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.NinePatch;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureAtlas.AtlasRegion;
import com.badlogic.gdx.graphics.g2d.TextureAtlas.AtlasSprite;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable;
import com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Disposable;
import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.Json.ReadOnlySerializer;
import com.badlogic.gdx.utils.JsonValue;
import com.badlogic.gdx.utils.ObjectMap;
import com.badlogic.gdx.utils.SerializationException;
import com.badlogic.gdx.utils.reflect.ClassReflection;
import com.badlogic.gdx.utils.reflect.Method;
import com.badlogic.gdx.utils.reflect.ReflectionException;

/** A skin stores resources for UI widgets to use (texture regions, ninepatches, fonts, colors, etc). Resources are named and can
 * be looked up by name and type. Resources can be described in JSON. Skin provides useful conversions, such as allowing access to
 * regions in the atlas as ninepatches, sprites, drawables, etc. The get* methods return an instance of the object in the skin.
 * The new* methods return a copy of an instance in the skin.
 * &lt;p&gt;
 * See the &lt;a href=&quot;https://github.com/libgdx/libgdx/wiki/Skin&quot;&gt;documentation&lt;/a&gt; for more.
 * @author Nathan Sweet */
public class Skin implements Disposable {
<span class="nc" id="L57">	ObjectMap&lt;Class, ObjectMap&lt;String, Object&gt;&gt; resources = new ObjectMap();</span>
	TextureAtlas atlas;

	/** Creates an empty skin. */
<span class="nc" id="L61">	public Skin () {</span>
<span class="nc" id="L62">	}</span>

	/** Creates a skin containing the resources in the specified skin JSON file. If a file in the same directory with a &quot;.atlas&quot;
	 * extension exists, it is loaded as a {@link TextureAtlas} and the texture regions added to the skin. The atlas is
	 * automatically disposed when the skin is disposed. */
<span class="nc" id="L67">	public Skin (FileHandle skinFile) {</span>
<span class="nc" id="L68">		FileHandle atlasFile = skinFile.sibling(skinFile.nameWithoutExtension() + &quot;.atlas&quot;);</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">		if (atlasFile.exists()) {</span>
<span class="nc" id="L70">			atlas = new TextureAtlas(atlasFile);</span>
<span class="nc" id="L71">			addRegions(atlas);</span>
		}

<span class="nc" id="L74">		load(skinFile);</span>
<span class="nc" id="L75">	}</span>

	/** Creates a skin containing the resources in the specified skin JSON file and the texture regions from the specified atlas.
	 * The atlas is automatically disposed when the skin is disposed. */
<span class="nc" id="L79">	public Skin (FileHandle skinFile, TextureAtlas atlas) {</span>
<span class="nc" id="L80">		this.atlas = atlas;</span>
<span class="nc" id="L81">		addRegions(atlas);</span>
<span class="nc" id="L82">		load(skinFile);</span>
<span class="nc" id="L83">	}</span>

	/** Creates a skin containing the texture regions from the specified atlas. The atlas is automatically disposed when the skin
	 * is disposed. */
<span class="nc" id="L87">	public Skin (TextureAtlas atlas) {</span>
<span class="nc" id="L88">		this.atlas = atlas;</span>
<span class="nc" id="L89">		addRegions(atlas);</span>
<span class="nc" id="L90">	}</span>

	/** Adds all resources in the specified skin JSON file. */
	public void load (FileHandle skinFile) {
		try {
<span class="nc" id="L95">			getJsonLoader(skinFile).fromJson(Skin.class, skinFile);</span>
<span class="nc" id="L96">		} catch (SerializationException ex) {</span>
<span class="nc" id="L97">			throw new SerializationException(&quot;Error reading file: &quot; + skinFile, ex);</span>
<span class="nc" id="L98">		}</span>
<span class="nc" id="L99">	}</span>

	/** Adds all named texture regions from the atlas. The atlas will not be automatically disposed when the skin is disposed. */
	public void addRegions (TextureAtlas atlas) {
<span class="nc" id="L103">		Array&lt;AtlasRegion&gt; regions = atlas.getRegions();</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">		for (int i = 0, n = regions.size; i &lt; n; i++) {</span>
<span class="nc" id="L105">			AtlasRegion region = regions.get(i);</span>
<span class="nc" id="L106">			add(region.name, region, TextureRegion.class);</span>
		}
<span class="nc" id="L108">	}</span>

	public void add (String name, Object resource) {
<span class="nc" id="L111">		add(name, resource, resource.getClass());</span>
<span class="nc" id="L112">	}</span>

	public void add (String name, Object resource, Class type) {
<span class="nc bnc" id="L115" title="All 2 branches missed.">		if (name == null) throw new IllegalArgumentException(&quot;name cannot be null.&quot;);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">		if (resource == null) throw new IllegalArgumentException(&quot;resource cannot be null.&quot;);</span>
<span class="nc" id="L117">		ObjectMap&lt;String, Object&gt; typeResources = resources.get(type);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">		if (typeResources == null) {</span>
<span class="nc bnc" id="L119" title="All 6 branches missed.">			typeResources = new ObjectMap(type == TextureRegion.class || type == Drawable.class || type == Sprite.class ? 256 : 64);</span>
<span class="nc" id="L120">			resources.put(type, typeResources);</span>
		}
<span class="nc" id="L122">		typeResources.put(name, resource);</span>
<span class="nc" id="L123">	}</span>

	public void remove (String name, Class type) {
<span class="nc bnc" id="L126" title="All 2 branches missed.">		if (name == null) throw new IllegalArgumentException(&quot;name cannot be null.&quot;);</span>
<span class="nc" id="L127">		ObjectMap&lt;String, Object&gt; typeResources = resources.get(type);</span>
<span class="nc" id="L128">		typeResources.remove(name);</span>
<span class="nc" id="L129">	}</span>

	/** Returns a resource named &quot;default&quot; for the specified type.
	 * @throws GdxRuntimeException if the resource was not found. */
	public &lt;T&gt; T get (Class&lt;T&gt; type) {
<span class="nc" id="L134">		return get(&quot;default&quot;, type);</span>
	}

	/** Returns a named resource of the specified type.
	 * @throws GdxRuntimeException if the resource was not found. */
	public &lt;T&gt; T get (String name, Class&lt;T&gt; type) {
<span class="nc bnc" id="L140" title="All 2 branches missed.">		if (name == null) throw new IllegalArgumentException(&quot;name cannot be null.&quot;);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">		if (type == null) throw new IllegalArgumentException(&quot;type cannot be null.&quot;);</span>

<span class="nc bnc" id="L143" title="All 2 branches missed.">		if (type == Drawable.class) return (T)getDrawable(name);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">		if (type == TextureRegion.class) return (T)getRegion(name);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">		if (type == NinePatch.class) return (T)getPatch(name);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">		if (type == Sprite.class) return (T)getSprite(name);</span>

<span class="nc" id="L148">		ObjectMap&lt;String, Object&gt; typeResources = resources.get(type);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">		if (typeResources == null) throw new GdxRuntimeException(&quot;No &quot; + type.getName() + &quot; registered with name: &quot; + name);</span>
<span class="nc" id="L150">		Object resource = typeResources.get(name);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">		if (resource == null) throw new GdxRuntimeException(&quot;No &quot; + type.getName() + &quot; registered with name: &quot; + name);</span>
<span class="nc" id="L152">		return (T)resource;</span>
	}

	/** Returns a named resource of the specified type.
	 * @return null if not found. */
	public &lt;T&gt; T optional (String name, Class&lt;T&gt; type) {
<span class="nc bnc" id="L158" title="All 2 branches missed.">		if (name == null) throw new IllegalArgumentException(&quot;name cannot be null.&quot;);</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">		if (type == null) throw new IllegalArgumentException(&quot;type cannot be null.&quot;);</span>
<span class="nc" id="L160">		ObjectMap&lt;String, Object&gt; typeResources = resources.get(type);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">		if (typeResources == null) return null;</span>
<span class="nc" id="L162">		return (T)typeResources.get(name);</span>
	}

	public boolean has (String name, Class type) {
<span class="nc" id="L166">		ObjectMap&lt;String, Object&gt; typeResources = resources.get(type);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">		if (typeResources == null) return false;</span>
<span class="nc" id="L168">		return typeResources.containsKey(name);</span>
	}

	/** Returns the name to resource mapping for the specified type, or null if no resources of that type exist. */
	public &lt;T&gt; ObjectMap&lt;String, T&gt; getAll (Class&lt;T&gt; type) {
<span class="nc" id="L173">		return (ObjectMap&lt;String, T&gt;)resources.get(type);</span>
	}

	public Color getColor (String name) {
<span class="nc" id="L177">		return get(name, Color.class);</span>
	}

	public BitmapFont getFont (String name) {
<span class="nc" id="L181">		return get(name, BitmapFont.class);</span>
	}

	/** Returns a registered texture region. If no region is found but a texture exists with the name, a region is created from the
	 * texture and stored in the skin. */
	public TextureRegion getRegion (String name) {
<span class="nc" id="L187">		TextureRegion region = optional(name, TextureRegion.class);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">		if (region != null) return region;</span>

<span class="nc" id="L190">		Texture texture = optional(name, Texture.class);</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">		if (texture == null) throw new GdxRuntimeException(&quot;No TextureRegion or Texture registered with name: &quot; + name);</span>
<span class="nc" id="L192">		region = new TextureRegion(texture);</span>
<span class="nc" id="L193">		add(name, region, TextureRegion.class);</span>
<span class="nc" id="L194">		return region;</span>
	}

	/** Returns a registered tiled drawable. If no tiled drawable is found but a region exists with the name, a tiled drawable is
	 * created from the region and stored in the skin. */
	public TiledDrawable getTiledDrawable (String name) {
<span class="nc" id="L200">		TiledDrawable tiled = optional(name, TiledDrawable.class);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">		if (tiled != null) return tiled;</span>

<span class="nc" id="L203">		tiled = new TiledDrawable(getRegion(name));</span>
<span class="nc" id="L204">		tiled.setName(name);</span>
<span class="nc" id="L205">		add(name, tiled, TiledDrawable.class);</span>
<span class="nc" id="L206">		return tiled;</span>
	}

	/** Returns a registered ninepatch. If no ninepatch is found but a region exists with the name, a ninepatch is created from the
	 * region and stored in the skin. If the region is an {@link AtlasRegion} then the {@link AtlasRegion#splits} are used,
	 * otherwise the ninepatch will have the region as the center patch. */
	public NinePatch getPatch (String name) {
<span class="nc" id="L213">		NinePatch patch = optional(name, NinePatch.class);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">		if (patch != null) return patch;</span>

		try {
<span class="nc" id="L217">			TextureRegion region = getRegion(name);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">			if (region instanceof AtlasRegion) {</span>
<span class="nc" id="L219">				int[] splits = ((AtlasRegion)region).splits;</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">				if (splits != null) {</span>
<span class="nc" id="L221">					patch = new NinePatch(region, splits[0], splits[1], splits[2], splits[3]);</span>
<span class="nc" id="L222">					int[] pads = ((AtlasRegion)region).pads;</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">					if (pads != null) patch.setPadding(pads[0], pads[1], pads[2], pads[3]);</span>
				}
			}
<span class="nc bnc" id="L226" title="All 2 branches missed.">			if (patch == null) patch = new NinePatch(region);</span>
<span class="nc" id="L227">			add(name, patch, NinePatch.class);</span>
<span class="nc" id="L228">			return patch;</span>
<span class="nc" id="L229">		} catch (GdxRuntimeException ex) {</span>
<span class="nc" id="L230">			throw new GdxRuntimeException(&quot;No NinePatch, TextureRegion, or Texture registered with name: &quot; + name);</span>
		}
	}

	/** Returns a registered sprite. If no sprite is found but a region exists with the name, a sprite is created from the region
	 * and stored in the skin. If the region is an {@link AtlasRegion} then an {@link AtlasSprite} is used if the region has been
	 * whitespace stripped or packed rotated 90 degrees. */
	public Sprite getSprite (String name) {
<span class="nc" id="L238">		Sprite sprite = optional(name, Sprite.class);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">		if (sprite != null) return sprite;</span>

		try {
<span class="nc" id="L242">			TextureRegion textureRegion = getRegion(name);</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">			if (textureRegion instanceof AtlasRegion) {</span>
<span class="nc" id="L244">				AtlasRegion region = (AtlasRegion)textureRegion;</span>
<span class="nc bnc" id="L245" title="All 6 branches missed.">				if (region.rotate || region.packedWidth != region.originalWidth || region.packedHeight != region.originalHeight)</span>
<span class="nc" id="L246">					sprite = new AtlasSprite(region);</span>
			}
<span class="nc bnc" id="L248" title="All 2 branches missed.">			if (sprite == null) sprite = new Sprite(textureRegion);</span>
<span class="nc" id="L249">			add(name, sprite, Sprite.class);</span>
<span class="nc" id="L250">			return sprite;</span>
<span class="nc" id="L251">		} catch (GdxRuntimeException ex) {</span>
<span class="nc" id="L252">			throw new GdxRuntimeException(&quot;No NinePatch, TextureRegion, or Texture registered with name: &quot; + name);</span>
		}
	}

	/** Returns a registered drawable. If no drawable is found but a region, ninepatch, or sprite exists with the name, then the
	 * appropriate drawable is created and stored in the skin. */
	public Drawable getDrawable (String name) {
<span class="nc" id="L259">		Drawable drawable = optional(name, Drawable.class);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">		if (drawable != null) return drawable;</span>

		// Use texture or texture region. If it has splits, use ninepatch. If it has rotation or whitespace stripping, use sprite.
		try {
<span class="nc" id="L264">			TextureRegion textureRegion = getRegion(name);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">			if (textureRegion instanceof AtlasRegion) {</span>
<span class="nc" id="L266">				AtlasRegion region = (AtlasRegion)textureRegion;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">				if (region.splits != null)</span>
<span class="nc" id="L268">					drawable = new NinePatchDrawable(getPatch(name));</span>
<span class="nc bnc" id="L269" title="All 6 branches missed.">				else if (region.rotate || region.packedWidth != region.originalWidth || region.packedHeight != region.originalHeight)</span>
<span class="nc" id="L270">					drawable = new SpriteDrawable(getSprite(name));</span>
			}
<span class="nc bnc" id="L272" title="All 2 branches missed.">			if (drawable == null) drawable = new TextureRegionDrawable(textureRegion);</span>
<span class="nc" id="L273">		} catch (GdxRuntimeException ignored) {</span>
<span class="nc" id="L274">		}</span>

		// Check for explicit registration of ninepatch, sprite, or tiled drawable.
<span class="nc bnc" id="L277" title="All 2 branches missed.">		if (drawable == null) {</span>
<span class="nc" id="L278">			NinePatch patch = optional(name, NinePatch.class);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">			if (patch != null)</span>
<span class="nc" id="L280">				drawable = new NinePatchDrawable(patch);</span>
			else {
<span class="nc" id="L282">				Sprite sprite = optional(name, Sprite.class);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">				if (sprite != null)</span>
<span class="nc" id="L284">					drawable = new SpriteDrawable(sprite);</span>
				else
<span class="nc" id="L286">					throw new GdxRuntimeException(</span>
						&quot;No Drawable, NinePatch, TextureRegion, Texture, or Sprite registered with name: &quot; + name);
			}
		}

<span class="nc bnc" id="L291" title="All 2 branches missed.">		if (drawable instanceof BaseDrawable) ((BaseDrawable)drawable).setName(name);</span>

<span class="nc" id="L293">		add(name, drawable, Drawable.class);</span>
<span class="nc" id="L294">		return drawable;</span>
	}

	/** Returns the name of the specified style object, or null if it is not in the skin. This compares potentially every style
	 * object in the skin of the same type as the specified style, which may be a somewhat expensive operation. */
	public String find (Object resource) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">		if (resource == null) throw new IllegalArgumentException(&quot;style cannot be null.&quot;);</span>
<span class="nc" id="L301">		ObjectMap&lt;String, Object&gt; typeResources = resources.get(resource.getClass());</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">		if (typeResources == null) return null;</span>
<span class="nc" id="L303">		return typeResources.findKey(resource, true);</span>
	}

	/** Returns a copy of a drawable found in the skin via {@link #getDrawable(String)}. */
	public Drawable newDrawable (String name) {
<span class="nc" id="L308">		return newDrawable(getDrawable(name));</span>
	}

	/** Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}. */
	public Drawable newDrawable (String name, float r, float g, float b, float a) {
<span class="nc" id="L313">		return newDrawable(getDrawable(name), new Color(r, g, b, a));</span>
	}

	/** Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}. */
	public Drawable newDrawable (String name, Color tint) {
<span class="nc" id="L318">		return newDrawable(getDrawable(name), tint);</span>
	}

	/** Returns a copy of the specified drawable. */
	public Drawable newDrawable (Drawable drawable) {
<span class="nc bnc" id="L323" title="All 2 branches missed.">		if (drawable instanceof TiledDrawable) return new TiledDrawable((TiledDrawable)drawable);</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">		if (drawable instanceof TextureRegionDrawable) return new TextureRegionDrawable((TextureRegionDrawable)drawable);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">		if (drawable instanceof NinePatchDrawable) return new NinePatchDrawable((NinePatchDrawable)drawable);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">		if (drawable instanceof SpriteDrawable) return new SpriteDrawable((SpriteDrawable)drawable);</span>
<span class="nc" id="L327">		throw new GdxRuntimeException(&quot;Unable to copy, unknown drawable type: &quot; + drawable.getClass());</span>
	}

	/** Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}. */
	public Drawable newDrawable (Drawable drawable, float r, float g, float b, float a) {
<span class="nc" id="L332">		return newDrawable(drawable, new Color(r, g, b, a));</span>
	}

	/** Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}. */
	public Drawable newDrawable (Drawable drawable, Color tint) {
		Drawable newDrawable;
<span class="nc bnc" id="L338" title="All 2 branches missed.">		if (drawable instanceof TextureRegionDrawable)</span>
<span class="nc" id="L339">			newDrawable = ((TextureRegionDrawable)drawable).tint(tint);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">		else if (drawable instanceof NinePatchDrawable)</span>
<span class="nc" id="L341">			newDrawable = ((NinePatchDrawable)drawable).tint(tint);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">		else if (drawable instanceof SpriteDrawable)</span>
<span class="nc" id="L343">			newDrawable = ((SpriteDrawable)drawable).tint(tint);</span>
		else
<span class="nc" id="L345">			throw new GdxRuntimeException(&quot;Unable to copy, unknown drawable type: &quot; + drawable.getClass());</span>

<span class="nc bnc" id="L347" title="All 2 branches missed.">		if (newDrawable instanceof BaseDrawable) {</span>
<span class="nc" id="L348">			BaseDrawable named = (BaseDrawable)newDrawable;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">			if (drawable instanceof BaseDrawable)</span>
<span class="nc" id="L350">				named.setName(((BaseDrawable)drawable).getName() + &quot; (&quot; + tint + &quot;)&quot;);</span>
			else
<span class="nc" id="L352">				named.setName(&quot; (&quot; + tint + &quot;)&quot;);</span>
		}

<span class="nc" id="L355">		return newDrawable;</span>
	}

	/** Sets the style on the actor to disabled or enabled. This is done by appending &quot;-disabled&quot; to the style name when enabled is
	 * false, and removing &quot;-disabled&quot; from the style name when enabled is true. A method named &quot;getStyle&quot; is called the actor via
	 * reflection and the name of that style is found in the skin. If the actor doesn't have a &quot;getStyle&quot; method or the style was
	 * not found in the skin, no exception is thrown and the actor is left unchanged. */
	public void setEnabled (Actor actor, boolean enabled) {
		// Get current style.
<span class="nc" id="L364">		Method method = findMethod(actor.getClass(), &quot;getStyle&quot;);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">		if (method == null) return;</span>
		Object style;
		try {
<span class="nc" id="L368">			style = method.invoke(actor);</span>
<span class="nc" id="L369">		} catch (Exception ignored) {</span>
<span class="nc" id="L370">			return;</span>
<span class="nc" id="L371">		}</span>
		// Determine new style.
<span class="nc" id="L373">		String name = find(style);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">		if (name == null) return;</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">		name = name.replace(&quot;-disabled&quot;, &quot;&quot;) + (enabled ? &quot;&quot; : &quot;-disabled&quot;);</span>
<span class="nc" id="L376">		style = get(name, style.getClass());</span>
		// Set new style.
<span class="nc" id="L378">		method = findMethod(actor.getClass(), &quot;setStyle&quot;);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">		if (method == null) return;</span>
		try {
<span class="nc" id="L381">			method.invoke(actor, style);</span>
<span class="nc" id="L382">		} catch (Exception ignored) {</span>
<span class="nc" id="L383">		}</span>
<span class="nc" id="L384">	}</span>

	/** Returns the {@link TextureAtlas} passed to this skin constructor, or null. */
	public TextureAtlas getAtlas () {
<span class="nc" id="L388">		return atlas;</span>
	}

	/** Disposes the {@link TextureAtlas} and all {@link Disposable} resources in the skin. */
	public void dispose () {
<span class="nc bnc" id="L393" title="All 2 branches missed.">		if (atlas != null) atlas.dispose();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">		for (ObjectMap&lt;String, Object&gt; entry : resources.values()) {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">			for (Object resource : entry.values())</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">				if (resource instanceof Disposable) ((Disposable)resource).dispose();</span>
<span class="nc" id="L397">		}</span>
<span class="nc" id="L398">	}</span>

	protected Json getJsonLoader (final FileHandle skinFile) {
<span class="nc" id="L401">		final Skin skin = this;</span>

<span class="nc" id="L403">		final Json json = new Json() {</span>
			public &lt;T&gt; T readValue (Class&lt;T&gt; type, Class elementType, JsonValue jsonData) {
				// If the JSON is a string but the type is not, look up the actual value by name.
<span class="nc bnc" id="L406" title="All 4 branches missed.">				if (jsonData.isString() &amp;&amp; !ClassReflection.isAssignableFrom(CharSequence.class, type))</span>
<span class="nc" id="L407">					return get(jsonData.asString(), type);</span>
<span class="nc" id="L408">				return super.readValue(type, elementType, jsonData);</span>
			}
		};
<span class="nc" id="L411">		json.setTypeName(null);</span>
<span class="nc" id="L412">		json.setUsePrototypes(false);</span>

<span class="nc" id="L414">		json.setSerializer(Skin.class, new ReadOnlySerializer&lt;Skin&gt;() {</span>
			public Skin read (Json json, JsonValue typeToValueMap, Class ignored) {
<span class="nc bnc" id="L416" title="All 2 branches missed.">				for (JsonValue valueMap = typeToValueMap.child; valueMap != null; valueMap = valueMap.next) {</span>
					try {
<span class="nc" id="L418">						readNamedObjects(json, ClassReflection.forName(valueMap.name()), valueMap);</span>
<span class="nc" id="L419">					} catch (ReflectionException ex) {</span>
<span class="nc" id="L420">						throw new SerializationException(ex);</span>
<span class="nc" id="L421">					}</span>
				}
<span class="nc" id="L423">				return skin;</span>
			}

			private void readNamedObjects (Json json, Class type, JsonValue valueMap) {
<span class="nc bnc" id="L427" title="All 2 branches missed.">				Class addType = type == TintedDrawable.class ? Drawable.class : type;</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">				for (JsonValue valueEntry = valueMap.child; valueEntry != null; valueEntry = valueEntry.next) {</span>
<span class="nc" id="L429">					Object object = json.readValue(type, valueEntry);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">					if (object == null) continue;</span>
					try {
<span class="nc" id="L432">						add(valueEntry.name, object, addType);</span>
<span class="nc bnc" id="L433" title="All 4 branches missed.">						if (addType != Drawable.class &amp;&amp; ClassReflection.isAssignableFrom(Drawable.class, addType))</span>
<span class="nc" id="L434">							add(valueEntry.name, object, Drawable.class);</span>
<span class="nc" id="L435">					} catch (Exception ex) {</span>
<span class="nc" id="L436">						throw new SerializationException(</span>
							&quot;Error reading &quot; + ClassReflection.getSimpleName(type) + &quot;: &quot; + valueEntry.name, ex);
<span class="nc" id="L438">					}</span>
				}
<span class="nc" id="L440">			}</span>
		});

<span class="nc" id="L443">		json.setSerializer(BitmapFont.class, new ReadOnlySerializer&lt;BitmapFont&gt;() {</span>
			public BitmapFont read (Json json, JsonValue jsonData, Class type) {
<span class="nc" id="L445">				String path = json.readValue(&quot;file&quot;, String.class, jsonData);</span>
<span class="nc" id="L446">				int scaledSize = json.readValue(&quot;scaledSize&quot;, int.class, -1, jsonData);</span>
<span class="nc" id="L447">				Boolean flip = json.readValue(&quot;flip&quot;, Boolean.class, false, jsonData);</span>
<span class="nc" id="L448">				Boolean markupEnabled = json.readValue(&quot;markupEnabled&quot;, Boolean.class, false, jsonData);</span>

<span class="nc" id="L450">				FileHandle fontFile = skinFile.parent().child(path);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">				if (!fontFile.exists()) fontFile = Gdx.files.internal(path);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">				if (!fontFile.exists()) throw new SerializationException(&quot;Font file not found: &quot; + fontFile);</span>

				// Use a region with the same name as the font, else use a PNG file in the same directory as the FNT file.
<span class="nc" id="L455">				String regionName = fontFile.nameWithoutExtension();</span>
				try {
					BitmapFont font;
<span class="nc" id="L458">					TextureRegion region = skin.optional(regionName, TextureRegion.class);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">					if (region != null)</span>
<span class="nc" id="L460">						font = new BitmapFont(fontFile, region, flip);</span>
					else {
<span class="nc" id="L462">						FileHandle imageFile = fontFile.parent().child(regionName + &quot;.png&quot;);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">						if (imageFile.exists())</span>
<span class="nc" id="L464">							font = new BitmapFont(fontFile, imageFile, flip);</span>
						else
<span class="nc" id="L466">							font = new BitmapFont(fontFile, flip);</span>
					}
<span class="nc" id="L468">					font.getData().markupEnabled = markupEnabled;</span>
					// Scaled size is the desired cap height to scale the font to.
<span class="nc bnc" id="L470" title="All 2 branches missed.">					if (scaledSize != -1) font.getData().setScale(scaledSize / font.getCapHeight());</span>
<span class="nc" id="L471">					return font;</span>
<span class="nc" id="L472">				} catch (RuntimeException ex) {</span>
<span class="nc" id="L473">					throw new SerializationException(&quot;Error loading bitmap font: &quot; + fontFile, ex);</span>
				}
			}
		});

<span class="nc" id="L478">		json.setSerializer(Color.class, new ReadOnlySerializer&lt;Color&gt;() {</span>
			public Color read (Json json, JsonValue jsonData, Class type) {
<span class="nc bnc" id="L480" title="All 2 branches missed.">				if (jsonData.isString()) return get(jsonData.asString(), Color.class);</span>
<span class="nc" id="L481">				String hex = json.readValue(&quot;hex&quot;, String.class, (String)null, jsonData);</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">				if (hex != null) return Color.valueOf(hex);</span>
<span class="nc" id="L483">				float r = json.readValue(&quot;r&quot;, float.class, 0f, jsonData);</span>
<span class="nc" id="L484">				float g = json.readValue(&quot;g&quot;, float.class, 0f, jsonData);</span>
<span class="nc" id="L485">				float b = json.readValue(&quot;b&quot;, float.class, 0f, jsonData);</span>
<span class="nc" id="L486">				float a = json.readValue(&quot;a&quot;, float.class, 1f, jsonData);</span>
<span class="nc" id="L487">				return new Color(r, g, b, a);</span>
			}
		});

<span class="nc" id="L491">		json.setSerializer(TintedDrawable.class, new ReadOnlySerializer() {</span>
			public Object read (Json json, JsonValue jsonData, Class type) {
<span class="nc" id="L493">				String name = json.readValue(&quot;name&quot;, String.class, jsonData);</span>
<span class="nc" id="L494">				Color color = json.readValue(&quot;color&quot;, Color.class, jsonData);</span>
<span class="nc" id="L495">				Drawable drawable = newDrawable(name, color);</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">				if (drawable instanceof BaseDrawable) {</span>
<span class="nc" id="L497">					BaseDrawable named = (BaseDrawable)drawable;</span>
<span class="nc" id="L498">					named.setName(jsonData.name + &quot; (&quot; + name + &quot;, &quot; + color + &quot;)&quot;);</span>
				}
<span class="nc" id="L500">				return drawable;</span>
			}
		});

<span class="nc" id="L504">		return json;</span>
	}

	static private Method findMethod (Class type, String name) {
<span class="nc" id="L508">		Method[] methods = ClassReflection.getMethods(type);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">		for (int i = 0, n = methods.length; i &lt; n; i++) {</span>
<span class="nc" id="L510">			Method method = methods[i];</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">			if (method.getName().equals(name)) return method;</span>
		}
<span class="nc" id="L513">		return null;</span>
	}

	/** @author Nathan Sweet */
<span class="nc" id="L517">	static public class TintedDrawable {</span>
		public String name;
		public Color color;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>