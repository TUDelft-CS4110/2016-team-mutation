<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Intersector.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.math</a> &gt; <span class="el_source">Intersector.java</span></div><h1>Intersector.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.math;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.badlogic.gdx.math.Plane.PlaneSide;
import com.badlogic.gdx.math.collision.BoundingBox;
import com.badlogic.gdx.math.collision.Ray;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.FloatArray;

/** Class offering various static methods for intersection testing between different geometric objects.
 * 
 * @author badlogicgames@gmail.com
 * @author jan.stria
 * @author Nathan Sweet */
<span class="nc" id="L34">public final class Intersector {</span>
<span class="fc" id="L35">	private final static Vector3 v0 = new Vector3();</span>
<span class="fc" id="L36">	private final static Vector3 v1 = new Vector3();</span>
<span class="fc" id="L37">	private final static Vector3 v2 = new Vector3();</span>
<span class="fc" id="L38">	private final static FloatArray floatArray = new FloatArray();</span>
<span class="fc" id="L39">	private final static FloatArray floatArray2 = new FloatArray();</span>
	/** Returns whether the given point is inside the triangle. This assumes that the point is on the plane of the triangle. No
	 * check is performed that this is the case.
	 * 
	 * @param point the point
	 * @param t1 the first vertex of the triangle
	 * @param t2 the second vertex of the triangle
	 * @param t3 the third vertex of the triangle
	 * @return whether the point is in the triangle */
	public static boolean isPointInTriangle (Vector3 point, Vector3 t1, Vector3 t2, Vector3 t3) {
<span class="nc" id="L49">		v0.set(t1).sub(point);</span>
<span class="nc" id="L50">		v1.set(t2).sub(point);</span>
<span class="nc" id="L51">		v2.set(t3).sub(point);</span>

<span class="nc" id="L53">		float ab = v0.dot(v1);</span>
<span class="nc" id="L54">		float ac = v0.dot(v2);</span>
<span class="nc" id="L55">		float bc = v1.dot(v2);</span>
<span class="nc" id="L56">		float cc = v2.dot(v2);</span>

<span class="nc bnc" id="L58" title="All 2 branches missed.">		if (bc * ac - cc * ab &lt; 0) return false;</span>
<span class="nc" id="L59">		float bb = v1.dot(v1);</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">		if (ab * bc - ac * bb &lt; 0) return false;</span>
<span class="nc" id="L61">		return true;</span>
	}

	/** Returns true if the given point is inside the triangle. */
	public static boolean isPointInTriangle (Vector2 p, Vector2 a, Vector2 b, Vector2 c) {
<span class="nc" id="L66">		float px1 = p.x - a.x;</span>
<span class="nc" id="L67">		float py1 = p.y - a.y;</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">		boolean side12 = (b.x - a.x) * py1 - (b.y - a.y) * px1 &gt; 0;</span>
<span class="nc bnc" id="L69" title="All 4 branches missed.">		if ((c.x - a.x) * py1 - (c.y - a.y) * px1 &gt; 0 == side12) return false;</span>
<span class="nc bnc" id="L70" title="All 4 branches missed.">		if ((c.x - b.x) * (p.y - b.y) - (c.y - b.y) * (p.x - b.x) &gt; 0 != side12) return false;</span>
<span class="nc" id="L71">		return true;</span>
	}

	/** Returns true if the given point is inside the triangle. */
	public static boolean isPointInTriangle (float px, float py, float ax, float ay, float bx, float by, float cx, float cy) {
<span class="nc" id="L76">		float px1 = px - ax;</span>
<span class="nc" id="L77">		float py1 = py - ay;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">		boolean side12 = (bx - ax) * py1 - (by - ay) * px1 &gt; 0;</span>
<span class="nc bnc" id="L79" title="All 4 branches missed.">		if ((cx - ax) * py1 - (cy - ay) * px1 &gt; 0 == side12) return false;</span>
<span class="nc bnc" id="L80" title="All 4 branches missed.">		if ((cx - bx) * (py - by) - (cy - by) * (px - bx) &gt; 0 != side12) return false;</span>
<span class="nc" id="L81">		return true;</span>
	}

	public static boolean intersectSegmentPlane (Vector3 start, Vector3 end, Plane plane, Vector3 intersection) {
<span class="nc" id="L85">		Vector3 dir = v0.set(end).sub(start);</span>
<span class="nc" id="L86">		float denom = dir.dot(plane.getNormal());</span>
<span class="nc" id="L87">		float t = -(start.dot(plane.getNormal()) + plane.getD()) / denom;</span>
<span class="nc bnc" id="L88" title="All 4 branches missed.">		if (t &lt; 0 || t &gt; 1) return false;</span>

<span class="nc" id="L90">		intersection.set(start).add(dir.scl(t));</span>
<span class="nc" id="L91">		return true;</span>
	}

	/** Determines on which side of the given line the point is. Returns -1 if the point is on the left side of the line, 0 if the
	 * point is on the line and 1 if the point is on the right side of the line. Left and right are relative to the lines direction
	 * which is linePoint1 to linePoint2. */
	public static int pointLineSide (Vector2 linePoint1, Vector2 linePoint2, Vector2 point) {
<span class="nc" id="L98">		return (int)Math.signum((linePoint2.x - linePoint1.x) * (point.y - linePoint1.y) - (linePoint2.y - linePoint1.y)</span>
			* (point.x - linePoint1.x));
	}

	public static int pointLineSide (float linePoint1X, float linePoint1Y, float linePoint2X, float linePoint2Y, float pointX,
		float pointY) {
<span class="nc" id="L104">		return (int)Math.signum((linePoint2X - linePoint1X) * (pointY - linePoint1Y) - (linePoint2Y - linePoint1Y)</span>
			* (pointX - linePoint1X));
	}

	/** Checks whether the given point is in the polygon.
	 * @param polygon The polygon vertices passed as an array
	 * @param point The point
	 * @return true if the point is in the polygon */
	public static boolean isPointInPolygon (Array&lt;Vector2&gt; polygon, Vector2 point) {
<span class="nc" id="L113">		Vector2 lastVertice = polygon.peek();</span>
<span class="nc" id="L114">		boolean oddNodes = false;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">		for (int i = 0; i &lt; polygon.size; i++) {</span>
<span class="nc" id="L116">			Vector2 vertice = polygon.get(i);</span>
<span class="nc bnc" id="L117" title="All 8 branches missed.">			if ((vertice.y &lt; point.y &amp;&amp; lastVertice.y &gt;= point.y) || (lastVertice.y &lt; point.y &amp;&amp; vertice.y &gt;= point.y)) {</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">				if (vertice.x + (point.y - vertice.y) / (lastVertice.y - vertice.y) * (lastVertice.x - vertice.x) &lt; point.x) {</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">					oddNodes = !oddNodes;</span>
				}
			}
<span class="nc" id="L122">			lastVertice = vertice;</span>
		}
<span class="nc" id="L124">		return oddNodes;</span>
	}

	/** Returns true if the specified point is in the polygon.
	 * @param offset Starting polygon index.
	 * @param count Number of array indices to use after offset. */
	public static boolean isPointInPolygon (float[] polygon, int offset, int count, float x, float y) {
<span class="nc" id="L131">		boolean oddNodes = false;</span>
<span class="nc" id="L132">		int j = offset + count - 2;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">		for (int i = offset, n = j; i &lt;= n; i += 2) {</span>
<span class="nc" id="L134">			float yi = polygon[i + 1];</span>
<span class="nc" id="L135">			float yj = polygon[j + 1];</span>
<span class="nc bnc" id="L136" title="All 8 branches missed.">			if ((yi &lt; y &amp;&amp; yj &gt;= y) || (yj &lt; y &amp;&amp; yi &gt;= y)) {</span>
<span class="nc" id="L137">				float xi = polygon[i];</span>
<span class="nc bnc" id="L138" title="All 4 branches missed.">				if (xi + (y - yi) / (yj - yi) * (polygon[j] - xi) &lt; x) oddNodes = !oddNodes;</span>
			}
<span class="nc" id="L140">			j = i;</span>
		}
<span class="nc" id="L142">		return oddNodes;</span>
	}

<span class="fc" id="L145">	private final static Vector2 ip = new Vector2();</span>
<span class="fc" id="L146">	private final static Vector2 ep1 = new Vector2();</span>
<span class="fc" id="L147">	private final static Vector2 ep2 = new Vector2();</span>
<span class="fc" id="L148">	private final static Vector2 s = new Vector2();</span>
<span class="fc" id="L149">	private final static Vector2 e = new Vector2();</span>

	/** Intersects the two closed polygons and returns the polygon resulting from the intersection.
	 *  Follows the Sutherland-Hodgman algorithm.
	 *
	 * @param p1 The polygon that is being clipped
	 * @param p2 The clip polygon
	 * @param overlap The intersection of the two polygons (optional)
	 * @return Whether the two polygons intersect.
	 */
	public static boolean intersectPolygons (Polygon p1, Polygon p2, Polygon overlap) {
		//reusable points to trace edges around polygon
<span class="nc" id="L161">		floatArray2.clear();</span>
<span class="nc" id="L162">		floatArray.clear();</span>
<span class="nc" id="L163">		floatArray2.addAll(p1.getTransformedVertices());</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">		for (int i = 0; i &lt; p2.getTransformedVertices().length; i += 2) {</span>
<span class="nc" id="L165">			ep1.set(p2.getTransformedVertices()[i], p2.getTransformedVertices()[i+1]);</span>
			//wrap around to beginning of array if index points to end;
<span class="nc bnc" id="L167" title="All 2 branches missed.">			if (i &lt; p2.getTransformedVertices().length - 2) {</span>
<span class="nc" id="L168">				ep2.set(p2.getTransformedVertices()[i + 2], p2.getTransformedVertices()[i + 3]);</span>
			} else {
<span class="nc" id="L170">				ep2.set(p2.getTransformedVertices()[0], p2.getTransformedVertices()[1]);</span>
			}
<span class="nc bnc" id="L172" title="All 2 branches missed.">			if (floatArray2.size == 0) {</span>
<span class="nc" id="L173">				return false;</span>
			}
<span class="nc" id="L175">			s.set(floatArray2.get(floatArray2.size - 2), floatArray2.get(floatArray2.size - 1));</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">			for (int j = 0; j &lt; floatArray2.size; j += 2) {</span>
<span class="nc" id="L177">				e.set(floatArray2.get(j), floatArray2.get(j + 1));</span>
				//determine if point is inside clip edge
<span class="nc bnc" id="L179" title="All 2 branches missed.">				if (Intersector.pointLineSide(ep2, ep1, e) &gt; 0) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">					if (!(Intersector.pointLineSide(ep2, ep1, s) &gt; 0)) {</span>
<span class="nc" id="L181">						Intersector.intersectLines(s, e, ep1, ep2, ip);</span>
<span class="nc" id="L182">						floatArray.add(ip.x);</span>
<span class="nc" id="L183">						floatArray.add(ip.y);</span>
					}
<span class="nc" id="L185">					floatArray.add(e.x);</span>
<span class="nc" id="L186">					floatArray.add(e.y);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">				} else if (Intersector.pointLineSide(ep2, ep1, s) &gt; 0) {</span>
<span class="nc" id="L188">					Intersector.intersectLines(s, e, ep1, ep2, ip);</span>
<span class="nc" id="L189">					floatArray.add(ip.x);</span>
<span class="nc" id="L190">					floatArray.add(ip.y);</span>
				}
<span class="nc" id="L192">				s.set(e.x, e.y);</span>
			}
<span class="nc" id="L194">			floatArray2.clear();</span>
<span class="nc" id="L195">			floatArray2.addAll(floatArray);</span>
<span class="nc" id="L196">			floatArray.clear();</span>
		}
<span class="nc bnc" id="L198" title="All 2 branches missed.">		if (! (floatArray2.size == 0)) {</span>
<span class="nc" id="L199">			overlap.setVertices(floatArray2.toArray());</span>
<span class="nc" id="L200">			return true;</span>
		} else {
<span class="nc" id="L202">			return false;</span>
		}
	}

	/** Returns the distance between the given line and point. Note the specified line is not a line segment. */
	public static float distanceLinePoint (float startX, float startY, float endX, float endY, float pointX, float pointY) {
<span class="nc" id="L208">		float normalLength = (float)Math.sqrt((endX - startX) * (endX - startX) + (endY - startY) * (endY - startY));</span>
<span class="nc" id="L209">		return Math.abs((pointX - startX) * (endY - startY) - (pointY - startY) * (endX - startX)) / normalLength;</span>
	}

	/** Returns the distance between the given segment and point. */
	public static float distanceSegmentPoint (float startX, float startY, float endX, float endY, float pointX, float pointY) {
<span class="nc" id="L214">		return nearestSegmentPoint(startX, startY, endX, endY, pointX, pointY, v2tmp).dst(pointX, pointY);</span>
	}

	/** Returns the distance between the given segment and point. */
	public static float distanceSegmentPoint (Vector2 start, Vector2 end, Vector2 point) {
<span class="nc" id="L219">		return nearestSegmentPoint(start, end, point, v2tmp).dst(point);</span>
	}

	/** Returns a point on the segment nearest to the specified point. */
	public static Vector2 nearestSegmentPoint (Vector2 start, Vector2 end, Vector2 point, Vector2 nearest) {
<span class="nc" id="L224">		float length2 = start.dst2(end);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">		if (length2 == 0) return nearest.set(start);</span>
<span class="nc" id="L226">		float t = ((point.x - start.x) * (end.x - start.x) + (point.y - start.y) * (end.y - start.y)) / length2;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">		if (t &lt; 0) return nearest.set(start);</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">		if (t &gt; 1) return nearest.set(end);</span>
<span class="nc" id="L229">		return nearest.set(start.x + t * (end.x - start.x), start.y + t * (end.y - start.y));</span>
	}

	/** Returns a point on the segment nearest to the specified point. */
	public static Vector2 nearestSegmentPoint (float startX, float startY, float endX, float endY, float pointX, float pointY,
		Vector2 nearest) {
<span class="nc" id="L235">		final float xDiff = endX - startX;</span>
<span class="nc" id="L236">		final float yDiff = endY - startY;</span>
<span class="nc" id="L237">		float length2 = xDiff * xDiff + yDiff * yDiff;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">		if (length2 == 0) return nearest.set(startX, startY);</span>
<span class="nc" id="L239">		float t = ((pointX - startX) * (endX - startX) + (pointY - startY) * (endY - startY)) / length2;</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">		if (t &lt; 0) return nearest.set(startX, startY);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">		if (t &gt; 1) return nearest.set(endX, endY);</span>
<span class="nc" id="L242">		return nearest.set(startX + t * (endX - startX), startY + t * (endY - startY));</span>
	}

	/** Returns whether the given line segment intersects the given circle.
	 * @param start The start point of the line segment
	 * @param end The end point of the line segment
	 * @param center The center of the circle
	 * @param squareRadius The squared radius of the circle
	 * @return Whether the line segment and the circle intersect */
	public static boolean intersectSegmentCircle (Vector2 start, Vector2 end, Vector2 center, float squareRadius) {
<span class="nc" id="L252">		tmp.set(end.x - start.x, end.y - start.y, 0);</span>
<span class="nc" id="L253">		tmp1.set(center.x - start.x, center.y - start.y, 0);</span>
<span class="nc" id="L254">		float l = tmp.len();</span>
<span class="nc" id="L255">		float u = tmp1.dot(tmp.nor());</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">		if (u &lt;= 0) {</span>
<span class="nc" id="L257">			tmp2.set(start.x, start.y, 0);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">		} else if (u &gt;= l) {</span>
<span class="nc" id="L259">			tmp2.set(end.x, end.y, 0);</span>
		} else {
<span class="nc" id="L261">			tmp3.set(tmp.scl(u)); // remember tmp is already normalized</span>
<span class="nc" id="L262">			tmp2.set(tmp3.x + start.x, tmp3.y + start.y, 0);</span>
		}

<span class="nc" id="L265">		float x = center.x - tmp2.x;</span>
<span class="nc" id="L266">		float y = center.y - tmp2.y;</span>

<span class="nc bnc" id="L268" title="All 2 branches missed.">		return x * x + y * y &lt;= squareRadius;</span>
	}

	/** Checks whether the line segment and the circle intersect and returns by how much and in what direction the line has to move
	 * away from the circle to not intersect.
	 * 
	 * @param start The line segment starting point
	 * @param end The line segment end point
	 * @param point The center of the circle
	 * @param radius The radius of the circle
	 * @param displacement The displacement vector set by the method having unit length
	 * @return The displacement or Float.POSITIVE_INFINITY if no intersection is present */
	public static float intersectSegmentCircleDisplace (Vector2 start, Vector2 end, Vector2 point, float radius,
		Vector2 displacement) {
<span class="nc" id="L282">		float u = (point.x - start.x) * (end.x - start.x) + (point.y - start.y) * (end.y - start.y);</span>
<span class="nc" id="L283">		float d = start.dst(end);</span>
<span class="nc" id="L284">		u /= d * d;</span>
<span class="nc bnc" id="L285" title="All 4 branches missed.">		if (u &lt; 0 || u &gt; 1) return Float.POSITIVE_INFINITY;</span>
<span class="nc" id="L286">		tmp.set(end.x, end.y, 0).sub(start.x, start.y, 0);</span>
<span class="nc" id="L287">		tmp2.set(start.x, start.y, 0).add(tmp.scl(u));</span>
<span class="nc" id="L288">		d = tmp2.dst(point.x, point.y, 0);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">		if (d &lt; radius) {</span>
<span class="nc" id="L290">			displacement.set(point).sub(tmp2.x, tmp2.y).nor();</span>
<span class="nc" id="L291">			return d;</span>
		} else
<span class="nc" id="L293">			return Float.POSITIVE_INFINITY;</span>
	}
	
	/** Intersect two 2D Rays and return the scalar parameter of the first ray at the intersection point.
	 * You can get the intersection point by: Vector2 point(direction1).scl(scalar).add(start1);
	 * For more information, check: http://stackoverflow.com/a/565282/1091440
	 * @param start1 Where the first ray start
	 * @param direction1 The direction the first ray is pointing
	 * @param start2 Where the second ray start
	 * @param direction2 The direction the second ray is pointing
	 * @return scalar parameter on the first ray describing the point where the intersection happens. May be negative.
	 * In case the rays are collinear, Float.POSITIVE_INFINITY will be returned.
	 */
	public static float intersectRayRay(Vector2 start1, Vector2 direction1, Vector2 start2, Vector2 direction2) {
<span class="nc" id="L307">		float difx = start2.x - start1.x;</span>
<span class="nc" id="L308">		float dify = start2.y - start1.y;</span>
<span class="nc" id="L309">		float d1xd2 = direction1.x * direction2.y - direction1.y * direction2.x;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">		if(d1xd2 == 0.0f) {</span>
<span class="nc" id="L311">			return Float.POSITIVE_INFINITY; //collinear</span>
		}
<span class="nc" id="L313">		float d2sx = direction2.x / d1xd2;</span>
<span class="nc" id="L314">		float d2sy = direction2.y / d1xd2;</span>
<span class="nc" id="L315">		return difx * d2sy - dify * d2sx;</span>
	}

	/** Intersects a {@link Ray} and a {@link Plane}. The intersection point is stored in intersection in case an intersection is
	 * present.
	 * 
	 * @param ray The ray
	 * @param plane The plane
	 * @param intersection The vector the intersection point is written to (optional)
	 * @return Whether an intersection is present. */
	public static boolean intersectRayPlane (Ray ray, Plane plane, Vector3 intersection) {
<span class="nc" id="L326">		float denom = ray.direction.dot(plane.getNormal());</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">		if (denom != 0) {</span>
<span class="nc" id="L328">			float t = -(ray.origin.dot(plane.getNormal()) + plane.getD()) / denom;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">			if (t &lt; 0) return false;</span>

<span class="nc bnc" id="L331" title="All 2 branches missed.">			if (intersection != null) intersection.set(ray.origin).add(v0.set(ray.direction).scl(t));</span>
<span class="nc" id="L332">			return true;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">		} else if (plane.testPoint(ray.origin) == Plane.PlaneSide.OnPlane) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">			if (intersection != null) intersection.set(ray.origin);</span>
<span class="nc" id="L335">			return true;</span>
		} else
<span class="nc" id="L337">			return false;</span>
	}

	/** Intersects a line and a plane. The intersection is returned as the distance from the first point to the plane. In case an
	 * intersection happened, the return value is in the range [0,1]. The intersection point can be recovered by point1 + t *
	 * (point2 - point1) where t is the return value of this method.
	 * @param x
	 * @param y
	 * @param z
	 * @param x2
	 * @param y2
	 * @param z2
	 * @param plane */
	public static float intersectLinePlane (float x, float y, float z, float x2, float y2, float z2, Plane plane,
		Vector3 intersection) {
<span class="fc" id="L352">		Vector3 direction = tmp.set(x2, y2, z2).sub(x, y, z);</span>
<span class="fc" id="L353">		Vector3 origin = tmp2.set(x, y, z);</span>
<span class="fc" id="L354">		float denom = direction.dot(plane.getNormal());</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">		if (denom != 0) {</span>
<span class="fc" id="L356">			float t = -(origin.dot(plane.getNormal()) + plane.getD()) / denom;</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">			if (intersection != null) intersection.set(origin).add(direction.scl(t));</span>
<span class="fc" id="L358">			return t;</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">		} else if (plane.testPoint(origin) == Plane.PlaneSide.OnPlane) {</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">			if (intersection != null) intersection.set(origin);</span>
<span class="nc" id="L361">			return 0;</span>
		}

<span class="nc" id="L364">		return -1;</span>
	}

<span class="fc" id="L367">	private static final Plane p = new Plane(new Vector3(), 0);</span>
<span class="fc" id="L368">	private static final Vector3 i = new Vector3();</span>

	/** Intersect a {@link Ray} and a triangle, returning the intersection point in intersection.
	 * 
	 * @param ray The ray
	 * @param t1 The first vertex of the triangle
	 * @param t2 The second vertex of the triangle
	 * @param t3 The third vertex of the triangle
	 * @param intersection The intersection point (optional)
	 * @return True in case an intersection is present. */
	public static boolean intersectRayTriangle (Ray ray, Vector3 t1, Vector3 t2, Vector3 t3, Vector3 intersection) {
<span class="nc" id="L379">		Vector3 edge1 = v0.set(t2).sub(t1);</span>
<span class="nc" id="L380">		Vector3 edge2 = v1.set(t3).sub(t1);</span>
		
<span class="nc" id="L382">		Vector3 pvec = v2.set(ray.direction).crs(edge2);</span>
<span class="nc" id="L383">		float det = edge1.dot(pvec);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">		if (MathUtils.isZero(det)) {</span>
<span class="nc" id="L385">			p.set(t1, t2, t3);</span>
<span class="nc bnc" id="L386" title="All 4 branches missed.">			if (p.testPoint(ray.origin) == PlaneSide.OnPlane &amp;&amp; Intersector.isPointInTriangle(ray.origin, t1, t2, t3)) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">				if (intersection != null) intersection.set(ray.origin);</span>
<span class="nc" id="L388">				return true;</span>
			}
<span class="nc" id="L390">			return false;</span>
		}
		
<span class="nc" id="L393">		det = 1.0f / det;</span>

<span class="nc" id="L395">		Vector3 tvec = i.set(ray.origin).sub(t1);</span>
<span class="nc" id="L396">		float u = tvec.dot(pvec) * det;</span>
<span class="nc bnc" id="L397" title="All 4 branches missed.">		if (u &lt; 0.0f || u &gt; 1.0f) return false;</span>
		
<span class="nc" id="L399">		Vector3 qvec = tvec.crs(edge1);</span>
<span class="nc" id="L400">		float v = ray.direction.dot(qvec) * det;</span>
<span class="nc bnc" id="L401" title="All 4 branches missed.">		if (v &lt; 0.0f || u + v &gt; 1.0f) return false;</span>
		
<span class="nc" id="L403">		float t = edge2.dot(qvec) * det;</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">		if (t &lt; 0) return false;</span>
		
<span class="nc bnc" id="L406" title="All 2 branches missed.">		if (intersection != null) {</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">			if (t &lt;= MathUtils.FLOAT_ROUNDING_ERROR) {</span>
<span class="nc" id="L408">				intersection.set(ray.origin);</span>
			} else {
<span class="nc" id="L410">				ray.getEndPoint(intersection, t);</span>
			}
		}
		
<span class="nc" id="L414">		return true;</span>
	}

<span class="fc" id="L417">	private static final Vector3 dir = new Vector3();</span>
<span class="fc" id="L418">	private static final Vector3 start = new Vector3();</span>

	/** Intersects a {@link Ray} and a sphere, returning the intersection point in intersection.
	 * 
	 * @param ray The ray, the direction component must be normalized before calling this method
	 * @param center The center of the sphere
	 * @param radius The radius of the sphere
	 * @param intersection The intersection point (optional, can be null)
	 * @return Whether an intersection is present. */
	public static boolean intersectRaySphere (Ray ray, Vector3 center, float radius, Vector3 intersection) {
<span class="nc" id="L428">		final float len = ray.direction.dot(center.x - ray.origin.x, center.y - ray.origin.y, center.z - ray.origin.z);</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">		if (len &lt; 0.f) // behind the ray</span>
<span class="nc" id="L430">			return false;</span>
<span class="nc" id="L431">		final float dst2 = center.dst2(ray.origin.x + ray.direction.x * len, ray.origin.y + ray.direction.y * len, ray.origin.z</span>
			+ ray.direction.z * len);
<span class="nc" id="L433">		final float r2 = radius * radius;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">		if (dst2 &gt; r2) return false;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">		if (intersection != null) intersection.set(ray.direction).scl(len - (float)Math.sqrt(r2 - dst2)).add(ray.origin);</span>
<span class="nc" id="L436">		return true;</span>
	}

	/** Intersects a {@link Ray} and a {@link BoundingBox}, returning the intersection point in intersection.
	 * This intersection is defined as the point on the ray closest to the origin which is within the specified
	 * bounds.
	 * 
	 * &lt;p&gt;The returned intersection (if any) is guaranteed to be within the bounds of the bounding box, but
	 * it can occasionally diverge slightly from ray, due to small floating-point errors.&lt;/p&gt;
	 * 
	 * &lt;p&gt;If the origin of the ray is inside the box, this method returns true and the intersection point is
	 * set to the origin of the ray, accordingly to the definition above.&lt;/p&gt;
	 * 
	 * @param ray The ray
	 * @param box The box
	 * @param intersection The intersection point (optional)
	 * @return Whether an intersection is present. */
	public static boolean intersectRayBounds (Ray ray, BoundingBox box, Vector3 intersection) {
<span class="nc bnc" id="L454" title="All 2 branches missed.">		if (box.contains(ray.origin)) {</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">			if (intersection != null) intersection.set(ray.origin);</span>
<span class="nc" id="L456">			return true;</span>
		}
<span class="nc" id="L458">		float lowest = 0, t;</span>
<span class="nc" id="L459">		boolean hit = false;</span>

		// min x
<span class="nc bnc" id="L462" title="All 4 branches missed.">		if (ray.origin.x &lt;= box.min.x &amp;&amp; ray.direction.x &gt; 0) {</span>
<span class="nc" id="L463">			t = (box.min.x - ray.origin.x) / ray.direction.x;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L465">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L466" title="All 12 branches missed.">				if (v2.y &gt;= box.min.y &amp;&amp; v2.y &lt;= box.max.y &amp;&amp; v2.z &gt;= box.min.z &amp;&amp; v2.z &lt;= box.max.z &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L467">					hit = true;</span>
<span class="nc" id="L468">					lowest = t;</span>
				}
			}
		}
		// max x
<span class="nc bnc" id="L473" title="All 4 branches missed.">		if (ray.origin.x &gt;= box.max.x &amp;&amp; ray.direction.x &lt; 0) {</span>
<span class="nc" id="L474">			t = (box.max.x - ray.origin.x) / ray.direction.x;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L476">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L477" title="All 12 branches missed.">				if (v2.y &gt;= box.min.y &amp;&amp; v2.y &lt;= box.max.y &amp;&amp; v2.z &gt;= box.min.z &amp;&amp; v2.z &lt;= box.max.z &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L478">					hit = true;</span>
<span class="nc" id="L479">					lowest = t;</span>
				}
			}
		}
		// min y
<span class="nc bnc" id="L484" title="All 4 branches missed.">		if (ray.origin.y &lt;= box.min.y &amp;&amp; ray.direction.y &gt; 0) {</span>
<span class="nc" id="L485">			t = (box.min.y - ray.origin.y) / ray.direction.y;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L487">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L488" title="All 12 branches missed.">				if (v2.x &gt;= box.min.x &amp;&amp; v2.x &lt;= box.max.x &amp;&amp; v2.z &gt;= box.min.z &amp;&amp; v2.z &lt;= box.max.z &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L489">					hit = true;</span>
<span class="nc" id="L490">					lowest = t;</span>
				}
			}
		}
		// max y
<span class="nc bnc" id="L495" title="All 4 branches missed.">		if (ray.origin.y &gt;= box.max.y &amp;&amp; ray.direction.y &lt; 0) {</span>
<span class="nc" id="L496">			t = (box.max.y - ray.origin.y) / ray.direction.y;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L498">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L499" title="All 12 branches missed.">				if (v2.x &gt;= box.min.x &amp;&amp; v2.x &lt;= box.max.x &amp;&amp; v2.z &gt;= box.min.z &amp;&amp; v2.z &lt;= box.max.z &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L500">					hit = true;</span>
<span class="nc" id="L501">					lowest = t;</span>
				}
			}
		}
		// min z
<span class="nc bnc" id="L506" title="All 4 branches missed.">		if (ray.origin.z &lt;= box.min.z &amp;&amp; ray.direction.z &gt; 0) {</span>
<span class="nc" id="L507">			t = (box.min.z - ray.origin.z) / ray.direction.z;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L509">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L510" title="All 12 branches missed.">				if (v2.x &gt;= box.min.x &amp;&amp; v2.x &lt;= box.max.x &amp;&amp; v2.y &gt;= box.min.y &amp;&amp; v2.y &lt;= box.max.y &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L511">					hit = true;</span>
<span class="nc" id="L512">					lowest = t;</span>
				}
			}
		}
		// max y
<span class="nc bnc" id="L517" title="All 4 branches missed.">		if (ray.origin.z &gt;= box.max.z &amp;&amp; ray.direction.z &lt; 0) {</span>
<span class="nc" id="L518">			t = (box.max.z - ray.origin.z) / ray.direction.z;</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">			if (t &gt;= 0) {</span>
<span class="nc" id="L520">				v2.set(ray.direction).scl(t).add(ray.origin);</span>
<span class="nc bnc" id="L521" title="All 12 branches missed.">				if (v2.x &gt;= box.min.x &amp;&amp; v2.x &lt;= box.max.x &amp;&amp; v2.y &gt;= box.min.y &amp;&amp; v2.y &lt;= box.max.y &amp;&amp; (!hit || t &lt; lowest)) {</span>
<span class="nc" id="L522">					hit = true;</span>
<span class="nc" id="L523">					lowest = t;</span>
				}
			}
		}
<span class="nc bnc" id="L527" title="All 4 branches missed.">		if (hit &amp;&amp; intersection != null) {</span>
<span class="nc" id="L528">			intersection.set(ray.direction).scl(lowest).add(ray.origin);</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">			if (intersection.x &lt; box.min.x) {</span>
<span class="nc" id="L530">				intersection.x = box.min.x;</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">			} else if (intersection.x &gt; box.max.x) {</span>
<span class="nc" id="L532">				intersection.x = box.max.x;</span>
			}
<span class="nc bnc" id="L534" title="All 2 branches missed.">			if (intersection.y &lt; box.min.y) {</span>
<span class="nc" id="L535">				intersection.y = box.min.y;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">			} else if (intersection.y &gt; box.max.y) {</span>
<span class="nc" id="L537">				intersection.y = box.max.y;</span>
			}
<span class="nc bnc" id="L539" title="All 2 branches missed.">			if (intersection.z &lt; box.min.z) {</span>
<span class="nc" id="L540">				intersection.z = box.min.z;</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">			} else if (intersection.z &gt; box.max.z) {</span>
<span class="nc" id="L542">				intersection.z = box.max.z;</span>
			}
		}
<span class="nc" id="L545">		return hit;</span>
	}

	/** Quick check whether the given {@link Ray} and {@link BoundingBox} intersect.
	 * 
	 * @param ray The ray
	 * @param box The bounding box
	 * @return Whether the ray and the bounding box intersect. */
	static public boolean intersectRayBoundsFast (Ray ray, BoundingBox box) {
<span class="nc" id="L554">		return intersectRayBoundsFast(ray, box.getCenter(tmp1), box.getDimensions(tmp2));</span>
	}

	/** Quick check whether the given {@link Ray} and {@link BoundingBox} intersect.
	 * 
	 * @param ray The ray
	 * @param center The center of the bounding box
	 * @param dimensions The dimensions (width, height and depth) of the bounding box
	 * @return Whether the ray and the bounding box intersect. */
	static public boolean intersectRayBoundsFast (Ray ray, Vector3 center, Vector3 dimensions) {
<span class="nc" id="L564">		final float divX = 1f / ray.direction.x;</span>
<span class="nc" id="L565">		final float divY = 1f / ray.direction.y;</span>
<span class="nc" id="L566">		final float divZ = 1f / ray.direction.z;</span>

<span class="nc" id="L568">		float minx = ((center.x - dimensions.x * .5f) - ray.origin.x) * divX;</span>
<span class="nc" id="L569">		float maxx = ((center.x + dimensions.x * .5f) - ray.origin.x) * divX;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">		if (minx &gt; maxx) {</span>
<span class="nc" id="L571">			final float t = minx;</span>
<span class="nc" id="L572">			minx = maxx;</span>
<span class="nc" id="L573">			maxx = t;</span>
		}

<span class="nc" id="L576">		float miny = ((center.y - dimensions.y * .5f) - ray.origin.y) * divY;</span>
<span class="nc" id="L577">		float maxy = ((center.y + dimensions.y * .5f) - ray.origin.y) * divY;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">		if (miny &gt; maxy) {</span>
<span class="nc" id="L579">			final float t = miny;</span>
<span class="nc" id="L580">			miny = maxy;</span>
<span class="nc" id="L581">			maxy = t;</span>
		}

<span class="nc" id="L584">		float minz = ((center.z - dimensions.z * .5f) - ray.origin.z) * divZ;</span>
<span class="nc" id="L585">		float maxz = ((center.z + dimensions.z * .5f) - ray.origin.z) * divZ;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">		if (minz &gt; maxz) {</span>
<span class="nc" id="L587">			final float t = minz;</span>
<span class="nc" id="L588">			minz = maxz;</span>
<span class="nc" id="L589">			maxz = t;</span>
		}

<span class="nc" id="L592">		float min = Math.max(Math.max(minx, miny), minz);</span>
<span class="nc" id="L593">		float max = Math.min(Math.min(maxx, maxy), maxz);</span>

<span class="nc bnc" id="L595" title="All 4 branches missed.">		return max &gt;= 0 &amp;&amp; max &gt;= min;</span>
	}

<span class="fc" id="L598">	static Vector3 best = new Vector3();</span>
<span class="fc" id="L599">	static Vector3 tmp = new Vector3();</span>
<span class="fc" id="L600">	static Vector3 tmp1 = new Vector3();</span>
<span class="fc" id="L601">	static Vector3 tmp2 = new Vector3();</span>
<span class="fc" id="L602">	static Vector3 tmp3 = new Vector3();</span>
<span class="fc" id="L603">	static Vector2 v2tmp = new Vector2();</span>

	/** Intersects the given ray with list of triangles. Returns the nearest intersection point in intersection
	 * 
	 * @param ray The ray
	 * @param triangles The triangles, each successive 3 elements from a vertex
	 * @param intersection The nearest intersection point (optional)
	 * @return Whether the ray and the triangles intersect. */
	public static boolean intersectRayTriangles (Ray ray, float[] triangles, Vector3 intersection) {
<span class="nc" id="L612">		float min_dist = Float.MAX_VALUE;</span>
<span class="nc" id="L613">		boolean hit = false;</span>

<span class="nc bnc" id="L615" title="All 2 branches missed.">		if (triangles.length / 3 % 3 != 0) throw new RuntimeException(&quot;triangle list size is not a multiple of 3&quot;);</span>

<span class="nc bnc" id="L617" title="All 2 branches missed.">		for (int i = 0; i &lt; triangles.length - 6; i += 9) {</span>
<span class="nc" id="L618">			boolean result = intersectRayTriangle(ray, tmp1.set(triangles[i], triangles[i + 1], triangles[i + 2]),</span>
				tmp2.set(triangles[i + 3], triangles[i + 4], triangles[i + 5]),
				tmp3.set(triangles[i + 6], triangles[i + 7], triangles[i + 8]), tmp);

<span class="nc bnc" id="L622" title="All 2 branches missed.">			if (result == true) {</span>
<span class="nc" id="L623">				float dist = ray.origin.dst2(tmp);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">				if (dist &lt; min_dist) {</span>
<span class="nc" id="L625">					min_dist = dist;</span>
<span class="nc" id="L626">					best.set(tmp);</span>
<span class="nc" id="L627">					hit = true;</span>
				}
			}
		}

<span class="nc bnc" id="L632" title="All 2 branches missed.">		if (hit == false)</span>
<span class="nc" id="L633">			return false;</span>
		else {
<span class="nc bnc" id="L635" title="All 2 branches missed.">			if (intersection != null) intersection.set(best);</span>
<span class="nc" id="L636">			return true;</span>
		}
	}

	/** Intersects the given ray with list of triangles. Returns the nearest intersection point in intersection
	 * 
	 * @param ray The ray
	 * @param vertices the vertices
	 * @param indices the indices, each successive 3 shorts index the 3 vertices of a triangle
	 * @param vertexSize the size of a vertex in floats
	 * @param intersection The nearest intersection point (optional)
	 * @return Whether the ray and the triangles intersect. */
	public static boolean intersectRayTriangles (Ray ray, float[] vertices, short[] indices, int vertexSize, Vector3 intersection) {
<span class="nc" id="L649">		float min_dist = Float.MAX_VALUE;</span>
<span class="nc" id="L650">		boolean hit = false;</span>

<span class="nc bnc" id="L652" title="All 2 branches missed.">		if (indices.length % 3 != 0) throw new RuntimeException(&quot;triangle list size is not a multiple of 3&quot;);</span>

<span class="nc bnc" id="L654" title="All 2 branches missed.">		for (int i = 0; i &lt; indices.length; i += 3) {</span>
<span class="nc" id="L655">			int i1 = indices[i] * vertexSize;</span>
<span class="nc" id="L656">			int i2 = indices[i + 1] * vertexSize;</span>
<span class="nc" id="L657">			int i3 = indices[i + 2] * vertexSize;</span>

<span class="nc" id="L659">			boolean result = intersectRayTriangle(ray, tmp1.set(vertices[i1], vertices[i1 + 1], vertices[i1 + 2]),</span>
				tmp2.set(vertices[i2], vertices[i2 + 1], vertices[i2 + 2]),
				tmp3.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]), tmp);

<span class="nc bnc" id="L663" title="All 2 branches missed.">			if (result == true) {</span>
<span class="nc" id="L664">				float dist = ray.origin.dst2(tmp);</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">				if (dist &lt; min_dist) {</span>
<span class="nc" id="L666">					min_dist = dist;</span>
<span class="nc" id="L667">					best.set(tmp);</span>
<span class="nc" id="L668">					hit = true;</span>
				}
			}
		}

<span class="nc bnc" id="L673" title="All 2 branches missed.">		if (hit == false)</span>
<span class="nc" id="L674">			return false;</span>
		else {
<span class="nc bnc" id="L676" title="All 2 branches missed.">			if (intersection != null) intersection.set(best);</span>
<span class="nc" id="L677">			return true;</span>
		}
	}

	/** Intersects the given ray with list of triangles. Returns the nearest intersection point in intersection
	 * 
	 * @param ray The ray
	 * @param triangles The triangles
	 * @param intersection The nearest intersection point (optional)
	 * @return Whether the ray and the triangles intersect. */
	public static boolean intersectRayTriangles (Ray ray, List&lt;Vector3&gt; triangles, Vector3 intersection) {
<span class="nc" id="L688">		float min_dist = Float.MAX_VALUE;</span>
<span class="nc" id="L689">		boolean hit = false;</span>

<span class="nc bnc" id="L691" title="All 2 branches missed.">		if (triangles.size() % 3 != 0) throw new RuntimeException(&quot;triangle list size is not a multiple of 3&quot;);</span>

<span class="nc bnc" id="L693" title="All 2 branches missed.">		for (int i = 0; i &lt; triangles.size() - 2; i += 3) {</span>
<span class="nc" id="L694">			boolean result = intersectRayTriangle(ray, triangles.get(i), triangles.get(i + 1), triangles.get(i + 2), tmp);</span>

<span class="nc bnc" id="L696" title="All 2 branches missed.">			if (result == true) {</span>
<span class="nc" id="L697">				float dist = ray.origin.dst2(tmp);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">				if (dist &lt; min_dist) {</span>
<span class="nc" id="L699">					min_dist = dist;</span>
<span class="nc" id="L700">					best.set(tmp);</span>
<span class="nc" id="L701">					hit = true;</span>
				}
			}
		}

<span class="nc bnc" id="L706" title="All 2 branches missed.">		if (!hit)</span>
<span class="nc" id="L707">			return false;</span>
		else {
<span class="nc bnc" id="L709" title="All 2 branches missed.">			if (intersection != null) intersection.set(best);</span>
<span class="nc" id="L710">			return true;</span>
		}
	}

	/** Intersects the two lines and returns the intersection point in intersection.
	 * 
	 * @param p1 The first point of the first line
	 * @param p2 The second point of the first line
	 * @param p3 The first point of the second line
	 * @param p4 The second point of the second line
	 * @param intersection The intersection point
	 * @return Whether the two lines intersect */
	public static boolean intersectLines (Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 intersection) {
<span class="nc" id="L723">		float x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;</span>

<span class="nc" id="L725">		float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">		if (d == 0) return false;</span>

<span class="nc bnc" id="L728" title="All 2 branches missed.">		if (intersection != null) {</span>
<span class="nc" id="L729">			float ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d;</span>
<span class="nc" id="L730">			intersection.set(x1 + (x2 - x1) * ua, y1 + (y2 - y1) * ua);</span>
		}
<span class="nc" id="L732">		return true;</span>
	}

	/** Intersects the two lines and returns the intersection point in intersection.
	 * @param intersection The intersection point, or null.
	 * @return Whether the two lines intersect */
	public static boolean intersectLines (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4,
		Vector2 intersection) {
<span class="nc" id="L740">		float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">		if (d == 0) return false;</span>

<span class="nc bnc" id="L743" title="All 2 branches missed.">		if (intersection != null) {</span>
<span class="nc" id="L744">			float ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d;</span>
<span class="nc" id="L745">			intersection.set(x1 + (x2 - x1) * ua, y1 + (y2 - y1) * ua);</span>
		}
<span class="nc" id="L747">		return true;</span>
	}

	/** Check whether the given line and {@link Polygon} intersect.
	 * @param p1 The first point of the line
	 * @param p2 The second point of the line
	 * @param polygon The polygon
	 * @return Whether polygon and line intersects */
	public static boolean intersectLinePolygon (Vector2 p1, Vector2 p2, Polygon polygon) {
<span class="nc" id="L756">		 float[] vertices = polygon.getTransformedVertices();</span>
<span class="nc" id="L757">		 float x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;</span>
<span class="nc" id="L758">		 int n = vertices.length;</span>
<span class="nc" id="L759">		 float x3 = vertices[n - 2], y3 = vertices[n - 1];</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">		 for (int i = 0; i &lt; n; i += 2) {</span>
<span class="nc" id="L761">			  float x4 = vertices[i], y4 = vertices[i + 1];</span>
<span class="nc" id="L762">			  float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">			  if (d != 0) {</span>
<span class="nc" id="L764">					float yd = y1 - y3;</span>
<span class="nc" id="L765">					float xd = x1 - x3;</span>
<span class="nc" id="L766">					float ua = ((x4 - x3) * yd - (y4 - y3) * xd) / d;</span>
<span class="nc bnc" id="L767" title="All 4 branches missed.">					if (ua &gt;= 0 &amp;&amp; ua &lt;= 1) {</span>
<span class="nc" id="L768">						 return true;</span>
					}
			  }
<span class="nc" id="L771">			  x3 = x4;</span>
<span class="nc" id="L772">			  y3 = y4;</span>
		 }
<span class="nc" id="L774">		 return false;</span>
	}

	/** Determines whether the given rectangles intersect and, if they do, sets the supplied {@code intersection} rectangle to the
	 * area of overlap.
	 * 
	 * @return Whether the rectangles intersect */
	static public boolean intersectRectangles (Rectangle rectangle1, Rectangle rectangle2, Rectangle intersection) {
<span class="nc bnc" id="L782" title="All 2 branches missed.">		if (rectangle1.overlaps(rectangle2)) {</span>
<span class="nc" id="L783">			intersection.x = Math.max(rectangle1.x, rectangle2.x);</span>
<span class="nc" id="L784">			intersection.width = Math.min(rectangle1.x + rectangle1.width, rectangle2.x + rectangle2.width) - intersection.x;</span>
<span class="nc" id="L785">			intersection.y = Math.max(rectangle1.y, rectangle2.y);</span>
<span class="nc" id="L786">			intersection.height = Math.min(rectangle1.y + rectangle1.height, rectangle2.y + rectangle2.height) - intersection.y;</span>
<span class="nc" id="L787">			return true;</span>
		}
<span class="nc" id="L789">		return false;</span>
	}

	 /** Check whether the given line segment and {@link Polygon} intersect.
	  * @param p1 The first point of the segment
	  * @param p2 The second point of the segment
	  * @return Whether polygon and segment intersect */
	 public static boolean intersectSegmentPolygon (Vector2 p1, Vector2 p2, Polygon polygon) {
<span class="nc" id="L797">		  float[] vertices = polygon.getTransformedVertices();</span>
<span class="nc" id="L798">		  float x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;</span>
<span class="nc" id="L799">		  int n = vertices.length;</span>
<span class="nc" id="L800">		  float x3 = vertices[n - 2], y3 = vertices[n - 1];</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">		  for (int i = 0; i &lt; n; i += 2) {</span>
<span class="nc" id="L802">				float x4 = vertices[i], y4 = vertices[i + 1];</span>
<span class="nc" id="L803">				float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">				if (d != 0) {</span>
<span class="nc" id="L805">					 float yd = y1 - y3;</span>
<span class="nc" id="L806">					 float xd = x1 - x3;</span>
<span class="nc" id="L807">					 float ua = ((x4 - x3) * yd - (y4 - y3) * xd) / d;</span>
<span class="nc bnc" id="L808" title="All 4 branches missed.">					 if (ua &gt;= 0 &amp;&amp; ua &lt;= 1) {</span>
<span class="nc" id="L809">						  float ub = ((x2 - x1) * yd - (y2 - y1) * xd) / d;</span>
<span class="nc bnc" id="L810" title="All 4 branches missed.">						  if (ub &gt;= 0 &amp;&amp; ub &lt;= 1) {</span>
<span class="nc" id="L811">								return true;</span>
						  }
					 }
				}
<span class="nc" id="L815">				x3 = x4;</span>
<span class="nc" id="L816">				y3 = y4;</span>
		  }
<span class="nc" id="L818">		  return false;</span>
	 }

	/** Intersects the two line segments and returns the intersection point in intersection.
	 * 
	 * @param p1 The first point of the first line segment
	 * @param p2 The second point of the first line segment
	 * @param p3 The first point of the second line segment
	 * @param p4 The second point of the second line segment
	 * @param intersection The intersection point (optional)
	 * @return Whether the two line segments intersect */
	public static boolean intersectSegments (Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 intersection) {
<span class="nc" id="L830">		float x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;</span>

<span class="nc" id="L832">		float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">		if (d == 0) return false;</span>

<span class="nc" id="L835">		float yd = y1 - y3;</span>
<span class="nc" id="L836">		float xd = x1 - x3;</span>
<span class="nc" id="L837">		float ua = ((x4 - x3) * yd - (y4 - y3) * xd) / d;</span>
<span class="nc bnc" id="L838" title="All 4 branches missed.">		if (ua &lt; 0 || ua &gt; 1) return false;</span>

<span class="nc" id="L840">		float ub = ((x2 - x1) * yd - (y2 - y1) * xd) / d;</span>
<span class="nc bnc" id="L841" title="All 4 branches missed.">		if (ub &lt; 0 || ub &gt; 1) return false;</span>

<span class="nc bnc" id="L843" title="All 2 branches missed.">		if (intersection != null) intersection.set(x1 + (x2 - x1) * ua, y1 + (y2 - y1) * ua);</span>
<span class="nc" id="L844">		return true;</span>
	}

	public static boolean intersectSegments (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4,
		Vector2 intersection) {
<span class="nc" id="L849">		float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">		if (d == 0) return false;</span>

<span class="nc" id="L852">		float yd = y1 - y3;</span>
<span class="nc" id="L853">		float xd = x1 - x3;</span>
<span class="nc" id="L854">		float ua = ((x4 - x3) * yd - (y4 - y3) * xd) / d;</span>
<span class="nc bnc" id="L855" title="All 4 branches missed.">		if (ua &lt; 0 || ua &gt; 1) return false;</span>

<span class="nc" id="L857">		float ub = ((x2 - x1) * yd - (y2 - y1) * xd) / d;</span>
<span class="nc bnc" id="L858" title="All 4 branches missed.">		if (ub &lt; 0 || ub &gt; 1) return false;</span>

<span class="nc bnc" id="L860" title="All 2 branches missed.">		if (intersection != null) intersection.set(x1 + (x2 - x1) * ua, y1 + (y2 - y1) * ua);</span>
<span class="nc" id="L861">		return true;</span>
	}

	static float det (float a, float b, float c, float d) {
<span class="nc" id="L865">		return a * d - b * c;</span>
	}

	static double detd (double a, double b, double c, double d) {
<span class="nc" id="L869">		return a * d - b * c;</span>
	}

	public static boolean overlaps (Circle c1, Circle c2) {
<span class="nc" id="L873">		return c1.overlaps(c2);</span>
	}

	public static boolean overlaps (Rectangle r1, Rectangle r2) {
<span class="nc" id="L877">		return r1.overlaps(r2);</span>
	}

	public static boolean overlaps (Circle c, Rectangle r) {
<span class="nc" id="L881">		float closestX = c.x;</span>
<span class="nc" id="L882">		float closestY = c.y;</span>

<span class="nc bnc" id="L884" title="All 2 branches missed.">		if (c.x &lt; r.x) {</span>
<span class="nc" id="L885">			closestX = r.x;</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">		} else if (c.x &gt; r.x + r.width) {</span>
<span class="nc" id="L887">			closestX = r.x + r.width;</span>
		}

<span class="nc bnc" id="L890" title="All 2 branches missed.">		if (c.y &lt; r.y) {</span>
<span class="nc" id="L891">			closestY = r.y;</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">		} else if (c.y &gt; r.y + r.height) {</span>
<span class="nc" id="L893">			closestY = r.y + r.height;</span>
		}

<span class="nc" id="L896">		closestX = closestX - c.x;</span>
<span class="nc" id="L897">		closestX *= closestX;</span>
<span class="nc" id="L898">		closestY = closestY - c.y;</span>
<span class="nc" id="L899">		closestY *= closestY;</span>

<span class="nc bnc" id="L901" title="All 2 branches missed.">		return closestX + closestY &lt; c.radius * c.radius;</span>
	}

	/** Check whether specified counter-clockwise wound convex polygons overlap.
	 * 
	 * @param p1 The first polygon.
	 * @param p2 The second polygon.
	 * @return Whether polygons overlap. */
	public static boolean overlapConvexPolygons (Polygon p1, Polygon p2) {
<span class="nc" id="L910">		return overlapConvexPolygons(p1, p2, null);</span>
	}

	/** Check whether specified counter-clockwise wound convex polygons overlap. If they do, optionally obtain a Minimum Translation Vector indicating the
	 * minimum magnitude vector required to push the polygon p1 out of collision with polygon p2.
	 * 
	 * @param p1 The first polygon.
	 * @param p2 The second polygon.
	 * @param mtv A Minimum Translation Vector to fill in the case of a collision, or null (optional).
	 * @return Whether polygons overlap. */
	public static boolean overlapConvexPolygons (Polygon p1, Polygon p2, MinimumTranslationVector mtv) {
<span class="nc" id="L921">		return overlapConvexPolygons(p1.getTransformedVertices(), p2.getTransformedVertices(), mtv);</span>
	}

	/** @see #overlapConvexPolygons(float[], int, int, float[], int, int, MinimumTranslationVector) */
	public static boolean overlapConvexPolygons (float[] verts1, float[] verts2, MinimumTranslationVector mtv) {
<span class="nc" id="L926">		return overlapConvexPolygons(verts1, 0, verts1.length, verts2, 0, verts2.length, mtv);</span>
	}

	/** Check whether polygons defined by the given counter-clockwise wound vertex arrays overlap. If they do, optionally obtain a Minimum Translation
	 * Vector indicating the minimum magnitude vector required to push the polygon defined by verts1 out of the collision with the polygon defined by verts2.
	 * 
	 * @param verts1 Vertices of the first polygon.
	 * @param verts2 Vertices of the second polygon.
	 * @param mtv A Minimum Translation Vector to fill in the case of a collision, or null (optional).
	 * @return Whether polygons overlap. */
	public static boolean overlapConvexPolygons (float[] verts1, int offset1, int count1, float[] verts2, int offset2, int count2,
		MinimumTranslationVector mtv) {
<span class="nc" id="L938">		float overlap = Float.MAX_VALUE;</span>
<span class="nc" id="L939">		float smallestAxisX = 0;</span>
<span class="nc" id="L940">		float smallestAxisY = 0;</span>
		int numInNormalDir;

<span class="nc" id="L943">		int end1 = offset1 + count1;</span>
<span class="nc" id="L944">		int end2 = offset2 + count2;</span>

		// Get polygon1 axes
<span class="nc bnc" id="L947" title="All 2 branches missed.">		for (int i = offset1; i &lt; end1; i += 2) {</span>
<span class="nc" id="L948">			float x1 = verts1[i];</span>
<span class="nc" id="L949">			float y1 = verts1[i + 1];</span>
<span class="nc" id="L950">			float x2 = verts1[(i + 2) % count1];</span>
<span class="nc" id="L951">			float y2 = verts1[(i + 3) % count1];</span>

<span class="nc" id="L953">			float axisX = y1 - y2;</span>
<span class="nc" id="L954">			float axisY = -(x1 - x2);</span>

<span class="nc" id="L956">			final float length = (float)Math.sqrt(axisX * axisX + axisY * axisY);</span>
<span class="nc" id="L957">			axisX /= length;</span>
<span class="nc" id="L958">			axisY /= length;</span>

			// -- Begin check for separation on this axis --//

			// Project polygon1 onto this axis
<span class="nc" id="L963">			float min1 = axisX * verts1[0] + axisY * verts1[1];</span>
<span class="nc" id="L964">			float max1 = min1;</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">			for (int j = offset1; j &lt; end1; j += 2) {</span>
<span class="nc" id="L966">				float p = axisX * verts1[j] + axisY * verts1[j + 1];</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">				if (p &lt; min1) {</span>
<span class="nc" id="L968">					min1 = p;</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">				} else if (p &gt; max1) {</span>
<span class="nc" id="L970">					max1 = p;</span>
				}
			}

			// Project polygon2 onto this axis
<span class="nc" id="L975">			numInNormalDir = 0;</span>
<span class="nc" id="L976">			float min2 = axisX * verts2[0] + axisY * verts2[1];</span>
<span class="nc" id="L977">			float max2 = min2;</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">			for (int j = offset2; j &lt; end2; j += 2) {</span>
				// Counts the number of points that are within the projected area.
<span class="nc" id="L980">				numInNormalDir -= pointLineSide(x1, y1, x2, y2, verts2[j], verts2[j + 1]);</span>
<span class="nc" id="L981">				float p = axisX * verts2[j] + axisY * verts2[j + 1];</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">				if (p &lt; min2) {</span>
<span class="nc" id="L983">					min2 = p;</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">				} else if (p &gt; max2) {</span>
<span class="nc" id="L985">					max2 = p;</span>
				}
			}

<span class="nc bnc" id="L989" title="All 8 branches missed.">			if (!(min1 &lt;= min2 &amp;&amp; max1 &gt;= min2 || min2 &lt;= min1 &amp;&amp; max2 &gt;= min1)) {</span>
<span class="nc" id="L990">				return false;</span>
			} else {
<span class="nc" id="L992">				float o = Math.min(max1, max2) - Math.max(min1, min2);</span>
<span class="nc bnc" id="L993" title="All 8 branches missed.">				if (min1 &lt; min2 &amp;&amp; max1 &gt; max2 || min2 &lt; min1 &amp;&amp; max2 &gt; max1) {</span>
<span class="nc" id="L994">					float mins = Math.abs(min1 - min2);</span>
<span class="nc" id="L995">					float maxs = Math.abs(max1 - max2);</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">					if (mins &lt; maxs) {</span>
<span class="nc" id="L997">						o += mins;</span>
					} else {
<span class="nc" id="L999">						o += maxs;</span>
					}
				}
<span class="nc bnc" id="L1002" title="All 2 branches missed.">				if (o &lt; overlap) {</span>
<span class="nc" id="L1003">					overlap = o;</span>
					// Adjusts the direction based on the number of points found
<span class="nc bnc" id="L1005" title="All 2 branches missed.">					smallestAxisX = numInNormalDir &gt;= 0 ? axisX : -axisX;</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">					smallestAxisY = numInNormalDir &gt;= 0 ? axisY : -axisY;</span>
				}
			}
			// -- End check for separation on this axis --//
		}

		// Get polygon2 axes
<span class="nc bnc" id="L1013" title="All 2 branches missed.">		for (int i = offset2; i &lt; end2; i += 2) {</span>
<span class="nc" id="L1014">			float x1 = verts2[i];</span>
<span class="nc" id="L1015">			float y1 = verts2[i + 1];</span>
<span class="nc" id="L1016">			float x2 = verts2[(i + 2) % count2];</span>
<span class="nc" id="L1017">			float y2 = verts2[(i + 3) % count2];</span>

<span class="nc" id="L1019">			float axisX = y1 - y2;</span>
<span class="nc" id="L1020">			float axisY = -(x1 - x2);</span>

<span class="nc" id="L1022">			final float length = (float)Math.sqrt(axisX * axisX + axisY * axisY);</span>
<span class="nc" id="L1023">			axisX /= length;</span>
<span class="nc" id="L1024">			axisY /= length;</span>

			// -- Begin check for separation on this axis --//
<span class="nc" id="L1027">			numInNormalDir = 0;</span>

			// Project polygon1 onto this axis
<span class="nc" id="L1030">			float min1 = axisX * verts1[0] + axisY * verts1[1];</span>
<span class="nc" id="L1031">			float max1 = min1;</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">			for (int j = offset1; j &lt; end1; j += 2) {</span>
<span class="nc" id="L1033">				float p = axisX * verts1[j] + axisY * verts1[j + 1];</span>
				// Counts the number of points that are within the projected area.
<span class="nc" id="L1035">				numInNormalDir -= pointLineSide(x1, y1, x2, y2, verts1[j], verts1[j + 1]);</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">				if (p &lt; min1) {</span>
<span class="nc" id="L1037">					min1 = p;</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">				} else if (p &gt; max1) {</span>
<span class="nc" id="L1039">					max1 = p;</span>
				}
			}

			// Project polygon2 onto this axis
<span class="nc" id="L1044">			float min2 = axisX * verts2[0] + axisY * verts2[1];</span>
<span class="nc" id="L1045">			float max2 = min2;</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">			for (int j = offset2; j &lt; end2; j += 2) {</span>
<span class="nc" id="L1047">				float p = axisX * verts2[j] + axisY * verts2[j + 1];</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">				if (p &lt; min2) {</span>
<span class="nc" id="L1049">					min2 = p;</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">				} else if (p &gt; max2) {</span>
<span class="nc" id="L1051">					max2 = p;</span>
				}
			}

<span class="nc bnc" id="L1055" title="All 8 branches missed.">			if (!(min1 &lt;= min2 &amp;&amp; max1 &gt;= min2 || min2 &lt;= min1 &amp;&amp; max2 &gt;= min1)) {</span>
<span class="nc" id="L1056">				return false;</span>
			} else {
<span class="nc" id="L1058">				float o = Math.min(max1, max2) - Math.max(min1, min2);</span>

<span class="nc bnc" id="L1060" title="All 8 branches missed.">				if (min1 &lt; min2 &amp;&amp; max1 &gt; max2 || min2 &lt; min1 &amp;&amp; max2 &gt; max1) {</span>
<span class="nc" id="L1061">					float mins = Math.abs(min1 - min2);</span>
<span class="nc" id="L1062">					float maxs = Math.abs(max1 - max2);</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">					if (mins &lt; maxs) {</span>
<span class="nc" id="L1064">						o += mins;</span>
					} else {
<span class="nc" id="L1066">						o += maxs;</span>
					}
				}

<span class="nc bnc" id="L1070" title="All 2 branches missed.">				if (o &lt; overlap) {</span>
<span class="nc" id="L1071">					overlap = o;</span>
					// Adjusts the direction based on the number of points found
<span class="nc bnc" id="L1073" title="All 2 branches missed.">					smallestAxisX = numInNormalDir &lt; 0 ? axisX : -axisX;</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">					smallestAxisY = numInNormalDir &lt; 0 ? axisY : -axisY;</span>
				}
			}
			// -- End check for separation on this axis --//
		}
<span class="nc bnc" id="L1079" title="All 2 branches missed.">		if (mtv != null) {</span>
<span class="nc" id="L1080">			mtv.normal.set(smallestAxisX, smallestAxisY);</span>
<span class="nc" id="L1081">			mtv.depth = overlap;</span>
		}
<span class="nc" id="L1083">		return true;</span>
	}

	/** Splits the triangle by the plane. The result is stored in the SplitTriangle instance. Depending on where the triangle is
	 * relative to the plane, the result can be:
	 * 
	 * &lt;ul&gt;
	 * &lt;li&gt;Triangle is fully in front/behind: {@link SplitTriangle#front} or {@link SplitTriangle#back} will contain the original
	 * triangle, {@link SplitTriangle#total} will be one.&lt;/li&gt;
	 * &lt;li&gt;Triangle has two vertices in front, one behind: {@link SplitTriangle#front} contains 2 triangles,
	 * {@link SplitTriangle#back} contains 1 triangles, {@link SplitTriangle#total} will be 3.&lt;/li&gt;
	 * &lt;li&gt;Triangle has one vertex in front, two behind: {@link SplitTriangle#front} contains 1 triangle,
	 * {@link SplitTriangle#back} contains 2 triangles, {@link SplitTriangle#total} will be 3.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * The input triangle should have the form: x, y, z, x2, y2, z2, x3, y3, z3. One can add additional attributes per vertex which
	 * will be interpolated if split, such as texture coordinates or normals. Note that these additional attributes won't be
	 * normalized, as might be necessary in case of normals.
	 * 
	 * @param triangle
	 * @param plane
	 * @param split output SplitTriangle */
	public static void splitTriangle (float[] triangle, Plane plane, SplitTriangle split) {
<span class="fc" id="L1106">		int stride = triangle.length / 3;</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">		boolean r1 = plane.testPoint(triangle[0], triangle[1], triangle[2]) == PlaneSide.Back;</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">		boolean r2 = plane.testPoint(triangle[0 + stride], triangle[1 + stride], triangle[2 + stride]) == PlaneSide.Back;</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">		boolean r3 = plane.testPoint(triangle[0 + stride * 2], triangle[1 + stride * 2], triangle[2 + stride * 2]) == PlaneSide.Back;</span>

<span class="fc" id="L1111">		split.reset();</span>

		// easy case, triangle is on one side (point on plane means front).
<span class="pc bpc" id="L1114" title="1 of 4 branches missed.">		if (r1 == r2 &amp;&amp; r2 == r3) {</span>
<span class="fc" id="L1115">			split.total = 1;</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">			if (r1) {</span>
<span class="fc" id="L1117">				split.numBack = 1;</span>
<span class="fc" id="L1118">				System.arraycopy(triangle, 0, split.back, 0, triangle.length);</span>
			} else {
<span class="fc" id="L1120">				split.numFront = 1;</span>
<span class="fc" id="L1121">				System.arraycopy(triangle, 0, split.front, 0, triangle.length);</span>
			}
<span class="fc" id="L1123">			return;</span>
		}

		// set number of triangles
<span class="fc" id="L1127">		split.total = 3;</span>
<span class="fc bfc" id="L1128" title="All 6 branches covered.">		split.numFront = (r1 ? 0 : 1) + (r2 ? 0 : 1) + (r3 ? 0 : 1);</span>
<span class="fc" id="L1129">		split.numBack = split.total - split.numFront;</span>

		// hard case, split the three edges on the plane
		// determine which array to fill first, front or back, flip if we
		// cross the plane
<span class="fc bfc" id="L1134" title="All 2 branches covered.">		split.setSide(!r1);</span>

		// split first edge
<span class="fc" id="L1137">		int first = 0;</span>
<span class="fc" id="L1138">		int second = stride;</span>
<span class="pc bpc" id="L1139" title="1 of 2 branches missed.">		if (r1 != r2) {</span>
			// split the edge
<span class="fc" id="L1141">			splitEdge(triangle, first, second, stride, plane, split.edgeSplit, 0);</span>

			// add first edge vertex and new vertex to current side
<span class="fc" id="L1144">			split.add(triangle, first, stride);</span>
<span class="fc" id="L1145">			split.add(split.edgeSplit, 0, stride);</span>

			// flip side and add new vertex and second edge vertex to current side
<span class="fc bfc" id="L1148" title="All 2 branches covered.">			split.setSide(!split.getSide());</span>
<span class="fc" id="L1149">			split.add(split.edgeSplit, 0, stride);</span>
		} else {
			// add both vertices
<span class="nc" id="L1152">			split.add(triangle, first, stride);</span>
		}

		// split second edge
<span class="fc" id="L1156">		first = stride;</span>
<span class="fc" id="L1157">		second = stride + stride;</span>
<span class="pc bpc" id="L1158" title="1 of 2 branches missed.">		if (r2 != r3) {</span>
			// split the edge
<span class="fc" id="L1160">			splitEdge(triangle, first, second, stride, plane, split.edgeSplit, 0);</span>

			// add first edge vertex and new vertex to current side
<span class="fc" id="L1163">			split.add(triangle, first, stride);</span>
<span class="fc" id="L1164">			split.add(split.edgeSplit, 0, stride);</span>

			// flip side and add new vertex and second edge vertex to current side
<span class="fc bfc" id="L1167" title="All 2 branches covered.">			split.setSide(!split.getSide());</span>
<span class="fc" id="L1168">			split.add(split.edgeSplit, 0, stride);</span>
		} else {
			// add both vertices
<span class="nc" id="L1171">			split.add(triangle, first, stride);</span>
		}

		// split third edge
<span class="fc" id="L1175">		first = stride + stride;</span>
<span class="fc" id="L1176">		second = 0;</span>
<span class="pc bpc" id="L1177" title="1 of 2 branches missed.">		if (r3 != r1) {</span>
			// split the edge
<span class="nc" id="L1179">			splitEdge(triangle, first, second, stride, plane, split.edgeSplit, 0);</span>

			// add first edge vertex and new vertex to current side
<span class="nc" id="L1182">			split.add(triangle, first, stride);</span>
<span class="nc" id="L1183">			split.add(split.edgeSplit, 0, stride);</span>

			// flip side and add new vertex and second edge vertex to current side
<span class="nc bnc" id="L1186" title="All 2 branches missed.">			split.setSide(!split.getSide());</span>
<span class="nc" id="L1187">			split.add(split.edgeSplit, 0, stride);</span>
		} else {
			// add both vertices
<span class="fc" id="L1190">			split.add(triangle, first, stride);</span>
		}

		// triangulate the side with 2 triangles
<span class="fc bfc" id="L1194" title="All 2 branches covered.">		if (split.numFront == 2) {</span>
<span class="fc" id="L1195">			System.arraycopy(split.front, stride * 2, split.front, stride * 3, stride * 2);</span>
<span class="fc" id="L1196">			System.arraycopy(split.front, 0, split.front, stride * 5, stride);</span>
		} else {
<span class="fc" id="L1198">			System.arraycopy(split.back, stride * 2, split.back, stride * 3, stride * 2);</span>
<span class="fc" id="L1199">			System.arraycopy(split.back, 0, split.back, stride * 5, stride);</span>
		}
<span class="fc" id="L1201">	}</span>

<span class="fc" id="L1203">	static Vector3 intersection = new Vector3();</span>

	private static void splitEdge (float[] vertices, int s, int e, int stride, Plane plane, float[] split, int offset) {
<span class="fc" id="L1206">		float t = Intersector.intersectLinePlane(vertices[s], vertices[s + 1], vertices[s + 2], vertices[e], vertices[e + 1],</span>
			vertices[e + 2], plane, intersection);
<span class="fc" id="L1208">		split[offset + 0] = intersection.x;</span>
<span class="fc" id="L1209">		split[offset + 1] = intersection.y;</span>
<span class="fc" id="L1210">		split[offset + 2] = intersection.z;</span>
<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">		for (int i = 3; i &lt; stride; i++) {</span>
<span class="nc" id="L1212">			float a = vertices[s + i];</span>
<span class="nc" id="L1213">			float b = vertices[e + i];</span>
<span class="nc" id="L1214">			split[offset + i] = a + t * (b - a);</span>
		}
<span class="fc" id="L1216">	}</span>
	
	public static class SplitTriangle {
		public float[] front;
		public float[] back;
		float[] edgeSplit;
		public int numFront;
		public int numBack;
		public int total;
<span class="fc" id="L1225">		boolean frontCurrent = false;</span>
<span class="fc" id="L1226">		int frontOffset = 0;</span>
<span class="fc" id="L1227">		int backOffset = 0;</span>

		/** Creates a new instance, assuming numAttributes attributes per triangle vertex.
		 * @param numAttributes must be &gt;= 3 */
<span class="fc" id="L1231">		public SplitTriangle (int numAttributes) {</span>
<span class="fc" id="L1232">			front = new float[numAttributes * 3 * 2];</span>
<span class="fc" id="L1233">			back = new float[numAttributes * 3 * 2];</span>
<span class="fc" id="L1234">			edgeSplit = new float[numAttributes];</span>
<span class="fc" id="L1235">		}</span>

		@Override
		public String toString () {
<span class="nc" id="L1239">			return &quot;SplitTriangle [front=&quot; + Arrays.toString(front) + &quot;, back=&quot; + Arrays.toString(back) + &quot;, numFront=&quot; + numFront</span>
				+ &quot;, numBack=&quot; + numBack + &quot;, total=&quot; + total + &quot;]&quot;;
		}

		void setSide (boolean front) {
<span class="fc" id="L1244">			frontCurrent = front;</span>
<span class="fc" id="L1245">		}</span>

		boolean getSide () {
<span class="fc" id="L1248">			return frontCurrent;</span>
		}

		void add (float[] vertex, int offset, int stride) {
<span class="fc bfc" id="L1252" title="All 2 branches covered.">			if (frontCurrent) {</span>
<span class="fc" id="L1253">				System.arraycopy(vertex, offset, front, frontOffset, stride);</span>
<span class="fc" id="L1254">				frontOffset += stride;</span>
			} else {
<span class="fc" id="L1256">				System.arraycopy(vertex, offset, back, backOffset, stride);</span>
<span class="fc" id="L1257">				backOffset += stride;</span>
			}
<span class="fc" id="L1259">		}</span>

		void reset () {
<span class="fc" id="L1262">			frontCurrent = false;</span>
<span class="fc" id="L1263">			frontOffset = 0;</span>
<span class="fc" id="L1264">			backOffset = 0;</span>
<span class="fc" id="L1265">			numFront = 0;</span>
<span class="fc" id="L1266">			numBack = 0;</span>
<span class="fc" id="L1267">			total = 0;</span>
<span class="fc" id="L1268">		}</span>
	}

	/**
	 * Minimum translation required to separate two polygons.
	 */
<span class="nc" id="L1274">	public static class MinimumTranslationVector {</span>
		/** Unit length vector that indicates the direction for the separation */
<span class="nc" id="L1276">		public Vector2 normal = new Vector2();</span>
		/** Distance of the translation required for the separation */
<span class="nc" id="L1278">		public float depth = 0;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>