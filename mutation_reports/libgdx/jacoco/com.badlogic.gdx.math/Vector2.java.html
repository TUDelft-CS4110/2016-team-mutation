<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Vector2.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.math</a> &gt; <span class="el_source">Vector2.java</span></div><h1>Vector2.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.math;

import java.io.Serializable;

import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.NumberUtils;

/** Encapsulates a 2D vector. Allows chaining methods by returning a reference to itself
 * @author badlogicgames@gmail.com */
public class Vector2 implements Serializable, Vector&lt;Vector2&gt; {
	private static final long serialVersionUID = 913902788239530931L;

<span class="fc" id="L29">	public final static Vector2 X = new Vector2(1, 0);</span>
<span class="fc" id="L30">	public final static Vector2 Y = new Vector2(0, 1);</span>
<span class="fc" id="L31">	public final static Vector2 Zero = new Vector2(0, 0);</span>

	/** the x-component of this vector **/
	public float x;
	/** the y-component of this vector **/
	public float y;

	/** Constructs a new vector at (0,0) */
<span class="fc" id="L39">	public Vector2 () {</span>
<span class="fc" id="L40">	}</span>

	/** Constructs a vector with the given components
	 * @param x The x-component
	 * @param y The y-component */
<span class="fc" id="L45">	public Vector2 (float x, float y) {</span>
<span class="fc" id="L46">		this.x = x;</span>
<span class="fc" id="L47">		this.y = y;</span>
<span class="fc" id="L48">	}</span>

	/** Constructs a vector from the given vector
	 * @param v The vector */
<span class="nc" id="L52">	public Vector2 (Vector2 v) {</span>
<span class="nc" id="L53">		set(v);</span>
<span class="nc" id="L54">	}</span>

	@Override
	public Vector2 cpy () {
<span class="nc" id="L58">		return new Vector2(this);</span>
	}

	public static float len (float x, float y) {
<span class="nc" id="L62">		return (float)Math.sqrt(x * x + y * y);</span>
	}

	@Override
	public float len () {
<span class="nc" id="L67">		return (float)Math.sqrt(x * x + y * y);</span>
	}

	public static float len2 (float x, float y) {
<span class="nc" id="L71">		return x * x + y * y;</span>
	}

	@Override
	public float len2 () {
<span class="nc" id="L76">		return x * x + y * y;</span>
	}

	@Override
	public Vector2 set (Vector2 v) {
<span class="nc" id="L81">		x = v.x;</span>
<span class="nc" id="L82">		y = v.y;</span>
<span class="nc" id="L83">		return this;</span>
	}

	/** Sets the components of this vector
	 * @param x The x-component
	 * @param y The y-component
	 * @return This vector for chaining */
	public Vector2 set (float x, float y) {
<span class="fc" id="L91">		this.x = x;</span>
<span class="fc" id="L92">		this.y = y;</span>
<span class="fc" id="L93">		return this;</span>
	}

	@Override
	public Vector2 sub (Vector2 v) {
<span class="nc" id="L98">		x -= v.x;</span>
<span class="nc" id="L99">		y -= v.y;</span>
<span class="nc" id="L100">		return this;</span>
	}

	/** Substracts the other vector from this vector.
	 * @param x The x-component of the other vector
	 * @param y The y-component of the other vector
	 * @return This vector for chaining */
	public Vector2 sub (float x, float y) {
<span class="nc" id="L108">		this.x -= x;</span>
<span class="nc" id="L109">		this.y -= y;</span>
<span class="nc" id="L110">		return this;</span>
	}

	@Override
	public Vector2 nor () {
<span class="nc" id="L115">		float len = len();</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">		if (len != 0) {</span>
<span class="nc" id="L117">			x /= len;</span>
<span class="nc" id="L118">			y /= len;</span>
		}
<span class="nc" id="L120">		return this;</span>
	}

	@Override
	public Vector2 add (Vector2 v) {
<span class="nc" id="L125">		x += v.x;</span>
<span class="nc" id="L126">		y += v.y;</span>
<span class="nc" id="L127">		return this;</span>
	}

	/** Adds the given components to this vector
	 * @param x The x-component
	 * @param y The y-component
	 * @return This vector for chaining */
	public Vector2 add (float x, float y) {
<span class="nc" id="L135">		this.x += x;</span>
<span class="nc" id="L136">		this.y += y;</span>
<span class="nc" id="L137">		return this;</span>
	}

	public static float dot (float x1, float y1, float x2, float y2) {
<span class="nc" id="L141">		return x1 * x2 + y1 * y2;</span>
	}

	@Override
	public float dot (Vector2 v) {
<span class="nc" id="L146">		return x * v.x + y * v.y;</span>
	}

	public float dot (float ox, float oy) {
<span class="nc" id="L150">		return x * ox + y * oy;</span>
	}

	@Override
	public Vector2 scl (float scalar) {
<span class="nc" id="L155">		x *= scalar;</span>
<span class="nc" id="L156">		y *= scalar;</span>
<span class="nc" id="L157">		return this;</span>
	}

	/** Multiplies this vector by a scalar
	 * @return This vector for chaining */
	public Vector2 scl (float x, float y) {
<span class="nc" id="L163">		this.x *= x;</span>
<span class="nc" id="L164">		this.y *= y;</span>
<span class="nc" id="L165">		return this;</span>
	}

	@Override
	public Vector2 scl (Vector2 v) {
<span class="nc" id="L170">		this.x *= v.x;</span>
<span class="nc" id="L171">		this.y *= v.y;</span>
<span class="nc" id="L172">		return this;</span>
	}

	@Override
	public Vector2 mulAdd (Vector2 vec, float scalar) {
<span class="nc" id="L177">		this.x += vec.x * scalar;</span>
<span class="nc" id="L178">		this.y += vec.y * scalar;</span>
<span class="nc" id="L179">		return this;</span>
	}

	@Override
	public Vector2 mulAdd (Vector2 vec, Vector2 mulVec) {
<span class="nc" id="L184">		this.x += vec.x * mulVec.x;</span>
<span class="nc" id="L185">		this.y += vec.y * mulVec.y;</span>
<span class="nc" id="L186">		return this;</span>
	}

	public static float dst (float x1, float y1, float x2, float y2) {
<span class="nc" id="L190">		final float x_d = x2 - x1;</span>
<span class="nc" id="L191">		final float y_d = y2 - y1;</span>
<span class="nc" id="L192">		return (float)Math.sqrt(x_d * x_d + y_d * y_d);</span>
	}

	@Override
	public float dst (Vector2 v) {
<span class="nc" id="L197">		final float x_d = v.x - x;</span>
<span class="nc" id="L198">		final float y_d = v.y - y;</span>
<span class="nc" id="L199">		return (float)Math.sqrt(x_d * x_d + y_d * y_d);</span>
	}

	/** @param x The x-component of the other vector
	 * @param y The y-component of the other vector
	 * @return the distance between this and the other vector */
	public float dst (float x, float y) {
<span class="nc" id="L206">		final float x_d = x - this.x;</span>
<span class="nc" id="L207">		final float y_d = y - this.y;</span>
<span class="nc" id="L208">		return (float)Math.sqrt(x_d * x_d + y_d * y_d);</span>
	}

	public static float dst2 (float x1, float y1, float x2, float y2) {
<span class="nc" id="L212">		final float x_d = x2 - x1;</span>
<span class="nc" id="L213">		final float y_d = y2 - y1;</span>
<span class="nc" id="L214">		return x_d * x_d + y_d * y_d;</span>
	}

	@Override
	public float dst2 (Vector2 v) {
<span class="nc" id="L219">		final float x_d = v.x - x;</span>
<span class="nc" id="L220">		final float y_d = v.y - y;</span>
<span class="nc" id="L221">		return x_d * x_d + y_d * y_d;</span>
	}

	/** @param x The x-component of the other vector
	 * @param y The y-component of the other vector
	 * @return the squared distance between this and the other vector */
	public float dst2 (float x, float y) {
<span class="nc" id="L228">		final float x_d = x - this.x;</span>
<span class="nc" id="L229">		final float y_d = y - this.y;</span>
<span class="nc" id="L230">		return x_d * x_d + y_d * y_d;</span>
	}

	@Override
	public Vector2 limit (float limit) {
<span class="nc" id="L235">		return limit2(limit * limit);</span>
	}

	@Override
	public Vector2 limit2 (float limit2) {
<span class="nc" id="L240">		float len2 = len2();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">		if (len2 &gt; limit2) {</span>
<span class="nc" id="L242">			return scl((float)Math.sqrt(limit2 / len2));</span>
		}
<span class="nc" id="L244">		return this;</span>
	}

	@Override
	public Vector2 clamp (float min, float max) {
<span class="nc" id="L249">		final float len2 = len2();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">		if (len2 == 0f) return this;</span>
<span class="nc" id="L251">		float max2 = max * max;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">		if (len2 &gt; max2) return scl((float)Math.sqrt(max2 / len2));</span>
<span class="nc" id="L253">		float min2 = min * min;</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">		if (len2 &lt; min2) return scl((float)Math.sqrt(min2 / len2));</span>
<span class="nc" id="L255">		return this;</span>
	}

	@Override
	public Vector2 setLength (float len) {
<span class="nc" id="L260">		return setLength2(len * len);</span>
	}

	@Override
	public Vector2 setLength2 (float len2) {
<span class="nc" id="L265">		float oldLen2 = len2();</span>
<span class="nc bnc" id="L266" title="All 4 branches missed.">		return (oldLen2 == 0 || oldLen2 == len2) ? this : scl((float)Math.sqrt(len2 / oldLen2));</span>
	}

	/** Converts this {@code Vector2} to a string in the format {@code (x,y)}.
	 * @return a string representation of this object. */
	@Override
	public String toString () {
<span class="fc" id="L273">		return &quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot;;</span>
	}

	/** Sets this {@code Vector2} to the value represented by the specified string according to the format of {@link #toString()}.
	 * @param v the string.
	 * @return this vector for chaining */
	public Vector2 fromString (String v) {
<span class="fc" id="L280">		int s = v.indexOf(',', 1);</span>
<span class="pc bpc" id="L281" title="3 of 6 branches missed.">		if (s != -1 &amp;&amp; v.charAt(0) == '(' &amp;&amp; v.charAt(v.length() - 1) == ')') {</span>
			try {
<span class="fc" id="L283">				float x = Float.parseFloat(v.substring(1, s));</span>
<span class="fc" id="L284">				float y = Float.parseFloat(v.substring(s + 1, v.length() - 1));</span>
<span class="fc" id="L285">				return this.set(x, y);</span>
<span class="nc" id="L286">			} catch (NumberFormatException ex) {</span>
				// Throw a GdxRuntimeException
			}
		}
<span class="nc" id="L290">		throw new GdxRuntimeException(&quot;Malformed Vector2: &quot; + v);</span>
	}

	/** Left-multiplies this vector by the given matrix
	 * @param mat the matrix
	 * @return this vector */
	public Vector2 mul (Matrix3 mat) {
<span class="nc" id="L297">		float x = this.x * mat.val[0] + this.y * mat.val[3] + mat.val[6];</span>
<span class="nc" id="L298">		float y = this.x * mat.val[1] + this.y * mat.val[4] + mat.val[7];</span>
<span class="nc" id="L299">		this.x = x;</span>
<span class="nc" id="L300">		this.y = y;</span>
<span class="nc" id="L301">		return this;</span>
	}

	/** Calculates the 2D cross product between this and the given vector.
	 * @param v the other vector
	 * @return the cross product */
	public float crs (Vector2 v) {
<span class="nc" id="L308">		return this.x * v.y - this.y * v.x;</span>
	}

	/** Calculates the 2D cross product between this and the given vector.
	 * @param x the x-coordinate of the other vector
	 * @param y the y-coordinate of the other vector
	 * @return the cross product */
	public float crs (float x, float y) {
<span class="nc" id="L316">		return this.x * y - this.y * x;</span>
	}

	/** @return the angle in degrees of this vector (point) relative to the x-axis. Angles are towards the positive y-axis (typically
	 *         counter-clockwise) and between 0 and 360. */
	public float angle () {
<span class="nc" id="L322">		float angle = (float)Math.atan2(y, x) * MathUtils.radiansToDegrees;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">		if (angle &lt; 0) angle += 360;</span>
<span class="nc" id="L324">		return angle;</span>
	}

	/** @return the angle in degrees of this vector (point) relative to the given vector. Angles are towards the positive y-axis
	 *         (typically counter-clockwise.) between -180 and +180 */
	public float angle (Vector2 reference) {
<span class="nc" id="L330">		return (float)Math.atan2(crs(reference), dot(reference)) * MathUtils.radiansToDegrees;</span>
	}

	/** @return the angle in radians of this vector (point) relative to the x-axis. Angles are towards the positive y-axis.
	 *         (typically counter-clockwise) */
	public float angleRad () {
<span class="nc" id="L336">		return (float)Math.atan2(y, x);</span>
	}

	/** @return the angle in radians of this vector (point) relative to the given vector. Angles are towards the positive y-axis.
	 *         (typically counter-clockwise.) */
	public float angleRad (Vector2 reference) {
<span class="nc" id="L342">		return (float)Math.atan2(crs(reference), dot(reference));</span>
	}

	/** Sets the angle of the vector in degrees relative to the x-axis, towards the positive y-axis (typically counter-clockwise).
	 * @param degrees The angle in degrees to set. */
	public Vector2 setAngle (float degrees) {
<span class="nc" id="L348">		return setAngleRad(degrees * MathUtils.degreesToRadians);</span>
	}

	/** Sets the angle of the vector in radians relative to the x-axis, towards the positive y-axis (typically counter-clockwise).
	 * @param radians The angle in radians to set. */
	public Vector2 setAngleRad (float radians) {
<span class="nc" id="L354">		this.set(len(), 0f);</span>
<span class="nc" id="L355">		this.rotateRad(radians);</span>

<span class="nc" id="L357">		return this;</span>
	}

	/** Rotates the Vector2 by the given angle, counter-clockwise assuming the y-axis points up.
	 * @param degrees the angle in degrees */
	public Vector2 rotate (float degrees) {
<span class="nc" id="L363">		return rotateRad(degrees * MathUtils.degreesToRadians);</span>
	}

	/** Rotates the Vector2 by the given angle, counter-clockwise assuming the y-axis points up.
	 * @param radians the angle in radians */
	public Vector2 rotateRad (float radians) {
<span class="nc" id="L369">		float cos = (float)Math.cos(radians);</span>
<span class="nc" id="L370">		float sin = (float)Math.sin(radians);</span>

<span class="nc" id="L372">		float newX = this.x * cos - this.y * sin;</span>
<span class="nc" id="L373">		float newY = this.x * sin + this.y * cos;</span>

<span class="nc" id="L375">		this.x = newX;</span>
<span class="nc" id="L376">		this.y = newY;</span>

<span class="nc" id="L378">		return this;</span>
	}

	/** Rotates the Vector2 by 90 degrees in the specified direction, where &gt;= 0 is counter-clockwise and &lt; 0 is clockwise. */
	public Vector2 rotate90 (int dir) {
<span class="nc" id="L383">		float x = this.x;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">		if (dir &gt;= 0) {</span>
<span class="nc" id="L385">			this.x = -y;</span>
<span class="nc" id="L386">			y = x;</span>
		} else {
<span class="nc" id="L388">			this.x = y;</span>
<span class="nc" id="L389">			y = -x;</span>
		}
<span class="nc" id="L391">		return this;</span>
	}

	@Override
	public Vector2 lerp (Vector2 target, float alpha) {
<span class="nc" id="L396">		final float invAlpha = 1.0f - alpha;</span>
<span class="nc" id="L397">		this.x = (x * invAlpha) + (target.x * alpha);</span>
<span class="nc" id="L398">		this.y = (y * invAlpha) + (target.y * alpha);</span>
<span class="nc" id="L399">		return this;</span>
	}

	@Override
	public Vector2 interpolate (Vector2 target, float alpha, Interpolation interpolation) {
<span class="nc" id="L404">		return lerp(target, interpolation.apply(alpha));</span>
	}

	@Override
	public Vector2 setToRandomDirection () {
<span class="nc" id="L409">		float theta = MathUtils.random(0f, MathUtils.PI2);</span>
<span class="nc" id="L410">		return this.set(MathUtils.cos(theta), MathUtils.sin(theta));</span>
	}

	@Override
	public int hashCode () {
<span class="nc" id="L415">		final int prime = 31;</span>
<span class="nc" id="L416">		int result = 1;</span>
<span class="nc" id="L417">		result = prime * result + NumberUtils.floatToIntBits(x);</span>
<span class="nc" id="L418">		result = prime * result + NumberUtils.floatToIntBits(y);</span>
<span class="nc" id="L419">		return result;</span>
	}

	@Override
	public boolean equals (Object obj) {
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">		if (this == obj) return true;</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">		if (obj == null) return false;</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">		if (getClass() != obj.getClass()) return false;</span>
<span class="fc" id="L427">		Vector2 other = (Vector2)obj;</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">		if (NumberUtils.floatToIntBits(x) != NumberUtils.floatToIntBits(other.x)) return false;</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">		if (NumberUtils.floatToIntBits(y) != NumberUtils.floatToIntBits(other.y)) return false;</span>
<span class="fc" id="L430">		return true;</span>
	}

	@Override
	public boolean epsilonEquals (Vector2 other, float epsilon) {
<span class="nc bnc" id="L435" title="All 2 branches missed.">		if (other == null) return false;</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">		if (Math.abs(other.x - x) &gt; epsilon) return false;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">		if (Math.abs(other.y - y) &gt; epsilon) return false;</span>
<span class="nc" id="L438">		return true;</span>
	}

	/** Compares this vector with the other vector, using the supplied epsilon for fuzzy equality testing.
	 * @return whether the vectors are the same. */
	public boolean epsilonEquals (float x, float y, float epsilon) {
<span class="nc bnc" id="L444" title="All 2 branches missed.">		if (Math.abs(x - this.x) &gt; epsilon) return false;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">		if (Math.abs(y - this.y) &gt; epsilon) return false;</span>
<span class="nc" id="L446">		return true;</span>
	}

	@Override
	public boolean isUnit () {
<span class="nc" id="L451">		return isUnit(0.000000001f);</span>
	}

	@Override
	public boolean isUnit (final float margin) {
<span class="nc bnc" id="L456" title="All 2 branches missed.">		return Math.abs(len2() - 1f) &lt; margin;</span>
	}

	@Override
	public boolean isZero () {
<span class="nc bnc" id="L461" title="All 4 branches missed.">		return x == 0 &amp;&amp; y == 0;</span>
	}

	@Override
	public boolean isZero (final float margin) {
<span class="nc bnc" id="L466" title="All 2 branches missed.">		return len2() &lt; margin;</span>
	}

	@Override
	public boolean isOnLine (Vector2 other) {
<span class="nc" id="L471">		return MathUtils.isZero(x * other.y - y * other.x);</span>
	}

	@Override
	public boolean isOnLine (Vector2 other, float epsilon) {
<span class="nc" id="L476">		return MathUtils.isZero(x * other.y - y * other.x, epsilon);</span>
	}

	@Override
	public boolean isCollinear (Vector2 other, float epsilon) {
<span class="nc bnc" id="L481" title="All 4 branches missed.">		return isOnLine(other, epsilon) &amp;&amp; dot(other) &gt; 0f;</span>
	}

	@Override
	public boolean isCollinear (Vector2 other) {
<span class="nc bnc" id="L486" title="All 4 branches missed.">		return isOnLine(other) &amp;&amp; dot(other) &gt; 0f;</span>
	}

	@Override
	public boolean isCollinearOpposite (Vector2 other, float epsilon) {
<span class="nc bnc" id="L491" title="All 4 branches missed.">		return isOnLine(other, epsilon) &amp;&amp; dot(other) &lt; 0f;</span>
	}

	@Override
	public boolean isCollinearOpposite (Vector2 other) {
<span class="nc bnc" id="L496" title="All 4 branches missed.">		return isOnLine(other) &amp;&amp; dot(other) &lt; 0f;</span>
	}

	@Override
	public boolean isPerpendicular (Vector2 vector) {
<span class="nc" id="L501">		return MathUtils.isZero(dot(vector));</span>
	}

	@Override
	public boolean isPerpendicular (Vector2 vector, float epsilon) {
<span class="nc" id="L506">		return MathUtils.isZero(dot(vector), epsilon);</span>
	}

	@Override
	public boolean hasSameDirection (Vector2 vector) {
<span class="nc bnc" id="L511" title="All 2 branches missed.">		return dot(vector) &gt; 0;</span>
	}

	@Override
	public boolean hasOppositeDirection (Vector2 vector) {
<span class="nc bnc" id="L516" title="All 2 branches missed.">		return dot(vector) &lt; 0;</span>
	}

	@Override
	public Vector2 setZero () {
<span class="nc" id="L521">		this.x = 0;</span>
<span class="nc" id="L522">		this.y = 0;</span>
<span class="nc" id="L523">		return this;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>