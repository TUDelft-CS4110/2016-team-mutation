<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Matrix4.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.math</a> &gt; <span class="el_source">Matrix4.java</span></div><h1>Matrix4.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.math;

import java.io.Serializable;

/** Encapsulates a &lt;a href=&quot;http://en.wikipedia.org/wiki/Row-major_order#Column-major_order&quot;&gt;column major&lt;/a&gt; 4 by 4 matrix. Like
 * the {@link Vector3} class it allows the chaining of methods by returning a reference to itself. For example:
 * 
 * &lt;pre&gt;
 * Matrix4 mat = new Matrix4().trn(position).mul(camera.combined);
 * &lt;/pre&gt;
 * 
 * @author badlogicgames@gmail.com */
public class Matrix4 implements Serializable {
	private static final long serialVersionUID = -2717655254359579617L;
	/** XX: Typically the unrotated X component for scaling, also the cosine of the angle when rotated on the Y and/or Z axis. On
	 * Vector3 multiplication this value is multiplied with the source X component and added to the target X component. */
	public static final int M00 = 0;
	/** XY: Typically the negative sine of the angle when rotated on the Z axis. On Vector3 multiplication this value is multiplied
	 * with the source Y component and added to the target X component. */
	public static final int M01 = 4;
	/** XZ: Typically the sine of the angle when rotated on the Y axis. On Vector3 multiplication this value is multiplied with the
	 * source Z component and added to the target X component. */
	public static final int M02 = 8;
	/** XW: Typically the translation of the X component. On Vector3 multiplication this value is added to the target X component. */
	public static final int M03 = 12;
	/** YX: Typically the sine of the angle when rotated on the Z axis. On Vector3 multiplication this value is multiplied with the
	 * source X component and added to the target Y component. */
	public static final int M10 = 1;
	/** YY: Typically the unrotated Y component for scaling, also the cosine of the angle when rotated on the X and/or Z axis. On
	 * Vector3 multiplication this value is multiplied with the source Y component and added to the target Y component. */
	public static final int M11 = 5;
	/** YZ: Typically the negative sine of the angle when rotated on the X axis. On Vector3 multiplication this value is multiplied
	 * with the source Z component and added to the target Y component. */
	public static final int M12 = 9;
	/** YW: Typically the translation of the Y component. On Vector3 multiplication this value is added to the target Y component. */
	public static final int M13 = 13;
	/** ZX: Typically the negative sine of the angle when rotated on the Y axis. On Vector3 multiplication this value is multiplied
	 * with the source X component and added to the target Z component. */
	public static final int M20 = 2;
	/** ZY: Typical the sine of the angle when rotated on the X axis. On Vector3 multiplication this value is multiplied with the
	 * source Y component and added to the target Z component. */
	public static final int M21 = 6;
	/** ZZ: Typically the unrotated Z component for scaling, also the cosine of the angle when rotated on the X and/or Y axis. On
	 * Vector3 multiplication this value is multiplied with the source Z component and added to the target Z component. */
	public static final int M22 = 10;
	/** ZW: Typically the translation of the Z component. On Vector3 multiplication this value is added to the target Z component. */
	public static final int M23 = 14;
	/** WX: Typically the value zero. On Vector3 multiplication this value is ignored. */
	public static final int M30 = 3;
	/** WY: Typically the value zero. On Vector3 multiplication this value is ignored. */
	public static final int M31 = 7;
	/** WZ: Typically the value zero. On Vector3 multiplication this value is ignored. */
	public static final int M32 = 11;
	/** WW: Typically the value one. On Vector3 multiplication this value is ignored. */
	public static final int M33 = 15;

<span class="fc" id="L73">	private static final float tmp[] = new float[16];</span>
<span class="pc" id="L74">	public final float val[] = new float[16];</span>

	/** Constructs an identity matrix */
<span class="fc" id="L77">	public Matrix4 () {</span>
<span class="fc" id="L78">		val[M00] = 1f;</span>
<span class="fc" id="L79">		val[M11] = 1f;</span>
<span class="fc" id="L80">		val[M22] = 1f;</span>
<span class="fc" id="L81">		val[M33] = 1f;</span>
<span class="fc" id="L82">	}</span>

	/** Constructs a matrix from the given matrix.
	 * 
	 * @param matrix The matrix to copy. (This matrix is not modified) */
<span class="nc" id="L87">	public Matrix4 (Matrix4 matrix) {</span>
<span class="nc" id="L88">		this.set(matrix);</span>
<span class="nc" id="L89">	}</span>

	/** Constructs a matrix from the given float array. The array must have at least 16 elements; the first 16 will be copied.
	 * @param values The float array to copy. Remember that this matrix is in &lt;a
	 *           href=&quot;http://en.wikipedia.org/wiki/Row-major_order&quot;&gt;column major&lt;/a&gt; order. (The float array is not modified) */
<span class="nc" id="L94">	public Matrix4 (float[] values) {</span>
<span class="nc" id="L95">		this.set(values);</span>
<span class="nc" id="L96">	}</span>

	/** Constructs a rotation matrix from the given {@link Quaternion}.
	 * @param quaternion The quaternion to be copied. (The quaternion is not modified) */
<span class="nc" id="L100">	public Matrix4 (Quaternion quaternion) {</span>
<span class="nc" id="L101">		this.set(quaternion);</span>
<span class="nc" id="L102">	}</span>

	/** Construct a matrix from the given translation, rotation and scale.
	 * @param position The translation
	 * @param rotation The rotation, must be normalized
	 * @param scale The scale */
<span class="nc" id="L108">	public Matrix4 (Vector3 position, Quaternion rotation, Vector3 scale) {</span>
<span class="nc" id="L109">		set(position, rotation, scale);</span>
<span class="nc" id="L110">	}</span>

	/** Sets the matrix to the given matrix.
	 * 
	 * @param matrix The matrix that is to be copied. (The given matrix is not modified)
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 set (Matrix4 matrix) {
<span class="nc" id="L117">		return this.set(matrix.val);</span>
	}

	/** Sets the matrix to the given matrix as a float array. The float array must have at least 16 elements; the first 16 will be
	 * copied.
	 * 
	 * @param values The matrix, in float form, that is to be copied. Remember that this matrix is in &lt;a
	 *           href=&quot;http://en.wikipedia.org/wiki/Row-major_order&quot;&gt;column major&lt;/a&gt; order.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 set (float[] values) {
<span class="nc" id="L127">		System.arraycopy(values, 0, val, 0, val.length);</span>
<span class="nc" id="L128">		return this;</span>
	}

	/** Sets the matrix to a rotation matrix representing the quaternion.
	 * 
	 * @param quaternion The quaternion that is to be used to set this matrix.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 set (Quaternion quaternion) {
<span class="nc" id="L136">		return set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);</span>
	}

	/** Sets the matrix to a rotation matrix representing the quaternion.
	 * 
	 * @param quaternionX The X component of the quaternion that is to be used to set this matrix.
	 * @param quaternionY The Y component of the quaternion that is to be used to set this matrix.
	 * @param quaternionZ The Z component of the quaternion that is to be used to set this matrix.
	 * @param quaternionW The W component of the quaternion that is to be used to set this matrix.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 set (float quaternionX, float quaternionY, float quaternionZ, float quaternionW) {
<span class="nc" id="L147">		return set(0f, 0f, 0f, quaternionX, quaternionY, quaternionZ, quaternionW);</span>
	}

	/** Set this matrix to the specified translation and rotation.
	 * @param position The translation
	 * @param orientation The rotation, must be normalized
	 * @return This matrix for chaining */
	public Matrix4 set (Vector3 position, Quaternion orientation) {
<span class="nc" id="L155">		return set(position.x, position.y, position.z, orientation.x, orientation.y, orientation.z, orientation.w);</span>
	}

	/** Sets the matrix to a rotation matrix representing the translation and quaternion.
	 * 
	 * @param translationX The X component of the translation that is to be used to set this matrix.
	 * @param translationY The Y component of the translation that is to be used to set this matrix.
	 * @param translationZ The Z component of the translation that is to be used to set this matrix.
	 * @param quaternionX The X component of the quaternion that is to be used to set this matrix.
	 * @param quaternionY The Y component of the quaternion that is to be used to set this matrix.
	 * @param quaternionZ The Z component of the quaternion that is to be used to set this matrix.
	 * @param quaternionW The W component of the quaternion that is to be used to set this matrix.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 set (float translationX, float translationY, float translationZ, float quaternionX, float quaternionY,
		float quaternionZ, float quaternionW) {
<span class="nc" id="L170">		final float xs = quaternionX * 2f, ys = quaternionY * 2f, zs = quaternionZ * 2f;</span>
<span class="nc" id="L171">		final float wx = quaternionW * xs, wy = quaternionW * ys, wz = quaternionW * zs;</span>
<span class="nc" id="L172">		final float xx = quaternionX * xs, xy = quaternionX * ys, xz = quaternionX * zs;</span>
<span class="nc" id="L173">		final float yy = quaternionY * ys, yz = quaternionY * zs, zz = quaternionZ * zs;</span>

<span class="nc" id="L175">		val[M00] = (1.0f - (yy + zz));</span>
<span class="nc" id="L176">		val[M01] = (xy - wz);</span>
<span class="nc" id="L177">		val[M02] = (xz + wy);</span>
<span class="nc" id="L178">		val[M03] = translationX;</span>

<span class="nc" id="L180">		val[M10] = (xy + wz);</span>
<span class="nc" id="L181">		val[M11] = (1.0f - (xx + zz));</span>
<span class="nc" id="L182">		val[M12] = (yz - wx);</span>
<span class="nc" id="L183">		val[M13] = translationY;</span>

<span class="nc" id="L185">		val[M20] = (xz - wy);</span>
<span class="nc" id="L186">		val[M21] = (yz + wx);</span>
<span class="nc" id="L187">		val[M22] = (1.0f - (xx + yy));</span>
<span class="nc" id="L188">		val[M23] = translationZ;</span>

<span class="nc" id="L190">		val[M30] = 0.f;</span>
<span class="nc" id="L191">		val[M31] = 0.f;</span>
<span class="nc" id="L192">		val[M32] = 0.f;</span>
<span class="nc" id="L193">		val[M33] = 1.0f;</span>
<span class="nc" id="L194">		return this;</span>
	}

	/** Set this matrix to the specified translation, rotation and scale.
	 * @param position The translation
	 * @param orientation The rotation, must be normalized
	 * @param scale The scale
	 * @return This matrix for chaining */
	public Matrix4 set (Vector3 position, Quaternion orientation, Vector3 scale) {
<span class="nc" id="L203">		return set(position.x, position.y, position.z, orientation.x, orientation.y, orientation.z, orientation.w, scale.x,</span>
			scale.y, scale.z);
	}

	/** Sets the matrix to a rotation matrix representing the translation and quaternion.
	 * 
	 * @param translationX The X component of the translation that is to be used to set this matrix.
	 * @param translationY The Y component of the translation that is to be used to set this matrix.
	 * @param translationZ The Z component of the translation that is to be used to set this matrix.
	 * @param quaternionX The X component of the quaternion that is to be used to set this matrix.
	 * @param quaternionY The Y component of the quaternion that is to be used to set this matrix.
	 * @param quaternionZ The Z component of the quaternion that is to be used to set this matrix.
	 * @param quaternionW The W component of the quaternion that is to be used to set this matrix.
	 * @param scaleX The X component of the scaling that is to be used to set this matrix.
	 * @param scaleY The Y component of the scaling that is to be used to set this matrix.
	 * @param scaleZ The Z component of the scaling that is to be used to set this matrix.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 set (float translationX, float translationY, float translationZ, float quaternionX, float quaternionY,
		float quaternionZ, float quaternionW, float scaleX, float scaleY, float scaleZ) {
<span class="nc" id="L222">		final float xs = quaternionX * 2f, ys = quaternionY * 2f, zs = quaternionZ * 2f;</span>
<span class="nc" id="L223">		final float wx = quaternionW * xs, wy = quaternionW * ys, wz = quaternionW * zs;</span>
<span class="nc" id="L224">		final float xx = quaternionX * xs, xy = quaternionX * ys, xz = quaternionX * zs;</span>
<span class="nc" id="L225">		final float yy = quaternionY * ys, yz = quaternionY * zs, zz = quaternionZ * zs;</span>

<span class="nc" id="L227">		val[M00] = scaleX * (1.0f - (yy + zz));</span>
<span class="nc" id="L228">		val[M01] = scaleY * (xy - wz);</span>
<span class="nc" id="L229">		val[M02] = scaleZ * (xz + wy);</span>
<span class="nc" id="L230">		val[M03] = translationX;</span>

<span class="nc" id="L232">		val[M10] = scaleX * (xy + wz);</span>
<span class="nc" id="L233">		val[M11] = scaleY * (1.0f - (xx + zz));</span>
<span class="nc" id="L234">		val[M12] = scaleZ * (yz - wx);</span>
<span class="nc" id="L235">		val[M13] = translationY;</span>

<span class="nc" id="L237">		val[M20] = scaleX * (xz - wy);</span>
<span class="nc" id="L238">		val[M21] = scaleY * (yz + wx);</span>
<span class="nc" id="L239">		val[M22] = scaleZ * (1.0f - (xx + yy));</span>
<span class="nc" id="L240">		val[M23] = translationZ;</span>

<span class="nc" id="L242">		val[M30] = 0.f;</span>
<span class="nc" id="L243">		val[M31] = 0.f;</span>
<span class="nc" id="L244">		val[M32] = 0.f;</span>
<span class="nc" id="L245">		val[M33] = 1.0f;</span>
<span class="nc" id="L246">		return this;</span>
	}

	/** Sets the four columns of the matrix which correspond to the x-, y- and z-axis of the vector space this matrix creates as
	 * well as the 4th column representing the translation of any point that is multiplied by this matrix.
	 * 
	 * @param xAxis The x-axis.
	 * @param yAxis The y-axis.
	 * @param zAxis The z-axis.
	 * @param pos The translation vector. */
	public Matrix4 set (Vector3 xAxis, Vector3 yAxis, Vector3 zAxis, Vector3 pos) {
<span class="nc" id="L257">		val[M00] = xAxis.x;</span>
<span class="nc" id="L258">		val[M01] = xAxis.y;</span>
<span class="nc" id="L259">		val[M02] = xAxis.z;</span>
<span class="nc" id="L260">		val[M10] = yAxis.x;</span>
<span class="nc" id="L261">		val[M11] = yAxis.y;</span>
<span class="nc" id="L262">		val[M12] = yAxis.z;</span>
<span class="nc" id="L263">		val[M20] = zAxis.x;</span>
<span class="nc" id="L264">		val[M21] = zAxis.y;</span>
<span class="nc" id="L265">		val[M22] = zAxis.z;</span>
<span class="nc" id="L266">		val[M03] = pos.x;</span>
<span class="nc" id="L267">		val[M13] = pos.y;</span>
<span class="nc" id="L268">		val[M23] = pos.z;</span>
<span class="nc" id="L269">		val[M30] = 0;</span>
<span class="nc" id="L270">		val[M31] = 0;</span>
<span class="nc" id="L271">		val[M32] = 0;</span>
<span class="nc" id="L272">		val[M33] = 1;</span>
<span class="nc" id="L273">		return this;</span>
	}

	/** @return a copy of this matrix */
	public Matrix4 cpy () {
<span class="nc" id="L278">		return new Matrix4(this);</span>
	}

	/** Adds a translational component to the matrix in the 4th column. The other columns are untouched.
	 * 
	 * @param vector The translation vector to add to the current matrix. (This vector is not modified)
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 trn (Vector3 vector) {
<span class="nc" id="L286">		val[M03] += vector.x;</span>
<span class="nc" id="L287">		val[M13] += vector.y;</span>
<span class="nc" id="L288">		val[M23] += vector.z;</span>
<span class="nc" id="L289">		return this;</span>
	}

	/** Adds a translational component to the matrix in the 4th column. The other columns are untouched.
	 * 
	 * @param x The x-component of the translation vector.
	 * @param y The y-component of the translation vector.
	 * @param z The z-component of the translation vector.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 trn (float x, float y, float z) {
<span class="nc" id="L299">		val[M03] += x;</span>
<span class="nc" id="L300">		val[M13] += y;</span>
<span class="nc" id="L301">		val[M23] += z;</span>
<span class="nc" id="L302">		return this;</span>
	}

	/** @return the backing float array */
	public float[] getValues () {
<span class="nc" id="L307">		return val;</span>
	}

	/** Postmultiplies this matrix with the given matrix, storing the result in this matrix. For example:
	 * 
	 * &lt;pre&gt;
	 * A.mul(B) results in A := AB.
	 * &lt;/pre&gt;
	 * 
	 * @param matrix The other matrix to multiply by.
	 * @return This matrix for the purpose of chaining operations together. */
	public Matrix4 mul (Matrix4 matrix) {
<span class="nc" id="L319">		mul(val, matrix.val);</span>
<span class="nc" id="L320">		return this;</span>
	}

	/** Premultiplies this matrix with the given matrix, storing the result in this matrix. For example:
	 * 
	 * &lt;pre&gt;
	 * A.mulLeft(B) results in A := BA.
	 * &lt;/pre&gt;
	 * 
	 * @param matrix The other matrix to multiply by.
	 * @return This matrix for the purpose of chaining operations together. */
	public Matrix4 mulLeft (Matrix4 matrix) {
<span class="nc" id="L332">		tmpMat.set(matrix);</span>
<span class="nc" id="L333">		mul(tmpMat.val, this.val);</span>
<span class="nc" id="L334">		return set(tmpMat);</span>
	}

	/** Transposes the matrix.
	 * 
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 tra () {
<span class="nc" id="L341">		tmp[M00] = val[M00];</span>
<span class="nc" id="L342">		tmp[M01] = val[M10];</span>
<span class="nc" id="L343">		tmp[M02] = val[M20];</span>
<span class="nc" id="L344">		tmp[M03] = val[M30];</span>
<span class="nc" id="L345">		tmp[M10] = val[M01];</span>
<span class="nc" id="L346">		tmp[M11] = val[M11];</span>
<span class="nc" id="L347">		tmp[M12] = val[M21];</span>
<span class="nc" id="L348">		tmp[M13] = val[M31];</span>
<span class="nc" id="L349">		tmp[M20] = val[M02];</span>
<span class="nc" id="L350">		tmp[M21] = val[M12];</span>
<span class="nc" id="L351">		tmp[M22] = val[M22];</span>
<span class="nc" id="L352">		tmp[M23] = val[M32];</span>
<span class="nc" id="L353">		tmp[M30] = val[M03];</span>
<span class="nc" id="L354">		tmp[M31] = val[M13];</span>
<span class="nc" id="L355">		tmp[M32] = val[M23];</span>
<span class="nc" id="L356">		tmp[M33] = val[M33];</span>
<span class="nc" id="L357">		return set(tmp);</span>
	}

	/** Sets the matrix to an identity matrix.
	 * 
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 idt () {
<span class="nc" id="L364">		val[M00] = 1;</span>
<span class="nc" id="L365">		val[M01] = 0;</span>
<span class="nc" id="L366">		val[M02] = 0;</span>
<span class="nc" id="L367">		val[M03] = 0;</span>
<span class="nc" id="L368">		val[M10] = 0;</span>
<span class="nc" id="L369">		val[M11] = 1;</span>
<span class="nc" id="L370">		val[M12] = 0;</span>
<span class="nc" id="L371">		val[M13] = 0;</span>
<span class="nc" id="L372">		val[M20] = 0;</span>
<span class="nc" id="L373">		val[M21] = 0;</span>
<span class="nc" id="L374">		val[M22] = 1;</span>
<span class="nc" id="L375">		val[M23] = 0;</span>
<span class="nc" id="L376">		val[M30] = 0;</span>
<span class="nc" id="L377">		val[M31] = 0;</span>
<span class="nc" id="L378">		val[M32] = 0;</span>
<span class="nc" id="L379">		val[M33] = 1;</span>
<span class="nc" id="L380">		return this;</span>
	}

	/** Inverts the matrix. Stores the result in this matrix.
	 * 
	 * @return This matrix for the purpose of chaining methods together.
	 * @throws RuntimeException if the matrix is singular (not invertible) */
	public Matrix4 inv () {
<span class="nc" id="L388">		float l_det = val[M30] * val[M21] * val[M12] * val[M03] - val[M20] * val[M31] * val[M12] * val[M03] - val[M30] * val[M11]</span>
			* val[M22] * val[M03] + val[M10] * val[M31] * val[M22] * val[M03] + val[M20] * val[M11] * val[M32] * val[M03] - val[M10]
			* val[M21] * val[M32] * val[M03] - val[M30] * val[M21] * val[M02] * val[M13] + val[M20] * val[M31] * val[M02] * val[M13]
			+ val[M30] * val[M01] * val[M22] * val[M13] - val[M00] * val[M31] * val[M22] * val[M13] - val[M20] * val[M01] * val[M32]
			* val[M13] + val[M00] * val[M21] * val[M32] * val[M13] + val[M30] * val[M11] * val[M02] * val[M23] - val[M10] * val[M31]
			* val[M02] * val[M23] - val[M30] * val[M01] * val[M12] * val[M23] + val[M00] * val[M31] * val[M12] * val[M23] + val[M10]
			* val[M01] * val[M32] * val[M23] - val[M00] * val[M11] * val[M32] * val[M23] - val[M20] * val[M11] * val[M02] * val[M33]
			+ val[M10] * val[M21] * val[M02] * val[M33] + val[M20] * val[M01] * val[M12] * val[M33] - val[M00] * val[M21] * val[M12]
			* val[M33] - val[M10] * val[M01] * val[M22] * val[M33] + val[M00] * val[M11] * val[M22] * val[M33];
<span class="nc bnc" id="L397" title="All 2 branches missed.">		if (l_det == 0f) throw new RuntimeException(&quot;non-invertible matrix&quot;);</span>
<span class="nc" id="L398">		float inv_det = 1.0f / l_det;</span>
<span class="nc" id="L399">		tmp[M00] = val[M12] * val[M23] * val[M31] - val[M13] * val[M22] * val[M31] + val[M13] * val[M21] * val[M32] - val[M11]</span>
			* val[M23] * val[M32] - val[M12] * val[M21] * val[M33] + val[M11] * val[M22] * val[M33];
<span class="nc" id="L401">		tmp[M01] = val[M03] * val[M22] * val[M31] - val[M02] * val[M23] * val[M31] - val[M03] * val[M21] * val[M32] + val[M01]</span>
			* val[M23] * val[M32] + val[M02] * val[M21] * val[M33] - val[M01] * val[M22] * val[M33];
<span class="nc" id="L403">		tmp[M02] = val[M02] * val[M13] * val[M31] - val[M03] * val[M12] * val[M31] + val[M03] * val[M11] * val[M32] - val[M01]</span>
			* val[M13] * val[M32] - val[M02] * val[M11] * val[M33] + val[M01] * val[M12] * val[M33];
<span class="nc" id="L405">		tmp[M03] = val[M03] * val[M12] * val[M21] - val[M02] * val[M13] * val[M21] - val[M03] * val[M11] * val[M22] + val[M01]</span>
			* val[M13] * val[M22] + val[M02] * val[M11] * val[M23] - val[M01] * val[M12] * val[M23];
<span class="nc" id="L407">		tmp[M10] = val[M13] * val[M22] * val[M30] - val[M12] * val[M23] * val[M30] - val[M13] * val[M20] * val[M32] + val[M10]</span>
			* val[M23] * val[M32] + val[M12] * val[M20] * val[M33] - val[M10] * val[M22] * val[M33];
<span class="nc" id="L409">		tmp[M11] = val[M02] * val[M23] * val[M30] - val[M03] * val[M22] * val[M30] + val[M03] * val[M20] * val[M32] - val[M00]</span>
			* val[M23] * val[M32] - val[M02] * val[M20] * val[M33] + val[M00] * val[M22] * val[M33];
<span class="nc" id="L411">		tmp[M12] = val[M03] * val[M12] * val[M30] - val[M02] * val[M13] * val[M30] - val[M03] * val[M10] * val[M32] + val[M00]</span>
			* val[M13] * val[M32] + val[M02] * val[M10] * val[M33] - val[M00] * val[M12] * val[M33];
<span class="nc" id="L413">		tmp[M13] = val[M02] * val[M13] * val[M20] - val[M03] * val[M12] * val[M20] + val[M03] * val[M10] * val[M22] - val[M00]</span>
			* val[M13] * val[M22] - val[M02] * val[M10] * val[M23] + val[M00] * val[M12] * val[M23];
<span class="nc" id="L415">		tmp[M20] = val[M11] * val[M23] * val[M30] - val[M13] * val[M21] * val[M30] + val[M13] * val[M20] * val[M31] - val[M10]</span>
			* val[M23] * val[M31] - val[M11] * val[M20] * val[M33] + val[M10] * val[M21] * val[M33];
<span class="nc" id="L417">		tmp[M21] = val[M03] * val[M21] * val[M30] - val[M01] * val[M23] * val[M30] - val[M03] * val[M20] * val[M31] + val[M00]</span>
			* val[M23] * val[M31] + val[M01] * val[M20] * val[M33] - val[M00] * val[M21] * val[M33];
<span class="nc" id="L419">		tmp[M22] = val[M01] * val[M13] * val[M30] - val[M03] * val[M11] * val[M30] + val[M03] * val[M10] * val[M31] - val[M00]</span>
			* val[M13] * val[M31] - val[M01] * val[M10] * val[M33] + val[M00] * val[M11] * val[M33];
<span class="nc" id="L421">		tmp[M23] = val[M03] * val[M11] * val[M20] - val[M01] * val[M13] * val[M20] - val[M03] * val[M10] * val[M21] + val[M00]</span>
			* val[M13] * val[M21] + val[M01] * val[M10] * val[M23] - val[M00] * val[M11] * val[M23];
<span class="nc" id="L423">		tmp[M30] = val[M12] * val[M21] * val[M30] - val[M11] * val[M22] * val[M30] - val[M12] * val[M20] * val[M31] + val[M10]</span>
			* val[M22] * val[M31] + val[M11] * val[M20] * val[M32] - val[M10] * val[M21] * val[M32];
<span class="nc" id="L425">		tmp[M31] = val[M01] * val[M22] * val[M30] - val[M02] * val[M21] * val[M30] + val[M02] * val[M20] * val[M31] - val[M00]</span>
			* val[M22] * val[M31] - val[M01] * val[M20] * val[M32] + val[M00] * val[M21] * val[M32];
<span class="nc" id="L427">		tmp[M32] = val[M02] * val[M11] * val[M30] - val[M01] * val[M12] * val[M30] - val[M02] * val[M10] * val[M31] + val[M00]</span>
			* val[M12] * val[M31] + val[M01] * val[M10] * val[M32] - val[M00] * val[M11] * val[M32];
<span class="nc" id="L429">		tmp[M33] = val[M01] * val[M12] * val[M20] - val[M02] * val[M11] * val[M20] + val[M02] * val[M10] * val[M21] - val[M00]</span>
			* val[M12] * val[M21] - val[M01] * val[M10] * val[M22] + val[M00] * val[M11] * val[M22];
<span class="nc" id="L431">		val[M00] = tmp[M00] * inv_det;</span>
<span class="nc" id="L432">		val[M01] = tmp[M01] * inv_det;</span>
<span class="nc" id="L433">		val[M02] = tmp[M02] * inv_det;</span>
<span class="nc" id="L434">		val[M03] = tmp[M03] * inv_det;</span>
<span class="nc" id="L435">		val[M10] = tmp[M10] * inv_det;</span>
<span class="nc" id="L436">		val[M11] = tmp[M11] * inv_det;</span>
<span class="nc" id="L437">		val[M12] = tmp[M12] * inv_det;</span>
<span class="nc" id="L438">		val[M13] = tmp[M13] * inv_det;</span>
<span class="nc" id="L439">		val[M20] = tmp[M20] * inv_det;</span>
<span class="nc" id="L440">		val[M21] = tmp[M21] * inv_det;</span>
<span class="nc" id="L441">		val[M22] = tmp[M22] * inv_det;</span>
<span class="nc" id="L442">		val[M23] = tmp[M23] * inv_det;</span>
<span class="nc" id="L443">		val[M30] = tmp[M30] * inv_det;</span>
<span class="nc" id="L444">		val[M31] = tmp[M31] * inv_det;</span>
<span class="nc" id="L445">		val[M32] = tmp[M32] * inv_det;</span>
<span class="nc" id="L446">		val[M33] = tmp[M33] * inv_det;</span>
<span class="nc" id="L447">		return this;</span>
	}

	/** @return The determinant of this matrix */
	public float det () {
<span class="nc" id="L452">		return val[M30] * val[M21] * val[M12] * val[M03] - val[M20] * val[M31] * val[M12] * val[M03] - val[M30] * val[M11]</span>
			* val[M22] * val[M03] + val[M10] * val[M31] * val[M22] * val[M03] + val[M20] * val[M11] * val[M32] * val[M03] - val[M10]
			* val[M21] * val[M32] * val[M03] - val[M30] * val[M21] * val[M02] * val[M13] + val[M20] * val[M31] * val[M02] * val[M13]
			+ val[M30] * val[M01] * val[M22] * val[M13] - val[M00] * val[M31] * val[M22] * val[M13] - val[M20] * val[M01] * val[M32]
			* val[M13] + val[M00] * val[M21] * val[M32] * val[M13] + val[M30] * val[M11] * val[M02] * val[M23] - val[M10] * val[M31]
			* val[M02] * val[M23] - val[M30] * val[M01] * val[M12] * val[M23] + val[M00] * val[M31] * val[M12] * val[M23] + val[M10]
			* val[M01] * val[M32] * val[M23] - val[M00] * val[M11] * val[M32] * val[M23] - val[M20] * val[M11] * val[M02] * val[M33]
			+ val[M10] * val[M21] * val[M02] * val[M33] + val[M20] * val[M01] * val[M12] * val[M33] - val[M00] * val[M21] * val[M12]
			* val[M33] - val[M10] * val[M01] * val[M22] * val[M33] + val[M00] * val[M11] * val[M22] * val[M33];
	}

	/** @return The determinant of the 3x3 upper left matrix */
	public float det3x3 () {
<span class="nc" id="L465">		return val[M00] * val[M11] * val[M22] + val[M01] * val[M12] * val[M20] + val[M02] * val[M10] * val[M21] - val[M00]</span>
			* val[M12] * val[M21] - val[M01] * val[M10] * val[M22] - val[M02] * val[M11] * val[M20];
	}

	/** Sets the matrix to a projection matrix with a near- and far plane, a field of view in degrees and an aspect ratio. Note that
	 * the field of view specified is the angle in degrees for the height, the field of view for the width will be calculated
	 * according to the aspect ratio.
	 * 
	 * @param near The near plane
	 * @param far The far plane
	 * @param fovy The field of view of the height in degrees
	 * @param aspectRatio The &quot;width over height&quot; aspect ratio
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToProjection (float near, float far, float fovy, float aspectRatio) {
<span class="nc" id="L479">		idt();</span>
<span class="nc" id="L480">		float l_fd = (float)(1.0 / Math.tan((fovy * (Math.PI / 180)) / 2.0));</span>
<span class="nc" id="L481">		float l_a1 = (far + near) / (near - far);</span>
<span class="nc" id="L482">		float l_a2 = (2 * far * near) / (near - far);</span>
<span class="nc" id="L483">		val[M00] = l_fd / aspectRatio;</span>
<span class="nc" id="L484">		val[M10] = 0;</span>
<span class="nc" id="L485">		val[M20] = 0;</span>
<span class="nc" id="L486">		val[M30] = 0;</span>
<span class="nc" id="L487">		val[M01] = 0;</span>
<span class="nc" id="L488">		val[M11] = l_fd;</span>
<span class="nc" id="L489">		val[M21] = 0;</span>
<span class="nc" id="L490">		val[M31] = 0;</span>
<span class="nc" id="L491">		val[M02] = 0;</span>
<span class="nc" id="L492">		val[M12] = 0;</span>
<span class="nc" id="L493">		val[M22] = l_a1;</span>
<span class="nc" id="L494">		val[M32] = -1;</span>
<span class="nc" id="L495">		val[M03] = 0;</span>
<span class="nc" id="L496">		val[M13] = 0;</span>
<span class="nc" id="L497">		val[M23] = l_a2;</span>
<span class="nc" id="L498">		val[M33] = 0;</span>

<span class="nc" id="L500">		return this;</span>
	}

	/** Sets the matrix to a projection matrix with a near/far plane, and left, bottom, right and top specifying the points on the
	 * near plane that are mapped to the lower left and upper right corners of the viewport. This allows to create projection
	 * matrix with off-center vanishing point.
	 * 
	 * @param left
	 * @param right
	 * @param bottom
	 * @param top
	 * @param near The near plane
	 * @param far The far plane
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToProjection (float left, float right, float bottom, float top, float near, float far) {
<span class="nc" id="L515">		float x = 2.0f * near / (right - left);</span>
<span class="nc" id="L516">		float y = 2.0f * near / (top - bottom);</span>
<span class="nc" id="L517">		float a = (right + left) / (right - left);</span>
<span class="nc" id="L518">		float b = (top + bottom) / (top - bottom);</span>
<span class="nc" id="L519">		float l_a1 = (far + near) / (near - far);</span>
<span class="nc" id="L520">		float l_a2 = (2 * far * near) / (near - far);</span>
<span class="nc" id="L521">		val[M00] = x;</span>
<span class="nc" id="L522">		val[M10] = 0;</span>
<span class="nc" id="L523">		val[M20] = 0;</span>
<span class="nc" id="L524">		val[M30] = 0;</span>
<span class="nc" id="L525">		val[M01] = 0;</span>
<span class="nc" id="L526">		val[M11] = y;</span>
<span class="nc" id="L527">		val[M21] = 0;</span>
<span class="nc" id="L528">		val[M31] = 0;</span>
<span class="nc" id="L529">		val[M02] = a;</span>
<span class="nc" id="L530">		val[M12] = b;</span>
<span class="nc" id="L531">		val[M22] = l_a1;</span>
<span class="nc" id="L532">		val[M32] = -1;</span>
<span class="nc" id="L533">		val[M03] = 0;</span>
<span class="nc" id="L534">		val[M13] = 0;</span>
<span class="nc" id="L535">		val[M23] = l_a2;</span>
<span class="nc" id="L536">		val[M33] = 0;</span>

<span class="nc" id="L538">		return this;</span>
	}

	/** Sets this matrix to an orthographic projection matrix with the origin at (x,y) extending by width and height. The near plane
	 * is set to 0, the far plane is set to 1.
	 * 
	 * @param x The x-coordinate of the origin
	 * @param y The y-coordinate of the origin
	 * @param width The width
	 * @param height The height
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToOrtho2D (float x, float y, float width, float height) {
<span class="nc" id="L550">		setToOrtho(x, x + width, y, y + height, 0, 1);</span>
<span class="nc" id="L551">		return this;</span>
	}

	/** Sets this matrix to an orthographic projection matrix with the origin at (x,y) extending by width and height, having a near
	 * and far plane.
	 * 
	 * @param x The x-coordinate of the origin
	 * @param y The y-coordinate of the origin
	 * @param width The width
	 * @param height The height
	 * @param near The near plane
	 * @param far The far plane
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToOrtho2D (float x, float y, float width, float height, float near, float far) {
<span class="nc" id="L565">		setToOrtho(x, x + width, y, y + height, near, far);</span>
<span class="nc" id="L566">		return this;</span>
	}

	/** Sets the matrix to an orthographic projection like glOrtho (http://www.opengl.org/sdk/docs/man/xhtml/glOrtho.xml) following
	 * the OpenGL equivalent
	 * 
	 * @param left The left clipping plane
	 * @param right The right clipping plane
	 * @param bottom The bottom clipping plane
	 * @param top The top clipping plane
	 * @param near The near clipping plane
	 * @param far The far clipping plane
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToOrtho (float left, float right, float bottom, float top, float near, float far) {

<span class="nc" id="L581">		this.idt();</span>
<span class="nc" id="L582">		float x_orth = 2 / (right - left);</span>
<span class="nc" id="L583">		float y_orth = 2 / (top - bottom);</span>
<span class="nc" id="L584">		float z_orth = -2 / (far - near);</span>

<span class="nc" id="L586">		float tx = -(right + left) / (right - left);</span>
<span class="nc" id="L587">		float ty = -(top + bottom) / (top - bottom);</span>
<span class="nc" id="L588">		float tz = -(far + near) / (far - near);</span>

<span class="nc" id="L590">		val[M00] = x_orth;</span>
<span class="nc" id="L591">		val[M10] = 0;</span>
<span class="nc" id="L592">		val[M20] = 0;</span>
<span class="nc" id="L593">		val[M30] = 0;</span>
<span class="nc" id="L594">		val[M01] = 0;</span>
<span class="nc" id="L595">		val[M11] = y_orth;</span>
<span class="nc" id="L596">		val[M21] = 0;</span>
<span class="nc" id="L597">		val[M31] = 0;</span>
<span class="nc" id="L598">		val[M02] = 0;</span>
<span class="nc" id="L599">		val[M12] = 0;</span>
<span class="nc" id="L600">		val[M22] = z_orth;</span>
<span class="nc" id="L601">		val[M32] = 0;</span>
<span class="nc" id="L602">		val[M03] = tx;</span>
<span class="nc" id="L603">		val[M13] = ty;</span>
<span class="nc" id="L604">		val[M23] = tz;</span>
<span class="nc" id="L605">		val[M33] = 1;</span>

<span class="nc" id="L607">		return this;</span>
	}

	/** Sets the 4th column to the translation vector.
	 * 
	 * @param vector The translation vector
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setTranslation (Vector3 vector) {
<span class="nc" id="L615">		val[M03] = vector.x;</span>
<span class="nc" id="L616">		val[M13] = vector.y;</span>
<span class="nc" id="L617">		val[M23] = vector.z;</span>
<span class="nc" id="L618">		return this;</span>
	}

	/** Sets the 4th column to the translation vector.
	 * 
	 * @param x The X coordinate of the translation vector
	 * @param y The Y coordinate of the translation vector
	 * @param z The Z coordinate of the translation vector
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setTranslation (float x, float y, float z) {
<span class="nc" id="L628">		val[M03] = x;</span>
<span class="nc" id="L629">		val[M13] = y;</span>
<span class="nc" id="L630">		val[M23] = z;</span>
<span class="nc" id="L631">		return this;</span>
	}

	/** Sets this matrix to a translation matrix, overwriting it first by an identity matrix and then setting the 4th column to the
	 * translation vector.
	 * 
	 * @param vector The translation vector
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToTranslation (Vector3 vector) {
<span class="nc" id="L640">		idt();</span>
<span class="nc" id="L641">		val[M03] = vector.x;</span>
<span class="nc" id="L642">		val[M13] = vector.y;</span>
<span class="nc" id="L643">		val[M23] = vector.z;</span>
<span class="nc" id="L644">		return this;</span>
	}

	/** Sets this matrix to a translation matrix, overwriting it first by an identity matrix and then setting the 4th column to the
	 * translation vector.
	 * 
	 * @param x The x-component of the translation vector.
	 * @param y The y-component of the translation vector.
	 * @param z The z-component of the translation vector.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToTranslation (float x, float y, float z) {
<span class="nc" id="L655">		idt();</span>
<span class="nc" id="L656">		val[M03] = x;</span>
<span class="nc" id="L657">		val[M13] = y;</span>
<span class="nc" id="L658">		val[M23] = z;</span>
<span class="nc" id="L659">		return this;</span>
	}

	/** Sets this matrix to a translation and scaling matrix by first overwriting it with an identity and then setting the
	 * translation vector in the 4th column and the scaling vector in the diagonal.
	 * 
	 * @param translation The translation vector
	 * @param scaling The scaling vector
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToTranslationAndScaling (Vector3 translation, Vector3 scaling) {
<span class="nc" id="L669">		idt();</span>
<span class="nc" id="L670">		val[M03] = translation.x;</span>
<span class="nc" id="L671">		val[M13] = translation.y;</span>
<span class="nc" id="L672">		val[M23] = translation.z;</span>
<span class="nc" id="L673">		val[M00] = scaling.x;</span>
<span class="nc" id="L674">		val[M11] = scaling.y;</span>
<span class="nc" id="L675">		val[M22] = scaling.z;</span>
<span class="nc" id="L676">		return this;</span>
	}

	/** Sets this matrix to a translation and scaling matrix by first overwriting it with an identity and then setting the
	 * translation vector in the 4th column and the scaling vector in the diagonal.
	 * 
	 * @param translationX The x-component of the translation vector
	 * @param translationY The y-component of the translation vector
	 * @param translationZ The z-component of the translation vector
	 * @param scalingX The x-component of the scaling vector
	 * @param scalingY The x-component of the scaling vector
	 * @param scalingZ The x-component of the scaling vector
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToTranslationAndScaling (float translationX, float translationY, float translationZ, float scalingX,
		float scalingY, float scalingZ) {
<span class="nc" id="L691">		idt();</span>
<span class="nc" id="L692">		val[M03] = translationX;</span>
<span class="nc" id="L693">		val[M13] = translationY;</span>
<span class="nc" id="L694">		val[M23] = translationZ;</span>
<span class="nc" id="L695">		val[M00] = scalingX;</span>
<span class="nc" id="L696">		val[M11] = scalingY;</span>
<span class="nc" id="L697">		val[M22] = scalingZ;</span>
<span class="nc" id="L698">		return this;</span>
	}

<span class="fc" id="L701">	static Quaternion quat = new Quaternion();</span>
<span class="fc" id="L702">	static Quaternion quat2 = new Quaternion();</span>

	/** Sets the matrix to a rotation matrix around the given axis.
	 * 
	 * @param axis The axis
	 * @param degrees The angle in degrees
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToRotation (Vector3 axis, float degrees) {
<span class="nc bnc" id="L710" title="All 2 branches missed.">		if (degrees == 0) {</span>
<span class="nc" id="L711">			idt();</span>
<span class="nc" id="L712">			return this;</span>
		}
<span class="nc" id="L714">		return set(quat.set(axis, degrees));</span>
	}

	/** Sets the matrix to a rotation matrix around the given axis.
	 * 
	 * @param axis The axis
	 * @param radians The angle in radians
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToRotationRad (Vector3 axis, float radians) {
<span class="nc bnc" id="L723" title="All 2 branches missed.">		if (radians == 0) {</span>
<span class="nc" id="L724">			idt();</span>
<span class="nc" id="L725">			return this;</span>
		}
<span class="nc" id="L727">		return set(quat.setFromAxisRad(axis, radians));</span>
	}

	/** Sets the matrix to a rotation matrix around the given axis.
	 * 
	 * @param axisX The x-component of the axis
	 * @param axisY The y-component of the axis
	 * @param axisZ The z-component of the axis
	 * @param degrees The angle in degrees
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToRotation (float axisX, float axisY, float axisZ, float degrees) {
<span class="nc bnc" id="L738" title="All 2 branches missed.">		if (degrees == 0) {</span>
<span class="nc" id="L739">			idt();</span>
<span class="nc" id="L740">			return this;</span>
		}
<span class="nc" id="L742">		return set(quat.setFromAxis(axisX, axisY, axisZ, degrees));</span>
	}

	/** Sets the matrix to a rotation matrix around the given axis.
	 * 
	 * @param axisX The x-component of the axis
	 * @param axisY The y-component of the axis
	 * @param axisZ The z-component of the axis
	 * @param radians The angle in radians
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToRotationRad (float axisX, float axisY, float axisZ, float radians) {
<span class="nc bnc" id="L753" title="All 2 branches missed.">		if (radians == 0) {</span>
<span class="nc" id="L754">			idt();</span>
<span class="nc" id="L755">			return this;</span>
		}
<span class="nc" id="L757">		return set(quat.setFromAxisRad(axisX, axisY, axisZ, radians));</span>
	}

	/** Set the matrix to a rotation matrix between two vectors.
	 * @param v1 The base vector
	 * @param v2 The target vector
	 * @return This matrix for the purpose of chaining methods together */
	public Matrix4 setToRotation (final Vector3 v1, final Vector3 v2) {
<span class="nc" id="L765">		return set(quat.setFromCross(v1, v2));</span>
	}

	/** Set the matrix to a rotation matrix between two vectors.
	 * @param x1 The base vectors x value
	 * @param y1 The base vectors y value
	 * @param z1 The base vectors z value
	 * @param x2 The target vector x value
	 * @param y2 The target vector y value
	 * @param z2 The target vector z value
	 * @return This matrix for the purpose of chaining methods together */
	public Matrix4 setToRotation (final float x1, final float y1, final float z1, final float x2, final float y2, final float z2) {
<span class="nc" id="L777">		return set(quat.setFromCross(x1, y1, z1, x2, y2, z2));</span>
	}

	/** Sets this matrix to a rotation matrix from the given euler angles.
	 * @param yaw the yaw in degrees
	 * @param pitch the pitch in degrees
	 * @param roll the roll in degrees
	 * @return This matrix */
	public Matrix4 setFromEulerAngles (float yaw, float pitch, float roll) {
<span class="nc" id="L786">		quat.setEulerAngles(yaw, pitch, roll);</span>
<span class="nc" id="L787">		return set(quat);</span>
	}
	
	/** Sets this matrix to a rotation matrix from the given euler angles.
	 * @param yaw the yaw in radians
	 * @param pitch the pitch in radians
	 * @param roll the roll in radians
	 * @return This matrix */
	public Matrix4 setFromEulerAnglesRad (float yaw, float pitch, float roll) {
<span class="nc" id="L796">		quat.setEulerAnglesRad(yaw, pitch, roll);</span>
<span class="nc" id="L797">		return set(quat);</span>
	}

	/** Sets this matrix to a scaling matrix
	 * 
	 * @param vector The scaling vector
	 * @return This matrix for chaining. */
	public Matrix4 setToScaling (Vector3 vector) {
<span class="nc" id="L805">		idt();</span>
<span class="nc" id="L806">		val[M00] = vector.x;</span>
<span class="nc" id="L807">		val[M11] = vector.y;</span>
<span class="nc" id="L808">		val[M22] = vector.z;</span>
<span class="nc" id="L809">		return this;</span>
	}

	/** Sets this matrix to a scaling matrix
	 * 
	 * @param x The x-component of the scaling vector
	 * @param y The y-component of the scaling vector
	 * @param z The z-component of the scaling vector
	 * @return This matrix for chaining. */
	public Matrix4 setToScaling (float x, float y, float z) {
<span class="nc" id="L819">		idt();</span>
<span class="nc" id="L820">		val[M00] = x;</span>
<span class="nc" id="L821">		val[M11] = y;</span>
<span class="nc" id="L822">		val[M22] = z;</span>
<span class="nc" id="L823">		return this;</span>
	}

<span class="fc" id="L826">	static final Vector3 l_vez = new Vector3();</span>
<span class="fc" id="L827">	static final Vector3 l_vex = new Vector3();</span>
<span class="fc" id="L828">	static final Vector3 l_vey = new Vector3();</span>

	/** Sets the matrix to a look at matrix with a direction and an up vector. Multiply with a translation matrix to get a camera
	 * model view matrix.
	 * 
	 * @param direction The direction vector
	 * @param up The up vector
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 setToLookAt (Vector3 direction, Vector3 up) {
<span class="nc" id="L837">		l_vez.set(direction).nor();</span>
<span class="nc" id="L838">		l_vex.set(direction).nor();</span>
<span class="nc" id="L839">		l_vex.crs(up).nor();</span>
<span class="nc" id="L840">		l_vey.set(l_vex).crs(l_vez).nor();</span>
<span class="nc" id="L841">		idt();</span>
<span class="nc" id="L842">		val[M00] = l_vex.x;</span>
<span class="nc" id="L843">		val[M01] = l_vex.y;</span>
<span class="nc" id="L844">		val[M02] = l_vex.z;</span>
<span class="nc" id="L845">		val[M10] = l_vey.x;</span>
<span class="nc" id="L846">		val[M11] = l_vey.y;</span>
<span class="nc" id="L847">		val[M12] = l_vey.z;</span>
<span class="nc" id="L848">		val[M20] = -l_vez.x;</span>
<span class="nc" id="L849">		val[M21] = -l_vez.y;</span>
<span class="nc" id="L850">		val[M22] = -l_vez.z;</span>

<span class="nc" id="L852">		return this;</span>
	}

<span class="fc" id="L855">	static final Vector3 tmpVec = new Vector3();</span>
<span class="fc" id="L856">	static final Matrix4 tmpMat = new Matrix4();</span>

	/** Sets this matrix to a look at matrix with the given position, target and up vector.
	 * 
	 * @param position the position
	 * @param target the target
	 * @param up the up vector
	 * @return This matrix */
	public Matrix4 setToLookAt (Vector3 position, Vector3 target, Vector3 up) {
<span class="nc" id="L865">		tmpVec.set(target).sub(position);</span>
<span class="nc" id="L866">		setToLookAt(tmpVec, up);</span>
<span class="nc" id="L867">		this.mul(tmpMat.setToTranslation(-position.x, -position.y, -position.z));</span>

<span class="nc" id="L869">		return this;</span>
	}

<span class="fc" id="L872">	static final Vector3 right = new Vector3();</span>
<span class="fc" id="L873">	static final Vector3 tmpForward = new Vector3();</span>
<span class="fc" id="L874">	static final Vector3 tmpUp = new Vector3();</span>

	public Matrix4 setToWorld (Vector3 position, Vector3 forward, Vector3 up) {
<span class="nc" id="L877">		tmpForward.set(forward).nor();</span>
<span class="nc" id="L878">		right.set(tmpForward).crs(up).nor();</span>
<span class="nc" id="L879">		tmpUp.set(right).crs(tmpForward).nor();</span>

<span class="nc" id="L881">		this.set(right, tmpUp, tmpForward.scl(-1), position);</span>
<span class="nc" id="L882">		return this;</span>
	}

	public String toString () {
<span class="nc" id="L886">		return &quot;[&quot; + val[M00] + &quot;|&quot; + val[M01] + &quot;|&quot; + val[M02] + &quot;|&quot; + val[M03] + &quot;]\n&quot; + &quot;[&quot; + val[M10] + &quot;|&quot; + val[M11] + &quot;|&quot;</span>
			+ val[M12] + &quot;|&quot; + val[M13] + &quot;]\n&quot; + &quot;[&quot; + val[M20] + &quot;|&quot; + val[M21] + &quot;|&quot; + val[M22] + &quot;|&quot; + val[M23] + &quot;]\n&quot; + &quot;[&quot;
			+ val[M30] + &quot;|&quot; + val[M31] + &quot;|&quot; + val[M32] + &quot;|&quot; + val[M33] + &quot;]\n&quot;;
	}

	/** Linearly interpolates between this matrix and the given matrix mixing by alpha
	 * @param matrix the matrix
	 * @param alpha the alpha value in the range [0,1]
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 lerp (Matrix4 matrix, float alpha) {
<span class="nc bnc" id="L896" title="All 2 branches missed.">		for (int i = 0; i &lt; 16; i++)</span>
<span class="nc" id="L897">			this.val[i] = this.val[i] * (1 - alpha) + matrix.val[i] * alpha;</span>
<span class="nc" id="L898">		return this;</span>
	}

	/** Averages the given transform with this one and stores the result in this matrix. Translations and scales are lerped while
	 * rotations are slerped.
	 * @param other The other transform
	 * @param w Weight of this transform; weight of the other transform is (1 - w)
	 * @return This matrix for chaining */
	public Matrix4 avg (Matrix4 other, float w) {
<span class="nc" id="L907">		getScale(tmpVec);</span>
<span class="nc" id="L908">		other.getScale(tmpForward);</span>

<span class="nc" id="L910">		getRotation(quat);</span>
<span class="nc" id="L911">		other.getRotation(quat2);</span>

<span class="nc" id="L913">		getTranslation(tmpUp);</span>
<span class="nc" id="L914">		other.getTranslation(right);</span>

<span class="nc" id="L916">		setToScaling(tmpVec.scl(w).add(tmpForward.scl(1 - w)));</span>
<span class="nc" id="L917">		rotate(quat.slerp(quat2, 1 - w));</span>
<span class="nc" id="L918">		setTranslation(tmpUp.scl(w).add(right.scl(1 - w)));</span>

<span class="nc" id="L920">		return this;</span>
	}

	/** Averages the given transforms and stores the result in this matrix. Translations and scales are lerped while rotations are
	 * slerped. Does not destroy the data contained in t.
	 * @param t List of transforms
	 * @return This matrix for chaining */
	public Matrix4 avg (Matrix4[] t) {
<span class="nc" id="L928">		final float w = 1.0f / t.length;</span>

<span class="nc" id="L930">		tmpVec.set(t[0].getScale(tmpUp).scl(w));</span>
<span class="nc" id="L931">		quat.set(t[0].getRotation(quat2).exp(w));</span>
<span class="nc" id="L932">		tmpForward.set(t[0].getTranslation(tmpUp).scl(w));</span>

<span class="nc bnc" id="L934" title="All 2 branches missed.">		for (int i = 1; i &lt; t.length; i++) {</span>
<span class="nc" id="L935">			tmpVec.add(t[i].getScale(tmpUp).scl(w));</span>
<span class="nc" id="L936">			quat.mul(t[i].getRotation(quat2).exp(w));</span>
<span class="nc" id="L937">			tmpForward.add(t[i].getTranslation(tmpUp).scl(w));</span>
		}
<span class="nc" id="L939">		quat.nor();</span>

<span class="nc" id="L941">		setToScaling(tmpVec);</span>
<span class="nc" id="L942">		rotate(quat);</span>
<span class="nc" id="L943">		setTranslation(tmpForward);</span>

<span class="nc" id="L945">		return this;</span>
	}

	/** Averages the given transforms with the given weights and stores the result in this matrix. Translations and scales are
	 * lerped while rotations are slerped. Does not destroy the data contained in t or w; Sum of w_i must be equal to 1, or
	 * unexpected results will occur.
	 * @param t List of transforms
	 * @param w List of weights
	 * @return This matrix for chaining */
	public Matrix4 avg (Matrix4[] t, float[] w) {
<span class="nc" id="L955">		tmpVec.set(t[0].getScale(tmpUp).scl(w[0]));</span>
<span class="nc" id="L956">		quat.set(t[0].getRotation(quat2).exp(w[0]));</span>
<span class="nc" id="L957">		tmpForward.set(t[0].getTranslation(tmpUp).scl(w[0]));</span>

<span class="nc bnc" id="L959" title="All 2 branches missed.">		for (int i = 1; i &lt; t.length; i++) {</span>
<span class="nc" id="L960">			tmpVec.add(t[i].getScale(tmpUp).scl(w[i]));</span>
<span class="nc" id="L961">			quat.mul(t[i].getRotation(quat2).exp(w[i]));</span>
<span class="nc" id="L962">			tmpForward.add(t[i].getTranslation(tmpUp).scl(w[i]));</span>
		}
<span class="nc" id="L964">		quat.nor();</span>

<span class="nc" id="L966">		setToScaling(tmpVec);</span>
<span class="nc" id="L967">		rotate(quat);</span>
<span class="nc" id="L968">		setTranslation(tmpForward);</span>

<span class="nc" id="L970">		return this;</span>
	}

	/** Sets this matrix to the given 3x3 matrix. The third column of this matrix is set to (0,0,1,0).
	 * @param mat the matrix */
	public Matrix4 set (Matrix3 mat) {
<span class="nc" id="L976">		val[0] = mat.val[0];</span>
<span class="nc" id="L977">		val[1] = mat.val[1];</span>
<span class="nc" id="L978">		val[2] = mat.val[2];</span>
<span class="nc" id="L979">		val[3] = 0;</span>
<span class="nc" id="L980">		val[4] = mat.val[3];</span>
<span class="nc" id="L981">		val[5] = mat.val[4];</span>
<span class="nc" id="L982">		val[6] = mat.val[5];</span>
<span class="nc" id="L983">		val[7] = 0;</span>
<span class="nc" id="L984">		val[8] = 0;</span>
<span class="nc" id="L985">		val[9] = 0;</span>
<span class="nc" id="L986">		val[10] = 1;</span>
<span class="nc" id="L987">		val[11] = 0;</span>
<span class="nc" id="L988">		val[12] = mat.val[6];</span>
<span class="nc" id="L989">		val[13] = mat.val[7];</span>
<span class="nc" id="L990">		val[14] = 0;</span>
<span class="nc" id="L991">		val[15] = mat.val[8];</span>
<span class="nc" id="L992">		return this;</span>
	}

	/** Sets this matrix to the given affine matrix. The values are mapped as follows:
	 *
	 * &lt;pre&gt;
	 *      [  M00  M01   0   M02  ]
	 *      [  M10  M11   0   M12  ]
	 *      [   0    0    1    0   ]
	 *      [   0    0    0    1   ]
	 * &lt;/pre&gt;
	 * @param affine the affine matrix
	 * @return This matrix for chaining */
	public Matrix4 set (Affine2 affine) {
<span class="nc" id="L1006">		val[M00] = affine.m00;</span>
<span class="nc" id="L1007">		val[M10] = affine.m10;</span>
<span class="nc" id="L1008">		val[M20] = 0;</span>
<span class="nc" id="L1009">		val[M30] = 0;</span>
<span class="nc" id="L1010">		val[M01] = affine.m01;</span>
<span class="nc" id="L1011">		val[M11] = affine.m11;</span>
<span class="nc" id="L1012">		val[M21] = 0;</span>
<span class="nc" id="L1013">		val[M31] = 0;</span>
<span class="nc" id="L1014">		val[M02] = 0;</span>
<span class="nc" id="L1015">		val[M12] = 0;</span>
<span class="nc" id="L1016">		val[M22] = 1;</span>
<span class="nc" id="L1017">		val[M32] = 0;</span>
<span class="nc" id="L1018">		val[M03] = affine.m02;</span>
<span class="nc" id="L1019">		val[M13] = affine.m12;</span>
<span class="nc" id="L1020">		val[M23] = 0;</span>
<span class="nc" id="L1021">		val[M33] = 1;</span>
<span class="nc" id="L1022">		return this;</span>
	}

	/** Assumes that this matrix is a 2D affine transformation, copying only the relevant components. The values are mapped as
	 * follows:
	 *
	 * &lt;pre&gt;
	 *      [  M00  M01   _   M02  ]
	 *      [  M10  M11   _   M12  ]
	 *      [   _    _    _    _   ]
	 *      [   _    _    _    _   ]
	 * &lt;/pre&gt;
	 * @param affine the source matrix
	 * @return This matrix for chaining */
	public Matrix4 setAsAffine (Affine2 affine) {
<span class="nc" id="L1037">		val[M00] = affine.m00;</span>
<span class="nc" id="L1038">		val[M10] = affine.m10;</span>
<span class="nc" id="L1039">		val[M01] = affine.m01;</span>
<span class="nc" id="L1040">		val[M11] = affine.m11;</span>
<span class="nc" id="L1041">		val[M03] = affine.m02;</span>
<span class="nc" id="L1042">		val[M13] = affine.m12;</span>
<span class="nc" id="L1043">		return this;</span>
	}

	/** Assumes that both matrices are 2D affine transformations, copying only the relevant components. The copied values are:
	 *
	 * &lt;pre&gt;
	 *      [  M00  M01   _   M03  ]
	 *      [  M10  M11   _   M13  ]
	 *      [   _    _    _    _   ]
	 *      [   _    _    _    _   ]
	 * &lt;/pre&gt;
	 * @param mat the source matrix
	 * @return This matrix for chaining */
	public Matrix4 setAsAffine (Matrix4 mat) {
<span class="nc" id="L1057">		val[M00] = mat.val[M00];</span>
<span class="nc" id="L1058">		val[M10] = mat.val[M10];</span>
<span class="nc" id="L1059">		val[M01] = mat.val[M01];</span>
<span class="nc" id="L1060">		val[M11] = mat.val[M11];</span>
<span class="nc" id="L1061">		val[M03] = mat.val[M03];</span>
<span class="nc" id="L1062">		val[M13] = mat.val[M13];</span>
<span class="nc" id="L1063">		return this;</span>
	}

	public Matrix4 scl (Vector3 scale) {
<span class="nc" id="L1067">		val[M00] *= scale.x;</span>
<span class="nc" id="L1068">		val[M11] *= scale.y;</span>
<span class="nc" id="L1069">		val[M22] *= scale.z;</span>
<span class="nc" id="L1070">		return this;</span>
	}

	public Matrix4 scl (float x, float y, float z) {
<span class="nc" id="L1074">		val[M00] *= x;</span>
<span class="nc" id="L1075">		val[M11] *= y;</span>
<span class="nc" id="L1076">		val[M22] *= z;</span>
<span class="nc" id="L1077">		return this;</span>
	}

	public Matrix4 scl (float scale) {
<span class="nc" id="L1081">		val[M00] *= scale;</span>
<span class="nc" id="L1082">		val[M11] *= scale;</span>
<span class="nc" id="L1083">		val[M22] *= scale;</span>
<span class="nc" id="L1084">		return this;</span>
	}

	public Vector3 getTranslation (Vector3 position) {
<span class="nc" id="L1088">		position.x = val[M03];</span>
<span class="nc" id="L1089">		position.y = val[M13];</span>
<span class="nc" id="L1090">		position.z = val[M23];</span>
<span class="nc" id="L1091">		return position;</span>
	}

	/** Gets the rotation of this matrix.
	 * @param rotation The {@link Quaternion} to receive the rotation
	 * @param normalizeAxes True to normalize the axes, necessary when the matrix might also include scaling.
	 * @return The provided {@link Quaternion} for chaining. */
	public Quaternion getRotation (Quaternion rotation, boolean normalizeAxes) {
<span class="nc" id="L1099">		return rotation.setFromMatrix(normalizeAxes, this);</span>
	}

	/** Gets the rotation of this matrix.
	 * @param rotation The {@link Quaternion} to receive the rotation
	 * @return The provided {@link Quaternion} for chaining. */
	public Quaternion getRotation (Quaternion rotation) {
<span class="nc" id="L1106">		return rotation.setFromMatrix(this);</span>
	}

	/** @return the squared scale factor on the X axis */
	public float getScaleXSquared () {
<span class="nc" id="L1111">		return val[Matrix4.M00] * val[Matrix4.M00] + val[Matrix4.M01] * val[Matrix4.M01] + val[Matrix4.M02] * val[Matrix4.M02];</span>
	}

	/** @return the squared scale factor on the Y axis */
	public float getScaleYSquared () {
<span class="nc" id="L1116">		return val[Matrix4.M10] * val[Matrix4.M10] + val[Matrix4.M11] * val[Matrix4.M11] + val[Matrix4.M12] * val[Matrix4.M12];</span>
	}

	/** @return the squared scale factor on the Z axis */
	public float getScaleZSquared () {
<span class="nc" id="L1121">		return val[Matrix4.M20] * val[Matrix4.M20] + val[Matrix4.M21] * val[Matrix4.M21] + val[Matrix4.M22] * val[Matrix4.M22];</span>
	}

	/** @return the scale factor on the X axis (non-negative) */
	public float getScaleX () {
<span class="nc bnc" id="L1126" title="All 4 branches missed.">		return (MathUtils.isZero(val[Matrix4.M01]) &amp;&amp; MathUtils.isZero(val[Matrix4.M02])) ? Math.abs(val[Matrix4.M00])</span>
			: (float)Math.sqrt(getScaleXSquared());
	}

	/** @return the scale factor on the Y axis (non-negative) */
	public float getScaleY () {
<span class="nc bnc" id="L1132" title="All 4 branches missed.">		return (MathUtils.isZero(val[Matrix4.M10]) &amp;&amp; MathUtils.isZero(val[Matrix4.M12])) ? Math.abs(val[Matrix4.M11])</span>
			: (float)Math.sqrt(getScaleYSquared());
	}

	/** @return the scale factor on the X axis (non-negative) */
	public float getScaleZ () {
<span class="nc bnc" id="L1138" title="All 4 branches missed.">		return (MathUtils.isZero(val[Matrix4.M20]) &amp;&amp; MathUtils.isZero(val[Matrix4.M21])) ? Math.abs(val[Matrix4.M22])</span>
			: (float)Math.sqrt(getScaleZSquared());
	}

	/** @param scale The vector which will receive the (non-negative) scale components on each axis.
	 * @return The provided vector for chaining. */
	public Vector3 getScale (Vector3 scale) {
<span class="nc" id="L1145">		return scale.set(getScaleX(), getScaleY(), getScaleZ());</span>
	}

	/** removes the translational part and transposes the matrix. */
	public Matrix4 toNormalMatrix () {
<span class="nc" id="L1150">		val[M03] = 0;</span>
<span class="nc" id="L1151">		val[M13] = 0;</span>
<span class="nc" id="L1152">		val[M23] = 0;</span>
<span class="nc" id="L1153">		return inv().tra();</span>
	}

	// @off
	/*JNI
	#include &lt;memory.h&gt;
	#include &lt;stdio.h&gt;
	#include &lt;string.h&gt;
	
	#define M00 0
	#define M01 4
	#define M02 8
	#define M03 12
	#define M10 1
	#define M11 5
	#define M12 9
	#define M13 13
	#define M20 2
	#define M21 6
	#define M22 10
	#define M23 14
	#define M30 3
	#define M31 7
	#define M32 11
	#define M33 15
	
	static inline void matrix4_mul(float* mata, float* matb) {
		float tmp[16];
		tmp[M00] = mata[M00] * matb[M00] + mata[M01] * matb[M10] + mata[M02] * matb[M20] + mata[M03] * matb[M30];
		tmp[M01] = mata[M00] * matb[M01] + mata[M01] * matb[M11] + mata[M02] * matb[M21] + mata[M03] * matb[M31];
		tmp[M02] = mata[M00] * matb[M02] + mata[M01] * matb[M12] + mata[M02] * matb[M22] + mata[M03] * matb[M32];
		tmp[M03] = mata[M00] * matb[M03] + mata[M01] * matb[M13] + mata[M02] * matb[M23] + mata[M03] * matb[M33];
		tmp[M10] = mata[M10] * matb[M00] + mata[M11] * matb[M10] + mata[M12] * matb[M20] + mata[M13] * matb[M30];
		tmp[M11] = mata[M10] * matb[M01] + mata[M11] * matb[M11] + mata[M12] * matb[M21] + mata[M13] * matb[M31];
		tmp[M12] = mata[M10] * matb[M02] + mata[M11] * matb[M12] + mata[M12] * matb[M22] + mata[M13] * matb[M32];
		tmp[M13] = mata[M10] * matb[M03] + mata[M11] * matb[M13] + mata[M12] * matb[M23] + mata[M13] * matb[M33];
		tmp[M20] = mata[M20] * matb[M00] + mata[M21] * matb[M10] + mata[M22] * matb[M20] + mata[M23] * matb[M30];
		tmp[M21] = mata[M20] * matb[M01] + mata[M21] * matb[M11] + mata[M22] * matb[M21] + mata[M23] * matb[M31];
		tmp[M22] = mata[M20] * matb[M02] + mata[M21] * matb[M12] + mata[M22] * matb[M22] + mata[M23] * matb[M32];
		tmp[M23] = mata[M20] * matb[M03] + mata[M21] * matb[M13] + mata[M22] * matb[M23] + mata[M23] * matb[M33];
		tmp[M30] = mata[M30] * matb[M00] + mata[M31] * matb[M10] + mata[M32] * matb[M20] + mata[M33] * matb[M30];
		tmp[M31] = mata[M30] * matb[M01] + mata[M31] * matb[M11] + mata[M32] * matb[M21] + mata[M33] * matb[M31];
		tmp[M32] = mata[M30] * matb[M02] + mata[M31] * matb[M12] + mata[M32] * matb[M22] + mata[M33] * matb[M32];
		tmp[M33] = mata[M30] * matb[M03] + mata[M31] * matb[M13] + mata[M32] * matb[M23] + mata[M33] * matb[M33];
		memcpy(mata, tmp, sizeof(float) *  16);
	}
	
	static inline float matrix4_det(float* val) {
		return val[M30] * val[M21] * val[M12] * val[M03] - val[M20] * val[M31] * val[M12] * val[M03] - val[M30] * val[M11]
				* val[M22] * val[M03] + val[M10] * val[M31] * val[M22] * val[M03] + val[M20] * val[M11] * val[M32] * val[M03] - val[M10]
				* val[M21] * val[M32] * val[M03] - val[M30] * val[M21] * val[M02] * val[M13] + val[M20] * val[M31] * val[M02] * val[M13]
				+ val[M30] * val[M01] * val[M22] * val[M13] - val[M00] * val[M31] * val[M22] * val[M13] - val[M20] * val[M01] * val[M32]
				* val[M13] + val[M00] * val[M21] * val[M32] * val[M13] + val[M30] * val[M11] * val[M02] * val[M23] - val[M10] * val[M31]
				* val[M02] * val[M23] - val[M30] * val[M01] * val[M12] * val[M23] + val[M00] * val[M31] * val[M12] * val[M23] + val[M10]
				* val[M01] * val[M32] * val[M23] - val[M00] * val[M11] * val[M32] * val[M23] - val[M20] * val[M11] * val[M02] * val[M33]
				+ val[M10] * val[M21] * val[M02] * val[M33] + val[M20] * val[M01] * val[M12] * val[M33] - val[M00] * val[M21] * val[M12]
				* val[M33] - val[M10] * val[M01] * val[M22] * val[M33] + val[M00] * val[M11] * val[M22] * val[M33];
	}
	
	static inline bool matrix4_inv(float* val) {
		float tmp[16];
		float l_det = matrix4_det(val);
		if (l_det == 0) return false;
		tmp[M00] = val[M12] * val[M23] * val[M31] - val[M13] * val[M22] * val[M31] + val[M13] * val[M21] * val[M32] - val[M11]
			* val[M23] * val[M32] - val[M12] * val[M21] * val[M33] + val[M11] * val[M22] * val[M33];
		tmp[M01] = val[M03] * val[M22] * val[M31] - val[M02] * val[M23] * val[M31] - val[M03] * val[M21] * val[M32] + val[M01]
			* val[M23] * val[M32] + val[M02] * val[M21] * val[M33] - val[M01] * val[M22] * val[M33];
		tmp[M02] = val[M02] * val[M13] * val[M31] - val[M03] * val[M12] * val[M31] + val[M03] * val[M11] * val[M32] - val[M01]
			* val[M13] * val[M32] - val[M02] * val[M11] * val[M33] + val[M01] * val[M12] * val[M33];
		tmp[M03] = val[M03] * val[M12] * val[M21] - val[M02] * val[M13] * val[M21] - val[M03] * val[M11] * val[M22] + val[M01]
			* val[M13] * val[M22] + val[M02] * val[M11] * val[M23] - val[M01] * val[M12] * val[M23];
		tmp[M10] = val[M13] * val[M22] * val[M30] - val[M12] * val[M23] * val[M30] - val[M13] * val[M20] * val[M32] + val[M10]
			* val[M23] * val[M32] + val[M12] * val[M20] * val[M33] - val[M10] * val[M22] * val[M33];
		tmp[M11] = val[M02] * val[M23] * val[M30] - val[M03] * val[M22] * val[M30] + val[M03] * val[M20] * val[M32] - val[M00]
			* val[M23] * val[M32] - val[M02] * val[M20] * val[M33] + val[M00] * val[M22] * val[M33];
		tmp[M12] = val[M03] * val[M12] * val[M30] - val[M02] * val[M13] * val[M30] - val[M03] * val[M10] * val[M32] + val[M00]
			* val[M13] * val[M32] + val[M02] * val[M10] * val[M33] - val[M00] * val[M12] * val[M33];
		tmp[M13] = val[M02] * val[M13] * val[M20] - val[M03] * val[M12] * val[M20] + val[M03] * val[M10] * val[M22] - val[M00]
			* val[M13] * val[M22] - val[M02] * val[M10] * val[M23] + val[M00] * val[M12] * val[M23];
		tmp[M20] = val[M11] * val[M23] * val[M30] - val[M13] * val[M21] * val[M30] + val[M13] * val[M20] * val[M31] - val[M10]
			* val[M23] * val[M31] - val[M11] * val[M20] * val[M33] + val[M10] * val[M21] * val[M33];
		tmp[M21] = val[M03] * val[M21] * val[M30] - val[M01] * val[M23] * val[M30] - val[M03] * val[M20] * val[M31] + val[M00]
			* val[M23] * val[M31] + val[M01] * val[M20] * val[M33] - val[M00] * val[M21] * val[M33];
		tmp[M22] = val[M01] * val[M13] * val[M30] - val[M03] * val[M11] * val[M30] + val[M03] * val[M10] * val[M31] - val[M00]
			* val[M13] * val[M31] - val[M01] * val[M10] * val[M33] + val[M00] * val[M11] * val[M33];
		tmp[M23] = val[M03] * val[M11] * val[M20] - val[M01] * val[M13] * val[M20] - val[M03] * val[M10] * val[M21] + val[M00]
			* val[M13] * val[M21] + val[M01] * val[M10] * val[M23] - val[M00] * val[M11] * val[M23];
		tmp[M30] = val[M12] * val[M21] * val[M30] - val[M11] * val[M22] * val[M30] - val[M12] * val[M20] * val[M31] + val[M10]
			* val[M22] * val[M31] + val[M11] * val[M20] * val[M32] - val[M10] * val[M21] * val[M32];
		tmp[M31] = val[M01] * val[M22] * val[M30] - val[M02] * val[M21] * val[M30] + val[M02] * val[M20] * val[M31] - val[M00]
			* val[M22] * val[M31] - val[M01] * val[M20] * val[M32] + val[M00] * val[M21] * val[M32];
		tmp[M32] = val[M02] * val[M11] * val[M30] - val[M01] * val[M12] * val[M30] - val[M02] * val[M10] * val[M31] + val[M00]
			* val[M12] * val[M31] + val[M01] * val[M10] * val[M32] - val[M00] * val[M11] * val[M32];
		tmp[M33] = val[M01] * val[M12] * val[M20] - val[M02] * val[M11] * val[M20] + val[M02] * val[M10] * val[M21] - val[M00]
			* val[M12] * val[M21] - val[M01] * val[M10] * val[M22] + val[M00] * val[M11] * val[M22];

		float inv_det = 1.0f / l_det;
		val[M00] = tmp[M00] * inv_det;
		val[M01] = tmp[M01] * inv_det;
		val[M02] = tmp[M02] * inv_det;
		val[M03] = tmp[M03] * inv_det;
		val[M10] = tmp[M10] * inv_det;
		val[M11] = tmp[M11] * inv_det;
		val[M12] = tmp[M12] * inv_det;
		val[M13] = tmp[M13] * inv_det;
		val[M20] = tmp[M20] * inv_det;
		val[M21] = tmp[M21] * inv_det;
		val[M22] = tmp[M22] * inv_det;
		val[M23] = tmp[M23] * inv_det;
		val[M30] = tmp[M30] * inv_det;
		val[M31] = tmp[M31] * inv_det;
		val[M32] = tmp[M32] * inv_det;
		val[M33] = tmp[M33] * inv_det;
		return true;
	}

	static inline void matrix4_mulVec(float* mat, float* vec) {
		float x = vec[0] * mat[M00] + vec[1] * mat[M01] + vec[2] * mat[M02] + mat[M03];
		float y = vec[0] * mat[M10] + vec[1] * mat[M11] + vec[2] * mat[M12] + mat[M13];
		float z = vec[0] * mat[M20] + vec[1] * mat[M21] + vec[2] * mat[M22] + mat[M23];
		vec[0] = x;
		vec[1] = y;
		vec[2] = z;
	}
	
	static inline void matrix4_proj(float* mat, float* vec) {
		float inv_w = 1.0f / (vec[0] * mat[M30] + vec[1] * mat[M31] + vec[2] * mat[M32] + mat[M33]);
		float x = (vec[0] * mat[M00] + vec[1] * mat[M01] + vec[2] * mat[M02] + mat[M03]) * inv_w;
		float y = (vec[0] * mat[M10] + vec[1] * mat[M11] + vec[2] * mat[M12] + mat[M13]) * inv_w; 
		float z = (vec[0] * mat[M20] + vec[1] * mat[M21] + vec[2] * mat[M22] + mat[M23]) * inv_w;
		vec[0] = x;
		vec[1] = y;
		vec[2] = z;
	}
	
	static inline void matrix4_rot(float* mat, float* vec) {
		float x = vec[0] * mat[M00] + vec[1] * mat[M01] + vec[2] * mat[M02];
		float y = vec[0] * mat[M10] + vec[1] * mat[M11] + vec[2] * mat[M12];
		float z = vec[0] * mat[M20] + vec[1] * mat[M21] + vec[2] * mat[M22];
		vec[0] = x;
		vec[1] = y;
		vec[2] = z;
	}
	 */

	/** Multiplies the matrix mata with matrix matb, storing the result in mata. The arrays are assumed to hold 4x4 column major
	 * matrices as you can get from {@link Matrix4#val}. This is the same as {@link Matrix4#mul(Matrix4)}.
	 *
	 * @param mata the first matrix.
	 * @param matb the second matrix. */
	public static native void mul (float[] mata, float[] matb) /*-{ }-*/; /*
		matrix4_mul(mata, matb);
	*/

	/** Multiplies the vector with the given matrix. The matrix array is assumed to hold a 4x4 column major matrix as you can get
	 * from {@link Matrix4#val}. The vector array is assumed to hold a 3-component vector, with x being the first element, y being
	 * the second and z being the last component. The result is stored in the vector array. This is the same as
	 * {@link Vector3#mul(Matrix4)}.
	 * @param mat the matrix
	 * @param vec the vector. */
	public static native void mulVec (float[] mat, float[] vec) /*-{ }-*/; /*
		matrix4_mulVec(mat, vec);
	*/

	/** Multiplies the vectors with the given matrix. The matrix array is assumed to hold a 4x4 column major matrix as you can get
	 * from {@link Matrix4#val}. The vectors array is assumed to hold 3-component vectors. Offset specifies the offset into the
	 * array where the x-component of the first vector is located. The numVecs parameter specifies the number of vectors stored in
	 * the vectors array. The stride parameter specifies the number of floats between subsequent vectors and must be &gt;= 3. This is
	 * the same as {@link Vector3#mul(Matrix4)} applied to multiple vectors.
	 * 
	 * @param mat the matrix
	 * @param vecs the vectors
	 * @param offset the offset into the vectors array
	 * @param numVecs the number of vectors
	 * @param stride the stride between vectors in floats */
	public static native void mulVec (float[] mat, float[] vecs, int offset, int numVecs, int stride) /*-{ }-*/; /*
		float* vecPtr = vecs + offset;
		for(int i = 0; i &lt; numVecs; i++) {
			matrix4_mulVec(mat, vecPtr);
			vecPtr += stride;
		}
	*/

	/** Multiplies the vector with the given matrix, performing a division by w. The matrix array is assumed to hold a 4x4 column
	 * major matrix as you can get from {@link Matrix4#val}. The vector array is assumed to hold a 3-component vector, with x being
	 * the first element, y being the second and z being the last component. The result is stored in the vector array. This is the
	 * same as {@link Vector3#prj(Matrix4)}.
	 * @param mat the matrix
	 * @param vec the vector. */
	public static native void prj (float[] mat, float[] vec) /*-{ }-*/; /*
		matrix4_proj(mat, vec);
	*/

	/** Multiplies the vectors with the given matrix, , performing a division by w. The matrix array is assumed to hold a 4x4 column
	 * major matrix as you can get from {@link Matrix4#val}. The vectors array is assumed to hold 3-component vectors. Offset
	 * specifies the offset into the array where the x-component of the first vector is located. The numVecs parameter specifies
	 * the number of vectors stored in the vectors array. The stride parameter specifies the number of floats between subsequent
	 * vectors and must be &gt;= 3. This is the same as {@link Vector3#prj(Matrix4)} applied to multiple vectors.
	 * 
	 * @param mat the matrix
	 * @param vecs the vectors
	 * @param offset the offset into the vectors array
	 * @param numVecs the number of vectors
	 * @param stride the stride between vectors in floats */
	public static native void prj (float[] mat, float[] vecs, int offset, int numVecs, int stride) /*-{ }-*/; /*
		float* vecPtr = vecs + offset;
		for(int i = 0; i &lt; numVecs; i++) {
			matrix4_proj(mat, vecPtr);
			vecPtr += stride;
		}
	*/

	/** Multiplies the vector with the top most 3x3 sub-matrix of the given matrix. The matrix array is assumed to hold a 4x4 column
	 * major matrix as you can get from {@link Matrix4#val}. The vector array is assumed to hold a 3-component vector, with x being
	 * the first element, y being the second and z being the last component. The result is stored in the vector array. This is the
	 * same as {@link Vector3#rot(Matrix4)}.
	 * @param mat the matrix
	 * @param vec the vector. */
	public static native void rot (float[] mat, float[] vec) /*-{ }-*/; /*
		matrix4_rot(mat, vec);
	*/

	/** Multiplies the vectors with the top most 3x3 sub-matrix of the given matrix. The matrix array is assumed to hold a 4x4
	 * column major matrix as you can get from {@link Matrix4#val}. The vectors array is assumed to hold 3-component vectors.
	 * Offset specifies the offset into the array where the x-component of the first vector is located. The numVecs parameter
	 * specifies the number of vectors stored in the vectors array. The stride parameter specifies the number of floats between
	 * subsequent vectors and must be &gt;= 3. This is the same as {@link Vector3#rot(Matrix4)} applied to multiple vectors.
	 * 
	 * @param mat the matrix
	 * @param vecs the vectors
	 * @param offset the offset into the vectors array
	 * @param numVecs the number of vectors
	 * @param stride the stride between vectors in floats */
	public static native void rot (float[] mat, float[] vecs, int offset, int numVecs, int stride) /*-{ }-*/; /*
		float* vecPtr = vecs + offset;
		for(int i = 0; i &lt; numVecs; i++) {
			matrix4_rot(mat, vecPtr);
			vecPtr += stride;
		}
	*/

	/** Computes the inverse of the given matrix. The matrix array is assumed to hold a 4x4 column major matrix as you can get from
	 * {@link Matrix4#val}.
	 * @param values the matrix values.
	 * @return false in case the inverse could not be calculated, true otherwise. */
	public static native boolean inv (float[] values) /*-{ }-*/; /*
		return matrix4_inv(values);
	*/

	/** Computes the determinante of the given matrix. The matrix array is assumed to hold a 4x4 column major matrix as you can get
	 * from {@link Matrix4#val}.
	 * @param values the matrix values.
	 * @return the determinante. */
	public static native float det (float[] values) /*-{ }-*/; /*
		return matrix4_det(values);
	*/

	// @on
	/** Postmultiplies this matrix by a translation matrix. Postmultiplication is also used by OpenGL ES'
	 * glTranslate/glRotate/glScale
	 * @param translation
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 translate (Vector3 translation) {
<span class="nc" id="L1416">		return translate(translation.x, translation.y, translation.z);</span>
	}

	/** Postmultiplies this matrix by a translation matrix. Postmultiplication is also used by OpenGL ES' 1.x
	 * glTranslate/glRotate/glScale.
	 * @param x Translation in the x-axis.
	 * @param y Translation in the y-axis.
	 * @param z Translation in the z-axis.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 translate (float x, float y, float z) {
<span class="nc" id="L1426">		tmp[M00] = 1;</span>
<span class="nc" id="L1427">		tmp[M01] = 0;</span>
<span class="nc" id="L1428">		tmp[M02] = 0;</span>
<span class="nc" id="L1429">		tmp[M03] = x;</span>
<span class="nc" id="L1430">		tmp[M10] = 0;</span>
<span class="nc" id="L1431">		tmp[M11] = 1;</span>
<span class="nc" id="L1432">		tmp[M12] = 0;</span>
<span class="nc" id="L1433">		tmp[M13] = y;</span>
<span class="nc" id="L1434">		tmp[M20] = 0;</span>
<span class="nc" id="L1435">		tmp[M21] = 0;</span>
<span class="nc" id="L1436">		tmp[M22] = 1;</span>
<span class="nc" id="L1437">		tmp[M23] = z;</span>
<span class="nc" id="L1438">		tmp[M30] = 0;</span>
<span class="nc" id="L1439">		tmp[M31] = 0;</span>
<span class="nc" id="L1440">		tmp[M32] = 0;</span>
<span class="nc" id="L1441">		tmp[M33] = 1;</span>

<span class="nc" id="L1443">		mul(val, tmp);</span>
<span class="nc" id="L1444">		return this;</span>
	}

	/** Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x
	 * glTranslate/glRotate/glScale.
	 * 
	 * @param axis The vector axis to rotate around.
	 * @param degrees The angle in degrees.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 rotate (Vector3 axis, float degrees) {
<span class="nc bnc" id="L1454" title="All 2 branches missed.">		if (degrees == 0) return this;</span>
<span class="nc" id="L1455">		quat.set(axis, degrees);</span>
<span class="nc" id="L1456">		return rotate(quat);</span>
	}

	/** Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x
	 * glTranslate/glRotate/glScale.
	 * 
	 * @param axis The vector axis to rotate around.
	 * @param radians The angle in radians.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 rotateRad (Vector3 axis, float radians) {
<span class="nc bnc" id="L1466" title="All 2 branches missed.">		if (radians == 0) return this;</span>
<span class="nc" id="L1467">		quat.setFromAxisRad(axis, radians);</span>
<span class="nc" id="L1468">		return rotate(quat);</span>
	}

	/** Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x
	 * glTranslate/glRotate/glScale
	 * @param axisX The x-axis component of the vector to rotate around.
	 * @param axisY The y-axis component of the vector to rotate around.
	 * @param axisZ The z-axis component of the vector to rotate around.
	 * @param degrees The angle in degrees
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 rotate (float axisX, float axisY, float axisZ, float degrees) {
<span class="nc bnc" id="L1479" title="All 2 branches missed.">		if (degrees == 0) return this;</span>
<span class="nc" id="L1480">		quat.setFromAxis(axisX, axisY, axisZ, degrees);</span>
<span class="nc" id="L1481">		return rotate(quat);</span>
	}

	/** Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x
	 * glTranslate/glRotate/glScale
	 * @param axisX The x-axis component of the vector to rotate around.
	 * @param axisY The y-axis component of the vector to rotate around.
	 * @param axisZ The z-axis component of the vector to rotate around.
	 * @param radians The angle in radians
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 rotateRad (float axisX, float axisY, float axisZ, float radians) {
<span class="nc bnc" id="L1492" title="All 2 branches missed.">		if (radians == 0) return this;</span>
<span class="nc" id="L1493">		quat.setFromAxisRad(axisX, axisY, axisZ, radians);</span>
<span class="nc" id="L1494">		return rotate(quat);</span>
	}

	/** Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x
	 * glTranslate/glRotate/glScale.
	 * 
	 * @param rotation
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 rotate (Quaternion rotation) {
<span class="nc" id="L1503">		rotation.toMatrix(tmp);</span>
<span class="nc" id="L1504">		mul(val, tmp);</span>
<span class="nc" id="L1505">		return this;</span>
	}

	/** Postmultiplies this matrix by the rotation between two vectors.
	 * @param v1 The base vector
	 * @param v2 The target vector
	 * @return This matrix for the purpose of chaining methods together */
	public Matrix4 rotate (final Vector3 v1, final Vector3 v2) {
<span class="nc" id="L1513">		return rotate(quat.setFromCross(v1, v2));</span>
	}

	/** Postmultiplies this matrix with a scale matrix. Postmultiplication is also used by OpenGL ES' 1.x
	 * glTranslate/glRotate/glScale.
	 * @param scaleX The scale in the x-axis.
	 * @param scaleY The scale in the y-axis.
	 * @param scaleZ The scale in the z-axis.
	 * @return This matrix for the purpose of chaining methods together. */
	public Matrix4 scale (float scaleX, float scaleY, float scaleZ) {
<span class="nc" id="L1523">		tmp[M00] = scaleX;</span>
<span class="nc" id="L1524">		tmp[M01] = 0;</span>
<span class="nc" id="L1525">		tmp[M02] = 0;</span>
<span class="nc" id="L1526">		tmp[M03] = 0;</span>
<span class="nc" id="L1527">		tmp[M10] = 0;</span>
<span class="nc" id="L1528">		tmp[M11] = scaleY;</span>
<span class="nc" id="L1529">		tmp[M12] = 0;</span>
<span class="nc" id="L1530">		tmp[M13] = 0;</span>
<span class="nc" id="L1531">		tmp[M20] = 0;</span>
<span class="nc" id="L1532">		tmp[M21] = 0;</span>
<span class="nc" id="L1533">		tmp[M22] = scaleZ;</span>
<span class="nc" id="L1534">		tmp[M23] = 0;</span>
<span class="nc" id="L1535">		tmp[M30] = 0;</span>
<span class="nc" id="L1536">		tmp[M31] = 0;</span>
<span class="nc" id="L1537">		tmp[M32] = 0;</span>
<span class="nc" id="L1538">		tmp[M33] = 1;</span>

<span class="nc" id="L1540">		mul(val, tmp);</span>
<span class="nc" id="L1541">		return this;</span>
	}

	/** Copies the 4x3 upper-left sub-matrix into float array. The destination array is supposed to be a column major matrix.
	 * @param dst the destination matrix */
	public void extract4x3Matrix (float[] dst) {
<span class="nc" id="L1547">		dst[0] = val[M00];</span>
<span class="nc" id="L1548">		dst[1] = val[M10];</span>
<span class="nc" id="L1549">		dst[2] = val[M20];</span>
<span class="nc" id="L1550">		dst[3] = val[M01];</span>
<span class="nc" id="L1551">		dst[4] = val[M11];</span>
<span class="nc" id="L1552">		dst[5] = val[M21];</span>
<span class="nc" id="L1553">		dst[6] = val[M02];</span>
<span class="nc" id="L1554">		dst[7] = val[M12];</span>
<span class="nc" id="L1555">		dst[8] = val[M22];</span>
<span class="nc" id="L1556">		dst[9] = val[M03];</span>
<span class="nc" id="L1557">		dst[10] = val[M13];</span>
<span class="nc" id="L1558">		dst[11] = val[M23];</span>
<span class="nc" id="L1559">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>