<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BufferUtils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.utils</a> &gt; <span class="el_source">BufferUtils.java</span></div><h1>BufferUtils.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.utils;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.CharBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;

import com.badlogic.gdx.math.Matrix3;
import com.badlogic.gdx.math.Matrix4;

/** Class with static helper methods to increase the speed of array/direct buffer and direct buffer/direct buffer transfers
 * 
 * @author mzechner, xoppa */
<span class="nc" id="L35">public final class BufferUtils {</span>
<span class="nc" id="L36">	static Array&lt;ByteBuffer&gt; unsafeBuffers = new Array&lt;ByteBuffer&gt;();</span>
<span class="nc" id="L37">	static int allocatedUnsafe = 0;</span>

	/** Copies numFloats floats from src starting at offset to dst. Dst is assumed to be a direct {@link Buffer}. The method will
	 * crash if that is not the case. The position and limit of the buffer are ignored, the copy is placed at position 0 in the
	 * buffer. After the copying process the position of the buffer is set to 0 and its limit is set to numFloats * 4 if it is a
	 * ByteBuffer and numFloats if it is a FloatBuffer. In case the Buffer is neither a ByteBuffer nor a FloatBuffer the limit is
	 * not set. This is an expert method, use at your own risk.
	 * 
	 * @param src the source array
	 * @param dst the destination buffer, has to be a direct Buffer
	 * @param numFloats the number of floats to copy
	 * @param offset the offset in src to start copying from */
	public static void copy (float[] src, Buffer dst, int numFloats, int offset) {
<span class="nc bnc" id="L50" title="All 2 branches missed.">		if (dst instanceof ByteBuffer)</span>
<span class="nc" id="L51">			dst.limit(numFloats &lt;&lt; 2);</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">		else if (dst instanceof FloatBuffer) dst.limit(numFloats);</span>

<span class="nc" id="L54">		copyJni(src, dst, numFloats, offset);</span>
<span class="nc" id="L55">		dst.position(0);</span>
<span class="nc" id="L56">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position will stay the same, the limit
	 * will be set to position + numElements. &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is
	 * performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param dst the destination Buffer, its position is used as an offset.
	 * @param numElements the number of elements to copy. */
	public static void copy (byte[] src, int srcOffset, Buffer dst, int numElements) {
<span class="nc" id="L68">		dst.limit(dst.position() + bytesToElements(dst, numElements));</span>
<span class="nc" id="L69">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements);</span>
<span class="nc" id="L70">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position will stay the same, the limit
	 * will be set to position + numElements. &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is
	 * performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param dst the destination Buffer, its position is used as an offset.
	 * @param numElements the number of elements to copy. */
	public static void copy (short[] src, int srcOffset, Buffer dst, int numElements) {
<span class="nc" id="L82">		dst.limit(dst.position() + bytesToElements(dst, numElements &lt;&lt; 1));</span>
<span class="nc" id="L83">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 1);</span>
<span class="nc" id="L84">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position and limit will stay the same.
	 * &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param numElements the number of elements to copy.
	 * @param dst the destination Buffer, its position is used as an offset. */
	public static void copy (char[] src, int srcOffset, int numElements, Buffer dst) {
<span class="nc" id="L95">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 1);</span>
<span class="nc" id="L96">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position and limit will stay the same.
	 * &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param numElements the number of elements to copy.
	 * @param dst the destination Buffer, its position is used as an offset. */
	public static void copy (int[] src, int srcOffset, int numElements, Buffer dst) {
<span class="nc" id="L107">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 2);</span>
<span class="nc" id="L108">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position and limit will stay the same.
	 * &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param numElements the number of elements to copy.
	 * @param dst the destination Buffer, its position is used as an offset. */
	public static void copy (long[] src, int srcOffset, int numElements, Buffer dst) {
<span class="nc" id="L119">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 3);</span>
<span class="nc" id="L120">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position and limit will stay the same.
	 * &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param numElements the number of elements to copy.
	 * @param dst the destination Buffer, its position is used as an offset. */
	public static void copy (float[] src, int srcOffset, int numElements, Buffer dst) {
<span class="nc" id="L131">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 2);</span>
<span class="nc" id="L132">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position and limit will stay the same.
	 * &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param numElements the number of elements to copy.
	 * @param dst the destination Buffer, its position is used as an offset. */
	public static void copy (double[] src, int srcOffset, int numElements, Buffer dst) {
<span class="nc" id="L143">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 3);</span>
<span class="nc" id="L144">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position will stay the same, the limit
	 * will be set to position + numElements. &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is
	 * performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param dst the destination Buffer, its position is used as an offset.
	 * @param numElements the number of elements to copy. */
	public static void copy (char[] src, int srcOffset, Buffer dst, int numElements) {
<span class="nc" id="L156">		dst.limit(dst.position() + bytesToElements(dst, numElements &lt;&lt; 1));</span>
<span class="nc" id="L157">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 1);</span>
<span class="nc" id="L158">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position will stay the same, the limit
	 * will be set to position + numElements. &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is
	 * performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param dst the destination Buffer, its position is used as an offset.
	 * @param numElements the number of elements to copy. */
	public static void copy (int[] src, int srcOffset, Buffer dst, int numElements) {
<span class="nc" id="L170">		dst.limit(dst.position() + bytesToElements(dst, numElements &lt;&lt; 2));</span>
<span class="nc" id="L171">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 2);</span>
<span class="nc" id="L172">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position will stay the same, the limit
	 * will be set to position + numElements. &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is
	 * performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param dst the destination Buffer, its position is used as an offset.
	 * @param numElements the number of elements to copy. */
	public static void copy (long[] src, int srcOffset, Buffer dst, int numElements) {
<span class="nc" id="L184">		dst.limit(dst.position() + bytesToElements(dst, numElements &lt;&lt; 3));</span>
<span class="nc" id="L185">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 3);</span>
<span class="nc" id="L186">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position will stay the same, the limit
	 * will be set to position + numElements. &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is
	 * performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param dst the destination Buffer, its position is used as an offset.
	 * @param numElements the number of elements to copy. */
	public static void copy (float[] src, int srcOffset, Buffer dst, int numElements) {
<span class="nc" id="L198">		dst.limit(dst.position() + bytesToElements(dst, numElements &lt;&lt; 2));</span>
<span class="nc" id="L199">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 2);</span>
<span class="nc" id="L200">	}</span>

	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
	 * {@link Buffer#position()} is used to define the offset into the Buffer itself. The position will stay the same, the limit
	 * will be set to position + numElements. &lt;b&gt;The Buffer must be a direct Buffer with native byte order. No error checking is
	 * performed&lt;/b&gt;.
	 * 
	 * @param src the source array.
	 * @param srcOffset the offset into the source array.
	 * @param dst the destination Buffer, its position is used as an offset.
	 * @param numElements the number of elements to copy. */
	public static void copy (double[] src, int srcOffset, Buffer dst, int numElements) {
<span class="nc" id="L212">		dst.limit(dst.position() + bytesToElements(dst, numElements &lt;&lt; 3));</span>
<span class="nc" id="L213">		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements &lt;&lt; 3);</span>
<span class="nc" id="L214">	}</span>

	/** Copies the contents of src to dst, starting from the current position of src, copying numElements elements (using the data
	 * type of src, no matter the datatype of dst). The dst {@link Buffer#position()} is used as the writing offset. The position
	 * of both Buffers will stay the same. The limit of the src Buffer will stay the same. The limit of the dst Buffer will be set
	 * to dst.position() + numElements, where numElements are translated to the number of elements appropriate for the dst Buffer
	 * data type. &lt;b&gt;The Buffers must be direct Buffers with native byte order. No error checking is performed&lt;/b&gt;.
	 * 
	 * @param src the source Buffer.
	 * @param dst the destination Buffer.
	 * @param numElements the number of elements to copy. */
	public static void copy (Buffer src, Buffer dst, int numElements) {
<span class="nc" id="L226">		int numBytes = elementsToBytes(src, numElements);</span>
<span class="nc" id="L227">		dst.limit(dst.position() + bytesToElements(dst, numBytes));</span>
<span class="nc" id="L228">		copyJni(src, positionInBytes(src), dst, positionInBytes(dst), numBytes);</span>
<span class="nc" id="L229">	}</span>

	/** Multiply float vector components within the buffer with the specified matrix. The {@link Buffer#position()} is used as the
	 * offset.
	 * @param data The buffer to transform.
	 * @param dimensions The number of components of the vector (2 for xy, 3 for xyz or 4 for xyzw)
	 * @param strideInBytes The offset between the first and the second vector to transform
	 * @param count The number of vectors to transform
	 * @param matrix The matrix to multiply the vector with */
	public static void transform (Buffer data, int dimensions, int strideInBytes, int count, Matrix4 matrix) {
<span class="nc" id="L239">		transform(data, dimensions, strideInBytes, count, matrix, 0);</span>
<span class="nc" id="L240">	}</span>

	/** Multiply float vector components within the buffer with the specified matrix. The {@link Buffer#position()} is used as the
	 * offset.
	 * @param data The buffer to transform.
	 * @param dimensions The number of components of the vector (2 for xy, 3 for xyz or 4 for xyzw)
	 * @param strideInBytes The offset between the first and the second vector to transform
	 * @param count The number of vectors to transform
	 * @param matrix The matrix to multiply the vector with */
	public static void transform (float[] data, int dimensions, int strideInBytes, int count, Matrix4 matrix) {
<span class="nc" id="L250">		transform(data, dimensions, strideInBytes, count, matrix, 0);</span>
<span class="nc" id="L251">	}</span>

	/** Multiply float vector components within the buffer with the specified matrix. The specified offset value is added to the
	 * {@link Buffer#position()} and used as the offset.
	 * @param data The buffer to transform.
	 * @param dimensions The number of components of the vector (2 for xy, 3 for xyz or 4 for xyzw)
	 * @param strideInBytes The offset between the first and the second vector to transform
	 * @param count The number of vectors to transform
	 * @param matrix The matrix to multiply the vector with
	 * @param offset The offset within the buffer (in bytes relative to the current position) to the vector */
	public static void transform (Buffer data, int dimensions, int strideInBytes, int count, Matrix4 matrix, int offset) {
<span class="nc bnc" id="L262" title="All 4 branches missed.">		switch (dimensions) {</span>
		case 4:
<span class="nc" id="L264">			transformV4M4Jni(data, strideInBytes, count, matrix.val, positionInBytes(data) + offset);</span>
<span class="nc" id="L265">			break;</span>
		case 3:
<span class="nc" id="L267">			transformV3M4Jni(data, strideInBytes, count, matrix.val, positionInBytes(data) + offset);</span>
<span class="nc" id="L268">			break;</span>
		case 2:
<span class="nc" id="L270">			transformV2M4Jni(data, strideInBytes, count, matrix.val, positionInBytes(data) + offset);</span>
<span class="nc" id="L271">			break;</span>
		default:
<span class="nc" id="L273">			throw new IllegalArgumentException();</span>
		}
<span class="nc" id="L275">	}</span>

	/** Multiply float vector components within the buffer with the specified matrix. The specified offset value is added to the
	 * {@link Buffer#position()} and used as the offset.
	 * @param data The buffer to transform.
	 * @param dimensions The number of components of the vector (2 for xy, 3 for xyz or 4 for xyzw)
	 * @param strideInBytes The offset between the first and the second vector to transform
	 * @param count The number of vectors to transform
	 * @param matrix The matrix to multiply the vector with
	 * @param offset The offset within the buffer (in bytes relative to the current position) to the vector */
	public static void transform (float[] data, int dimensions, int strideInBytes, int count, Matrix4 matrix, int offset) {
<span class="nc bnc" id="L286" title="All 4 branches missed.">		switch (dimensions) {</span>
		case 4:
<span class="nc" id="L288">			transformV4M4Jni(data, strideInBytes, count, matrix.val, offset);</span>
<span class="nc" id="L289">			break;</span>
		case 3:
<span class="nc" id="L291">			transformV3M4Jni(data, strideInBytes, count, matrix.val, offset);</span>
<span class="nc" id="L292">			break;</span>
		case 2:
<span class="nc" id="L294">			transformV2M4Jni(data, strideInBytes, count, matrix.val, offset);</span>
<span class="nc" id="L295">			break;</span>
		default:
<span class="nc" id="L297">			throw new IllegalArgumentException();</span>
		}
<span class="nc" id="L299">	}</span>

	/** Multiply float vector components within the buffer with the specified matrix. The {@link Buffer#position()} is used as the
	 * offset.
	 * @param data The buffer to transform.
	 * @param dimensions The number of components (x, y, z) of the vector (2 for xy or 3 for xyz)
	 * @param strideInBytes The offset between the first and the second vector to transform
	 * @param count The number of vectors to transform
	 * @param matrix The matrix to multiply the vector with */
	public static void transform (Buffer data, int dimensions, int strideInBytes, int count, Matrix3 matrix) {
<span class="nc" id="L309">		transform(data, dimensions, strideInBytes, count, matrix, 0);</span>
<span class="nc" id="L310">	}</span>

	/** Multiply float vector components within the buffer with the specified matrix. The {@link Buffer#position()} is used as the
	 * offset.
	 * @param data The buffer to transform.
	 * @param dimensions The number of components (x, y, z) of the vector (2 for xy or 3 for xyz)
	 * @param strideInBytes The offset between the first and the second vector to transform
	 * @param count The number of vectors to transform
	 * @param matrix The matrix to multiply the vector with */
	public static void transform (float[] data, int dimensions, int strideInBytes, int count, Matrix3 matrix) {
<span class="nc" id="L320">		transform(data, dimensions, strideInBytes, count, matrix, 0);</span>
<span class="nc" id="L321">	}</span>

	/** Multiply float vector components within the buffer with the specified matrix. The specified offset value is added to the
	 * {@link Buffer#position()} and used as the offset.
	 * @param data The buffer to transform.
	 * @param dimensions The number of components (x, y, z) of the vector (2 for xy or 3 for xyz)
	 * @param strideInBytes The offset between the first and the second vector to transform
	 * @param count The number of vectors to transform
	 * @param matrix The matrix to multiply the vector with,
	 * @param offset The offset within the buffer (in bytes relative to the current position) to the vector */
	public static void transform (Buffer data, int dimensions, int strideInBytes, int count, Matrix3 matrix, int offset) {
<span class="nc bnc" id="L332" title="All 3 branches missed.">		switch (dimensions) {</span>
		case 3:
<span class="nc" id="L334">			transformV3M3Jni(data, strideInBytes, count, matrix.val, positionInBytes(data) + offset);</span>
<span class="nc" id="L335">			break;</span>
		case 2:
<span class="nc" id="L337">			transformV2M3Jni(data, strideInBytes, count, matrix.val, positionInBytes(data) + offset);</span>
<span class="nc" id="L338">			break;</span>
		default:
<span class="nc" id="L340">			throw new IllegalArgumentException();</span>
		}
<span class="nc" id="L342">	}</span>

	/** Multiply float vector components within the buffer with the specified matrix. The specified offset value is added to the
	 * {@link Buffer#position()} and used as the offset.
	 * @param data The buffer to transform.
	 * @param dimensions The number of components (x, y, z) of the vector (2 for xy or 3 for xyz)
	 * @param strideInBytes The offset between the first and the second vector to transform
	 * @param count The number of vectors to transform
	 * @param matrix The matrix to multiply the vector with,
	 * @param offset The offset within the buffer (in bytes relative to the current position) to the vector */
	public static void transform (float[] data, int dimensions, int strideInBytes, int count, Matrix3 matrix, int offset) {
<span class="nc bnc" id="L353" title="All 3 branches missed.">		switch (dimensions) {</span>
		case 3:
<span class="nc" id="L355">			transformV3M3Jni(data, strideInBytes, count, matrix.val, offset);</span>
<span class="nc" id="L356">			break;</span>
		case 2:
<span class="nc" id="L358">			transformV2M3Jni(data, strideInBytes, count, matrix.val, offset);</span>
<span class="nc" id="L359">			break;</span>
		default:
<span class="nc" id="L361">			throw new IllegalArgumentException();</span>
		}
<span class="nc" id="L363">	}</span>

	public static long findFloats (Buffer vertex, int strideInBytes, Buffer vertices, int numVertices) {
<span class="nc" id="L366">		return find(vertex, positionInBytes(vertex), strideInBytes, vertices, positionInBytes(vertices), numVertices);</span>
	}

	public static long findFloats (float[] vertex, int strideInBytes, Buffer vertices, int numVertices) {
<span class="nc" id="L370">		return find(vertex, 0, strideInBytes, vertices, positionInBytes(vertices), numVertices);</span>
	}

	public static long findFloats (Buffer vertex, int strideInBytes, float[] vertices, int numVertices) {
<span class="nc" id="L374">		return find(vertex, positionInBytes(vertex), strideInBytes, vertices, 0, numVertices);</span>
	}

	public static long findFloats (float[] vertex, int strideInBytes, float[] vertices, int numVertices) {
<span class="nc" id="L378">		return find(vertex, 0, strideInBytes, vertices, 0, numVertices);</span>
	}

	public static long findFloats (Buffer vertex, int strideInBytes, Buffer vertices, int numVertices, float epsilon) {
<span class="nc" id="L382">		return find(vertex, positionInBytes(vertex), strideInBytes, vertices, positionInBytes(vertices), numVertices, epsilon);</span>
	}

	public static long findFloats (float[] vertex, int strideInBytes, Buffer vertices, int numVertices, float epsilon) {
<span class="nc" id="L386">		return find(vertex, 0, strideInBytes, vertices, positionInBytes(vertices), numVertices, epsilon);</span>
	}

	public static long findFloats (Buffer vertex, int strideInBytes, float[] vertices, int numVertices, float epsilon) {
<span class="nc" id="L390">		return find(vertex, positionInBytes(vertex), strideInBytes, vertices, 0, numVertices, epsilon);</span>
	}

	public static long findFloats (float[] vertex, int strideInBytes, float[] vertices, int numVertices, float epsilon) {
<span class="nc" id="L394">		return find(vertex, 0, strideInBytes, vertices, 0, numVertices, epsilon);</span>
	}

	private static int positionInBytes (Buffer dst) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">		if (dst instanceof ByteBuffer)</span>
<span class="nc" id="L399">			return dst.position();</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">		else if (dst instanceof ShortBuffer)</span>
<span class="nc" id="L401">			return dst.position() &lt;&lt; 1;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">		else if (dst instanceof CharBuffer)</span>
<span class="nc" id="L403">			return dst.position() &lt;&lt; 1;</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">		else if (dst instanceof IntBuffer)</span>
<span class="nc" id="L405">			return dst.position() &lt;&lt; 2;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">		else if (dst instanceof LongBuffer)</span>
<span class="nc" id="L407">			return dst.position() &lt;&lt; 3;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">		else if (dst instanceof FloatBuffer)</span>
<span class="nc" id="L409">			return dst.position() &lt;&lt; 2;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">		else if (dst instanceof DoubleBuffer)</span>
<span class="nc" id="L411">			return dst.position() &lt;&lt; 3;</span>
		else
<span class="nc" id="L413">			throw new GdxRuntimeException(&quot;Can't copy to a &quot; + dst.getClass().getName() + &quot; instance&quot;);</span>
	}

	private static int bytesToElements (Buffer dst, int bytes) {
<span class="nc bnc" id="L417" title="All 2 branches missed.">		if (dst instanceof ByteBuffer)</span>
<span class="nc" id="L418">			return bytes;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">		else if (dst instanceof ShortBuffer)</span>
<span class="nc" id="L420">			return bytes &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">		else if (dst instanceof CharBuffer)</span>
<span class="nc" id="L422">			return bytes &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">		else if (dst instanceof IntBuffer)</span>
<span class="nc" id="L424">			return bytes &gt;&gt;&gt; 2;</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">		else if (dst instanceof LongBuffer)</span>
<span class="nc" id="L426">			return bytes &gt;&gt;&gt; 3;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">		else if (dst instanceof FloatBuffer)</span>
<span class="nc" id="L428">			return bytes &gt;&gt;&gt; 2;</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">		else if (dst instanceof DoubleBuffer)</span>
<span class="nc" id="L430">			return bytes &gt;&gt;&gt; 3;</span>
		else
<span class="nc" id="L432">			throw new GdxRuntimeException(&quot;Can't copy to a &quot; + dst.getClass().getName() + &quot; instance&quot;);</span>
	}

	private static int elementsToBytes (Buffer dst, int elements) {
<span class="nc bnc" id="L436" title="All 2 branches missed.">		if (dst instanceof ByteBuffer)</span>
<span class="nc" id="L437">			return elements;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">		else if (dst instanceof ShortBuffer)</span>
<span class="nc" id="L439">			return elements &lt;&lt; 1;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">		else if (dst instanceof CharBuffer)</span>
<span class="nc" id="L441">			return elements &lt;&lt; 1;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">		else if (dst instanceof IntBuffer)</span>
<span class="nc" id="L443">			return elements &lt;&lt; 2;</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">		else if (dst instanceof LongBuffer)</span>
<span class="nc" id="L445">			return elements &lt;&lt; 3;</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">		else if (dst instanceof FloatBuffer)</span>
<span class="nc" id="L447">			return elements &lt;&lt; 2;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">		else if (dst instanceof DoubleBuffer)</span>
<span class="nc" id="L449">			return elements &lt;&lt; 3;</span>
		else
<span class="nc" id="L451">			throw new GdxRuntimeException(&quot;Can't copy to a &quot; + dst.getClass().getName() + &quot; instance&quot;);</span>
	}

	public static FloatBuffer newFloatBuffer (int numFloats) {
<span class="nc" id="L455">		ByteBuffer buffer = ByteBuffer.allocateDirect(numFloats * 4);</span>
<span class="nc" id="L456">		buffer.order(ByteOrder.nativeOrder());</span>
<span class="nc" id="L457">		return buffer.asFloatBuffer();</span>
	}

	public static DoubleBuffer newDoubleBuffer (int numDoubles) {
<span class="nc" id="L461">		ByteBuffer buffer = ByteBuffer.allocateDirect(numDoubles * 8);</span>
<span class="nc" id="L462">		buffer.order(ByteOrder.nativeOrder());</span>
<span class="nc" id="L463">		return buffer.asDoubleBuffer();</span>
	}

	public static ByteBuffer newByteBuffer (int numBytes) {
<span class="nc" id="L467">		ByteBuffer buffer = ByteBuffer.allocateDirect(numBytes);</span>
<span class="nc" id="L468">		buffer.order(ByteOrder.nativeOrder());</span>
<span class="nc" id="L469">		return buffer;</span>
	}

	public static ShortBuffer newShortBuffer (int numShorts) {
<span class="nc" id="L473">		ByteBuffer buffer = ByteBuffer.allocateDirect(numShorts * 2);</span>
<span class="nc" id="L474">		buffer.order(ByteOrder.nativeOrder());</span>
<span class="nc" id="L475">		return buffer.asShortBuffer();</span>
	}

	public static CharBuffer newCharBuffer (int numChars) {
<span class="nc" id="L479">		ByteBuffer buffer = ByteBuffer.allocateDirect(numChars * 2);</span>
<span class="nc" id="L480">		buffer.order(ByteOrder.nativeOrder());</span>
<span class="nc" id="L481">		return buffer.asCharBuffer();</span>
	}

	public static IntBuffer newIntBuffer (int numInts) {
<span class="nc" id="L485">		ByteBuffer buffer = ByteBuffer.allocateDirect(numInts * 4);</span>
<span class="nc" id="L486">		buffer.order(ByteOrder.nativeOrder());</span>
<span class="nc" id="L487">		return buffer.asIntBuffer();</span>
	}

	public static LongBuffer newLongBuffer (int numLongs) {
<span class="nc" id="L491">		ByteBuffer buffer = ByteBuffer.allocateDirect(numLongs * 8);</span>
<span class="nc" id="L492">		buffer.order(ByteOrder.nativeOrder());</span>
<span class="nc" id="L493">		return buffer.asLongBuffer();</span>
	}

	// @off
	/*JNI 
	#include &lt;stdio.h&gt;
	#include &lt;stdlib.h&gt;
	#include &lt;string.h&gt;
	*/
	
	public static void disposeUnsafeByteBuffer(ByteBuffer buffer) {
<span class="nc" id="L504">		int size = buffer.capacity(); </span>
<span class="nc" id="L505">		synchronized(unsafeBuffers) {</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">			if(!unsafeBuffers.removeValue(buffer, true))</span>
<span class="nc" id="L507">				throw new IllegalArgumentException(&quot;buffer not allocated with newUnsafeByteBuffer or already disposed&quot;);</span>
<span class="nc" id="L508">		}</span>
<span class="nc" id="L509">		allocatedUnsafe -= size;</span>
<span class="nc" id="L510">		freeMemory(buffer);</span>
<span class="nc" id="L511">	}</span>

	/** Allocates a new direct ByteBuffer from native heap memory using the native byte order. Needs to be disposed with
	 * {@link #freeMemory(ByteBuffer)}.
	 * @param numBytes */
	public static ByteBuffer newUnsafeByteBuffer (int numBytes) {
<span class="nc" id="L517">		ByteBuffer buffer = newDisposableByteBuffer(numBytes);</span>
<span class="nc" id="L518">		buffer.order(ByteOrder.nativeOrder());</span>
<span class="nc" id="L519">		allocatedUnsafe += numBytes;</span>
<span class="nc" id="L520">		synchronized(unsafeBuffers) {</span>
<span class="nc" id="L521">			unsafeBuffers.add(buffer);</span>
<span class="nc" id="L522">		}</span>
<span class="nc" id="L523">		return buffer;</span>
	}
	
	/**
	 * Returns the address of the Buffer, it assumes it is an unsafe buffer.
	 * @param buffer The Buffer to ask the address for.
	 * @return the address of the Buffer.
	 */
	public static long getUnsafeBufferAddress(Buffer buffer) {
<span class="nc" id="L532">		return getBufferAddress(buffer) + buffer.position();</span>
	}
	
	/**
	 * Registers the given ByteBuffer as an unsafe ByteBuffer. The ByteBuffer must have been 
	 * allocated in native code, pointing to a memory region allocated via malloc. Needs to 
	 * be disposed with {@link #freeMemory(ByteBuffer)}.
	 * @param buffer the {@link ByteBuffer} to register
	 * @return the ByteBuffer passed to the method
	 */
	public static ByteBuffer newUnsafeByteBuffer(ByteBuffer buffer) {
<span class="nc" id="L543">		allocatedUnsafe += buffer.capacity();</span>
<span class="nc" id="L544">		synchronized(unsafeBuffers) {</span>
<span class="nc" id="L545">			unsafeBuffers.add(buffer);</span>
<span class="nc" id="L546">		}</span>
<span class="nc" id="L547">		return buffer;</span>
	}

	/**
	 * @return the number of bytes allocated with {@link #newUnsafeByteBuffer(int)}
	 */
	public static int getAllocatedBytesUnsafe() {
<span class="nc" id="L554">		return allocatedUnsafe;</span>
	}
	
	/** Frees the memory allocated for the ByteBuffer. DO NOT USE THIS ON BYTEBUFFERS ALLOCATEd VIA METHODS IN THIS CLASS OR
	 * ByteBuffer.allocateDirect()! IT WILL EXPLODE! */
	private static native void freeMemory (ByteBuffer buffer); /*
		free(buffer);
	 */
	
	private static native ByteBuffer newDisposableByteBuffer (int numBytes); /*
		return env-&gt;NewDirectByteBuffer((char*)malloc(numBytes), numBytes);
	*/
	
	private static native long getBufferAddress (Buffer buffer); /*
	    return (jlong) buffer;
	*/
	
	/** Writes the specified number of zeros to the buffer. This is generally faster than reallocating a new buffer. */
	public static native void clear (ByteBuffer buffer, int numBytes); /*
		memset(buffer, 0, numBytes);
	*/
	
	private native static void copyJni (float[] src, Buffer dst, int numFloats, int offset); /*
		memcpy(dst, src + offset, numFloats &lt;&lt; 2 );
	*/

	private native static void copyJni (byte[] src, int srcOffset, Buffer dst, int dstOffset, int numBytes); /*
		memcpy(dst + dstOffset, src + srcOffset, numBytes);
	*/

	private native static void copyJni (char[] src, int srcOffset, Buffer dst, int dstOffset, int numBytes); /*
		memcpy(dst + dstOffset, src + srcOffset, numBytes);
	*/

	private native static void copyJni (short[] src, int srcOffset, Buffer dst, int dstOffset, int numBytes); /*
		memcpy(dst + dstOffset, src + srcOffset, numBytes);
	 */

	private native static void copyJni (int[] src, int srcOffset, Buffer dst, int dstOffset, int numBytes); /*
		memcpy(dst + dstOffset, src + srcOffset, numBytes);
	*/
	
	private native static void copyJni (long[] src, int srcOffset, Buffer dst, int dstOffset, int numBytes); /*
		memcpy(dst + dstOffset, src + srcOffset, numBytes);
	*/

	private native static void copyJni (float[] src, int srcOffset, Buffer dst, int dstOffset, int numBytes); /*
		memcpy(dst + dstOffset, src + srcOffset, numBytes);
	*/
	
	private native static void copyJni (double[] src, int srcOffset, Buffer dst, int dstOffset, int numBytes); /*
		memcpy(dst + dstOffset, src + srcOffset, numBytes);
	*/

	private native static void copyJni (Buffer src, int srcOffset, Buffer dst, int dstOffset, int numBytes); /*
		memcpy(dst + dstOffset, src + srcOffset, numBytes);
	*/
	
	/*JNI
	template&lt;size_t n1, size_t n2&gt; void transform(float * const &amp;src, float * const &amp;m, float * const &amp;dst) {}
	
	template&lt;&gt; inline void transform&lt;4, 4&gt;(float * const &amp;src, float * const &amp;m, float * const &amp;dst) {
		const float x = src[0], y = src[1], z = src[2], w = src[3];
		dst[0] = x * m[ 0] + y * m[ 4] + z * m[ 8] + w * m[12]; 
		dst[1] = x * m[ 1] + y * m[ 5] + z * m[ 9] + w * m[13];
		dst[2] = x * m[ 2] + y * m[ 6] + z * m[10] + w * m[14];
		dst[3] = x * m[ 3] + y * m[ 7] + z * m[11] + w * m[15]; 
	}
	
	template&lt;&gt; inline void transform&lt;3, 4&gt;(float * const &amp;src, float * const &amp;m, float * const &amp;dst) {
		const float x = src[0], y = src[1], z = src[2];
		dst[0] = x * m[ 0] + y * m[ 4] + z * m[ 8] + m[12]; 
		dst[1] = x * m[ 1] + y * m[ 5] + z * m[ 9] + m[13];
		dst[2] = x * m[ 2] + y * m[ 6] + z * m[10] + m[14]; 
	}
	
	template&lt;&gt; inline void transform&lt;2, 4&gt;(float * const &amp;src, float * const &amp;m, float * const &amp;dst) {
		const float x = src[0], y = src[1];
		dst[0] = x * m[ 0] + y * m[ 4] + m[12]; 
		dst[1] = x * m[ 1] + y * m[ 5] + m[13]; 
	}
	
	template&lt;&gt; inline void transform&lt;3, 3&gt;(float * const &amp;src, float * const &amp;m, float * const &amp;dst) {
		const float x = src[0], y = src[1], z = src[2];
		dst[0] = x * m[0] + y * m[3] + z * m[6]; 
		dst[1] = x * m[1] + y * m[4] + z * m[7];
		dst[2] = x * m[2] + y * m[5] + z * m[8]; 
	}
	
	template&lt;&gt; inline void transform&lt;2, 3&gt;(float * const &amp;src, float * const &amp;m, float * const &amp;dst) {
		const float x = src[0], y = src[1];
		dst[0] = x * m[0] + y * m[3] + m[6]; 
		dst[1] = x * m[1] + y * m[4] + m[7]; 
	}
	
	template&lt;size_t n1, size_t n2&gt; void transform(float * const &amp;v, int const &amp;stride, int const &amp;count, float * const &amp;m, int offset) {
		for (int i = 0; i &lt; count; i++) {
			transform&lt;n1, n2&gt;(&amp;v[offset], m, &amp;v[offset]);
			offset += stride;
		}
	}
	
	template&lt;size_t n1, size_t n2&gt; void transform(float * const &amp;v, int const &amp;stride, unsigned short * const &amp;indices, int const &amp;count, float * const &amp;m, int offset) {
		for (int i = 0; i &lt; count; i++) {
			transform&lt;n1, n2&gt;(&amp;v[offset], m, &amp;v[offset]);
			offset += stride;
		}
	}
	
	inline bool compare(float * const &amp;lhs, float * const &amp; rhs, const unsigned int &amp;size, const float &amp;epsilon) {
   	for (unsigned int i = 0; i &lt; size; i++)
   		if ((*(unsigned int*)&amp;lhs[i] != *(unsigned int*)&amp;rhs[i]) &amp;&amp; ((lhs[i] &gt; rhs[i] ? lhs[i] - rhs[i] : rhs[i] - lhs[i]) &gt; epsilon))
         	return false;
		return true;
	}
	
	long find(float * const &amp;vertex, const unsigned int &amp;size, float * const &amp;vertices, const unsigned int &amp;count, const float &amp;epsilon) {
		for (unsigned int i = 0; i &lt; count; i++)
			if (compare(&amp;vertices[i*size], vertex, size, epsilon))
				return (long)i;
		return -1;
	}

	inline bool compare(float * const &amp;lhs, float * const &amp; rhs, const unsigned int &amp;size) {
   	for (unsigned int i = 0; i &lt; size; i++)
      	if ((*(unsigned int*)&amp;lhs[i] != *(unsigned int*)&amp;rhs[i]) &amp;&amp; lhs[i] != rhs[i])
         	return false;
		return true;
	}
	
	long find(float * const &amp;vertex, const unsigned int &amp;size, float * const &amp;vertices, const unsigned int &amp;count) {
		for (unsigned int i = 0; i &lt; count; i++)
			if (compare(&amp;vertices[i*size], vertex, size))
				return (long)i;
		return -1;
	}

	inline unsigned int calcHash(float * const &amp;vertex, const unsigned int &amp;size) {
		unsigned int result = 0;
		for (unsigned int i = 0; i &lt; size; ++i)
			result += ((*((unsigned int *)&amp;vertex[i])) &amp; 0xffffff80) &gt;&gt; (i &amp; 0x7);
		return result &amp; 0x7fffffff;
	}
	
	long find(float * const &amp;vertex, const unsigned int &amp;size, float * const &amp;vertices, unsigned int * const &amp;hashes, const unsigned int &amp;count) {
		const unsigned int hash = calcHash(vertex, size);
		for (unsigned int i = 0; i &lt; count; i++)
			if (hashes[i] == hash &amp;&amp; compare(&amp;vertices[i*size], vertex, size))
				return (long)i;
		return -1;
	}
	*/
	
	private native static void transformV4M4Jni (Buffer data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
		transform&lt;4, 4&gt;((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);  
	*/
	
	private native static void transformV4M4Jni (float[] data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
		transform&lt;4, 4&gt;((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);  
	*/
	
	private native static void transformV3M4Jni (Buffer data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
		transform&lt;3, 4&gt;((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
	*/
	
	private native static void transformV3M4Jni (float[] data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
		transform&lt;3, 4&gt;((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
	*/
	
	private native static void transformV2M4Jni (Buffer data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
		transform&lt;2, 4&gt;((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
	*/
	
	private native static void transformV2M4Jni (float[] data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
		transform&lt;2, 4&gt;((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
	*/

	private native static void transformV3M3Jni (Buffer data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
		transform&lt;3, 3&gt;((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
	*/
	
	private native static void transformV3M3Jni (float[] data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
		transform&lt;3, 3&gt;((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
	*/
	
	private native static void transformV2M3Jni (Buffer data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
		transform&lt;2, 3&gt;((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
	*/
	
	private native static void transformV2M3Jni (float[] data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
		transform&lt;2, 3&gt;((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
	*/
	
	private native static long find(Buffer vertex, int vertexOffsetInBytes, int strideInBytes, Buffer vertices, int verticesOffsetInBytes, int numVertices); /*
		return find((float *)&amp;vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&amp;vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
	*/
	
	private native static long find(float[] vertex, int vertexOffsetInBytes, int strideInBytes, Buffer vertices, int verticesOffsetInBytes, int numVertices); /*
		return find((float *)&amp;vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&amp;vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
	*/
	
	private native static long find(Buffer vertex, int vertexOffsetInBytes, int strideInBytes, float[] vertices, int verticesOffsetInBytes, int numVertices); /*
		return find((float *)&amp;vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&amp;vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
	*/
	
	private native static long find(float[] vertex, int vertexOffsetInBytes, int strideInBytes, float[] vertices, int verticesOffsetInBytes, int numVertices); /*
		return find((float *)&amp;vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&amp;vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
	*/
	
	private native static long find(Buffer vertex, int vertexOffsetInBytes, int strideInBytes, Buffer vertices, int verticesOffsetInBytes, int numVertices, float epsilon); /*
		return find((float *)&amp;vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&amp;vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
	*/
	
	private native static long find(float[] vertex, int vertexOffsetInBytes, int strideInBytes, Buffer vertices, int verticesOffsetInBytes, int numVertices, float epsilon); /*
		return find((float *)&amp;vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&amp;vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
	*/
	
	private native static long find(Buffer vertex, int vertexOffsetInBytes, int strideInBytes, float[] vertices, int verticesOffsetInBytes, int numVertices, float epsilon); /*
		return find((float *)&amp;vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&amp;vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
	*/
	
	private native static long find(float[] vertex, int vertexOffsetInBytes, int strideInBytes, float[] vertices, int verticesOffsetInBytes, int numVertices, float epsilon); /*
		return find((float *)&amp;vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&amp;vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
	*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>