<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimSort.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.utils</a> &gt; <span class="el_source">TimSort.java</span></div><h1>TimSort.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2008 The Android Open Source Project
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot;
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

package com.badlogic.gdx.utils;

import java.util.Arrays;
import java.util.Comparator;

/** A stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when running on partially sorted
 * arrays, while offering performance comparable to a traditional mergesort when run on random arrays. Like all proper mergesorts,
 * this sort is stable and runs O(n log n) time (worst case). In the worst case, this sort requires temporary storage space for
 * n/2 object references; in the best case, it requires only a small constant amount of space.
 * 
 * This implementation was adapted from Tim Peters's list sort for Python, which is described in detail here:
 * 
 * http://svn.python.org/projects/python/trunk/Objects/listsort.txt
 * 
 * Tim's C code may be found here:
 * 
 * http://svn.python.org/projects/python/trunk/Objects/listobject.c
 * 
 * The underlying techniques are described in this paper (and may have even earlier origins):
 * 
 * &quot;Optimistic Sorting and Information Theoretic Complexity&quot; Peter McIlroy SODA (Fourth Annual ACM-SIAM Symposium on Discrete
 * Algorithms), pp 467-474, Austin, Texas, 25-27 January 1993.
 * 
 * While the API to this class consists solely of static methods, it is (privately) instantiable; a TimSort instance holds the
 * state of an ongoing sort, assuming the input array is large enough to warrant the full-blown TimSort. Small arrays are sorted
 * in place, using a binary insertion sort. */
class TimSort&lt;T&gt; {
	/** This is the minimum sized sequence that will be merged. Shorter sequences will be lengthened by calling binarySort. If the
	 * entire array is less than this length, no merges will be performed.
	 * 
	 * This constant should be a power of two. It was 64 in Tim Peter's C implementation, but 32 was empirically determined to work
	 * better in this implementation. In the unlikely event that you set this constant to be a number that's not a power of two,
	 * you'll need to change the {@link #minRunLength} computation.
	 * 
	 * If you decrease this constant, you must change the stackLen computation in the TimSort constructor, or you risk an
	 * ArrayOutOfBounds exception. See listsort.txt for a discussion of the minimum stack length required as a function of the
	 * length of the array being sorted and the minimum merge sequence length. */
	private static final int MIN_MERGE = 32;

	/** The array being sorted. */
	private T[] a;

	/** The comparator for this sort. */
	private Comparator&lt;? super T&gt; c;

	/** When we get into galloping mode, we stay there until both runs win less often than MIN_GALLOP consecutive times. */
	private static final int MIN_GALLOP = 7;

	/** This controls when we get *into* galloping mode. It is initialized to MIN_GALLOP. The mergeLo and mergeHi methods nudge it
	 * higher for random data, and lower for highly structured data. */
<span class="nc" id="L64">	private int minGallop = MIN_GALLOP;</span>

	/** Maximum initial size of tmp array, which is used for merging. The array can grow to accommodate demand.
	 * 
	 * Unlike Tim's original C version, we do not allocate this much storage when sorting smaller arrays. This change was required
	 * for performance. */
	private static final int INITIAL_TMP_STORAGE_LENGTH = 256;

	/** Temp storage for merges. */
	private T[] tmp; // Actual runtime type will be Object[], regardless of T
	private int tmpCount;

	/** A stack of pending runs yet to be merged. Run i starts at address base[i] and extends for len[i] elements. It's always true
	 * (so long as the indices are in bounds) that:
	 * 
	 * runBase[i] + runLen[i] == runBase[i + 1]
	 * 
	 * so we could cut the storage for this, but it's a minor amount, and keeping all the info explicit simplifies the code. */
<span class="nc" id="L82">	private int stackSize = 0; // Number of pending runs on stack</span>
	private final int[] runBase;
	private final int[] runLen;

	/** Asserts have been placed in if-statements for performance. To enable them, set this field to true and enable them in VM with
	 * a command line flag. If you modify this class, please do test the asserts! */
	private static final boolean DEBUG = false;

<span class="nc" id="L90">	TimSort () {</span>
<span class="nc" id="L91">		tmp = (T[])new Object[INITIAL_TMP_STORAGE_LENGTH];</span>
<span class="nc" id="L92">		runBase = new int[40];</span>
<span class="nc" id="L93">		runLen = new int[40];</span>
<span class="nc" id="L94">	}</span>

	public void doSort (T[] a, Comparator&lt;T&gt; c, int lo, int hi) {
<span class="nc" id="L97">		stackSize = 0;</span>
<span class="nc" id="L98">		rangeCheck(a.length, lo, hi);</span>
<span class="nc" id="L99">		int nRemaining = hi - lo;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">		if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted</span>

		// If array is small, do a &quot;mini-TimSort&quot; with no merges
<span class="nc bnc" id="L103" title="All 2 branches missed.">		if (nRemaining &lt; MIN_MERGE) {</span>
<span class="nc" id="L104">			int initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span>
<span class="nc" id="L105">			binarySort(a, lo, hi, lo + initRunLen, c);</span>
<span class="nc" id="L106">			return;</span>
		}

<span class="nc" id="L109">		this.a = a;</span>
<span class="nc" id="L110">		this.c = c;</span>
<span class="nc" id="L111">		tmpCount = 0;</span>

		/** March over the array once, left to right, finding natural runs, extending short natural runs to minRun elements, and
		 * merging runs to maintain stack invariant. */
<span class="nc" id="L115">		int minRun = minRunLength(nRemaining);</span>
		do {
			// Identify next run
<span class="nc" id="L118">			int runLen = countRunAndMakeAscending(a, lo, hi, c);</span>

			// If run is short, extend to min(minRun, nRemaining)
<span class="nc bnc" id="L121" title="All 2 branches missed.">			if (runLen &lt; minRun) {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">				int force = nRemaining &lt;= minRun ? nRemaining : minRun;</span>
<span class="nc" id="L123">				binarySort(a, lo, lo + force, lo + runLen, c);</span>
<span class="nc" id="L124">				runLen = force;</span>
			}

			// Push run onto pending-run stack, and maybe merge
<span class="nc" id="L128">			pushRun(lo, runLen);</span>
<span class="nc" id="L129">			mergeCollapse();</span>

			// Advance to find next run
<span class="nc" id="L132">			lo += runLen;</span>
<span class="nc" id="L133">			nRemaining -= runLen;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">		} while (nRemaining != 0);</span>

		// Merge all remaining runs to complete sort
		if (DEBUG) assert lo == hi;
<span class="nc" id="L138">		mergeForceCollapse();</span>
		if (DEBUG) assert stackSize == 1;

<span class="nc" id="L141">		this.a = null;</span>
<span class="nc" id="L142">		this.c = null;</span>
<span class="nc" id="L143">		T[] tmp = this.tmp;</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">		for (int i = 0, n = tmpCount; i &lt; n; i++)</span>
<span class="nc" id="L145">			tmp[i] = null;</span>
<span class="nc" id="L146">	}</span>

	/** Creates a TimSort instance to maintain the state of an ongoing sort.
	 * 
	 * @param a the array to be sorted
	 * @param c the comparator to determine the order of the sort */
<span class="nc" id="L152">	private TimSort (T[] a, Comparator&lt;? super T&gt; c) {</span>
<span class="nc" id="L153">		this.a = a;</span>
<span class="nc" id="L154">		this.c = c;</span>

		// Allocate temp storage (which may be increased later if necessary)
<span class="nc" id="L157">		int len = a.length;</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">		T[] newArray = (T[])new Object[len &lt; 2 * INITIAL_TMP_STORAGE_LENGTH ? len &gt;&gt;&gt; 1 : INITIAL_TMP_STORAGE_LENGTH];</span>
<span class="nc" id="L159">		tmp = newArray;</span>

		/*
		 * Allocate runs-to-be-merged stack (which cannot be expanded). The stack length requirements are described in listsort.txt.
		 * The C version always uses the same stack length (85), but this was measured to be too expensive when sorting &quot;mid-sized&quot;
		 * arrays (e.g., 100 elements) in Java. Therefore, we use smaller (but sufficiently large) stack lengths for smaller arrays.
		 * The &quot;magic numbers&quot; in the computation below must be changed if MIN_MERGE is decreased. See the MIN_MERGE declaration
		 * above for more information.
		 */
<span class="nc bnc" id="L168" title="All 6 branches missed.">		int stackLen = (len &lt; 120 ? 5 : len &lt; 1542 ? 10 : len &lt; 119151 ? 19 : 40);</span>
<span class="nc" id="L169">		runBase = new int[stackLen];</span>
<span class="nc" id="L170">		runLen = new int[stackLen];</span>
<span class="nc" id="L171">	}</span>

	/*
	 * The next two methods (which are package private and static) constitute the entire API of this class. Each of these methods
	 * obeys the contract of the public method with the same signature in java.util.Arrays.
	 */

	static &lt;T&gt; void sort (T[] a, Comparator&lt;? super T&gt; c) {
<span class="nc" id="L179">		sort(a, 0, a.length, c);</span>
<span class="nc" id="L180">	}</span>

	static &lt;T&gt; void sort (T[] a, int lo, int hi, Comparator&lt;? super T&gt; c) {
<span class="nc bnc" id="L183" title="All 2 branches missed.">		if (c == null) {</span>
<span class="nc" id="L184">			Arrays.sort(a, lo, hi);</span>
<span class="nc" id="L185">			return;</span>
		}

<span class="nc" id="L188">		rangeCheck(a.length, lo, hi);</span>
<span class="nc" id="L189">		int nRemaining = hi - lo;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">		if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted</span>

		// If array is small, do a &quot;mini-TimSort&quot; with no merges
<span class="nc bnc" id="L193" title="All 2 branches missed.">		if (nRemaining &lt; MIN_MERGE) {</span>
<span class="nc" id="L194">			int initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span>
<span class="nc" id="L195">			binarySort(a, lo, hi, lo + initRunLen, c);</span>
<span class="nc" id="L196">			return;</span>
		}

		/** March over the array once, left to right, finding natural runs, extending short natural runs to minRun elements, and
		 * merging runs to maintain stack invariant. */
<span class="nc" id="L201">		TimSort&lt;T&gt; ts = new TimSort&lt;T&gt;(a, c);</span>
<span class="nc" id="L202">		int minRun = minRunLength(nRemaining);</span>
		do {
			// Identify next run
<span class="nc" id="L205">			int runLen = countRunAndMakeAscending(a, lo, hi, c);</span>

			// If run is short, extend to min(minRun, nRemaining)
<span class="nc bnc" id="L208" title="All 2 branches missed.">			if (runLen &lt; minRun) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">				int force = nRemaining &lt;= minRun ? nRemaining : minRun;</span>
<span class="nc" id="L210">				binarySort(a, lo, lo + force, lo + runLen, c);</span>
<span class="nc" id="L211">				runLen = force;</span>
			}

			// Push run onto pending-run stack, and maybe merge
<span class="nc" id="L215">			ts.pushRun(lo, runLen);</span>
<span class="nc" id="L216">			ts.mergeCollapse();</span>

			// Advance to find next run
<span class="nc" id="L219">			lo += runLen;</span>
<span class="nc" id="L220">			nRemaining -= runLen;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">		} while (nRemaining != 0);</span>

		// Merge all remaining runs to complete sort
		if (DEBUG) assert lo == hi;
<span class="nc" id="L225">		ts.mergeForceCollapse();</span>
		if (DEBUG) assert ts.stackSize == 1;
<span class="nc" id="L227">	}</span>

	/** Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for sorting small
	 * numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
	 * 
	 * If the initial part of the specified range is already sorted, this method can take advantage of it: the method assumes that
	 * the elements from index {@code lo}, inclusive, to {@code start}, exclusive are already sorted.
	 * 
	 * @param a the array in which a range is to be sorted
	 * @param lo the index of the first element in the range to be sorted
	 * @param hi the index after the last element in the range to be sorted
	 * @param start the index of the first element in the range that is not already known to be sorted (@code lo &lt;= start &lt;= hi}
	 * @param c comparator to used for the sort */
	@SuppressWarnings(&quot;fallthrough&quot;)
	private static &lt;T&gt; void binarySort (T[] a, int lo, int hi, int start, Comparator&lt;? super T&gt; c) {
		if (DEBUG) assert lo &lt;= start &amp;&amp; start &lt;= hi;
<span class="nc bnc" id="L243" title="All 2 branches missed.">		if (start == lo) start++;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">		for (; start &lt; hi; start++) {</span>
<span class="nc" id="L245">			T pivot = a[start];</span>

			// Set left (and right) to the index where a[start] (pivot) belongs
<span class="nc" id="L248">			int left = lo;</span>
<span class="nc" id="L249">			int right = start;</span>
			if (DEBUG) assert left &lt;= right;
			/*
			 * Invariants: pivot &gt;= all in [lo, left). pivot &lt; all in [right, start).
			 */
<span class="nc bnc" id="L254" title="All 2 branches missed.">			while (left &lt; right) {</span>
<span class="nc" id="L255">				int mid = (left + right) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">				if (c.compare(pivot, a[mid]) &lt; 0)</span>
<span class="nc" id="L257">					right = mid;</span>
				else
<span class="nc" id="L259">					left = mid + 1;</span>
<span class="nc" id="L260">			}</span>
			if (DEBUG) assert left == right;

			/*
			 * The invariants still hold: pivot &gt;= all in [lo, left) and pivot &lt; all in [left, start), so pivot belongs at left. Note
			 * that if there are elements equal to pivot, left points to the first slot after them -- that's why this sort is stable.
			 * Slide elements over to make room for pivot.
			 */
<span class="nc" id="L268">			int n = start - left; // The number of elements to move</span>
			// Switch is just an optimization for arraycopy in default case
<span class="nc bnc" id="L270" title="All 3 branches missed.">			switch (n) {</span>
			case 2:
<span class="nc" id="L272">				a[left + 2] = a[left + 1];</span>
			case 1:
<span class="nc" id="L274">				a[left + 1] = a[left];</span>
<span class="nc" id="L275">				break;</span>
			default:
<span class="nc" id="L277">				System.arraycopy(a, left, a, left + 1, n);</span>
			}
<span class="nc" id="L279">			a[left] = pivot;</span>
		}
<span class="nc" id="L281">	}</span>

	/** Returns the length of the run beginning at the specified position in the specified array and reverses the run if it is
	 * descending (ensuring that the run will always be ascending when the method returns).
	 * 
	 * A run is the longest ascending sequence with:
	 * 
	 * a[lo] &lt;= a[lo + 1] &lt;= a[lo + 2] &lt;= ...
	 * 
	 * or the longest descending sequence with:
	 * 
	 * a[lo] &gt; a[lo + 1] &gt; a[lo + 2] &gt; ...
	 * 
	 * For its intended use in a stable mergesort, the strictness of the definition of &quot;descending&quot; is needed so that the call can
	 * safely reverse a descending sequence without violating stability.
	 * 
	 * @param a the array in which a run is to be counted and possibly reversed
	 * @param lo index of the first element in the run
	 * @param hi index after the last element that may be contained in the run. It is required that @code{lo &lt; hi}.
	 * @param c the comparator to used for the sort
	 * @return the length of the run beginning at the specified position in the specified array */
	private static &lt;T&gt; int countRunAndMakeAscending (T[] a, int lo, int hi, Comparator&lt;? super T&gt; c) {
		if (DEBUG) assert lo &lt; hi;
<span class="nc" id="L304">		int runHi = lo + 1;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">		if (runHi == hi) return 1;</span>

		// Find end of run, and reverse range if descending
<span class="nc bnc" id="L308" title="All 2 branches missed.">		if (c.compare(a[runHi++], a[lo]) &lt; 0) { // Descending</span>
<span class="nc bnc" id="L309" title="All 4 branches missed.">			while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &lt; 0)</span>
<span class="nc" id="L310">				runHi++;</span>
<span class="nc" id="L311">			reverseRange(a, lo, runHi);</span>
		} else { // Ascending
<span class="nc bnc" id="L313" title="All 4 branches missed.">			while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &gt;= 0)</span>
<span class="nc" id="L314">				runHi++;</span>
		}

<span class="nc" id="L317">		return runHi - lo;</span>
	}

	/** Reverse the specified range of the specified array.
	 * 
	 * @param a the array in which a range is to be reversed
	 * @param lo the index of the first element in the range to be reversed
	 * @param hi the index after the last element in the range to be reversed */
	private static void reverseRange (Object[] a, int lo, int hi) {
<span class="nc" id="L326">		hi--;</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">		while (lo &lt; hi) {</span>
<span class="nc" id="L328">			Object t = a[lo];</span>
<span class="nc" id="L329">			a[lo++] = a[hi];</span>
<span class="nc" id="L330">			a[hi--] = t;</span>
<span class="nc" id="L331">		}</span>
<span class="nc" id="L332">	}</span>

	/** Returns the minimum acceptable run length for an array of the specified length. Natural runs shorter than this will be
	 * extended with {@link #binarySort}.
	 * 
	 * Roughly speaking, the computation is:
	 * 
	 * If n &lt; MIN_MERGE, return n (it's too small to bother with fancy stuff). Else if n is an exact power of 2, return
	 * MIN_MERGE/2. Else return an int k, MIN_MERGE/2 &lt;= k &lt;= MIN_MERGE, such that n/k is close to, but strictly less than, an
	 * exact power of 2.
	 * 
	 * For the rationale, see listsort.txt.
	 * 
	 * @param n the length of the array to be sorted
	 * @return the length of the minimum run to be merged */
	private static int minRunLength (int n) {
		if (DEBUG) assert n &gt;= 0;
<span class="nc" id="L349">		int r = 0; // Becomes 1 if any 1 bits are shifted off</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">		while (n &gt;= MIN_MERGE) {</span>
<span class="nc" id="L351">			r |= (n &amp; 1);</span>
<span class="nc" id="L352">			n &gt;&gt;= 1;</span>
		}
<span class="nc" id="L354">		return n + r;</span>
	}

	/** Pushes the specified run onto the pending-run stack.
	 * 
	 * @param runBase index of the first element in the run
	 * @param runLen the number of elements in the run */
	private void pushRun (int runBase, int runLen) {
<span class="nc" id="L362">		this.runBase[stackSize] = runBase;</span>
<span class="nc" id="L363">		this.runLen[stackSize] = runLen;</span>
<span class="nc" id="L364">		stackSize++;</span>
<span class="nc" id="L365">	}</span>

	/** Examines the stack of runs waiting to be merged and merges adjacent runs until the stack invariants are reestablished:
	 * 
	 * 1. runLen[n - 2] &gt; runLen[n - 1] + runLen[n] 2. runLen[n - 1] &gt; runLen[n]
	 * 
	 * where n is the index of the last run in runLen.
	 * 
	 * This method has been formally verified to be correct after checking the last 4 runs.
	 * Checking for 3 runs results in an exception for large arrays.
	 * (Source: http://envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/)
	 * 
	 * This method is called each time a new run is pushed onto the stack, so the invariants are guaranteed to hold for i &lt;
	 * stackSize upon entry to the method. */
	private void mergeCollapse () {
<span class="nc bnc" id="L380" title="All 2 branches missed.">		while (stackSize &gt; 1) {</span>
<span class="nc" id="L381">			int n = stackSize - 2;</span>
<span class="nc bnc" id="L382" title="All 8 branches missed.">			if ((n &gt;= 1 &amp;&amp; runLen[n - 1] &lt;= runLen[n] + runLen[n + 1]) || (n &gt;= 2 &amp;&amp; runLen[n - 2] &lt;= runLen[n] + runLen[n - 1])) {</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">				if (runLen[n - 1] &lt; runLen[n + 1]) n--;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">			} else if (runLen[n] &gt; runLen[n + 1]) {</span>
<span class="nc" id="L385">				break; // Invariant is established</span>
			}
<span class="nc" id="L387">			mergeAt(n);</span>
<span class="nc" id="L388">		}</span>
<span class="nc" id="L389">	}</span>

	/** Merges all runs on the stack until only one remains. This method is called once, to complete the sort. */
	private void mergeForceCollapse () {
<span class="nc bnc" id="L393" title="All 2 branches missed.">		while (stackSize &gt; 1) {</span>
<span class="nc" id="L394">			int n = stackSize - 2;</span>
<span class="nc bnc" id="L395" title="All 4 branches missed.">			if (n &gt; 0 &amp;&amp; runLen[n - 1] &lt; runLen[n + 1]) n--;</span>
<span class="nc" id="L396">			mergeAt(n);</span>
<span class="nc" id="L397">		}</span>
<span class="nc" id="L398">	}</span>

	/** Merges the two runs at stack indices i and i+1. Run i must be the penultimate or antepenultimate run on the stack. In other
	 * words, i must be equal to stackSize-2 or stackSize-3.
	 * 
	 * @param i stack index of the first of the two runs to merge */
	private void mergeAt (int i) {
		if (DEBUG) assert stackSize &gt;= 2;
		if (DEBUG) assert i &gt;= 0;
		if (DEBUG) assert i == stackSize - 2 || i == stackSize - 3;

<span class="nc" id="L409">		int base1 = runBase[i];</span>
<span class="nc" id="L410">		int len1 = runLen[i];</span>
<span class="nc" id="L411">		int base2 = runBase[i + 1];</span>
<span class="nc" id="L412">		int len2 = runLen[i + 1];</span>
		if (DEBUG) assert len1 &gt; 0 &amp;&amp; len2 &gt; 0;
		if (DEBUG) assert base1 + len1 == base2;

		/*
		 * Record the length of the combined runs; if i is the 3rd-last run now, also slide over the last run (which isn't involved
		 * in this merge). The current run (i+1) goes away in any case.
		 */
<span class="nc" id="L420">		runLen[i] = len1 + len2;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">		if (i == stackSize - 3) {</span>
<span class="nc" id="L422">			runBase[i + 1] = runBase[i + 2];</span>
<span class="nc" id="L423">			runLen[i + 1] = runLen[i + 2];</span>
		}
<span class="nc" id="L425">		stackSize--;</span>

		/*
		 * Find where the first element of run2 goes in run1. Prior elements in run1 can be ignored (because they're already in
		 * place).
		 */
<span class="nc" id="L431">		int k = gallopRight(a[base2], a, base1, len1, 0, c);</span>
		if (DEBUG) assert k &gt;= 0;
<span class="nc" id="L433">		base1 += k;</span>
<span class="nc" id="L434">		len1 -= k;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">		if (len1 == 0) return;</span>

		/*
		 * Find where the last element of run1 goes in run2. Subsequent elements in run2 can be ignored (because they're already in
		 * place).
		 */
<span class="nc" id="L441">		len2 = gallopLeft(a[base1 + len1 - 1], a, base2, len2, len2 - 1, c);</span>
		if (DEBUG) assert len2 &gt;= 0;
<span class="nc bnc" id="L443" title="All 2 branches missed.">		if (len2 == 0) return;</span>

		// Merge remaining runs, using tmp array with min(len1, len2) elements
<span class="nc bnc" id="L446" title="All 2 branches missed.">		if (len1 &lt;= len2)</span>
<span class="nc" id="L447">			mergeLo(base1, len1, base2, len2);</span>
		else
<span class="nc" id="L449">			mergeHi(base1, len1, base2, len2);</span>
<span class="nc" id="L450">	}</span>

	/** Locates the position at which to insert the specified key into the specified sorted range; if the range contains an element
	 * equal to key, returns the index of the leftmost equal element.
	 * 
	 * @param key the key whose insertion point to search for
	 * @param a the array in which to search
	 * @param base the index of the first element in the range
	 * @param len the length of the range; must be &gt; 0
	 * @param hint the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, the faster this method
	 *           will run.
	 * @param c the comparator used to order the range, and to search
	 * @return the int k, 0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] is minus infinity and a[b
	 *         + n] is infinity. In other words, key belongs at index b + k; or in other words, the first k elements of a should
	 *         precede key, and the last n - k should follow it. */
	private static &lt;T&gt; int gallopLeft (T key, T[] a, int base, int len, int hint, Comparator&lt;? super T&gt; c) {
		if (DEBUG) assert len &gt; 0 &amp;&amp; hint &gt;= 0 &amp;&amp; hint &lt; len;
<span class="nc" id="L467">		int lastOfs = 0;</span>
<span class="nc" id="L468">		int ofs = 1;</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">		if (c.compare(key, a[base + hint]) &gt; 0) {</span>
			// Gallop right until a[base+hint+lastOfs] &lt; key &lt;= a[base+hint+ofs]
<span class="nc" id="L471">			int maxOfs = len - hint;</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">			while (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint + ofs]) &gt; 0) {</span>
<span class="nc" id="L473">				lastOfs = ofs;</span>
<span class="nc" id="L474">				ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">				if (ofs &lt;= 0) // int overflow</span>
<span class="nc" id="L476">					ofs = maxOfs;</span>
			}
<span class="nc bnc" id="L478" title="All 2 branches missed.">			if (ofs &gt; maxOfs) ofs = maxOfs;</span>

			// Make offsets relative to base
<span class="nc" id="L481">			lastOfs += hint;</span>
<span class="nc" id="L482">			ofs += hint;</span>
<span class="nc" id="L483">		} else { // key &lt;= a[base + hint]</span>
			// Gallop left until a[base+hint-ofs] &lt; key &lt;= a[base+hint-lastOfs]
<span class="nc" id="L485">			final int maxOfs = hint + 1;</span>
<span class="nc bnc" id="L486" title="All 4 branches missed.">			while (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint - ofs]) &lt;= 0) {</span>
<span class="nc" id="L487">				lastOfs = ofs;</span>
<span class="nc" id="L488">				ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">				if (ofs &lt;= 0) // int overflow</span>
<span class="nc" id="L490">					ofs = maxOfs;</span>
			}
<span class="nc bnc" id="L492" title="All 2 branches missed.">			if (ofs &gt; maxOfs) ofs = maxOfs;</span>

			// Make offsets relative to base
<span class="nc" id="L495">			int tmp = lastOfs;</span>
<span class="nc" id="L496">			lastOfs = hint - ofs;</span>
<span class="nc" id="L497">			ofs = hint - tmp;</span>
		}
		if (DEBUG) assert -1 &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;

		/*
		 * Now a[base+lastOfs] &lt; key &lt;= a[base+ofs], so key belongs somewhere to the right of lastOfs but no farther right than ofs.
		 * Do a binary search, with invariant a[base + lastOfs - 1] &lt; key &lt;= a[base + ofs].
		 */
<span class="nc" id="L505">		lastOfs++;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">		while (lastOfs &lt; ofs) {</span>
<span class="nc" id="L507">			int m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; 1);</span>

<span class="nc bnc" id="L509" title="All 2 branches missed.">			if (c.compare(key, a[base + m]) &gt; 0)</span>
<span class="nc" id="L510">				lastOfs = m + 1; // a[base + m] &lt; key</span>
			else
<span class="nc" id="L512">				ofs = m; // key &lt;= a[base + m]</span>
<span class="nc" id="L513">		}</span>
		if (DEBUG) assert lastOfs == ofs; // so a[base + ofs - 1] &lt; key &lt;= a[base + ofs]
<span class="nc" id="L515">		return ofs;</span>
	}

	/** Like gallopLeft, except that if the range contains an element equal to key, gallopRight returns the index after the
	 * rightmost equal element.
	 * 
	 * @param key the key whose insertion point to search for
	 * @param a the array in which to search
	 * @param base the index of the first element in the range
	 * @param len the length of the range; must be &gt; 0
	 * @param hint the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, the faster this method
	 *           will run.
	 * @param c the comparator used to order the range, and to search
	 * @return the int k, 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k] */
	private static &lt;T&gt; int gallopRight (T key, T[] a, int base, int len, int hint, Comparator&lt;? super T&gt; c) {
		if (DEBUG) assert len &gt; 0 &amp;&amp; hint &gt;= 0 &amp;&amp; hint &lt; len;

<span class="nc" id="L532">		int ofs = 1;</span>
<span class="nc" id="L533">		int lastOfs = 0;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">		if (c.compare(key, a[base + hint]) &lt; 0) {</span>
			// Gallop left until a[b+hint - ofs] &lt;= key &lt; a[b+hint - lastOfs]
<span class="nc" id="L536">			int maxOfs = hint + 1;</span>
<span class="nc bnc" id="L537" title="All 4 branches missed.">			while (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint - ofs]) &lt; 0) {</span>
<span class="nc" id="L538">				lastOfs = ofs;</span>
<span class="nc" id="L539">				ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">				if (ofs &lt;= 0) // int overflow</span>
<span class="nc" id="L541">					ofs = maxOfs;</span>
			}
<span class="nc bnc" id="L543" title="All 2 branches missed.">			if (ofs &gt; maxOfs) ofs = maxOfs;</span>

			// Make offsets relative to b
<span class="nc" id="L546">			int tmp = lastOfs;</span>
<span class="nc" id="L547">			lastOfs = hint - ofs;</span>
<span class="nc" id="L548">			ofs = hint - tmp;</span>
<span class="nc" id="L549">		} else { // a[b + hint] &lt;= key</span>
			// Gallop right until a[b+hint + lastOfs] &lt;= key &lt; a[b+hint + ofs]
<span class="nc" id="L551">			int maxOfs = len - hint;</span>
<span class="nc bnc" id="L552" title="All 4 branches missed.">			while (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint + ofs]) &gt;= 0) {</span>
<span class="nc" id="L553">				lastOfs = ofs;</span>
<span class="nc" id="L554">				ofs = (ofs &lt;&lt; 1) + 1;</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">				if (ofs &lt;= 0) // int overflow</span>
<span class="nc" id="L556">					ofs = maxOfs;</span>
			}
<span class="nc bnc" id="L558" title="All 2 branches missed.">			if (ofs &gt; maxOfs) ofs = maxOfs;</span>

			// Make offsets relative to b
<span class="nc" id="L561">			lastOfs += hint;</span>
<span class="nc" id="L562">			ofs += hint;</span>
		}
		if (DEBUG) assert -1 &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;

		/*
		 * Now a[b + lastOfs] &lt;= key &lt; a[b + ofs], so key belongs somewhere to the right of lastOfs but no farther right than ofs.
		 * Do a binary search, with invariant a[b + lastOfs - 1] &lt;= key &lt; a[b + ofs].
		 */
<span class="nc" id="L570">		lastOfs++;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">		while (lastOfs &lt; ofs) {</span>
<span class="nc" id="L572">			int m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; 1);</span>

<span class="nc bnc" id="L574" title="All 2 branches missed.">			if (c.compare(key, a[base + m]) &lt; 0)</span>
<span class="nc" id="L575">				ofs = m; // key &lt; a[b + m]</span>
			else
<span class="nc" id="L577">				lastOfs = m + 1; // a[b + m] &lt;= key</span>
<span class="nc" id="L578">		}</span>
		if (DEBUG) assert lastOfs == ofs; // so a[b + ofs - 1] &lt;= key &lt; a[b + ofs]
<span class="nc" id="L580">		return ofs;</span>
	}

	/** Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than the first
	 * element of the second run (a[base1] &gt; a[base2]), and the last element of the first run (a[base1 + len1-1]) must be greater
	 * than all elements of the second run.
	 * 
	 * For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if len1 &gt;= len2.
	 * (Either method may be called if len1 == len2.)
	 * 
	 * @param base1 index of first element in first run to be merged
	 * @param len1 length of first run to be merged (must be &gt; 0)
	 * @param base2 index of first element in second run to be merged (must be aBase + aLen)
	 * @param len2 length of second run to be merged (must be &gt; 0) */
	private void mergeLo (int base1, int len1, int base2, int len2) {
		if (DEBUG) assert len1 &gt; 0 &amp;&amp; len2 &gt; 0 &amp;&amp; base1 + len1 == base2;

		// Copy first run into temp array
<span class="nc" id="L598">		T[] a = this.a; // For performance</span>
<span class="nc" id="L599">		T[] tmp = ensureCapacity(len1);</span>
<span class="nc" id="L600">		System.arraycopy(a, base1, tmp, 0, len1);</span>

<span class="nc" id="L602">		int cursor1 = 0; // Indexes into tmp array</span>
<span class="nc" id="L603">		int cursor2 = base2; // Indexes int a</span>
<span class="nc" id="L604">		int dest = base1; // Indexes int a</span>

		// Move first element of second run and deal with degenerate cases
<span class="nc" id="L607">		a[dest++] = a[cursor2++];</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">		if (--len2 == 0) {</span>
<span class="nc" id="L609">			System.arraycopy(tmp, cursor1, a, dest, len1);</span>
<span class="nc" id="L610">			return;</span>
		}
<span class="nc bnc" id="L612" title="All 2 branches missed.">		if (len1 == 1) {</span>
<span class="nc" id="L613">			System.arraycopy(a, cursor2, a, dest, len2);</span>
<span class="nc" id="L614">			a[dest + len2] = tmp[cursor1]; // Last elt of run 1 to end of merge</span>
<span class="nc" id="L615">			return;</span>
		}

<span class="nc" id="L618">		Comparator&lt;? super T&gt; c = this.c; // Use local variable for performance</span>
<span class="nc" id="L619">		int minGallop = this.minGallop; // &quot;    &quot; &quot;     &quot; &quot;</span>
		outer:
		while (true) {
<span class="nc" id="L622">			int count1 = 0; // Number of times in a row that first run won</span>
<span class="nc" id="L623">			int count2 = 0; // Number of times in a row that second run won</span>

			/*
			 * Do the straightforward thing until (if ever) one run starts winning consistently.
			 */
			do {
				if (DEBUG) assert len1 &gt; 1 &amp;&amp; len2 &gt; 0;
<span class="nc bnc" id="L630" title="All 2 branches missed.">				if (c.compare(a[cursor2], tmp[cursor1]) &lt; 0) {</span>
<span class="nc" id="L631">					a[dest++] = a[cursor2++];</span>
<span class="nc" id="L632">					count2++;</span>
<span class="nc" id="L633">					count1 = 0;</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">					if (--len2 == 0) break outer;</span>
				} else {
<span class="nc" id="L636">					a[dest++] = tmp[cursor1++];</span>
<span class="nc" id="L637">					count1++;</span>
<span class="nc" id="L638">					count2 = 0;</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">					if (--len1 == 1) break outer;</span>
				}
<span class="nc bnc" id="L641" title="All 2 branches missed.">			} while ((count1 | count2) &lt; minGallop);</span>

			/*
			 * One run is winning so consistently that galloping may be a huge win. So try that, and continue galloping until (if
			 * ever) neither run appears to be winning consistently anymore.
			 */
			do {
				if (DEBUG) assert len1 &gt; 1 &amp;&amp; len2 &gt; 0;
<span class="nc" id="L649">				count1 = gallopRight(a[cursor2], tmp, cursor1, len1, 0, c);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">				if (count1 != 0) {</span>
<span class="nc" id="L651">					System.arraycopy(tmp, cursor1, a, dest, count1);</span>
<span class="nc" id="L652">					dest += count1;</span>
<span class="nc" id="L653">					cursor1 += count1;</span>
<span class="nc" id="L654">					len1 -= count1;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">					if (len1 &lt;= 1) // len1 == 1 || len1 == 0</span>
<span class="nc" id="L656">						break outer;</span>
				}
<span class="nc" id="L658">				a[dest++] = a[cursor2++];</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">				if (--len2 == 0) break outer;</span>

<span class="nc" id="L661">				count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, 0, c);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">				if (count2 != 0) {</span>
<span class="nc" id="L663">					System.arraycopy(a, cursor2, a, dest, count2);</span>
<span class="nc" id="L664">					dest += count2;</span>
<span class="nc" id="L665">					cursor2 += count2;</span>
<span class="nc" id="L666">					len2 -= count2;</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">					if (len2 == 0) break outer;</span>
				}
<span class="nc" id="L669">				a[dest++] = tmp[cursor1++];</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">				if (--len1 == 1) break outer;</span>
<span class="nc" id="L671">				minGallop--;</span>
<span class="nc bnc" id="L672" title="All 6 branches missed.">			} while (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">			if (minGallop &lt; 0) minGallop = 0;</span>
<span class="nc" id="L674">			minGallop += 2; // Penalize for leaving gallop mode</span>
<span class="nc" id="L675">		} // End of &quot;outer&quot; loop</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">		this.minGallop = minGallop &lt; 1 ? 1 : minGallop; // Write back to field</span>

<span class="nc bnc" id="L678" title="All 2 branches missed.">		if (len1 == 1) {</span>
			if (DEBUG) assert len2 &gt; 0;
<span class="nc" id="L680">			System.arraycopy(a, cursor2, a, dest, len2);</span>
<span class="nc" id="L681">			a[dest + len2] = tmp[cursor1]; // Last elt of run 1 to end of merge</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">		} else if (len1 == 0) {</span>
<span class="nc" id="L683">			throw new IllegalArgumentException(&quot;Comparison method violates its general contract!&quot;);</span>
		} else {
			if (DEBUG) assert len2 == 0;
			if (DEBUG) assert len1 &gt; 1;
<span class="nc" id="L687">			System.arraycopy(tmp, cursor1, a, dest, len1);</span>
		}
<span class="nc" id="L689">	}</span>

	/** Like mergeLo, except that this method should be called only if len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2.
	 * (Either method may be called if len1 == len2.)
	 * 
	 * @param base1 index of first element in first run to be merged
	 * @param len1 length of first run to be merged (must be &gt; 0)
	 * @param base2 index of first element in second run to be merged (must be aBase + aLen)
	 * @param len2 length of second run to be merged (must be &gt; 0) */
	private void mergeHi (int base1, int len1, int base2, int len2) {
		if (DEBUG) assert len1 &gt; 0 &amp;&amp; len2 &gt; 0 &amp;&amp; base1 + len1 == base2;

		// Copy second run into temp array
<span class="nc" id="L702">		T[] a = this.a; // For performance</span>
<span class="nc" id="L703">		T[] tmp = ensureCapacity(len2);</span>
<span class="nc" id="L704">		System.arraycopy(a, base2, tmp, 0, len2);</span>

<span class="nc" id="L706">		int cursor1 = base1 + len1 - 1; // Indexes into a</span>
<span class="nc" id="L707">		int cursor2 = len2 - 1; // Indexes into tmp array</span>
<span class="nc" id="L708">		int dest = base2 + len2 - 1; // Indexes into a</span>

		// Move last element of first run and deal with degenerate cases
<span class="nc" id="L711">		a[dest--] = a[cursor1--];</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">		if (--len1 == 0) {</span>
<span class="nc" id="L713">			System.arraycopy(tmp, 0, a, dest - (len2 - 1), len2);</span>
<span class="nc" id="L714">			return;</span>
		}
<span class="nc bnc" id="L716" title="All 2 branches missed.">		if (len2 == 1) {</span>
<span class="nc" id="L717">			dest -= len1;</span>
<span class="nc" id="L718">			cursor1 -= len1;</span>
<span class="nc" id="L719">			System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);</span>
<span class="nc" id="L720">			a[dest] = tmp[cursor2];</span>
<span class="nc" id="L721">			return;</span>
		}

<span class="nc" id="L724">		Comparator&lt;? super T&gt; c = this.c; // Use local variable for performance</span>
<span class="nc" id="L725">		int minGallop = this.minGallop; // &quot;    &quot; &quot;     &quot; &quot;</span>
		outer:
		while (true) {
<span class="nc" id="L728">			int count1 = 0; // Number of times in a row that first run won</span>
<span class="nc" id="L729">			int count2 = 0; // Number of times in a row that second run won</span>

			/*
			 * Do the straightforward thing until (if ever) one run appears to win consistently.
			 */
			do {
				if (DEBUG) assert len1 &gt; 0 &amp;&amp; len2 &gt; 1;
<span class="nc bnc" id="L736" title="All 2 branches missed.">				if (c.compare(tmp[cursor2], a[cursor1]) &lt; 0) {</span>
<span class="nc" id="L737">					a[dest--] = a[cursor1--];</span>
<span class="nc" id="L738">					count1++;</span>
<span class="nc" id="L739">					count2 = 0;</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">					if (--len1 == 0) break outer;</span>
				} else {
<span class="nc" id="L742">					a[dest--] = tmp[cursor2--];</span>
<span class="nc" id="L743">					count2++;</span>
<span class="nc" id="L744">					count1 = 0;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">					if (--len2 == 1) break outer;</span>
				}
<span class="nc bnc" id="L747" title="All 2 branches missed.">			} while ((count1 | count2) &lt; minGallop);</span>

			/*
			 * One run is winning so consistently that galloping may be a huge win. So try that, and continue galloping until (if
			 * ever) neither run appears to be winning consistently anymore.
			 */
			do {
				if (DEBUG) assert len1 &gt; 0 &amp;&amp; len2 &gt; 1;
<span class="nc" id="L755">				count1 = len1 - gallopRight(tmp[cursor2], a, base1, len1, len1 - 1, c);</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">				if (count1 != 0) {</span>
<span class="nc" id="L757">					dest -= count1;</span>
<span class="nc" id="L758">					cursor1 -= count1;</span>
<span class="nc" id="L759">					len1 -= count1;</span>
<span class="nc" id="L760">					System.arraycopy(a, cursor1 + 1, a, dest + 1, count1);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">					if (len1 == 0) break outer;</span>
				}
<span class="nc" id="L763">				a[dest--] = tmp[cursor2--];</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">				if (--len2 == 1) break outer;</span>

<span class="nc" id="L766">				count2 = len2 - gallopLeft(a[cursor1], tmp, 0, len2, len2 - 1, c);</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">				if (count2 != 0) {</span>
<span class="nc" id="L768">					dest -= count2;</span>
<span class="nc" id="L769">					cursor2 -= count2;</span>
<span class="nc" id="L770">					len2 -= count2;</span>
<span class="nc" id="L771">					System.arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">					if (len2 &lt;= 1) // len2 == 1 || len2 == 0</span>
<span class="nc" id="L773">						break outer;</span>
				}
<span class="nc" id="L775">				a[dest--] = a[cursor1--];</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">				if (--len1 == 0) break outer;</span>
<span class="nc" id="L777">				minGallop--;</span>
<span class="nc bnc" id="L778" title="All 6 branches missed.">			} while (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">			if (minGallop &lt; 0) minGallop = 0;</span>
<span class="nc" id="L780">			minGallop += 2; // Penalize for leaving gallop mode</span>
<span class="nc" id="L781">		} // End of &quot;outer&quot; loop</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">		this.minGallop = minGallop &lt; 1 ? 1 : minGallop; // Write back to field</span>

<span class="nc bnc" id="L784" title="All 2 branches missed.">		if (len2 == 1) {</span>
			if (DEBUG) assert len1 &gt; 0;
<span class="nc" id="L786">			dest -= len1;</span>
<span class="nc" id="L787">			cursor1 -= len1;</span>
<span class="nc" id="L788">			System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);</span>
<span class="nc" id="L789">			a[dest] = tmp[cursor2]; // Move first elt of run2 to front of merge</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">		} else if (len2 == 0) {</span>
<span class="nc" id="L791">			throw new IllegalArgumentException(&quot;Comparison method violates its general contract!&quot;);</span>
		} else {
			if (DEBUG) assert len1 == 0;
			if (DEBUG) assert len2 &gt; 0;
<span class="nc" id="L795">			System.arraycopy(tmp, 0, a, dest - (len2 - 1), len2);</span>
		}
<span class="nc" id="L797">	}</span>

	/** Ensures that the external array tmp has at least the specified number of elements, increasing its size if necessary. The
	 * size increases exponentially to ensure amortized linear time complexity.
	 * 
	 * @param minCapacity the minimum required capacity of the tmp array
	 * @return tmp, whether or not it grew */
	private T[] ensureCapacity (int minCapacity) {
<span class="nc" id="L805">		tmpCount = Math.max(tmpCount, minCapacity);</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">		if (tmp.length &lt; minCapacity) {</span>
			// Compute smallest power of 2 &gt; minCapacity
<span class="nc" id="L808">			int newSize = minCapacity;</span>
<span class="nc" id="L809">			newSize |= newSize &gt;&gt; 1;</span>
<span class="nc" id="L810">			newSize |= newSize &gt;&gt; 2;</span>
<span class="nc" id="L811">			newSize |= newSize &gt;&gt; 4;</span>
<span class="nc" id="L812">			newSize |= newSize &gt;&gt; 8;</span>
<span class="nc" id="L813">			newSize |= newSize &gt;&gt; 16;</span>
<span class="nc" id="L814">			newSize++;</span>

<span class="nc bnc" id="L816" title="All 2 branches missed.">			if (newSize &lt; 0) // Not bloody likely!</span>
<span class="nc" id="L817">				newSize = minCapacity;</span>
			else
<span class="nc" id="L819">				newSize = Math.min(newSize, a.length &gt;&gt;&gt; 1);</span>

<span class="nc" id="L821">			T[] newArray = (T[])new Object[newSize];</span>
<span class="nc" id="L822">			tmp = newArray;</span>
		}
<span class="nc" id="L824">		return tmp;</span>
	}

	/** Checks that fromIndex and toIndex are in range, and throws an appropriate exception if they aren't.
	 * 
	 * @param arrayLen the length of the array
	 * @param fromIndex the index of the first element of the range
	 * @param toIndex the index after the last element of the range
	 * @throws IllegalArgumentException if fromIndex &gt; toIndex
	 * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0 or toIndex &gt; arrayLen */
	private static void rangeCheck (int arrayLen, int fromIndex, int toIndex) {
<span class="nc bnc" id="L835" title="All 2 branches missed.">		if (fromIndex &gt; toIndex) throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">		if (fromIndex &lt; 0) throw new ArrayIndexOutOfBoundsException(fromIndex);</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">		if (toIndex &gt; arrayLen) throw new ArrayIndexOutOfBoundsException(toIndex);</span>
<span class="nc" id="L838">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>