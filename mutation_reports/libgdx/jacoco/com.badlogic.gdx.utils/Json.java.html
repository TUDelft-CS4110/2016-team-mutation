<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Json.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.utils</a> &gt; <span class="el_source">Json.java</span></div><h1>Json.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.utils;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringWriter;
import java.io.Writer;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.utils.JsonValue.PrettyPrintSettings;
import com.badlogic.gdx.utils.JsonWriter.OutputType;
import com.badlogic.gdx.utils.ObjectMap.Entry;
import com.badlogic.gdx.utils.OrderedMap.OrderedMapValues;
import com.badlogic.gdx.utils.reflect.ArrayReflection;
import com.badlogic.gdx.utils.reflect.ClassReflection;
import com.badlogic.gdx.utils.reflect.Constructor;
import com.badlogic.gdx.utils.reflect.Field;
import com.badlogic.gdx.utils.reflect.ReflectionException;

/** Reads/writes Java objects to/from JSON, automatically. See the wiki for usage:
 * https://github.com/libgdx/libgdx/wiki/Reading-%26-writing-JSON
 * @author Nathan Sweet */
public class Json {
	static private final boolean debug = false;

	private JsonWriter writer;
<span class="nc" id="L50">	private String typeName = &quot;class&quot;;</span>
<span class="nc" id="L51">	private boolean usePrototypes = true;</span>
	private OutputType outputType;
	private boolean quoteLongValues;
	private boolean ignoreUnknownFields;
<span class="nc" id="L55">	private boolean enumNames = true;</span>
	private Serializer defaultSerializer;
<span class="nc" id="L57">	private final ObjectMap&lt;Class, OrderedMap&lt;String, FieldMetadata&gt;&gt; typeToFields = new ObjectMap();</span>
<span class="nc" id="L58">	private final ObjectMap&lt;String, Class&gt; tagToClass = new ObjectMap();</span>
<span class="nc" id="L59">	private final ObjectMap&lt;Class, String&gt; classToTag = new ObjectMap();</span>
<span class="nc" id="L60">	private final ObjectMap&lt;Class, Serializer&gt; classToSerializer = new ObjectMap();</span>
<span class="nc" id="L61">	private final ObjectMap&lt;Class, Object[]&gt; classToDefaultValues = new ObjectMap();</span>
<span class="nc" id="L62">	private final Object[] equals1 = {null}, equals2 = {null};</span>

<span class="nc" id="L64">	public Json () {</span>
<span class="nc" id="L65">		outputType = OutputType.minimal;</span>
<span class="nc" id="L66">	}</span>

<span class="nc" id="L68">	public Json (OutputType outputType) {</span>
<span class="nc" id="L69">		this.outputType = outputType;</span>
<span class="nc" id="L70">	}</span>

	/** When true, fields in the JSON that are not found on the class will not throw a {@link SerializationException}. Default is
	 * false. */
	public void setIgnoreUnknownFields (boolean ignoreUnknownFields) {
<span class="nc" id="L75">		this.ignoreUnknownFields = ignoreUnknownFields;</span>
<span class="nc" id="L76">	}</span>

	/** @see JsonWriter#setOutputType(OutputType) */
	public void setOutputType (OutputType outputType) {
<span class="nc" id="L80">		this.outputType = outputType;</span>
<span class="nc" id="L81">	}</span>

	/** @see JsonWriter#setQuoteLongValues(boolean) */
	public void setQuoteLongValues (boolean quoteLongValues) {
<span class="nc" id="L85">		this.quoteLongValues = quoteLongValues;</span>
<span class="nc" id="L86">	}</span>

	/** When true, {@link Enum#name()} is used to write enum values. When false, {@link Enum#toString()} is used which may not be
	 * unique. Default is true. */
	public void setEnumNames (boolean enumNames) {
<span class="nc" id="L91">		this.enumNames = enumNames;</span>
<span class="nc" id="L92">	}</span>

	/** Sets a tag to use instead of the fully qualifier class name. This can make the JSON easier to read. */
	public void addClassTag (String tag, Class type) {
<span class="nc" id="L96">		tagToClass.put(tag, type);</span>
<span class="nc" id="L97">		classToTag.put(type, tag);</span>
<span class="nc" id="L98">	}</span>

	/** Returns the class for the specified tag, or null. */
	public Class getClass (String tag) {
<span class="nc" id="L102">		return tagToClass.get(tag);</span>
	}

	/** Returns the tag for the specified class, or null. */
	public String getTag (Class type) {
<span class="nc" id="L107">		return classToTag.get(type);</span>
	}

	/** Sets the name of the JSON field to store the Java class name or class tag when required to avoid ambiguity during
	 * deserialization. Set to null to never output this information, but be warned that deserialization may fail. Default is
	 * &quot;class&quot;. */
	public void setTypeName (String typeName) {
<span class="nc" id="L114">		this.typeName = typeName;</span>
<span class="nc" id="L115">	}</span>

	/** Sets the serializer to use when the type being deserialized is not known (null).
	 * @param defaultSerializer May be null. */
	public void setDefaultSerializer (Serializer defaultSerializer) {
<span class="nc" id="L120">		this.defaultSerializer = defaultSerializer;</span>
<span class="nc" id="L121">	}</span>

	/** Registers a serializer to use for the specified type instead of the default behavior of serializing all of an objects
	 * fields. */
	public &lt;T&gt; void setSerializer (Class&lt;T&gt; type, Serializer&lt;T&gt; serializer) {
<span class="nc" id="L126">		classToSerializer.put(type, serializer);</span>
<span class="nc" id="L127">	}</span>

	public &lt;T&gt; Serializer&lt;T&gt; getSerializer (Class&lt;T&gt; type) {
<span class="nc" id="L130">		return classToSerializer.get(type);</span>
	}

	/** When true, field values that are identical to a newly constructed instance are not written. Default is true. */
	public void setUsePrototypes (boolean usePrototypes) {
<span class="nc" id="L135">		this.usePrototypes = usePrototypes;</span>
<span class="nc" id="L136">	}</span>

	/** Sets the type of elements in a collection. When the element type is known, the class for each element in the collection
	 * does not need to be written unless different from the element type. */
	public void setElementType (Class type, String fieldName, Class elementType) {
<span class="nc" id="L141">		ObjectMap&lt;String, FieldMetadata&gt; fields = getFields(type);</span>
<span class="nc" id="L142">		FieldMetadata metadata = fields.get(fieldName);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">		if (metadata == null) throw new SerializationException(&quot;Field not found: &quot; + fieldName + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L144">		metadata.elementType = elementType;</span>
<span class="nc" id="L145">	}</span>

	private OrderedMap&lt;String, FieldMetadata&gt; getFields (Class type) {
<span class="nc" id="L148">		OrderedMap&lt;String, FieldMetadata&gt; fields = typeToFields.get(type);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">		if (fields != null) return fields;</span>

<span class="nc" id="L151">		Array&lt;Class&gt; classHierarchy = new Array();</span>
<span class="nc" id="L152">		Class nextClass = type;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">		while (nextClass != Object.class) {</span>
<span class="nc" id="L154">			classHierarchy.add(nextClass);</span>
<span class="nc" id="L155">			nextClass = nextClass.getSuperclass();</span>
		}
<span class="nc" id="L157">		ArrayList&lt;Field&gt; allFields = new ArrayList();</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">		for (int i = classHierarchy.size - 1; i &gt;= 0; i--)</span>
<span class="nc" id="L159">			Collections.addAll(allFields, ClassReflection.getDeclaredFields(classHierarchy.get(i)));</span>

<span class="nc" id="L161">		OrderedMap&lt;String, FieldMetadata&gt; nameToField = new OrderedMap(allFields.size());</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">		for (int i = 0, n = allFields.size(); i &lt; n; i++) {</span>
<span class="nc" id="L163">			Field field = allFields.get(i);</span>

<span class="nc bnc" id="L165" title="All 2 branches missed.">			if (field.isTransient()) continue;</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">			if (field.isStatic()) continue;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">			if (field.isSynthetic()) continue;</span>

<span class="nc bnc" id="L169" title="All 2 branches missed.">			if (!field.isAccessible()) {</span>
				try {
<span class="nc" id="L171">					field.setAccessible(true);</span>
<span class="nc" id="L172">				} catch (AccessControlException ex) {</span>
<span class="nc" id="L173">					continue;</span>
<span class="nc" id="L174">				}</span>
			}

<span class="nc" id="L177">			nameToField.put(field.getName(), new FieldMetadata(field));</span>
		}
<span class="nc" id="L179">		typeToFields.put(type, nameToField);</span>
<span class="nc" id="L180">		return nameToField;</span>
	}

	public String toJson (Object object) {
<span class="nc bnc" id="L184" title="All 2 branches missed.">		return toJson(object, object == null ? null : object.getClass(), (Class)null);</span>
	}

	public String toJson (Object object, Class knownType) {
<span class="nc" id="L188">		return toJson(object, knownType, (Class)null);</span>
	}

	/** @param knownType May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown. */
	public String toJson (Object object, Class knownType, Class elementType) {
<span class="nc" id="L194">		StringWriter buffer = new StringWriter();</span>
<span class="nc" id="L195">		toJson(object, knownType, elementType, buffer);</span>
<span class="nc" id="L196">		return buffer.toString();</span>
	}

	public void toJson (Object object, FileHandle file) {
<span class="nc bnc" id="L200" title="All 2 branches missed.">		toJson(object, object == null ? null : object.getClass(), null, file);</span>
<span class="nc" id="L201">	}</span>

	/** @param knownType May be null if the type is unknown. */
	public void toJson (Object object, Class knownType, FileHandle file) {
<span class="nc" id="L205">		toJson(object, knownType, null, file);</span>
<span class="nc" id="L206">	}</span>

	/** @param knownType May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown. */
	public void toJson (Object object, Class knownType, Class elementType, FileHandle file) {
<span class="nc" id="L211">		Writer writer = null;</span>
		try {
<span class="nc" id="L213">			writer = file.writer(false, &quot;UTF-8&quot;);</span>
<span class="nc" id="L214">			toJson(object, knownType, elementType, writer);</span>
<span class="nc" id="L215">		} catch (Exception ex) {</span>
<span class="nc" id="L216">			throw new SerializationException(&quot;Error writing file: &quot; + file, ex);</span>
		} finally {
<span class="nc" id="L218">			StreamUtils.closeQuietly(writer);</span>
<span class="nc" id="L219">		}</span>
<span class="nc" id="L220">	}</span>

	public void toJson (Object object, Writer writer) {
<span class="nc bnc" id="L223" title="All 2 branches missed.">		toJson(object, object == null ? null : object.getClass(), null, writer);</span>
<span class="nc" id="L224">	}</span>

	/** @param knownType May be null if the type is unknown. */
	public void toJson (Object object, Class knownType, Writer writer) {
<span class="nc" id="L228">		toJson(object, knownType, null, writer);</span>
<span class="nc" id="L229">	}</span>

	/** @param knownType May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown. */
	public void toJson (Object object, Class knownType, Class elementType, Writer writer) {
<span class="nc" id="L234">		setWriter(writer);</span>
		try {
<span class="nc" id="L236">			writeValue(object, knownType, elementType);</span>
		} finally {
<span class="nc" id="L238">			StreamUtils.closeQuietly(this.writer);</span>
<span class="nc" id="L239">			this.writer = null;</span>
<span class="nc" id="L240">		}</span>
<span class="nc" id="L241">	}</span>

	/** Sets the writer where JSON output will be written. This is only necessary when not using the toJson methods. */
	public void setWriter (Writer writer) {
<span class="nc bnc" id="L245" title="All 2 branches missed.">		if (!(writer instanceof JsonWriter)) writer = new JsonWriter(writer);</span>
<span class="nc" id="L246">		this.writer = (JsonWriter)writer;</span>
<span class="nc" id="L247">		this.writer.setOutputType(outputType);</span>
<span class="nc" id="L248">		this.writer.setQuoteLongValues(quoteLongValues);</span>
<span class="nc" id="L249">	}</span>

	public JsonWriter getWriter () {
<span class="nc" id="L252">		return writer;</span>
	}

	/** Writes all fields of the specified object to the current JSON object. */
	public void writeFields (Object object) {
<span class="nc" id="L257">		Class type = object.getClass();</span>

<span class="nc" id="L259">		Object[] defaultValues = getDefaultValues(type);</span>

<span class="nc" id="L261">		OrderedMap&lt;String, FieldMetadata&gt; fields = getFields(type);</span>
<span class="nc" id="L262">		int i = 0;</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">		for (FieldMetadata metadata : new OrderedMapValues&lt;FieldMetadata&gt;(fields)) {</span>
<span class="nc" id="L264">			Field field = metadata.field;</span>
			try {
<span class="nc" id="L266">				Object value = field.get(object);</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">				if (defaultValues != null) {</span>
<span class="nc" id="L268">					Object defaultValue = defaultValues[i++];</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">					if (value == null &amp;&amp; defaultValue == null) continue;</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">					if (value != null &amp;&amp; defaultValue != null) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">						if (value.equals(defaultValue)) continue;</span>
<span class="nc bnc" id="L272" title="All 4 branches missed.">						if (value.getClass().isArray() &amp;&amp; defaultValue.getClass().isArray()) {</span>
<span class="nc" id="L273">							equals1[0] = value;</span>
<span class="nc" id="L274">							equals2[0] = defaultValue;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">							if (Arrays.deepEquals(equals1, equals2)) continue;</span>
						}
					}
				}

				if (debug) System.out.println(&quot;Writing field: &quot; + field.getName() + &quot; (&quot; + type.getName() + &quot;)&quot;);
<span class="nc" id="L281">				writer.name(field.getName());</span>
<span class="nc" id="L282">				writeValue(value, field.getType(), metadata.elementType);</span>
<span class="nc" id="L283">			} catch (ReflectionException ex) {</span>
<span class="nc" id="L284">				throw new SerializationException(&quot;Error accessing field: &quot; + field.getName() + &quot; (&quot; + type.getName() + &quot;)&quot;, ex);</span>
<span class="nc" id="L285">			} catch (SerializationException ex) {</span>
<span class="nc" id="L286">				ex.addTrace(field + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L287">				throw ex;</span>
<span class="nc" id="L288">			} catch (Exception runtimeEx) {</span>
<span class="nc" id="L289">				SerializationException ex = new SerializationException(runtimeEx);</span>
<span class="nc" id="L290">				ex.addTrace(field + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L291">				throw ex;</span>
<span class="nc" id="L292">			}</span>
<span class="nc" id="L293">		}</span>
<span class="nc" id="L294">	}</span>

	private Object[] getDefaultValues (Class type) {
<span class="nc bnc" id="L297" title="All 2 branches missed.">		if (!usePrototypes) return null;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">		if (classToDefaultValues.containsKey(type)) return classToDefaultValues.get(type);</span>
		Object object;
		try {
<span class="nc" id="L301">			object = newInstance(type);</span>
<span class="nc" id="L302">		} catch (Exception ex) {</span>
<span class="nc" id="L303">			classToDefaultValues.put(type, null);</span>
<span class="nc" id="L304">			return null;</span>
<span class="nc" id="L305">		}</span>

<span class="nc" id="L307">		ObjectMap&lt;String, FieldMetadata&gt; fields = getFields(type);</span>
<span class="nc" id="L308">		Object[] values = new Object[fields.size];</span>
<span class="nc" id="L309">		classToDefaultValues.put(type, values);</span>

<span class="nc" id="L311">		int i = 0;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">		for (FieldMetadata metadata : fields.values()) {</span>
<span class="nc" id="L313">			Field field = metadata.field;</span>
			try {
<span class="nc" id="L315">				values[i++] = field.get(object);</span>
<span class="nc" id="L316">			} catch (ReflectionException ex) {</span>
<span class="nc" id="L317">				throw new SerializationException(&quot;Error accessing field: &quot; + field.getName() + &quot; (&quot; + type.getName() + &quot;)&quot;, ex);</span>
<span class="nc" id="L318">			} catch (SerializationException ex) {</span>
<span class="nc" id="L319">				ex.addTrace(field + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L320">				throw ex;</span>
<span class="nc" id="L321">			} catch (RuntimeException runtimeEx) {</span>
<span class="nc" id="L322">				SerializationException ex = new SerializationException(runtimeEx);</span>
<span class="nc" id="L323">				ex.addTrace(field + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L324">				throw ex;</span>
<span class="nc" id="L325">			}</span>
<span class="nc" id="L326">		}</span>
<span class="nc" id="L327">		return values;</span>
	}

	/** @see #writeField(Object, String, String, Class) */
	public void writeField (Object object, String name) {
<span class="nc" id="L332">		writeField(object, name, name, null);</span>
<span class="nc" id="L333">	}</span>

	/** @param elementType May be null if the type is unknown.
	 * @see #writeField(Object, String, String, Class) */
	public void writeField (Object object, String name, Class elementType) {
<span class="nc" id="L338">		writeField(object, name, name, elementType);</span>
<span class="nc" id="L339">	}</span>

	/** @see #writeField(Object, String, String, Class) */
	public void writeField (Object object, String fieldName, String jsonName) {
<span class="nc" id="L343">		writeField(object, fieldName, jsonName, null);</span>
<span class="nc" id="L344">	}</span>

	/** Writes the specified field to the current JSON object.
	 * @param elementType May be null if the type is unknown. */
	public void writeField (Object object, String fieldName, String jsonName, Class elementType) {
<span class="nc" id="L349">		Class type = object.getClass();</span>
<span class="nc" id="L350">		ObjectMap&lt;String, FieldMetadata&gt; fields = getFields(type);</span>
<span class="nc" id="L351">		FieldMetadata metadata = fields.get(fieldName);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">		if (metadata == null) throw new SerializationException(&quot;Field not found: &quot; + fieldName + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L353">		Field field = metadata.field;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">		if (elementType == null) elementType = metadata.elementType;</span>
		try {
			if (debug) System.out.println(&quot;Writing field: &quot; + field.getName() + &quot; (&quot; + type.getName() + &quot;)&quot;);
<span class="nc" id="L357">			writer.name(jsonName);</span>
<span class="nc" id="L358">			writeValue(field.get(object), field.getType(), elementType);</span>
<span class="nc" id="L359">		} catch (ReflectionException ex) {</span>
<span class="nc" id="L360">			throw new SerializationException(&quot;Error accessing field: &quot; + field.getName() + &quot; (&quot; + type.getName() + &quot;)&quot;, ex);</span>
<span class="nc" id="L361">		} catch (SerializationException ex) {</span>
<span class="nc" id="L362">			ex.addTrace(field + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L363">			throw ex;</span>
<span class="nc" id="L364">		} catch (Exception runtimeEx) {</span>
<span class="nc" id="L365">			SerializationException ex = new SerializationException(runtimeEx);</span>
<span class="nc" id="L366">			ex.addTrace(field + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L367">			throw ex;</span>
<span class="nc" id="L368">		}</span>
<span class="nc" id="L369">	}</span>

	/** Writes the value as a field on the current JSON object, without writing the actual class.
	 * @param value May be null.
	 * @see #writeValue(String, Object, Class, Class) */
	public void writeValue (String name, Object value) {
		try {
<span class="nc" id="L376">			writer.name(name);</span>
<span class="nc" id="L377">		} catch (IOException ex) {</span>
<span class="nc" id="L378">			throw new SerializationException(ex);</span>
<span class="nc" id="L379">		}</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">		if (value == null)</span>
<span class="nc" id="L381">			writeValue(value, null, null);</span>
		else
<span class="nc" id="L383">			writeValue(value, value.getClass(), null);</span>
<span class="nc" id="L384">	}</span>

	/** Writes the value as a field on the current JSON object, writing the class of the object if it differs from the specified
	 * known type.
	 * @param value May be null.
	 * @param knownType May be null if the type is unknown.
	 * @see #writeValue(String, Object, Class, Class) */
	public void writeValue (String name, Object value, Class knownType) {
		try {
<span class="nc" id="L393">			writer.name(name);</span>
<span class="nc" id="L394">		} catch (IOException ex) {</span>
<span class="nc" id="L395">			throw new SerializationException(ex);</span>
<span class="nc" id="L396">		}</span>
<span class="nc" id="L397">		writeValue(value, knownType, null);</span>
<span class="nc" id="L398">	}</span>

	/** Writes the value as a field on the current JSON object, writing the class of the object if it differs from the specified
	 * known type. The specified element type is used as the default type for collections.
	 * @param value May be null.
	 * @param knownType May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown. */
	public void writeValue (String name, Object value, Class knownType, Class elementType) {
		try {
<span class="nc" id="L407">			writer.name(name);</span>
<span class="nc" id="L408">		} catch (IOException ex) {</span>
<span class="nc" id="L409">			throw new SerializationException(ex);</span>
<span class="nc" id="L410">		}</span>
<span class="nc" id="L411">		writeValue(value, knownType, elementType);</span>
<span class="nc" id="L412">	}</span>

	/** Writes the value, without writing the class of the object.
	 * @param value May be null. */
	public void writeValue (Object value) {
<span class="nc bnc" id="L417" title="All 2 branches missed.">		if (value == null)</span>
<span class="nc" id="L418">			writeValue(value, null, null);</span>
		else
<span class="nc" id="L420">			writeValue(value, value.getClass(), null);</span>
<span class="nc" id="L421">	}</span>

	/** Writes the value, writing the class of the object if it differs from the specified known type.
	 * @param value May be null.
	 * @param knownType May be null if the type is unknown. */
	public void writeValue (Object value, Class knownType) {
<span class="nc" id="L427">		writeValue(value, knownType, null);</span>
<span class="nc" id="L428">	}</span>

	/** Writes the value, writing the class of the object if it differs from the specified known type. The specified element type
	 * is used as the default type for collections.
	 * @param value May be null.
	 * @param knownType May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown. */
	public void writeValue (Object value, Class knownType, Class elementType) {
		try {
<span class="nc bnc" id="L437" title="All 2 branches missed.">			if (value == null) {</span>
<span class="nc" id="L438">				writer.value(null);</span>
<span class="nc" id="L439">				return;</span>
			}

<span class="nc bnc" id="L442" title="All 22 branches missed.">			if ((knownType != null &amp;&amp; knownType.isPrimitive()) || knownType == String.class || knownType == Integer.class</span>
				|| knownType == Boolean.class || knownType == Float.class || knownType == Long.class || knownType == Double.class
				|| knownType == Short.class || knownType == Byte.class || knownType == Character.class) {
<span class="nc" id="L445">				writer.value(value);</span>
<span class="nc" id="L446">				return;</span>
			}

<span class="nc" id="L449">			Class actualType = value.getClass();</span>

<span class="nc bnc" id="L451" title="All 20 branches missed.">			if (actualType.isPrimitive() || actualType == String.class || actualType == Integer.class || actualType == Boolean.class</span>
				|| actualType == Float.class || actualType == Long.class || actualType == Double.class || actualType == Short.class
				|| actualType == Byte.class || actualType == Character.class) {
<span class="nc" id="L454">				writeObjectStart(actualType, null);</span>
<span class="nc" id="L455">				writeValue(&quot;value&quot;, value);</span>
<span class="nc" id="L456">				writeObjectEnd();</span>
<span class="nc" id="L457">				return;</span>
			}

<span class="nc bnc" id="L460" title="All 2 branches missed.">			if (value instanceof Serializable) {</span>
<span class="nc" id="L461">				writeObjectStart(actualType, knownType);</span>
<span class="nc" id="L462">				((Serializable)value).write(this);</span>
<span class="nc" id="L463">				writeObjectEnd();</span>
<span class="nc" id="L464">				return;</span>
			}

<span class="nc" id="L467">			Serializer serializer = classToSerializer.get(actualType);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">			if (serializer != null) {</span>
<span class="nc" id="L469">				serializer.write(this, value, knownType);</span>
<span class="nc" id="L470">				return;</span>
			}

			// JSON array special cases.
<span class="nc bnc" id="L474" title="All 2 branches missed.">			if (value instanceof Array) {</span>
<span class="nc bnc" id="L475" title="All 6 branches missed.">				if (knownType != null &amp;&amp; actualType != knownType &amp;&amp; actualType != Array.class)</span>
<span class="nc" id="L476">					throw new SerializationException(&quot;Serialization of an Array other than the known type is not supported.\n&quot;</span>
						+ &quot;Known type: &quot; + knownType + &quot;\nActual type: &quot; + actualType);
<span class="nc" id="L478">				writeArrayStart();</span>
<span class="nc" id="L479">				Array array = (Array)value;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">				for (int i = 0, n = array.size; i &lt; n; i++)</span>
<span class="nc" id="L481">					writeValue(array.get(i), elementType, null);</span>
<span class="nc" id="L482">				writeArrayEnd();</span>
<span class="nc" id="L483">				return;</span>
			}
<span class="nc bnc" id="L485" title="All 2 branches missed.">			if (value instanceof Queue) {</span>
<span class="nc bnc" id="L486" title="All 6 branches missed.">				if (knownType != null &amp;&amp; actualType != knownType &amp;&amp; actualType != Queue.class)</span>
<span class="nc" id="L487">					throw new SerializationException(&quot;Serialization of a Queue other than the known type is not supported.\n&quot;</span>
						+ &quot;Known type: &quot; + knownType + &quot;\nActual type: &quot; + actualType);
<span class="nc" id="L489">				writeArrayStart();</span>
<span class="nc" id="L490">				Queue queue = (Queue)value;</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">				for (int i = 0, n = queue.size; i &lt; n; i++)</span>
<span class="nc" id="L492">					writeValue(queue.get(i), elementType, null);</span>
<span class="nc" id="L493">				writeArrayEnd();</span>
<span class="nc" id="L494">				return;</span>
			}
<span class="nc bnc" id="L496" title="All 2 branches missed.">			if (value instanceof Collection) {</span>
<span class="nc bnc" id="L497" title="All 8 branches missed.">				if (typeName != null &amp;&amp; actualType != ArrayList.class &amp;&amp; (knownType == null || knownType != actualType)) {</span>
<span class="nc" id="L498">					writeObjectStart(actualType, knownType);</span>
<span class="nc" id="L499">					writeArrayStart(&quot;items&quot;);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">					for (Object item : (Collection)value)</span>
<span class="nc" id="L501">						writeValue(item, elementType, null);</span>
<span class="nc" id="L502">					writeArrayEnd();</span>
<span class="nc" id="L503">					writeObjectEnd();</span>
				} else {
<span class="nc" id="L505">					writeArrayStart();</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">					for (Object item : (Collection)value)</span>
<span class="nc" id="L507">						writeValue(item, elementType, null);</span>
<span class="nc" id="L508">					writeArrayEnd();</span>
				}
<span class="nc" id="L510">				return;</span>
			}
<span class="nc bnc" id="L512" title="All 2 branches missed.">			if (actualType.isArray()) {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">				if (elementType == null) elementType = actualType.getComponentType();</span>
<span class="nc" id="L514">				int length = ArrayReflection.getLength(value);</span>
<span class="nc" id="L515">				writeArrayStart();</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">				for (int i = 0; i &lt; length; i++)</span>
<span class="nc" id="L517">					writeValue(ArrayReflection.get(value, i), elementType, null);</span>
<span class="nc" id="L518">				writeArrayEnd();</span>
<span class="nc" id="L519">				return;</span>
			}

			// JSON object special cases.
<span class="nc bnc" id="L523" title="All 2 branches missed.">			if (value instanceof ObjectMap) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">				if (knownType == null) knownType = ObjectMap.class;</span>
<span class="nc" id="L525">				writeObjectStart(actualType, knownType);</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">				for (Entry entry : ((ObjectMap&lt;?, ?&gt;)value).entries()) {</span>
<span class="nc" id="L527">					writer.name(convertToString(entry.key));</span>
<span class="nc" id="L528">					writeValue(entry.value, elementType, null);</span>
<span class="nc" id="L529">				}</span>
<span class="nc" id="L530">				writeObjectEnd();</span>
<span class="nc" id="L531">				return;</span>
			}
<span class="nc bnc" id="L533" title="All 2 branches missed.">			if (value instanceof ArrayMap) {</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">				if (knownType == null) knownType = ArrayMap.class;</span>
<span class="nc" id="L535">				writeObjectStart(actualType, knownType);</span>
<span class="nc" id="L536">				ArrayMap map = (ArrayMap)value;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">				for (int i = 0, n = map.size; i &lt; n; i++) {</span>
<span class="nc" id="L538">					writer.name(convertToString(map.keys[i]));</span>
<span class="nc" id="L539">					writeValue(map.values[i], elementType, null);</span>
				}
<span class="nc" id="L541">				writeObjectEnd();</span>
<span class="nc" id="L542">				return;</span>
			}
<span class="nc bnc" id="L544" title="All 2 branches missed.">			if (value instanceof Map) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">				if (knownType == null) knownType = HashMap.class;</span>
<span class="nc" id="L546">				writeObjectStart(actualType, knownType);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">				for (Map.Entry entry : ((Map&lt;?, ?&gt;)value).entrySet()) {</span>
<span class="nc" id="L548">					writer.name(convertToString(entry.getKey()));</span>
<span class="nc" id="L549">					writeValue(entry.getValue(), elementType, null);</span>
<span class="nc" id="L550">				}</span>
<span class="nc" id="L551">				writeObjectEnd();</span>
<span class="nc" id="L552">				return;</span>
			}

			// Enum special case.
<span class="nc bnc" id="L556" title="All 2 branches missed.">			if (ClassReflection.isAssignableFrom(Enum.class, actualType)) {</span>
<span class="nc bnc" id="L557" title="All 6 branches missed.">				if (typeName != null &amp;&amp; (knownType == null || knownType != actualType)) {</span>
					// Ensures that enums with specific implementations (abstract logic) serialize correctly.
<span class="nc bnc" id="L559" title="All 2 branches missed.">					if (actualType.getEnumConstants() == null) actualType = actualType.getSuperclass();</span>

<span class="nc" id="L561">					writeObjectStart(actualType, null);</span>
<span class="nc" id="L562">					writer.name(&quot;value&quot;);</span>
<span class="nc" id="L563">					writer.value(convertToString((Enum)value));</span>
<span class="nc" id="L564">					writeObjectEnd();</span>
				} else {
<span class="nc" id="L566">					writer.value(convertToString((Enum)value));</span>
				}
<span class="nc" id="L568">				return;</span>
			}

<span class="nc" id="L571">			writeObjectStart(actualType, knownType);</span>
<span class="nc" id="L572">			writeFields(value);</span>
<span class="nc" id="L573">			writeObjectEnd();</span>
<span class="nc" id="L574">		} catch (IOException ex) {</span>
<span class="nc" id="L575">			throw new SerializationException(ex);</span>
<span class="nc" id="L576">		}</span>
<span class="nc" id="L577">	}</span>

	public void writeObjectStart (String name) {
		try {
<span class="nc" id="L581">			writer.name(name);</span>
<span class="nc" id="L582">		} catch (IOException ex) {</span>
<span class="nc" id="L583">			throw new SerializationException(ex);</span>
<span class="nc" id="L584">		}</span>
<span class="nc" id="L585">		writeObjectStart();</span>
<span class="nc" id="L586">	}</span>

	/** @param knownType May be null if the type is unknown. */
	public void writeObjectStart (String name, Class actualType, Class knownType) {
		try {
<span class="nc" id="L591">			writer.name(name);</span>
<span class="nc" id="L592">		} catch (IOException ex) {</span>
<span class="nc" id="L593">			throw new SerializationException(ex);</span>
<span class="nc" id="L594">		}</span>
<span class="nc" id="L595">		writeObjectStart(actualType, knownType);</span>
<span class="nc" id="L596">	}</span>

	public void writeObjectStart () {
		try {
<span class="nc" id="L600">			writer.object();</span>
<span class="nc" id="L601">		} catch (IOException ex) {</span>
<span class="nc" id="L602">			throw new SerializationException(ex);</span>
<span class="nc" id="L603">		}</span>
<span class="nc" id="L604">	}</span>

	/** Starts writing an object, writing the actualType to a field if needed.
	 * @param knownType May be null if the type is unknown. */
	public void writeObjectStart (Class actualType, Class knownType) {
		try {
<span class="nc" id="L610">			writer.object();</span>
<span class="nc" id="L611">		} catch (IOException ex) {</span>
<span class="nc" id="L612">			throw new SerializationException(ex);</span>
<span class="nc" id="L613">		}</span>
<span class="nc bnc" id="L614" title="All 4 branches missed.">		if (knownType == null || knownType != actualType) writeType(actualType);</span>
<span class="nc" id="L615">	}</span>

	public void writeObjectEnd () {
		try {
<span class="nc" id="L619">			writer.pop();</span>
<span class="nc" id="L620">		} catch (IOException ex) {</span>
<span class="nc" id="L621">			throw new SerializationException(ex);</span>
<span class="nc" id="L622">		}</span>
<span class="nc" id="L623">	}</span>

	public void writeArrayStart (String name) {
		try {
<span class="nc" id="L627">			writer.name(name);</span>
<span class="nc" id="L628">			writer.array();</span>
<span class="nc" id="L629">		} catch (IOException ex) {</span>
<span class="nc" id="L630">			throw new SerializationException(ex);</span>
<span class="nc" id="L631">		}</span>
<span class="nc" id="L632">	}</span>

	public void writeArrayStart () {
		try {
<span class="nc" id="L636">			writer.array();</span>
<span class="nc" id="L637">		} catch (IOException ex) {</span>
<span class="nc" id="L638">			throw new SerializationException(ex);</span>
<span class="nc" id="L639">		}</span>
<span class="nc" id="L640">	}</span>

	public void writeArrayEnd () {
		try {
<span class="nc" id="L644">			writer.pop();</span>
<span class="nc" id="L645">		} catch (IOException ex) {</span>
<span class="nc" id="L646">			throw new SerializationException(ex);</span>
<span class="nc" id="L647">		}</span>
<span class="nc" id="L648">	}</span>

	public void writeType (Class type) {
<span class="nc bnc" id="L651" title="All 2 branches missed.">		if (typeName == null) return;</span>
<span class="nc" id="L652">		String className = getTag(type);</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">		if (className == null) className = type.getName();</span>
		try {
<span class="nc" id="L655">			writer.set(typeName, className);</span>
<span class="nc" id="L656">		} catch (IOException ex) {</span>
<span class="nc" id="L657">			throw new SerializationException(ex);</span>
<span class="nc" id="L658">		}</span>
		if (debug) System.out.println(&quot;Writing type: &quot; + type.getName());
<span class="nc" id="L660">	}</span>

	/** @param type May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T fromJson (Class&lt;T&gt; type, Reader reader) {
<span class="nc" id="L665">		return (T)readValue(type, null, new JsonReader().parse(reader));</span>
	}

	/** @param type May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T fromJson (Class&lt;T&gt; type, Class elementType, Reader reader) {
<span class="nc" id="L672">		return (T)readValue(type, elementType, new JsonReader().parse(reader));</span>
	}

	/** @param type May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T fromJson (Class&lt;T&gt; type, InputStream input) {
<span class="nc" id="L678">		return (T)readValue(type, null, new JsonReader().parse(input));</span>
	}

	/** @param type May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T fromJson (Class&lt;T&gt; type, Class elementType, InputStream input) {
<span class="nc" id="L685">		return (T)readValue(type, elementType, new JsonReader().parse(input));</span>
	}

	/** @param type May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T fromJson (Class&lt;T&gt; type, FileHandle file) {
		try {
<span class="nc" id="L692">			return (T)readValue(type, null, new JsonReader().parse(file));</span>
<span class="nc" id="L693">		} catch (Exception ex) {</span>
<span class="nc" id="L694">			throw new SerializationException(&quot;Error reading file: &quot; + file, ex);</span>
		}
	}

	/** @param type May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T fromJson (Class&lt;T&gt; type, Class elementType, FileHandle file) {
		try {
<span class="nc" id="L703">			return (T)readValue(type, elementType, new JsonReader().parse(file));</span>
<span class="nc" id="L704">		} catch (Exception ex) {</span>
<span class="nc" id="L705">			throw new SerializationException(&quot;Error reading file: &quot; + file, ex);</span>
		}
	}

	/** @param type May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T fromJson (Class&lt;T&gt; type, char[] data, int offset, int length) {
<span class="nc" id="L712">		return (T)readValue(type, null, new JsonReader().parse(data, offset, length));</span>
	}

	/** @param type May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T fromJson (Class&lt;T&gt; type, Class elementType, char[] data, int offset, int length) {
<span class="nc" id="L719">		return (T)readValue(type, elementType, new JsonReader().parse(data, offset, length));</span>
	}

	/** @param type May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T fromJson (Class&lt;T&gt; type, String json) {
<span class="nc" id="L725">		return (T)readValue(type, null, new JsonReader().parse(json));</span>
	}

	/** @param type May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T fromJson (Class&lt;T&gt; type, Class elementType, String json) {
<span class="nc" id="L731">		return (T)readValue(type, elementType, new JsonReader().parse(json));</span>
	}

	public void readField (Object object, String name, JsonValue jsonData) {
<span class="nc" id="L735">		readField(object, name, name, null, jsonData);</span>
<span class="nc" id="L736">	}</span>

	public void readField (Object object, String name, Class elementType, JsonValue jsonData) {
<span class="nc" id="L739">		readField(object, name, name, elementType, jsonData);</span>
<span class="nc" id="L740">	}</span>

	public void readField (Object object, String fieldName, String jsonName, JsonValue jsonData) {
<span class="nc" id="L743">		readField(object, fieldName, jsonName, null, jsonData);</span>
<span class="nc" id="L744">	}</span>

	/** @param elementType May be null if the type is unknown. */
	public void readField (Object object, String fieldName, String jsonName, Class elementType, JsonValue jsonMap) {
<span class="nc" id="L748">		Class type = object.getClass();</span>
<span class="nc" id="L749">		ObjectMap&lt;String, FieldMetadata&gt; fields = getFields(type);</span>
<span class="nc" id="L750">		FieldMetadata metadata = fields.get(fieldName);</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">		if (metadata == null) throw new SerializationException(&quot;Field not found: &quot; + fieldName + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L752">		Field field = metadata.field;</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">		if (elementType == null) elementType = metadata.elementType;</span>
<span class="nc" id="L754">		readField(object, field, jsonName, elementType, jsonMap);</span>
<span class="nc" id="L755">	}</span>

	/** @param object May be null if the field is static.
	 * @param elementType May be null if the type is unknown. */
	public void readField (Object object, Field field, String jsonName, Class elementType, JsonValue jsonMap) {
<span class="nc" id="L760">		JsonValue jsonValue = jsonMap.get(jsonName);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">		if (jsonValue == null) return;</span>
		try {
<span class="nc" id="L763">			field.set(object, readValue(field.getType(), elementType, jsonValue));</span>
<span class="nc" id="L764">		} catch (ReflectionException ex) {</span>
<span class="nc" id="L765">			throw new SerializationException(</span>
				&quot;Error accessing field: &quot; + field.getName() + &quot; (&quot; + field.getDeclaringClass().getName() + &quot;)&quot;, ex);
<span class="nc" id="L767">		} catch (SerializationException ex) {</span>
<span class="nc" id="L768">			ex.addTrace(field.getName() + &quot; (&quot; + field.getDeclaringClass().getName() + &quot;)&quot;);</span>
<span class="nc" id="L769">			throw ex;</span>
<span class="nc" id="L770">		} catch (RuntimeException runtimeEx) {</span>
<span class="nc" id="L771">			SerializationException ex = new SerializationException(runtimeEx);</span>
<span class="nc" id="L772">			ex.addTrace(jsonValue.trace());</span>
<span class="nc" id="L773">			ex.addTrace(field.getName() + &quot; (&quot; + field.getDeclaringClass().getName() + &quot;)&quot;);</span>
<span class="nc" id="L774">			throw ex;</span>
<span class="nc" id="L775">		}</span>
<span class="nc" id="L776">	}</span>

	public void readFields (Object object, JsonValue jsonMap) {
<span class="nc" id="L779">		Class type = object.getClass();</span>
<span class="nc" id="L780">		ObjectMap&lt;String, FieldMetadata&gt; fields = getFields(type);</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">		for (JsonValue child = jsonMap.child; child != null; child = child.next) {</span>
<span class="nc" id="L782">			FieldMetadata metadata = fields.get(child.name);</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">			if (metadata == null) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">				if (child.name.equals(typeName)) continue;</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">				if (ignoreUnknownFields) {</span>
					if (debug) System.out.println(&quot;Ignoring unknown field: &quot; + child.name + &quot; (&quot; + type.getName() + &quot;)&quot;);
<span class="nc" id="L787">					continue;</span>
				} else {
<span class="nc" id="L789">					SerializationException ex = new SerializationException(</span>
						&quot;Field not found: &quot; + child.name + &quot; (&quot; + type.getName() + &quot;)&quot;);
<span class="nc" id="L791">					ex.addTrace(child.trace());</span>
<span class="nc" id="L792">					throw ex;</span>
				}
			}
<span class="nc" id="L795">			Field field = metadata.field;</span>
			try {
<span class="nc" id="L797">				field.set(object, readValue(field.getType(), metadata.elementType, child));</span>
<span class="nc" id="L798">			} catch (ReflectionException ex) {</span>
<span class="nc" id="L799">				throw new SerializationException(&quot;Error accessing field: &quot; + field.getName() + &quot; (&quot; + type.getName() + &quot;)&quot;, ex);</span>
<span class="nc" id="L800">			} catch (SerializationException ex) {</span>
<span class="nc" id="L801">				ex.addTrace(field.getName() + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L802">				throw ex;</span>
<span class="nc" id="L803">			} catch (RuntimeException runtimeEx) {</span>
<span class="nc" id="L804">				SerializationException ex = new SerializationException(runtimeEx);</span>
<span class="nc" id="L805">				ex.addTrace(child.trace());</span>
<span class="nc" id="L806">				ex.addTrace(field.getName() + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
<span class="nc" id="L807">				throw ex;</span>
<span class="nc" id="L808">			}</span>
		}
<span class="nc" id="L810">	}</span>

	/** @param type May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T readValue (String name, Class&lt;T&gt; type, JsonValue jsonMap) {
<span class="nc" id="L815">		return (T)readValue(type, null, jsonMap.get(name));</span>
	}

	/** @param type May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T readValue (String name, Class&lt;T&gt; type, T defaultValue, JsonValue jsonMap) {
<span class="nc" id="L821">		JsonValue jsonValue = jsonMap.get(name);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">		if (jsonValue == null) return defaultValue;</span>
<span class="nc" id="L823">		return (T)readValue(type, null, jsonValue);</span>
	}

	/** @param type May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T readValue (String name, Class&lt;T&gt; type, Class elementType, JsonValue jsonMap) {
<span class="nc" id="L830">		return (T)readValue(type, elementType, jsonMap.get(name));</span>
	}

	/** @param type May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T readValue (String name, Class&lt;T&gt; type, Class elementType, T defaultValue, JsonValue jsonMap) {
<span class="nc" id="L837">		JsonValue jsonValue = jsonMap.get(name);</span>
<span class="nc" id="L838">		return (T)readValue(type, elementType, defaultValue, jsonValue);</span>
	}

	/** @param type May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T readValue (Class&lt;T&gt; type, Class elementType, T defaultValue, JsonValue jsonData) {
<span class="nc bnc" id="L845" title="All 2 branches missed.">		if (jsonData == null) return defaultValue;</span>
<span class="nc" id="L846">		return (T)readValue(type, elementType, jsonData);</span>
	}

	/** @param type May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T readValue (Class&lt;T&gt; type, JsonValue jsonData) {
<span class="nc" id="L852">		return (T)readValue(type, null, jsonData);</span>
	}

	/** @param type May be null if the type is unknown.
	 * @param elementType May be null if the type is unknown.
	 * @return May be null. */
	public &lt;T&gt; T readValue (Class&lt;T&gt; type, Class elementType, JsonValue jsonData) {
<span class="nc bnc" id="L859" title="All 2 branches missed.">		if (jsonData == null) return null;</span>

<span class="nc bnc" id="L861" title="All 2 branches missed.">		if (jsonData.isObject()) {</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">			String className = typeName == null ? null : jsonData.getString(typeName, null);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">			if (className != null) {</span>
<span class="nc" id="L864">				type = getClass(className);</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">				if (type == null) {</span>
					try {
<span class="nc" id="L867">						type = (Class&lt;T&gt;)ClassReflection.forName(className);</span>
<span class="nc" id="L868">					} catch (ReflectionException ex) {</span>
<span class="nc" id="L869">						throw new SerializationException(ex);</span>
<span class="nc" id="L870">					}</span>
				}
			}

<span class="nc bnc" id="L874" title="All 2 branches missed.">			if (type == null) {</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">				if (defaultSerializer != null) return (T)defaultSerializer.read(this, jsonData, type);</span>
<span class="nc" id="L876">				return (T)jsonData;</span>
			}

<span class="nc bnc" id="L879" title="All 4 branches missed.">			if (typeName != null &amp;&amp; ClassReflection.isAssignableFrom(Collection.class, type)) {</span>
				// JSON object wrapper to specify type.
<span class="nc" id="L881">				jsonData = jsonData.get(&quot;items&quot;);</span>
			} else {
<span class="nc" id="L883">				Serializer serializer = classToSerializer.get(type);</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">				if (serializer != null) return (T)serializer.read(this, jsonData, type);</span>

<span class="nc bnc" id="L886" title="All 20 branches missed.">				if (type == String.class || type == Integer.class || type == Boolean.class || type == Float.class</span>
					|| type == Long.class || type == Double.class || type == Short.class || type == Byte.class
					|| type == Character.class || ClassReflection.isAssignableFrom(Enum.class, type)) {
<span class="nc" id="L889">					return readValue(&quot;value&quot;, type, jsonData);</span>
				}

<span class="nc" id="L892">				Object object = newInstance(type);</span>

<span class="nc bnc" id="L894" title="All 2 branches missed.">				if (object instanceof Serializable) {</span>
<span class="nc" id="L895">					((Serializable)object).read(this, jsonData);</span>
<span class="nc" id="L896">					return (T)object;</span>
				}

				// JSON object special cases.
<span class="nc bnc" id="L900" title="All 2 branches missed.">				if (object instanceof ObjectMap) {</span>
<span class="nc" id="L901">					ObjectMap result = (ObjectMap)object;</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">					for (JsonValue child = jsonData.child; child != null; child = child.next)</span>
<span class="nc" id="L903">						result.put(child.name, readValue(elementType, null, child));</span>
<span class="nc" id="L904">					return (T)result;</span>
				}
<span class="nc bnc" id="L906" title="All 2 branches missed.">				if (object instanceof ArrayMap) {</span>
<span class="nc" id="L907">					ArrayMap result = (ArrayMap)object;</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">					for (JsonValue child = jsonData.child; child != null; child = child.next)</span>
<span class="nc" id="L909">						result.put(child.name, readValue(elementType, null, child));</span>
<span class="nc" id="L910">					return (T)result;</span>
				}
<span class="nc bnc" id="L912" title="All 2 branches missed.">				if (object instanceof Map) {</span>
<span class="nc" id="L913">					Map result = (Map)object;</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">					for (JsonValue child = jsonData.child; child != null; child = child.next)</span>
<span class="nc" id="L915">						result.put(child.name, readValue(elementType, null, child));</span>
<span class="nc" id="L916">					return (T)result;</span>
				}

<span class="nc" id="L919">				readFields(object, jsonData);</span>
<span class="nc" id="L920">				return (T)object;</span>
			}
		}

<span class="nc bnc" id="L924" title="All 2 branches missed.">		if (type != null) {</span>
<span class="nc" id="L925">			Serializer serializer = classToSerializer.get(type);</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">			if (serializer != null) return (T)serializer.read(this, jsonData, type);</span>
		}

<span class="nc bnc" id="L929" title="All 2 branches missed.">		if (jsonData.isArray()) {</span>
			// JSON array special cases.
<span class="nc bnc" id="L931" title="All 4 branches missed.">			if (type == null || type == Object.class) type = (Class&lt;T&gt;)Array.class;</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">			if (ClassReflection.isAssignableFrom(Array.class, type)) {</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">				Array result = type == Array.class ? new Array() : (Array)newInstance(type);</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">				for (JsonValue child = jsonData.child; child != null; child = child.next)</span>
<span class="nc" id="L935">					result.add(readValue(elementType, null, child));</span>
<span class="nc" id="L936">				return (T)result;</span>
			}
<span class="nc bnc" id="L938" title="All 2 branches missed.">			if (ClassReflection.isAssignableFrom(Queue.class, type)) {</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">				Queue result = type == Queue.class ? new Queue() : (Queue)newInstance(type);</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">				for (JsonValue child = jsonData.child; child != null; child = child.next)</span>
<span class="nc" id="L941">					result.addLast(readValue(elementType, null, child));</span>
<span class="nc" id="L942">				return (T)result;</span>
			}
<span class="nc bnc" id="L944" title="All 2 branches missed.">			if (ClassReflection.isAssignableFrom(Collection.class, type)) {</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">				Collection result = type.isInterface() ? new ArrayList() : (Collection)newInstance(type);</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">				for (JsonValue child = jsonData.child; child != null; child = child.next)</span>
<span class="nc" id="L947">					result.add(readValue(elementType, null, child));</span>
<span class="nc" id="L948">				return (T)result;</span>
			}
<span class="nc bnc" id="L950" title="All 2 branches missed.">			if (type.isArray()) {</span>
<span class="nc" id="L951">				Class componentType = type.getComponentType();</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">				if (elementType == null) elementType = componentType;</span>
<span class="nc" id="L953">				Object result = ArrayReflection.newInstance(componentType, jsonData.size);</span>
<span class="nc" id="L954">				int i = 0;</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">				for (JsonValue child = jsonData.child; child != null; child = child.next)</span>
<span class="nc" id="L956">					ArrayReflection.set(result, i++, readValue(elementType, null, child));</span>
<span class="nc" id="L957">				return (T)result;</span>
			}
<span class="nc" id="L959">			throw new SerializationException(&quot;Unable to convert value to required type: &quot; + jsonData + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
		}

<span class="nc bnc" id="L962" title="All 2 branches missed.">		if (jsonData.isNumber()) {</span>
			try {
<span class="nc bnc" id="L964" title="All 6 branches missed.">				if (type == null || type == float.class || type == Float.class) return (T)(Float)jsonData.asFloat();</span>
<span class="nc bnc" id="L965" title="All 4 branches missed.">				if (type == int.class || type == Integer.class) return (T)(Integer)jsonData.asInt();</span>
<span class="nc bnc" id="L966" title="All 4 branches missed.">				if (type == long.class || type == Long.class) return (T)(Long)jsonData.asLong();</span>
<span class="nc bnc" id="L967" title="All 4 branches missed.">				if (type == double.class || type == Double.class) return (T)(Double)jsonData.asDouble();</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">				if (type == String.class) return (T)jsonData.asString();</span>
<span class="nc bnc" id="L969" title="All 4 branches missed.">				if (type == short.class || type == Short.class) return (T)(Short)jsonData.asShort();</span>
<span class="nc bnc" id="L970" title="All 4 branches missed.">				if (type == byte.class || type == Byte.class) return (T)(Byte)jsonData.asByte();</span>
<span class="nc" id="L971">			} catch (NumberFormatException ignored) {</span>
<span class="nc" id="L972">			}</span>
<span class="nc" id="L973">			jsonData = new JsonValue(jsonData.asString());</span>
		}

<span class="nc bnc" id="L976" title="All 2 branches missed.">		if (jsonData.isBoolean()) {</span>
			try {
<span class="nc bnc" id="L978" title="All 6 branches missed.">				if (type == null || type == boolean.class || type == Boolean.class) return (T)(Boolean)jsonData.asBoolean();</span>
<span class="nc" id="L979">			} catch (NumberFormatException ignored) {</span>
<span class="nc" id="L980">			}</span>
<span class="nc" id="L981">			jsonData = new JsonValue(jsonData.asString());</span>
		}

<span class="nc bnc" id="L984" title="All 2 branches missed.">		if (jsonData.isString()) {</span>
<span class="nc" id="L985">			String string = jsonData.asString();</span>
<span class="nc bnc" id="L986" title="All 4 branches missed.">			if (type == null || type == String.class) return (T)string;</span>
			try {
<span class="nc bnc" id="L988" title="All 4 branches missed.">				if (type == int.class || type == Integer.class) return (T)Integer.valueOf(string);</span>
<span class="nc bnc" id="L989" title="All 4 branches missed.">				if (type == float.class || type == Float.class) return (T)Float.valueOf(string);</span>
<span class="nc bnc" id="L990" title="All 4 branches missed.">				if (type == long.class || type == Long.class) return (T)Long.valueOf(string);</span>
<span class="nc bnc" id="L991" title="All 4 branches missed.">				if (type == double.class || type == Double.class) return (T)Double.valueOf(string);</span>
<span class="nc bnc" id="L992" title="All 4 branches missed.">				if (type == short.class || type == Short.class) return (T)Short.valueOf(string);</span>
<span class="nc bnc" id="L993" title="All 4 branches missed.">				if (type == byte.class || type == Byte.class) return (T)Byte.valueOf(string);</span>
<span class="nc" id="L994">			} catch (NumberFormatException ignored) {</span>
<span class="nc" id="L995">			}</span>
<span class="nc bnc" id="L996" title="All 4 branches missed.">			if (type == boolean.class || type == Boolean.class) return (T)Boolean.valueOf(string);</span>
<span class="nc bnc" id="L997" title="All 4 branches missed.">			if (type == char.class || type == Character.class) return (T)(Character)string.charAt(0);</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">			if (ClassReflection.isAssignableFrom(Enum.class, type)) {</span>
<span class="nc" id="L999">				Enum[] constants = (Enum[])type.getEnumConstants();</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">				for (int i = 0, n = constants.length; i &lt; n; i++) {</span>
<span class="nc" id="L1001">					Enum e = constants[i];</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">					if (string.equals(convertToString(e))) return (T)e;</span>
				}
			}
<span class="nc bnc" id="L1005" title="All 2 branches missed.">			if (type == CharSequence.class) return (T)string;</span>
<span class="nc" id="L1006">			throw new SerializationException(&quot;Unable to convert value to required type: &quot; + jsonData + &quot; (&quot; + type.getName() + &quot;)&quot;);</span>
		}

<span class="nc" id="L1009">		return null;</span>
	}

	private String convertToString (Enum e) {
<span class="nc bnc" id="L1013" title="All 2 branches missed.">		return enumNames ? e.name() : e.toString();</span>
	}

	private String convertToString (Object object) {
<span class="nc bnc" id="L1017" title="All 2 branches missed.">		if (object instanceof Enum) return convertToString((Enum)object);</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">		if (object instanceof Class) return ((Class)object).getName();</span>
<span class="nc" id="L1019">		return String.valueOf(object);</span>
	}

	protected Object newInstance (Class type) {
		try {
<span class="nc" id="L1024">			return ClassReflection.newInstance(type);</span>
<span class="nc" id="L1025">		} catch (Exception ex) {</span>
			try {
				// Try a private constructor.
<span class="nc" id="L1028">				Constructor constructor = ClassReflection.getDeclaredConstructor(type);</span>
<span class="nc" id="L1029">				constructor.setAccessible(true);</span>
<span class="nc" id="L1030">				return constructor.newInstance();</span>
<span class="nc" id="L1031">			} catch (SecurityException ignored) {</span>
<span class="nc" id="L1032">			} catch (ReflectionException ignored) {</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">				if (ClassReflection.isAssignableFrom(Enum.class, type)) {</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">					if (type.getEnumConstants() == null) type = type.getSuperclass();</span>
<span class="nc" id="L1035">					return type.getEnumConstants()[0];</span>
				}
<span class="nc bnc" id="L1037" title="All 2 branches missed.">				if (type.isArray())</span>
<span class="nc" id="L1038">					throw new SerializationException(&quot;Encountered JSON object when expected array of type: &quot; + type.getName(), ex);</span>
<span class="nc bnc" id="L1039" title="All 4 branches missed.">				else if (ClassReflection.isMemberClass(type) &amp;&amp; !ClassReflection.isStaticClass(type))</span>
<span class="nc" id="L1040">					throw new SerializationException(&quot;Class cannot be created (non-static member class): &quot; + type.getName(), ex);</span>
				else
<span class="nc" id="L1042">					throw new SerializationException(&quot;Class cannot be created (missing no-arg constructor): &quot; + type.getName(), ex);</span>
<span class="nc" id="L1043">			} catch (Exception privateConstructorException) {</span>
<span class="nc" id="L1044">				ex = privateConstructorException;</span>
<span class="nc" id="L1045">			}</span>
<span class="nc" id="L1046">			throw new SerializationException(&quot;Error constructing instance of class: &quot; + type.getName(), ex);</span>
		}
	}

	public String prettyPrint (Object object) {
<span class="nc" id="L1051">		return prettyPrint(object, 0);</span>
	}

	public String prettyPrint (String json) {
<span class="nc" id="L1055">		return prettyPrint(json, 0);</span>
	}

	public String prettyPrint (Object object, int singleLineColumns) {
<span class="nc" id="L1059">		return prettyPrint(toJson(object), singleLineColumns);</span>
	}

	public String prettyPrint (String json, int singleLineColumns) {
<span class="nc" id="L1063">		return new JsonReader().parse(json).prettyPrint(outputType, singleLineColumns);</span>
	}

	public String prettyPrint (Object object, PrettyPrintSettings settings) {
<span class="nc" id="L1067">		return prettyPrint(toJson(object), settings);</span>
	}

	public String prettyPrint (String json, PrettyPrintSettings settings) {
<span class="nc" id="L1071">		return new JsonReader().parse(json).prettyPrint(settings);</span>
	}

	static private class FieldMetadata {
		Field field;
		Class elementType;

<span class="nc" id="L1078">		public FieldMetadata (Field field) {</span>
<span class="nc" id="L1079">			this.field = field;</span>
<span class="nc bnc" id="L1080" title="All 4 branches missed.">			int index = (ClassReflection.isAssignableFrom(ObjectMap.class, field.getType())</span>
				|| ClassReflection.isAssignableFrom(Map.class, field.getType())) ? 1 : 0;
<span class="nc" id="L1082">			this.elementType = field.getElementType(index);</span>
<span class="nc" id="L1083">		}</span>
	}

	static public interface Serializer&lt;T&gt; {
		public void write (Json json, T object, Class knownType);

		public T read (Json json, JsonValue jsonData, Class type);
	}

<span class="nc" id="L1092">	static abstract public class ReadOnlySerializer&lt;T&gt; implements Serializer&lt;T&gt; {</span>
		public void write (Json json, T object, Class knownType) {
<span class="nc" id="L1094">		}</span>

		abstract public T read (Json json, JsonValue jsonData, Class type);
	}

	static public interface Serializable {
		public void write (Json json);

		public void read (Json json, JsonValue jsonData);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>