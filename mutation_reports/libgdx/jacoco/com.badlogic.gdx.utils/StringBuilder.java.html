<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StringBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.utils</a> &gt; <span class="el_source">StringBuilder.java</span></div><h1>StringBuilder.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.badlogic.gdx.utils;

import java.util.Arrays;

/** A {@link java.lang.StringBuilder} that implements equals and hashcode.
 * @see CharSequence
 * @see Appendable
 * @see java.lang.StringBuilder
 * @see String */
public class StringBuilder implements Appendable, CharSequence {
	static final int INITIAL_CAPACITY = 16;

	public char[] chars;
	public int length;

<span class="fc" id="L33">	private static final char[] digits = new char[] {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};</span>

	/** @return the number of characters required to represent the specified value with the specified radix */
	public static int numChars (int value, int radix) {
<span class="nc bnc" id="L37" title="All 2 branches missed.">		int result = (value &lt; 0) ? 2 : 1;</span>
<span class="nc bnc" id="L38" title="All 2 branches missed.">		while ((value /= radix) != 0)</span>
<span class="nc" id="L39">			++result;</span>
<span class="nc" id="L40">		return result;</span>
	}

	/** @return the number of characters required to represent the specified value with the specified radix */
	public static int numChars (long value, int radix) {
<span class="nc bnc" id="L45" title="All 2 branches missed.">		int result = (value &lt; 0) ? 2 : 1;</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">		while ((value /= radix) != 0)</span>
<span class="nc" id="L47">			++result;</span>
<span class="nc" id="L48">		return result;</span>
	}

	/*
	 * Returns the character array.
	 */
	final char[] getValue () {
<span class="nc" id="L55">		return chars;</span>
	}

	/** Constructs an instance with an initial capacity of {@code 16}.
	 * 
	 * @see #capacity() */
<span class="nc" id="L61">	public StringBuilder () {</span>
<span class="nc" id="L62">		chars = new char[INITIAL_CAPACITY];</span>
<span class="nc" id="L63">	}</span>

	/** Constructs an instance with the specified capacity.
	 * 
	 * @param capacity the initial capacity to use.
	 * @throws NegativeArraySizeException if the specified {@code capacity} is negative.
	 * @see #capacity() */
<span class="fc" id="L70">	public StringBuilder (int capacity) {</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">		if (capacity &lt; 0) {</span>
<span class="nc" id="L72">			throw new NegativeArraySizeException();</span>
		}
<span class="fc" id="L74">		chars = new char[capacity];</span>
<span class="fc" id="L75">	}</span>

	/** Constructs an instance that's initialized with the contents of the specified {@code CharSequence}. The capacity of the new
	 * builder will be the length of the {@code CharSequence} plus 16.
	 * 
	 * @param seq the {@code CharSequence} to copy into the builder.
	 * @throws NullPointerException if {@code seq} is {@code null}. */
	public StringBuilder (CharSequence seq) {
<span class="nc" id="L83">		this(seq.toString());</span>
<span class="nc" id="L84">	}</span>

<span class="nc" id="L86">	public StringBuilder (StringBuilder builder) {</span>
<span class="nc" id="L87">		length = builder.length;</span>
<span class="nc" id="L88">		chars = new char[length + INITIAL_CAPACITY];</span>
<span class="nc" id="L89">		System.arraycopy(builder.chars, 0, chars, 0, length);</span>
<span class="nc" id="L90">	}</span>

	/** Constructs an instance that's initialized with the contents of the specified {@code String}. The capacity of the new builder
	 * will be the length of the {@code String} plus 16.
	 * 
	 * @param string the {@code String} to copy into the builder.
	 * @throws NullPointerException if {@code str} is {@code null}. */
<span class="nc" id="L97">	public StringBuilder (String string) {</span>
<span class="nc" id="L98">		length = string.length();</span>
<span class="nc" id="L99">		chars = new char[length + INITIAL_CAPACITY];</span>
<span class="nc" id="L100">		string.getChars(0, length, chars, 0);</span>
<span class="nc" id="L101">	}</span>

	private void enlargeBuffer (int min) {
<span class="nc" id="L104">		int newSize = (chars.length &gt;&gt; 1) + chars.length + 2;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">		char[] newData = new char[min &gt; newSize ? min : newSize];</span>
<span class="nc" id="L106">		System.arraycopy(chars, 0, newData, 0, length);</span>
<span class="nc" id="L107">		chars = newData;</span>
<span class="nc" id="L108">	}</span>

	final void appendNull () {
<span class="nc" id="L111">		int newSize = length + 4;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">		if (newSize &gt; chars.length) {</span>
<span class="nc" id="L113">			enlargeBuffer(newSize);</span>
		}
<span class="nc" id="L115">		chars[length++] = 'n';</span>
<span class="nc" id="L116">		chars[length++] = 'u';</span>
<span class="nc" id="L117">		chars[length++] = 'l';</span>
<span class="nc" id="L118">		chars[length++] = 'l';</span>
<span class="nc" id="L119">	}</span>

	final void append0 (char[] value) {
<span class="nc" id="L122">		int newSize = length + value.length;</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">		if (newSize &gt; chars.length) {</span>
<span class="nc" id="L124">			enlargeBuffer(newSize);</span>
		}
<span class="nc" id="L126">		System.arraycopy(value, 0, chars, length, value.length);</span>
<span class="nc" id="L127">		length = newSize;</span>
<span class="nc" id="L128">	}</span>

	final void append0 (char[] value, int offset, int length) {
		// Force null check of chars first!
<span class="nc bnc" id="L132" title="All 4 branches missed.">		if (offset &gt; value.length || offset &lt; 0) {</span>
<span class="nc" id="L133">			throw new ArrayIndexOutOfBoundsException(&quot;Offset out of bounds: &quot; + offset);</span>
		}
<span class="nc bnc" id="L135" title="All 4 branches missed.">		if (length &lt; 0 || value.length - offset &lt; length) {</span>
<span class="nc" id="L136">			throw new ArrayIndexOutOfBoundsException(&quot;Length out of bounds: &quot; + length);</span>
		}

<span class="nc" id="L139">		int newSize = this.length + length;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">		if (newSize &gt; chars.length) {</span>
<span class="nc" id="L141">			enlargeBuffer(newSize);</span>
		}
<span class="nc" id="L143">		System.arraycopy(value, offset, chars, this.length, length);</span>
<span class="nc" id="L144">		this.length = newSize;</span>
<span class="nc" id="L145">	}</span>

	final void append0 (char ch) {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">		if (length == chars.length) {</span>
<span class="nc" id="L149">			enlargeBuffer(length + 1);</span>
		}
<span class="fc" id="L151">		chars[length++] = ch;</span>
<span class="fc" id="L152">	}</span>

	final void append0 (String string) {
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">		if (string == null) {</span>
<span class="nc" id="L156">			appendNull();</span>
<span class="nc" id="L157">			return;</span>
		}
<span class="fc" id="L159">		int adding = string.length();</span>
<span class="fc" id="L160">		int newSize = length + adding;</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">		if (newSize &gt; chars.length) {</span>
<span class="nc" id="L162">			enlargeBuffer(newSize);</span>
		}
<span class="fc" id="L164">		string.getChars(0, adding, chars, length);</span>
<span class="fc" id="L165">		length = newSize;</span>
<span class="fc" id="L166">	}</span>

	final void append0 (CharSequence s, int start, int end) {
<span class="nc bnc" id="L169" title="All 2 branches missed.">		if (s == null) {</span>
<span class="nc" id="L170">			s = &quot;null&quot;;</span>
		}
<span class="nc bnc" id="L172" title="All 8 branches missed.">		if (start &lt; 0 || end &lt; 0 || start &gt; end || end &gt; s.length()) {</span>
<span class="nc" id="L173">			throw new IndexOutOfBoundsException();</span>
		}

<span class="nc" id="L176">		append0(s.subSequence(start, end).toString());</span>
<span class="nc" id="L177">	}</span>

	/** Returns the number of characters that can be held without growing.
	 * 
	 * @return the capacity
	 * @see #ensureCapacity
	 * @see #length */
	public int capacity () {
<span class="nc" id="L185">		return chars.length;</span>
	}

	/** Retrieves the character at the {@code index}.
	 * 
	 * @param index the index of the character to retrieve.
	 * @return the char value.
	 * @throws IndexOutOfBoundsException if {@code index} is negative or greater than or equal to the current {@link #length()}. */
	public char charAt (int index) {
<span class="nc bnc" id="L194" title="All 4 branches missed.">		if (index &lt; 0 || index &gt;= length) {</span>
<span class="nc" id="L195">			throw new StringIndexOutOfBoundsException(index);</span>
		}
<span class="nc" id="L197">		return chars[index];</span>
	}

	final void delete0 (int start, int end) {
<span class="nc bnc" id="L201" title="All 2 branches missed.">		if (start &gt;= 0) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">			if (end &gt; length) {</span>
<span class="nc" id="L203">				end = length;</span>
			}
<span class="nc bnc" id="L205" title="All 2 branches missed.">			if (end == start) {</span>
<span class="nc" id="L206">				return;</span>
			}
<span class="nc bnc" id="L208" title="All 2 branches missed.">			if (end &gt; start) {</span>
<span class="nc" id="L209">				int count = length - end;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">				if (count &gt;= 0) System.arraycopy(chars, end, chars, start, count);</span>
<span class="nc" id="L211">				length -= end - start;</span>
<span class="nc" id="L212">				return;</span>
			}
		}
<span class="nc" id="L215">		throw new StringIndexOutOfBoundsException();</span>
	}

	final void deleteCharAt0 (int location) {
<span class="nc bnc" id="L219" title="All 4 branches missed.">		if (0 &gt; location || location &gt;= length) {</span>
<span class="nc" id="L220">			throw new StringIndexOutOfBoundsException(location);</span>
		}
<span class="nc" id="L222">		int count = length - location - 1;</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">		if (count &gt; 0) {</span>
<span class="nc" id="L224">			System.arraycopy(chars, location + 1, chars, location, count);</span>
		}
<span class="nc" id="L226">		length--;</span>
<span class="nc" id="L227">	}</span>

	/** Ensures that this object has a minimum capacity available before requiring the internal buffer to be enlarged. The general
	 * policy of this method is that if the {@code minimumCapacity} is larger than the current {@link #capacity()}, then the
	 * capacity will be increased to the largest value of either the {@code minimumCapacity} or the current capacity multiplied by
	 * two plus two. Although this is the general policy, there is no guarantee that the capacity will change.
	 * 
	 * @param min the new minimum capacity to set. */
	public void ensureCapacity (int min) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">		if (min &gt; chars.length) {</span>
<span class="nc" id="L237">			int twice = (chars.length &lt;&lt; 1) + 2;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">			enlargeBuffer(twice &gt; min ? twice : min);</span>
		}
<span class="nc" id="L240">	}</span>

	/** Copies the requested sequence of characters to the {@code char[]} passed starting at {@code destStart}.
	 * 
	 * @param start the inclusive start index of the characters to copy.
	 * @param end the exclusive end index of the characters to copy.
	 * @param dest the {@code char[]} to copy the characters to.
	 * @param destStart the inclusive start index of {@code dest} to begin copying to.
	 * @throws IndexOutOfBoundsException if the {@code start} is negative, the {@code destStart} is negative, the {@code start} is
	 *            greater than {@code end}, the {@code end} is greater than the current {@link #length()} or
	 *            {@code destStart + end - begin} is greater than {@code dest.length}. */
	public void getChars (int start, int end, char[] dest, int destStart) {
<span class="nc bnc" id="L252" title="All 6 branches missed.">		if (start &gt; length || end &gt; length || start &gt; end) {</span>
<span class="nc" id="L253">			throw new StringIndexOutOfBoundsException();</span>
		}
<span class="nc" id="L255">		System.arraycopy(chars, start, dest, destStart, end - start);</span>
<span class="nc" id="L256">	}</span>

	final void insert0 (int index, char[] value) {
<span class="nc bnc" id="L259" title="All 4 branches missed.">		if (0 &gt; index || index &gt; length) {</span>
<span class="nc" id="L260">			throw new StringIndexOutOfBoundsException(index);</span>
		}
<span class="nc bnc" id="L262" title="All 2 branches missed.">		if (value.length != 0) {</span>
<span class="nc" id="L263">			move(value.length, index);</span>
<span class="nc" id="L264">			System.arraycopy(value, 0, value, index, value.length);</span>
<span class="nc" id="L265">			length += value.length;</span>
		}
<span class="nc" id="L267">	}</span>

	final void insert0 (int index, char[] value, int start, int length) {
<span class="nc bnc" id="L270" title="All 4 branches missed.">		if (0 &lt;= index &amp;&amp; index &lt;= length) {</span>
			// start + length could overflow, start/length maybe MaxInt
<span class="nc bnc" id="L272" title="All 6 branches missed.">			if (start &gt;= 0 &amp;&amp; 0 &lt;= length &amp;&amp; length &lt;= value.length - start) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">				if (length != 0) {</span>
<span class="nc" id="L274">					move(length, index);</span>
<span class="nc" id="L275">					System.arraycopy(value, start, chars, index, length);</span>
<span class="nc" id="L276">					this.length += length;</span>
				}
<span class="nc" id="L278">				return;</span>
			}
<span class="nc" id="L280">			throw new StringIndexOutOfBoundsException(&quot;offset &quot; + start + &quot;, length &quot; + length + &quot;, char[].length &quot; + value.length);</span>
		}
<span class="nc" id="L282">		throw new StringIndexOutOfBoundsException(index);</span>
	}

	final void insert0 (int index, char ch) {
<span class="nc bnc" id="L286" title="All 4 branches missed.">		if (0 &gt; index || index &gt; length) {</span>
			// RI compatible exception type
<span class="nc" id="L288">			throw new ArrayIndexOutOfBoundsException(index);</span>
		}
<span class="nc" id="L290">		move(1, index);</span>
<span class="nc" id="L291">		chars[index] = ch;</span>
<span class="nc" id="L292">		length++;</span>
<span class="nc" id="L293">	}</span>

	final void insert0 (int index, String string) {
<span class="nc bnc" id="L296" title="All 4 branches missed.">		if (0 &lt;= index &amp;&amp; index &lt;= length) {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">			if (string == null) {</span>
<span class="nc" id="L298">				string = &quot;null&quot;;</span>
			}
<span class="nc" id="L300">			int min = string.length();</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">			if (min != 0) {</span>
<span class="nc" id="L302">				move(min, index);</span>
<span class="nc" id="L303">				string.getChars(0, min, chars, index);</span>
<span class="nc" id="L304">				length += min;</span>
			}
<span class="nc" id="L306">		} else {</span>
<span class="nc" id="L307">			throw new StringIndexOutOfBoundsException(index);</span>
		}
<span class="nc" id="L309">	}</span>

	final void insert0 (int index, CharSequence s, int start, int end) {
<span class="nc bnc" id="L312" title="All 2 branches missed.">		if (s == null) {</span>
<span class="nc" id="L313">			s = &quot;null&quot;;</span>
		}
<span class="nc bnc" id="L315" title="All 12 branches missed.">		if (index &lt; 0 || index &gt; length || start &lt; 0 || end &lt; 0 || start &gt; end || end &gt; s.length()) {</span>
<span class="nc" id="L316">			throw new IndexOutOfBoundsException();</span>
		}
<span class="nc" id="L318">		insert0(index, s.subSequence(start, end).toString());</span>
<span class="nc" id="L319">	}</span>

	/** The current length.
	 * 
	 * @return the number of characters contained in this instance. */
	public int length () {
<span class="nc" id="L325">		return length;</span>
	}

	private void move (int size, int index) {
<span class="nc bnc" id="L329" title="All 2 branches missed.">		if (chars.length - length &gt;= size) {</span>
<span class="nc" id="L330">			System.arraycopy(chars, index, chars, index + size, length - index); // index == count case is no-op</span>
<span class="nc" id="L331">			return;</span>
		}
<span class="nc" id="L333">		int a = length + size, b = (chars.length &lt;&lt; 1) + 2;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">		int newSize = a &gt; b ? a : b;</span>
<span class="nc" id="L335">		char[] newData = new char[newSize];</span>
<span class="nc" id="L336">		System.arraycopy(chars, 0, newData, 0, index);</span>
		// index == count case is no-op
<span class="nc" id="L338">		System.arraycopy(chars, index, newData, index + size, length - index);</span>
<span class="nc" id="L339">		chars = newData;</span>
<span class="nc" id="L340">	}</span>

	final void replace0 (int start, int end, String string) {
<span class="nc bnc" id="L343" title="All 2 branches missed.">		if (start &gt;= 0) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">			if (end &gt; length) {</span>
<span class="nc" id="L345">				end = length;</span>
			}
<span class="nc bnc" id="L347" title="All 2 branches missed.">			if (end &gt; start) {</span>
<span class="nc" id="L348">				int stringLength = string.length();</span>
<span class="nc" id="L349">				int diff = end - start - stringLength;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">				if (diff &gt; 0) { // replacing with fewer characters</span>
					// index == count case is no-op
<span class="nc" id="L352">					System.arraycopy(chars, end, chars, start + stringLength, length - end);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">				} else if (diff &lt; 0) {</span>
					// replacing with more characters...need some room
<span class="nc" id="L355">					move(-diff, end);</span>
				}
<span class="nc" id="L357">				string.getChars(0, stringLength, chars, start);</span>
<span class="nc" id="L358">				length -= diff;</span>
<span class="nc" id="L359">				return;</span>
			}
<span class="nc bnc" id="L361" title="All 2 branches missed.">			if (start == end) {</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">				if (string == null) {</span>
<span class="nc" id="L363">					throw new NullPointerException();</span>
				}
<span class="nc" id="L365">				insert0(start, string);</span>
<span class="nc" id="L366">				return;</span>
			}
		}
<span class="nc" id="L369">		throw new StringIndexOutOfBoundsException();</span>
	}

	final void reverse0 () {
<span class="nc bnc" id="L373" title="All 2 branches missed.">		if (length &lt; 2) {</span>
<span class="nc" id="L374">			return;</span>
		}
<span class="nc" id="L376">		int end = length - 1;</span>
<span class="nc" id="L377">		char frontHigh = chars[0];</span>
<span class="nc" id="L378">		char endLow = chars[end];</span>
<span class="nc" id="L379">		boolean allowFrontSur = true, allowEndSur = true;</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">		for (int i = 0, mid = length / 2; i &lt; mid; i++, --end) {</span>
<span class="nc" id="L381">			char frontLow = chars[i + 1];</span>
<span class="nc" id="L382">			char endHigh = chars[end - 1];</span>
<span class="nc bnc" id="L383" title="All 10 branches missed.">			boolean surAtFront = allowFrontSur &amp;&amp; frontLow &gt;= 0xdc00 &amp;&amp; frontLow &lt;= 0xdfff &amp;&amp; frontHigh &gt;= 0xd800</span>
				&amp;&amp; frontHigh &lt;= 0xdbff;
<span class="nc bnc" id="L385" title="All 4 branches missed.">			if (surAtFront &amp;&amp; length &lt; 3) {</span>
<span class="nc" id="L386">				return;</span>
			}
<span class="nc bnc" id="L388" title="All 10 branches missed.">			boolean surAtEnd = allowEndSur &amp;&amp; endHigh &gt;= 0xd800 &amp;&amp; endHigh &lt;= 0xdbff &amp;&amp; endLow &gt;= 0xdc00 &amp;&amp; endLow &lt;= 0xdfff;</span>
<span class="nc" id="L389">			allowFrontSur = allowEndSur = true;</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">			if (surAtFront == surAtEnd) {</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">				if (surAtFront) {</span>
					// both surrogates
<span class="nc" id="L393">					chars[end] = frontLow;</span>
<span class="nc" id="L394">					chars[end - 1] = frontHigh;</span>
<span class="nc" id="L395">					chars[i] = endHigh;</span>
<span class="nc" id="L396">					chars[i + 1] = endLow;</span>
<span class="nc" id="L397">					frontHigh = chars[i + 2];</span>
<span class="nc" id="L398">					endLow = chars[end - 2];</span>
<span class="nc" id="L399">					i++;</span>
<span class="nc" id="L400">					end--;</span>
				} else {
					// neither surrogates
<span class="nc" id="L403">					chars[end] = frontHigh;</span>
<span class="nc" id="L404">					chars[i] = endLow;</span>
<span class="nc" id="L405">					frontHigh = frontLow;</span>
<span class="nc" id="L406">					endLow = endHigh;</span>
				}
			} else {
<span class="nc bnc" id="L409" title="All 2 branches missed.">				if (surAtFront) {</span>
					// surrogate only at the front
<span class="nc" id="L411">					chars[end] = frontLow;</span>
<span class="nc" id="L412">					chars[i] = endLow;</span>
<span class="nc" id="L413">					endLow = endHigh;</span>
<span class="nc" id="L414">					allowFrontSur = false;</span>
				} else {
					// surrogate only at the end
<span class="nc" id="L417">					chars[end] = frontHigh;</span>
<span class="nc" id="L418">					chars[i] = endHigh;</span>
<span class="nc" id="L419">					frontHigh = frontLow;</span>
<span class="nc" id="L420">					allowEndSur = false;</span>
				}
			}
		}
<span class="nc bnc" id="L424" title="All 6 branches missed.">		if ((length &amp; 1) == 1 &amp;&amp; (!allowFrontSur || !allowEndSur)) {</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">			chars[end] = allowFrontSur ? endLow : frontHigh;</span>
		}
<span class="nc" id="L427">	}</span>

	/** Sets the character at the {@code index}.
	 * 
	 * @param index the zero-based index of the character to replace.
	 * @param ch the character to set.
	 * @throws IndexOutOfBoundsException if {@code index} is negative or greater than or equal to the current {@link #length()}. */
	public void setCharAt (int index, char ch) {
<span class="nc bnc" id="L435" title="All 4 branches missed.">		if (0 &gt; index || index &gt;= length) {</span>
<span class="nc" id="L436">			throw new StringIndexOutOfBoundsException(index);</span>
		}
<span class="nc" id="L438">		chars[index] = ch;</span>
<span class="nc" id="L439">	}</span>

	/** Sets the current length to a new value. If the new length is larger than the current length, then the new characters at the
	 * end of this object will contain the {@code char} value of {@code \u0000}.
	 * 
	 * @param newLength the new length of this StringBuilder.
	 * @exception IndexOutOfBoundsException if {@code length &lt; 0}.
	 * @see #length */
	public void setLength (int newLength) {
<span class="nc bnc" id="L448" title="All 2 branches missed.">		if (newLength &lt; 0) {</span>
<span class="nc" id="L449">			throw new StringIndexOutOfBoundsException(newLength);</span>
		}
<span class="nc bnc" id="L451" title="All 2 branches missed.">		if (newLength &gt; chars.length) {</span>
<span class="nc" id="L452">			enlargeBuffer(newLength);</span>
		} else {
<span class="nc bnc" id="L454" title="All 2 branches missed.">			if (length &lt; newLength) {</span>
<span class="nc" id="L455">				Arrays.fill(chars, length, newLength, (char)0);</span>
			}
		}
<span class="nc" id="L458">		length = newLength;</span>
<span class="nc" id="L459">	}</span>

	/** Returns the String value of the subsequence from the {@code start} index to the current end.
	 * 
	 * @param start the inclusive start index to begin the subsequence.
	 * @return a String containing the subsequence.
	 * @throws StringIndexOutOfBoundsException if {@code start} is negative or greater than the current {@link #length()}. */
	public String substring (int start) {
<span class="nc bnc" id="L467" title="All 4 branches missed.">		if (0 &lt;= start &amp;&amp; start &lt;= length) {</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">			if (start == length) {</span>
<span class="nc" id="L469">				return &quot;&quot;;</span>
			}

			// Remove String sharing for more performance
<span class="nc" id="L473">			return new String(chars, start, length - start);</span>
		}
<span class="nc" id="L475">		throw new StringIndexOutOfBoundsException(start);</span>
	}

	/** Returns the String value of the subsequence from the {@code start} index to the {@code end} index.
	 * 
	 * @param start the inclusive start index to begin the subsequence.
	 * @param end the exclusive end index to end the subsequence.
	 * @return a String containing the subsequence.
	 * @throws StringIndexOutOfBoundsException if {@code start} is negative, greater than {@code end} or if {@code end} is greater
	 *            than the current {@link #length()}. */
	public String substring (int start, int end) {
<span class="nc bnc" id="L486" title="All 6 branches missed.">		if (0 &lt;= start &amp;&amp; start &lt;= end &amp;&amp; end &lt;= length) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">			if (start == end) {</span>
<span class="nc" id="L488">				return &quot;&quot;;</span>
			}

			// Remove String sharing for more performance
<span class="nc" id="L492">			return new String(chars, start, end - start);</span>
		}
<span class="nc" id="L494">		throw new StringIndexOutOfBoundsException();</span>
	}

	/** Returns the current String representation.
	 * 
	 * @return a String containing the characters in this instance. */
	@Override
	public String toString () {
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">		if (length == 0) return &quot;&quot;;</span>
<span class="fc" id="L503">		return new String(chars, 0, length);</span>
	}

	/** Returns a {@code CharSequence} of the subsequence from the {@code start} index to the {@code end} index.
	 * 
	 * @param start the inclusive start index to begin the subsequence.
	 * @param end the exclusive end index to end the subsequence.
	 * @return a CharSequence containing the subsequence.
	 * @throws IndexOutOfBoundsException if {@code start} is negative, greater than {@code end} or if {@code end} is greater than
	 *            the current {@link #length()}.
	 * @since 1.4 */
	public CharSequence subSequence (int start, int end) {
<span class="nc" id="L515">		return substring(start, end);</span>
	}

	/** Searches for the first index of the specified character. The search for the character starts at the beginning and moves
	 * towards the end.
	 * 
	 * @param string the string to find.
	 * @return the index of the specified character, -1 if the character isn't found.
	 * @see #lastIndexOf(String)
	 * @since 1.4 */
	public int indexOf (String string) {
<span class="nc" id="L526">		return indexOf(string, 0);</span>
	}

	/** Searches for the index of the specified character. The search for the character starts at the specified offset and moves
	 * towards the end.
	 * 
	 * @param subString the string to find.
	 * @param start the starting offset.
	 * @return the index of the specified character, -1 if the character isn't found
	 * @see #lastIndexOf(String,int)
	 * @since 1.4 */
	public int indexOf (String subString, int start) {
<span class="nc bnc" id="L538" title="All 2 branches missed.">		if (start &lt; 0) {</span>
<span class="nc" id="L539">			start = 0;</span>
		}
<span class="nc" id="L541">		int subCount = subString.length();</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">		if (subCount &gt; 0) {</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">			if (subCount + start &gt; length) {</span>
<span class="nc" id="L544">				return -1;</span>
			}
<span class="nc" id="L546">			char firstChar = subString.charAt(0);</span>
			while (true) {
<span class="nc" id="L548">				int i = start;</span>
<span class="nc" id="L549">				boolean found = false;</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">				for (; i &lt; length; i++) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">					if (chars[i] == firstChar) {</span>
<span class="nc" id="L552">						found = true;</span>
<span class="nc" id="L553">						break;</span>
					}
				}
<span class="nc bnc" id="L556" title="All 4 branches missed.">				if (!found || subCount + i &gt; length) {</span>
<span class="nc" id="L557">					return -1; // handles subCount &gt; count || start &gt;= count</span>
				}
<span class="nc" id="L559">				int o1 = i, o2 = 0;</span>
<span class="nc bnc" id="L560" title="All 4 branches missed.">				while (++o2 &lt; subCount &amp;&amp; chars[++o1] == subString.charAt(o2)) {</span>
					// Intentionally empty
				}
<span class="nc bnc" id="L563" title="All 2 branches missed.">				if (o2 == subCount) {</span>
<span class="nc" id="L564">					return i;</span>
				}
<span class="nc" id="L566">				start = i + 1;</span>
<span class="nc" id="L567">			}</span>
		}
<span class="nc bnc" id="L569" title="All 4 branches missed.">		return start &lt; length || start == 0 ? start : length;</span>
	}

	/** Searches for the last index of the specified character. The search for the character starts at the end and moves towards the
	 * beginning.
	 * 
	 * @param string the string to find.
	 * @return the index of the specified character, -1 if the character isn't found.
	 * @throws NullPointerException if {@code string} is {@code null}.
	 * @see String#lastIndexOf(java.lang.String)
	 * @since 1.4 */
	public int lastIndexOf (String string) {
<span class="nc" id="L581">		return lastIndexOf(string, length);</span>
	}

	/** Searches for the index of the specified character. The search for the character starts at the specified offset and moves
	 * towards the beginning.
	 * 
	 * @param subString the string to find.
	 * @param start the starting offset.
	 * @return the index of the specified character, -1 if the character isn't found.
	 * @throws NullPointerException if {@code subString} is {@code null}.
	 * @see String#lastIndexOf(String,int)
	 * @since 1.4 */
	public int lastIndexOf (String subString, int start) {
<span class="nc" id="L594">		int subCount = subString.length();</span>
<span class="nc bnc" id="L595" title="All 4 branches missed.">		if (subCount &lt;= length &amp;&amp; start &gt;= 0) {</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">			if (subCount &gt; 0) {</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">				if (start &gt; length - subCount) {</span>
<span class="nc" id="L598">					start = length - subCount; // count and subCount are both</span>
				}
				// &gt;= 1
<span class="nc" id="L601">				char firstChar = subString.charAt(0);</span>
				while (true) {
<span class="nc" id="L603">					int i = start;</span>
<span class="nc" id="L604">					boolean found = false;</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">					for (; i &gt;= 0; --i) {</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">						if (chars[i] == firstChar) {</span>
<span class="nc" id="L607">							found = true;</span>
<span class="nc" id="L608">							break;</span>
						}
					}
<span class="nc bnc" id="L611" title="All 2 branches missed.">					if (!found) {</span>
<span class="nc" id="L612">						return -1;</span>
					}
<span class="nc" id="L614">					int o1 = i, o2 = 0;</span>
<span class="nc bnc" id="L615" title="All 4 branches missed.">					while (++o2 &lt; subCount &amp;&amp; chars[++o1] == subString.charAt(o2)) {</span>
						// Intentionally empty
					}
<span class="nc bnc" id="L618" title="All 2 branches missed.">					if (o2 == subCount) {</span>
<span class="nc" id="L619">						return i;</span>
					}
<span class="nc" id="L621">					start = i - 1;</span>
<span class="nc" id="L622">				}</span>
			}
<span class="nc bnc" id="L624" title="All 2 branches missed.">			return start &lt; length ? start : length;</span>
		}
<span class="nc" id="L626">		return -1;</span>
	}

	/** Trims off any extra capacity beyond the current length. Note, this method is NOT guaranteed to change the capacity of this
	 * object.
	 * 
	 * @since 1.5 */
	public void trimToSize () {
<span class="nc bnc" id="L634" title="All 2 branches missed.">		if (length &lt; chars.length) {</span>
<span class="nc" id="L635">			char[] newValue = new char[length];</span>
<span class="nc" id="L636">			System.arraycopy(chars, 0, newValue, 0, length);</span>
<span class="nc" id="L637">			chars = newValue;</span>
		}
<span class="nc" id="L639">	}</span>

	/** Retrieves the Unicode code point value at the {@code index}.
	 * 
	 * @param index the index to the {@code char} code unit.
	 * @return the Unicode code point value.
	 * @throws IndexOutOfBoundsException if {@code index} is negative or greater than or equal to {@link #length()}.
	 * @see Character
	 * @see Character#codePointAt(char[], int, int)
	 * @since 1.5 */
	public int codePointAt (int index) {
<span class="nc bnc" id="L650" title="All 4 branches missed.">		if (index &lt; 0 || index &gt;= length) {</span>
<span class="nc" id="L651">			throw new StringIndexOutOfBoundsException(index);</span>
		}
<span class="nc" id="L653">		return Character.codePointAt(chars, index, length);</span>
	}

	/** Retrieves the Unicode code point value that precedes the {@code index}.
	 * 
	 * @param index the index to the {@code char} code unit within this object.
	 * @return the Unicode code point value.
	 * @throws IndexOutOfBoundsException if {@code index} is less than 1 or greater than {@link #length()}.
	 * @see Character
	 * @see Character#codePointBefore(char[], int, int)
	 * @since 1.5 */
	public int codePointBefore (int index) {
<span class="nc bnc" id="L665" title="All 4 branches missed.">		if (index &lt; 1 || index &gt; length) {</span>
<span class="nc" id="L666">			throw new StringIndexOutOfBoundsException(index);</span>
		}
<span class="nc" id="L668">		return Character.codePointBefore(chars, index);</span>
	}

	/** Calculates the number of Unicode code points between {@code beginIndex} and {@code endIndex}.
	 * 
	 * @param beginIndex the inclusive beginning index of the subsequence.
	 * @param endIndex the exclusive end index of the subsequence.
	 * @return the number of Unicode code points in the subsequence.
	 * @throws IndexOutOfBoundsException if {@code beginIndex} is negative or greater than {@code endIndex} or {@code endIndex} is
	 *            greater than {@link #length()}.
	 * @see Character
	 * @see Character#codePointCount(char[], int, int)
	 * @since 1.5 */
	public int codePointCount (int beginIndex, int endIndex) {
<span class="nc bnc" id="L682" title="All 6 branches missed.">		if (beginIndex &lt; 0 || endIndex &gt; length || beginIndex &gt; endIndex) {</span>
<span class="nc" id="L683">			throw new StringIndexOutOfBoundsException();</span>
		}
<span class="nc" id="L685">		return Character.codePointCount(chars, beginIndex, endIndex - beginIndex);</span>
	}

	/** Returns the index that is offset {@code codePointOffset} code points from {@code index}.
	 * 
	 * @param index the index to calculate the offset from.
	 * @param codePointOffset the number of code points to count.
	 * @return the index that is {@code codePointOffset} code points away from index.
	 * @throws IndexOutOfBoundsException if {@code index} is negative or greater than {@link #length()} or if there aren't enough
	 *            code points before or after {@code index} to match {@code codePointOffset}.
	 * @see Character
	 * @see Character#offsetByCodePoints(char[], int, int, int, int)
	 * @since 1.5 */
	public int offsetByCodePoints (int index, int codePointOffset) {
<span class="nc" id="L699">		return Character.offsetByCodePoints(chars, 0, length, index, codePointOffset);</span>
	}

	/** Appends the string representation of the specified {@code boolean} value. The {@code boolean} value is converted to a String
	 * according to the rule defined by {@link String#valueOf(boolean)}.
	 * 
	 * @param b the {@code boolean} value to append.
	 * @return this builder.
	 * @see String#valueOf(boolean) */
	public StringBuilder append (boolean b) {
<span class="nc bnc" id="L709" title="All 2 branches missed.">		append0(b ? &quot;true&quot; : &quot;false&quot;); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L710">		return this;</span>
	}

	/** Appends the string representation of the specified {@code char} value. The {@code char} value is converted to a string
	 * according to the rule defined by {@link String#valueOf(char)}.
	 * 
	 * @param c the {@code char} value to append.
	 * @return this builder.
	 * @see String#valueOf(char) */
	public StringBuilder append (char c) {
<span class="fc" id="L720">		append0(c);</span>
<span class="fc" id="L721">		return this;</span>
	}

	/** Appends the string representation of the specified {@code int} value. The {@code int} value is converted to a string without
	 * memory allocation.
	 * 
	 * @param value the {@code int} value to append.
	 * @return this builder.
	 * @see String#valueOf(int) */
	public StringBuilder append (int value) {
<span class="nc" id="L731">		return append(value, 0);</span>
	}

	/** Appends the string representation of the specified {@code int} value. The {@code int} value is converted to a string without
	 * memory allocation.
	 * 
	 * @param value the {@code int} value to append.
	 * @param minLength the minimum number of characters to add
	 * @return this builder.
	 * @see String#valueOf(int) */
	public StringBuilder append (int value, int minLength) {
<span class="nc" id="L742">		return append(value, minLength, '0');</span>
	}

	/** Appends the string representation of the specified {@code int} value. The {@code int} value is converted to a string without
	 * memory allocation.
	 * 
	 * @param value the {@code int} value to append.
	 * @param minLength the minimum number of characters to add
	 * @param prefix the character to use as prefix
	 * @return this builder.
	 * @see String#valueOf(int) */
	public StringBuilder append (int value, final int minLength, final char prefix) {
<span class="nc bnc" id="L754" title="All 2 branches missed.">		if (value == Integer.MIN_VALUE) {</span>
<span class="nc" id="L755">			append0(&quot;-2147483648&quot;);</span>
<span class="nc" id="L756">			return this;</span>
		}
<span class="nc bnc" id="L758" title="All 2 branches missed.">		if (value &lt; 0) {</span>
<span class="nc" id="L759">			append0('-');</span>
<span class="nc" id="L760">			value = -value;</span>
		}
<span class="nc bnc" id="L762" title="All 2 branches missed.">		if (minLength &gt; 1) {</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">			for (int j = minLength - numChars(value, 10); j &gt; 0; --j)</span>
<span class="nc" id="L764">				append(prefix);</span>
		}
<span class="nc bnc" id="L766" title="All 2 branches missed.">		if (value &gt;= 10000) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">			if (value &gt;= 1000000000) append0(digits[(int)((long)value % 10000000000L / 1000000000L)]);</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">			if (value &gt;= 100000000) append0(digits[value % 1000000000 / 100000000]);</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">			if (value &gt;= 10000000) append0(digits[value % 100000000 / 10000000]);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">			if (value &gt;= 1000000) append0(digits[value % 10000000 / 1000000]);</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">			if (value &gt;= 100000) append0(digits[value % 1000000 / 100000]);</span>
<span class="nc" id="L772">			append0(digits[value % 100000 / 10000]);</span>
		}
<span class="nc bnc" id="L774" title="All 2 branches missed.">		if (value &gt;= 1000) append0(digits[value % 10000 / 1000]);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">		if (value &gt;= 100) append0(digits[value % 1000 / 100]);</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">		if (value &gt;= 10) append0(digits[value % 100 / 10]);</span>
<span class="nc" id="L777">		append0(digits[value % 10]);</span>
<span class="nc" id="L778">		return this;</span>
	}

	/** Appends the string representation of the specified {@code long} value. The {@code long} value is converted to a string
	 * without memory allocation.
	 * 
	 * @param value the {@code long} value.
	 * @return this builder. */
	public StringBuilder append (long value) {
<span class="nc" id="L787">		return append(value, 0);</span>
	}

	/** Appends the string representation of the specified {@code long} value. The {@code long} value is converted to a string
	 * without memory allocation.
	 * 
	 * @param value the {@code long} value.
	 * @param minLength the minimum number of characters to add
	 * @return this builder. */
	public StringBuilder append (long value, int minLength) {
<span class="nc" id="L797">		return append(value, minLength, '0');</span>
	}

	/** Appends the string representation of the specified {@code long} value. The {@code long} value is converted to a string
	 * without memory allocation.
	 * 
	 * @param value the {@code long} value.
	 * @param minLength the minimum number of characters to add
	 * @param prefix the character to use as prefix
	 * @return this builder. */
	public StringBuilder append (long value, int minLength, char prefix) {
<span class="nc bnc" id="L808" title="All 2 branches missed.">		if (value == Long.MIN_VALUE) {</span>
<span class="nc" id="L809">			append0(&quot;-9223372036854775808&quot;);</span>
<span class="nc" id="L810">			return this;</span>
		}
<span class="nc bnc" id="L812" title="All 2 branches missed.">		if (value &lt; 0L) {</span>
<span class="nc" id="L813">			append0('-');</span>
<span class="nc" id="L814">			value = -value;</span>
		}
<span class="nc bnc" id="L816" title="All 2 branches missed.">		if (minLength &gt; 1) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">			for (int j = minLength - numChars(value, 10); j &gt; 0; --j)</span>
<span class="nc" id="L818">				append(prefix);</span>
		}
<span class="nc bnc" id="L820" title="All 2 branches missed.">		if (value &gt;= 10000) {</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">			if (value &gt;= 1000000000000000000L) append0(digits[(int)(value % 10000000000000000000D / 1000000000000000000L)]);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">			if (value &gt;= 100000000000000000L) append0(digits[(int)(value % 1000000000000000000L / 100000000000000000L)]);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">			if (value &gt;= 10000000000000000L) append0(digits[(int)(value % 100000000000000000L / 10000000000000000L)]);</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">			if (value &gt;= 1000000000000000L) append0(digits[(int)(value % 10000000000000000L / 1000000000000000L)]);</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">			if (value &gt;= 100000000000000L) append0(digits[(int)(value % 1000000000000000L / 100000000000000L)]);</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">			if (value &gt;= 10000000000000L) append0(digits[(int)(value % 100000000000000L / 10000000000000L)]);</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">			if (value &gt;= 1000000000000L) append0(digits[(int)(value % 10000000000000L / 1000000000000L)]);</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">			if (value &gt;= 100000000000L) append0(digits[(int)(value % 1000000000000L / 100000000000L)]);</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">			if (value &gt;= 10000000000L) append0(digits[(int)(value % 100000000000L / 10000000000L)]);</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">			if (value &gt;= 1000000000L) append0(digits[(int)(value % 10000000000L / 1000000000L)]);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">			if (value &gt;= 100000000L) append0(digits[(int)(value % 1000000000L / 100000000L)]);</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">			if (value &gt;= 10000000L) append0(digits[(int)(value % 100000000L / 10000000L)]);</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">			if (value &gt;= 1000000L) append0(digits[(int)(value % 10000000L / 1000000L)]);</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">			if (value &gt;= 100000L) append0(digits[(int)(value % 1000000L / 100000L)]);</span>
<span class="nc" id="L835">			append0(digits[(int)(value % 100000L / 10000L)]);</span>
		}
<span class="nc bnc" id="L837" title="All 2 branches missed.">		if (value &gt;= 1000L) append0(digits[(int)(value % 10000L / 1000L)]);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">		if (value &gt;= 100L) append0(digits[(int)(value % 1000L / 100L)]);</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">		if (value &gt;= 10L) append0(digits[(int)(value % 100L / 10L)]);</span>
<span class="nc" id="L840">		append0(digits[(int)(value % 10L)]);</span>
<span class="nc" id="L841">		return this;</span>
	}

	/** Appends the string representation of the specified {@code float} value. The {@code float} value is converted to a string
	 * according to the rule defined by {@link String#valueOf(float)}.
	 * 
	 * @param f the {@code float} value to append.
	 * @return this builder. */
	public StringBuilder append (float f) {
<span class="nc" id="L850">		append0(Float.toString(f));</span>
<span class="nc" id="L851">		return this;</span>
	}

	/** Appends the string representation of the specified {@code double} value. The {@code double} value is converted to a string
	 * according to the rule defined by {@link String#valueOf(double)}.
	 * 
	 * @param d the {@code double} value to append.
	 * @return this builder.
	 * @see String#valueOf(double) */
	public StringBuilder append (double d) {
<span class="nc" id="L861">		append0(Double.toString(d));</span>
<span class="nc" id="L862">		return this;</span>
	}

	/** Appends the string representation of the specified {@code Object}. The {@code Object} value is converted to a string
	 * according to the rule defined by {@link String#valueOf(Object)}.
	 * 
	 * @param obj the {@code Object} to append.
	 * @return this builder.
	 * @see String#valueOf(Object) */
	public StringBuilder append (Object obj) {
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L873">			appendNull();</span>
		} else {
<span class="fc" id="L875">			append0(obj.toString());</span>
		}
<span class="fc" id="L877">		return this;</span>
	}

	/** Appends the contents of the specified string. If the string is {@code null}, then the string {@code &quot;null&quot;} is appended.
	 * 
	 * @param str the string to append.
	 * @return this builder. */
	public StringBuilder append (String str) {
<span class="fc" id="L885">		append0(str);</span>
<span class="fc" id="L886">		return this;</span>
	}

	/** Appends the string representation of the specified {@code char[]}. The {@code char[]} is converted to a string according to
	 * the rule defined by {@link String#valueOf(char[])}.
	 * 
	 * @param ch the {@code char[]} to append..
	 * @return this builder.
	 * @see String#valueOf(char[]) */
	public StringBuilder append (char[] ch) {
<span class="nc" id="L896">		append0(ch);</span>
<span class="nc" id="L897">		return this;</span>
	}

	/** Appends the string representation of the specified subset of the {@code char[]}. The {@code char[]} value is converted to a
	 * String according to the rule defined by {@link String#valueOf(char[],int,int)}.
	 * 
	 * @param str the {@code char[]} to append.
	 * @param offset the inclusive offset index.
	 * @param len the number of characters.
	 * @return this builder.
	 * @throws ArrayIndexOutOfBoundsException if {@code offset} and {@code len} do not specify a valid subsequence.
	 * @see String#valueOf(char[],int,int) */
	public StringBuilder append (char[] str, int offset, int len) {
<span class="nc" id="L910">		append0(str, offset, len);</span>
<span class="nc" id="L911">		return this;</span>
	}

	/** Appends the string representation of the specified {@code CharSequence}. If the {@code CharSequence} is {@code null}, then
	 * the string {@code &quot;null&quot;} is appended.
	 * 
	 * @param csq the {@code CharSequence} to append.
	 * @return this builder. */
	public StringBuilder append (CharSequence csq) {
<span class="nc bnc" id="L920" title="All 2 branches missed.">		if (csq == null) {</span>
<span class="nc" id="L921">			appendNull();</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">		} else if (csq instanceof StringBuilder) {</span>
<span class="nc" id="L923">			StringBuilder builder = (StringBuilder)csq;</span>
<span class="nc" id="L924">			append0(builder.chars, 0, builder.length);</span>
<span class="nc" id="L925">		} else {</span>
<span class="nc" id="L926">			append0(csq.toString());</span>
		}
<span class="nc" id="L928">		return this;</span>
	}

	public StringBuilder append (StringBuilder builder) {
<span class="nc bnc" id="L932" title="All 2 branches missed.">		if (builder == null)</span>
<span class="nc" id="L933">			appendNull();</span>
		else
<span class="nc" id="L935">			append0(builder.chars, 0, builder.length);</span>
<span class="nc" id="L936">		return this;</span>
	}

	/** Appends the string representation of the specified subsequence of the {@code CharSequence}. If the {@code CharSequence} is
	 * {@code null}, then the string {@code &quot;null&quot;} is used to extract the subsequence from.
	 * 
	 * @param csq the {@code CharSequence} to append.
	 * @param start the beginning index.
	 * @param end the ending index.
	 * @return this builder.
	 * @throws IndexOutOfBoundsException if {@code start} or {@code end} are negative, {@code start} is greater than {@code end} or
	 *            {@code end} is greater than the length of {@code csq}. */
	public StringBuilder append (CharSequence csq, int start, int end) {
<span class="nc" id="L949">		append0(csq, start, end);</span>
<span class="nc" id="L950">		return this;</span>
	}

	public StringBuilder append (StringBuilder builder, int start, int end) {
<span class="nc bnc" id="L954" title="All 2 branches missed.">		if (builder == null)</span>
<span class="nc" id="L955">			appendNull();</span>
		else
<span class="nc" id="L957">			append0(builder.chars, start, end);</span>
<span class="nc" id="L958">		return this;</span>
	}

	/** Appends the encoded Unicode code point. The code point is converted to a {@code char[]} as defined by
	 * {@link Character#toChars(int)}.
	 * 
	 * @param codePoint the Unicode code point to encode and append.
	 * @return this builder.
	 * @see Character#toChars(int) */
	public StringBuilder appendCodePoint (int codePoint) {
<span class="nc" id="L968">		append0(Character.toChars(codePoint));</span>
<span class="nc" id="L969">		return this;</span>
	}

	/** Deletes a sequence of characters specified by {@code start} and {@code end}. Shifts any remaining characters to the left.
	 * 
	 * @param start the inclusive start index.
	 * @param end the exclusive end index.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code start} is less than zero, greater than the current length or greater than
	 *            {@code end}. */
	public StringBuilder delete (int start, int end) {
<span class="nc" id="L980">		delete0(start, end);</span>
<span class="nc" id="L981">		return this;</span>
	}

	/** Deletes the character at the specified index. shifts any remaining characters to the left.
	 * 
	 * @param index the index of the character to delete.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code index} is less than zero or is greater than or equal to the current
	 *            length. */
	public StringBuilder deleteCharAt (int index) {
<span class="nc" id="L991">		deleteCharAt0(index);</span>
<span class="nc" id="L992">		return this;</span>
	}

	/** Inserts the string representation of the specified {@code boolean} value at the specified {@code offset}. The
	 * {@code boolean} value is converted to a string according to the rule defined by {@link String#valueOf(boolean)}.
	 * 
	 * @param offset the index to insert at.
	 * @param b the {@code boolean} value to insert.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length}.
	 * @see String#valueOf(boolean) */
	public StringBuilder insert (int offset, boolean b) {
<span class="nc bnc" id="L1004" title="All 2 branches missed.">		insert0(offset, b ? &quot;true&quot; : &quot;false&quot;); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L1005">		return this;</span>
	}

	/** Inserts the string representation of the specified {@code char} value at the specified {@code offset}. The {@code char}
	 * value is converted to a string according to the rule defined by {@link String#valueOf(char)}.
	 * 
	 * @param offset the index to insert at.
	 * @param c the {@code char} value to insert.
	 * @return this builder.
	 * @throws IndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length()}.
	 * @see String#valueOf(char) */
	public StringBuilder insert (int offset, char c) {
<span class="nc" id="L1017">		insert0(offset, c);</span>
<span class="nc" id="L1018">		return this;</span>
	}

	/** Inserts the string representation of the specified {@code int} value at the specified {@code offset}. The {@code int} value
	 * is converted to a String according to the rule defined by {@link String#valueOf(int)}.
	 * 
	 * @param offset the index to insert at.
	 * @param i the {@code int} value to insert.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length()}.
	 * @see String#valueOf(int) */
	public StringBuilder insert (int offset, int i) {
<span class="nc" id="L1030">		insert0(offset, Integer.toString(i));</span>
<span class="nc" id="L1031">		return this;</span>
	}

	/** Inserts the string representation of the specified {@code long} value at the specified {@code offset}. The {@code long}
	 * value is converted to a String according to the rule defined by {@link String#valueOf(long)}.
	 * 
	 * @param offset the index to insert at.
	 * @param l the {@code long} value to insert.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code offset} is negative or greater than the current {code length()}.
	 * @see String#valueOf(long) */
	public StringBuilder insert (int offset, long l) {
<span class="nc" id="L1043">		insert0(offset, Long.toString(l));</span>
<span class="nc" id="L1044">		return this;</span>
	}

	/** Inserts the string representation of the specified {@code float} value at the specified {@code offset}. The {@code float}
	 * value is converted to a string according to the rule defined by {@link String#valueOf(float)}.
	 * 
	 * @param offset the index to insert at.
	 * @param f the {@code float} value to insert.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length()}.
	 * @see String#valueOf(float) */
	public StringBuilder insert (int offset, float f) {
<span class="nc" id="L1056">		insert0(offset, Float.toString(f));</span>
<span class="nc" id="L1057">		return this;</span>
	}

	/** Inserts the string representation of the specified {@code double} value at the specified {@code offset}. The {@code double}
	 * value is converted to a String according to the rule defined by {@link String#valueOf(double)}.
	 * 
	 * @param offset the index to insert at.
	 * @param d the {@code double} value to insert.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length()}.
	 * @see String#valueOf(double) */
	public StringBuilder insert (int offset, double d) {
<span class="nc" id="L1069">		insert0(offset, Double.toString(d));</span>
<span class="nc" id="L1070">		return this;</span>
	}

	/** Inserts the string representation of the specified {@code Object} at the specified {@code offset}. The {@code Object} value
	 * is converted to a String according to the rule defined by {@link String#valueOf(Object)}.
	 * 
	 * @param offset the index to insert at.
	 * @param obj the {@code Object} to insert.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length()}.
	 * @see String#valueOf(Object) */
	public StringBuilder insert (int offset, Object obj) {
<span class="nc bnc" id="L1082" title="All 2 branches missed.">		insert0(offset, obj == null ? &quot;null&quot; : obj.toString()); //$NON-NLS-1$</span>
<span class="nc" id="L1083">		return this;</span>
	}

	/** Inserts the specified string at the specified {@code offset}. If the specified string is null, then the String
	 * {@code &quot;null&quot;} is inserted.
	 * 
	 * @param offset the index to insert at.
	 * @param str the {@code String} to insert.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length()}. */
	public StringBuilder insert (int offset, String str) {
<span class="nc" id="L1094">		insert0(offset, str);</span>
<span class="nc" id="L1095">		return this;</span>
	}

	/** Inserts the string representation of the specified {@code char[]} at the specified {@code offset}. The {@code char[]} value
	 * is converted to a String according to the rule defined by {@link String#valueOf(char[])}.
	 * 
	 * @param offset the index to insert at.
	 * @param ch the {@code char[]} to insert.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length()}.
	 * @see String#valueOf(char[]) */
	public StringBuilder insert (int offset, char[] ch) {
<span class="nc" id="L1107">		insert0(offset, ch);</span>
<span class="nc" id="L1108">		return this;</span>
	}

	/** Inserts the string representation of the specified subsequence of the {@code char[]} at the specified {@code offset}. The
	 * {@code char[]} value is converted to a String according to the rule defined by {@link String#valueOf(char[],int,int)}.
	 * 
	 * @param offset the index to insert at.
	 * @param str the {@code char[]} to insert.
	 * @param strOffset the inclusive index.
	 * @param strLen the number of characters.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length()}, or
	 *            {@code strOffset} and {@code strLen} do not specify a valid subsequence.
	 * @see String#valueOf(char[],int,int) */
	public StringBuilder insert (int offset, char[] str, int strOffset, int strLen) {
<span class="nc" id="L1123">		insert0(offset, str, strOffset, strLen);</span>
<span class="nc" id="L1124">		return this;</span>
	}

	/** Inserts the string representation of the specified {@code CharSequence} at the specified {@code offset}. The
	 * {@code CharSequence} is converted to a String as defined by {@link CharSequence#toString()}. If {@code s} is {@code null},
	 * then the String {@code &quot;null&quot;} is inserted.
	 * 
	 * @param offset the index to insert at.
	 * @param s the {@code CharSequence} to insert.
	 * @return this builder.
	 * @throws IndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length()}.
	 * @see CharSequence#toString() */
	public StringBuilder insert (int offset, CharSequence s) {
<span class="nc bnc" id="L1137" title="All 2 branches missed.">		insert0(offset, s == null ? &quot;null&quot; : s.toString()); //$NON-NLS-1$</span>
<span class="nc" id="L1138">		return this;</span>
	}

	/** Inserts the string representation of the specified subsequence of the {@code CharSequence} at the specified {@code offset}.
	 * The {@code CharSequence} is converted to a String as defined by {@link CharSequence#subSequence(int, int)}. If the
	 * {@code CharSequence} is {@code null}, then the string {@code &quot;null&quot;} is used to determine the subsequence.
	 * 
	 * @param offset the index to insert at.
	 * @param s the {@code CharSequence} to insert.
	 * @param start the start of the subsequence of the character sequence.
	 * @param end the end of the subsequence of the character sequence.
	 * @return this builder.
	 * @throws IndexOutOfBoundsException if {@code offset} is negative or greater than the current {@code length()}, or
	 *            {@code start} and {@code end} do not specify a valid subsequence.
	 * @see CharSequence#subSequence(int, int) */
	public StringBuilder insert (int offset, CharSequence s, int start, int end) {
<span class="nc" id="L1154">		insert0(offset, s, start, end);</span>
<span class="nc" id="L1155">		return this;</span>
	}

	/** Replaces the specified subsequence in this builder with the specified string.
	 * 
	 * @param start the inclusive begin index.
	 * @param end the exclusive end index.
	 * @param str the replacement string.
	 * @return this builder.
	 * @throws StringIndexOutOfBoundsException if {@code start} is negative, greater than the current {@code length()} or greater
	 *            than {@code end}.
	 * @throws NullPointerException if {@code str} is {@code null}. */
	public StringBuilder replace (int start, int end, String str) {
<span class="nc" id="L1168">		replace0(start, end, str);</span>
<span class="nc" id="L1169">		return this;</span>
	}

	/** Replaces all instances of {@code find} with {@code replace}. */
	public StringBuilder replace (String find, String replace) {
<span class="nc" id="L1174">		int findLength = find.length(), replaceLength = replace.length();</span>
<span class="nc" id="L1175">		int index = 0;</span>
		while (true) {
<span class="nc" id="L1177">			index = indexOf(find, index);</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">			if (index == -1) break;</span>
<span class="nc" id="L1179">			replace0(index, index + findLength, replace);</span>
<span class="nc" id="L1180">			index += replaceLength;</span>
		}
<span class="nc" id="L1182">		return this;</span>
	}

	/** Replaces all instances of {@code find} with {@code replace}. */
	public StringBuilder replace (char find, String replace) {
<span class="nc" id="L1187">		int replaceLength = replace.length();</span>
<span class="nc" id="L1188">		int index = 0;</span>
		while (true) {
			while (true) {
<span class="nc bnc" id="L1191" title="All 2 branches missed.">				if (index == length) return this;</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">				if (chars[index] == find) break;</span>
<span class="nc" id="L1193">				index++;</span>
			}
<span class="nc" id="L1195">			replace0(index, index + 1, replace);</span>
<span class="nc" id="L1196">			index += replaceLength;</span>
		}
	}

	/** Reverses the order of characters in this builder.
	 * 
	 * @return this buffer. */
	public StringBuilder reverse () {
<span class="nc" id="L1204">		reverse0();</span>
<span class="nc" id="L1205">		return this;</span>
	}

	public int hashCode () {
<span class="nc" id="L1209">		final int prime = 31;</span>
<span class="nc" id="L1210">		int result = 1;</span>
<span class="nc" id="L1211">		result = prime + length;</span>
<span class="nc" id="L1212">		result = prime * result + Arrays.hashCode(chars);</span>
<span class="nc" id="L1213">		return result;</span>
	}

	public boolean equals (Object obj) {
<span class="nc bnc" id="L1217" title="All 2 branches missed.">		if (this == obj) return true;</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">		if (obj == null) return false;</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">		if (getClass() != obj.getClass()) return false;</span>
<span class="nc" id="L1220">		StringBuilder other = (StringBuilder)obj;</span>
<span class="nc" id="L1221">		int length = this.length;</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">		if (length != other.length) return false;</span>
<span class="nc" id="L1223">		char[] chars = this.chars;</span>
<span class="nc" id="L1224">		char[] chars2 = other.chars;</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">		if (chars == chars2) return true;</span>
<span class="nc bnc" id="L1226" title="All 4 branches missed.">		if (chars == null || chars2 == null) return false;</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">		for (int i = 0; i &lt; length; i++)</span>
<span class="nc bnc" id="L1228" title="All 2 branches missed.">			if (chars[i] != chars2[i]) return false;</span>
<span class="nc" id="L1229">		return true;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>