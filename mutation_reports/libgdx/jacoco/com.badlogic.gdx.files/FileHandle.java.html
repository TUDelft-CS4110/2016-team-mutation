<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FileHandle.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.files</a> &gt; <span class="el_source">FileHandle.java</span></div><h1>FileHandle.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.files;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;

import com.badlogic.gdx.Files;
import com.badlogic.gdx.Files.FileType;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.StreamUtils;

/** Represents a file or directory on the filesystem, classpath, Android SD card, or Android assets directory. FileHandles are
 * created via a {@link Files} instance.
 * 
 * Because some of the file types are backed by composite files and may be compressed (for example, if they are in an Android .apk
 * or are found via the classpath), the methods for extracting a {@link #path()} or {@link #file()} may not be appropriate for all
 * types. Use the Reader or Stream methods here to hide these dependencies from your platform independent code.
 * 
 * @author mzechner
 * @author Nathan Sweet */
public class FileHandle {
	protected File file;
	protected FileType type;

<span class="nc" id="L55">	protected FileHandle () {</span>
<span class="nc" id="L56">	}</span>

	/** Creates a new absolute FileHandle for the file name. Use this for tools on the desktop that don't need any of the backends.
	 * Do not use this constructor in case you write something cross-platform. Use the {@link Files} interface instead.
	 * @param fileName the filename. */
<span class="nc" id="L61">	public FileHandle (String fileName) {</span>
<span class="nc" id="L62">		this.file = new File(fileName);</span>
<span class="nc" id="L63">		this.type = FileType.Absolute;</span>
<span class="nc" id="L64">	}</span>

	/** Creates a new absolute FileHandle for the {@link File}. Use this for tools on the desktop that don't need any of the
	 * backends. Do not use this constructor in case you write something cross-platform. Use the {@link Files} interface instead.
	 * @param file the file. */
<span class="nc" id="L69">	public FileHandle (File file) {</span>
<span class="nc" id="L70">		this.file = file;</span>
<span class="nc" id="L71">		this.type = FileType.Absolute;</span>
<span class="nc" id="L72">	}</span>

<span class="nc" id="L74">	protected FileHandle (String fileName, FileType type) {</span>
<span class="nc" id="L75">		this.type = type;</span>
<span class="nc" id="L76">		file = new File(fileName);</span>
<span class="nc" id="L77">	}</span>

<span class="nc" id="L79">	protected FileHandle (File file, FileType type) {</span>
<span class="nc" id="L80">		this.file = file;</span>
<span class="nc" id="L81">		this.type = type;</span>
<span class="nc" id="L82">	}</span>

	/** @return the path of the file as specified on construction, e.g. Gdx.files.internal(&quot;dir/file.png&quot;) -&gt; dir/file.png. backward
	 *         slashes will be replaced by forward slashes. */
	public String path () {
<span class="nc" id="L87">		return file.getPath().replace('\\', '/');</span>
	}

	/** @return the name of the file, without any parent paths. */
	public String name () {
<span class="nc" id="L92">		return file.getName();</span>
	}

	public String extension () {
<span class="nc" id="L96">		String name = file.getName();</span>
<span class="nc" id="L97">		int dotIndex = name.lastIndexOf('.');</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">		if (dotIndex == -1) return &quot;&quot;;</span>
<span class="nc" id="L99">		return name.substring(dotIndex + 1);</span>
	}

	/** @return the name of the file, without parent paths or the extension. */
	public String nameWithoutExtension () {
<span class="nc" id="L104">		String name = file.getName();</span>
<span class="nc" id="L105">		int dotIndex = name.lastIndexOf('.');</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">		if (dotIndex == -1) return name;</span>
<span class="nc" id="L107">		return name.substring(0, dotIndex);</span>
	}

	/** @return the path and filename without the extension, e.g. dir/dir2/file.png -&gt; dir/dir2/file. backward slashes will be
	 *         returned as forward slashes. */
	public String pathWithoutExtension () {
<span class="nc" id="L113">		String path = file.getPath().replace('\\', '/');</span>
<span class="nc" id="L114">		int dotIndex = path.lastIndexOf('.');</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">		if (dotIndex == -1) return path;</span>
<span class="nc" id="L116">		return path.substring(0, dotIndex);</span>
	}

	public FileType type () {
<span class="nc" id="L120">		return type;</span>
	}

	/** Returns a java.io.File that represents this file handle. Note the returned file will only be usable for
	 * {@link FileType#Absolute} and {@link FileType#External} file handles. */
	public File file () {
<span class="nc bnc" id="L126" title="All 2 branches missed.">		if (type == FileType.External) return new File(Gdx.files.getExternalStoragePath(), file.getPath());</span>
<span class="nc" id="L127">		return file;</span>
	}

	/** Returns a stream for reading this file as bytes.
	 * @throws GdxRuntimeException if the file handle represents a directory, doesn't exist, or could not be read. */
	public InputStream read () {
<span class="nc bnc" id="L133" title="All 10 branches missed.">		if (type == FileType.Classpath || (type == FileType.Internal &amp;&amp; !file().exists())</span>
			|| (type == FileType.Local &amp;&amp; !file().exists())) {
<span class="nc" id="L135">			InputStream input = FileHandle.class.getResourceAsStream(&quot;/&quot; + file.getPath().replace('\\', '/'));</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">			if (input == null) throw new GdxRuntimeException(&quot;File not found: &quot; + file + &quot; (&quot; + type + &quot;)&quot;);</span>
<span class="nc" id="L137">			return input;</span>
		}
		try {
<span class="nc" id="L140">			return new FileInputStream(file());</span>
<span class="nc" id="L141">		} catch (Exception ex) {</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">			if (file().isDirectory())</span>
<span class="nc" id="L143">				throw new GdxRuntimeException(&quot;Cannot open a stream to a directory: &quot; + file + &quot; (&quot; + type + &quot;)&quot;, ex);</span>
<span class="nc" id="L144">			throw new GdxRuntimeException(&quot;Error reading file: &quot; + file + &quot; (&quot; + type + &quot;)&quot;, ex);</span>
		}
	}

	/** Returns a buffered stream for reading this file as bytes.
	 * @throws GdxRuntimeException if the file handle represents a directory, doesn't exist, or could not be read. */
	public BufferedInputStream read (int bufferSize) {
<span class="nc" id="L151">		return new BufferedInputStream(read(), bufferSize);</span>
	}

	/** Returns a reader for reading this file as characters.
	 * @throws GdxRuntimeException if the file handle represents a directory, doesn't exist, or could not be read. */
	public Reader reader () {
<span class="nc" id="L157">		return new InputStreamReader(read());</span>
	}

	/** Returns a reader for reading this file as characters.
	 * @throws GdxRuntimeException if the file handle represents a directory, doesn't exist, or could not be read. */
	public Reader reader (String charset) {
<span class="nc" id="L163">		InputStream stream = read();</span>
		try {
<span class="nc" id="L165">			return new InputStreamReader(stream, charset);</span>
<span class="nc" id="L166">		} catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L167">			StreamUtils.closeQuietly(stream);</span>
<span class="nc" id="L168">			throw new GdxRuntimeException(&quot;Error reading file: &quot; + this, ex);</span>
		}
	}

	/** Returns a buffered reader for reading this file as characters.
	 * @throws GdxRuntimeException if the file handle represents a directory, doesn't exist, or could not be read. */
	public BufferedReader reader (int bufferSize) {
<span class="nc" id="L175">		return new BufferedReader(new InputStreamReader(read()), bufferSize);</span>
	}

	/** Returns a buffered reader for reading this file as characters.
	 * @throws GdxRuntimeException if the file handle represents a directory, doesn't exist, or could not be read. */
	public BufferedReader reader (int bufferSize, String charset) {
		try {
<span class="nc" id="L182">			return new BufferedReader(new InputStreamReader(read(), charset), bufferSize);</span>
<span class="nc" id="L183">		} catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L184">			throw new GdxRuntimeException(&quot;Error reading file: &quot; + this, ex);</span>
		}
	}

	/** Reads the entire file into a string using the platform's default charset.
	 * @throws GdxRuntimeException if the file handle represents a directory, doesn't exist, or could not be read. */
	public String readString () {
<span class="nc" id="L191">		return readString(null);</span>
	}

	/** Reads the entire file into a string using the specified charset.
	 * @param charset If null the default charset is used.
	 * @throws GdxRuntimeException if the file handle represents a directory, doesn't exist, or could not be read. */
	public String readString (String charset) {
<span class="nc" id="L198">		StringBuilder output = new StringBuilder(estimateLength());</span>
<span class="nc" id="L199">		InputStreamReader reader = null;</span>
		try {
<span class="nc bnc" id="L201" title="All 2 branches missed.">			if (charset == null)</span>
<span class="nc" id="L202">				reader = new InputStreamReader(read());</span>
			else
<span class="nc" id="L204">				reader = new InputStreamReader(read(), charset);</span>
<span class="nc" id="L205">			char[] buffer = new char[256];</span>
			while (true) {
<span class="nc" id="L207">				int length = reader.read(buffer);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">				if (length == -1) break;</span>
<span class="nc" id="L209">				output.append(buffer, 0, length);</span>
<span class="nc" id="L210">			}</span>
<span class="nc" id="L211">		} catch (IOException ex) {</span>
<span class="nc" id="L212">			throw new GdxRuntimeException(&quot;Error reading layout file: &quot; + this, ex);</span>
		} finally {
<span class="nc" id="L214">			StreamUtils.closeQuietly(reader);</span>
<span class="nc" id="L215">		}</span>
<span class="nc" id="L216">		return output.toString();</span>
	}

	/** Reads the entire file into a byte array.
	 * @throws GdxRuntimeException if the file handle represents a directory, doesn't exist, or could not be read. */
	public byte[] readBytes () {
<span class="nc" id="L222">		InputStream input = read();</span>
		try {
<span class="nc" id="L224">			return StreamUtils.copyStreamToByteArray(input, estimateLength());</span>
<span class="nc" id="L225">		} catch (IOException ex) {</span>
<span class="nc" id="L226">			throw new GdxRuntimeException(&quot;Error reading file: &quot; + this, ex);</span>
		} finally {
<span class="nc" id="L228">			StreamUtils.closeQuietly(input);</span>
		}
	}

	private int estimateLength () {
<span class="nc" id="L233">		int length = (int)length();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">		return length != 0 ? length : 512;</span>
	}

	/** Reads the entire file into the byte array. The byte array must be big enough to hold the file's data.
	 * @param bytes the array to load the file into
	 * @param offset the offset to start writing bytes
	 * @param size the number of bytes to read, see {@link #length()}
	 * @return the number of read bytes */
	public int readBytes (byte[] bytes, int offset, int size) {
<span class="nc" id="L243">		InputStream input = read();</span>
<span class="nc" id="L244">		int position = 0;</span>
		try {
			while (true) {
<span class="nc" id="L247">				int count = input.read(bytes, offset + position, size - position);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">				if (count &lt;= 0) break;</span>
<span class="nc" id="L249">				position += count;</span>
<span class="nc" id="L250">			}</span>
<span class="nc" id="L251">		} catch (IOException ex) {</span>
<span class="nc" id="L252">			throw new GdxRuntimeException(&quot;Error reading file: &quot; + this, ex);</span>
		} finally {
<span class="nc" id="L254">			StreamUtils.closeQuietly(input);</span>
<span class="nc" id="L255">		}</span>
<span class="nc" id="L256">		return position - offset;</span>
	}

	/** Returns a stream for writing to this file. Parent directories will be created if necessary.
	 * @param append If false, this file will be overwritten if it exists, otherwise it will be appended.
	 * @throws GdxRuntimeException if this file handle represents a directory, if it is a {@link FileType#Classpath} or
	 *            {@link FileType#Internal} file, or if it could not be written. */
	public OutputStream write (boolean append) {
<span class="nc bnc" id="L264" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot write to a classpath file: &quot; + file);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">		if (type == FileType.Internal) throw new GdxRuntimeException(&quot;Cannot write to an internal file: &quot; + file);</span>
<span class="nc" id="L266">		parent().mkdirs();</span>
		try {
<span class="nc" id="L268">			return new FileOutputStream(file(), append);</span>
<span class="nc" id="L269">		} catch (Exception ex) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">			if (file().isDirectory())</span>
<span class="nc" id="L271">				throw new GdxRuntimeException(&quot;Cannot open a stream to a directory: &quot; + file + &quot; (&quot; + type + &quot;)&quot;, ex);</span>
<span class="nc" id="L272">			throw new GdxRuntimeException(&quot;Error writing file: &quot; + file + &quot; (&quot; + type + &quot;)&quot;, ex);</span>
		}
	}

	/** Returns a buffered stream for writing to this file. Parent directories will be created if necessary.
	 * @param append If false, this file will be overwritten if it exists, otherwise it will be appended.
	 * @param bufferSize The size of the buffer.
	 * @throws GdxRuntimeException if this file handle represents a directory, if it is a {@link FileType#Classpath} or
	 *            {@link FileType#Internal} file, or if it could not be written. */
	public OutputStream write (boolean append, int bufferSize) {
<span class="nc" id="L282">		return new BufferedOutputStream(write(append), bufferSize);</span>
	}

	/** Reads the remaining bytes from the specified stream and writes them to this file. The stream is closed. Parent directories
	 * will be created if necessary.
	 * @param append If false, this file will be overwritten if it exists, otherwise it will be appended.
	 * @throws GdxRuntimeException if this file handle represents a directory, if it is a {@link FileType#Classpath} or
	 *            {@link FileType#Internal} file, or if it could not be written. */
	public void write (InputStream input, boolean append) {
<span class="nc" id="L291">		OutputStream output = null;</span>
		try {
<span class="nc" id="L293">			output = write(append);</span>
<span class="nc" id="L294">			StreamUtils.copyStream(input, output);</span>
<span class="nc" id="L295">		} catch (Exception ex) {</span>
<span class="nc" id="L296">			throw new GdxRuntimeException(&quot;Error stream writing to file: &quot; + file + &quot; (&quot; + type + &quot;)&quot;, ex);</span>
		} finally {
<span class="nc" id="L298">			StreamUtils.closeQuietly(input);</span>
<span class="nc" id="L299">			StreamUtils.closeQuietly(output);</span>
<span class="nc" id="L300">		}</span>

<span class="nc" id="L302">	}</span>

	/** Returns a writer for writing to this file using the default charset. Parent directories will be created if necessary.
	 * @param append If false, this file will be overwritten if it exists, otherwise it will be appended.
	 * @throws GdxRuntimeException if this file handle represents a directory, if it is a {@link FileType#Classpath} or
	 *            {@link FileType#Internal} file, or if it could not be written. */
	public Writer writer (boolean append) {
<span class="nc" id="L309">		return writer(append, null);</span>
	}

	/** Returns a writer for writing to this file. Parent directories will be created if necessary.
	 * @param append If false, this file will be overwritten if it exists, otherwise it will be appended.
	 * @param charset May be null to use the default charset.
	 * @throws GdxRuntimeException if this file handle represents a directory, if it is a {@link FileType#Classpath} or
	 *            {@link FileType#Internal} file, or if it could not be written. */
	public Writer writer (boolean append, String charset) {
<span class="nc bnc" id="L318" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot write to a classpath file: &quot; + file);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">		if (type == FileType.Internal) throw new GdxRuntimeException(&quot;Cannot write to an internal file: &quot; + file);</span>
<span class="nc" id="L320">		parent().mkdirs();</span>
		try {
<span class="nc" id="L322">			FileOutputStream output = new FileOutputStream(file(), append);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">			if (charset == null)</span>
<span class="nc" id="L324">				return new OutputStreamWriter(output);</span>
			else
<span class="nc" id="L326">				return new OutputStreamWriter(output, charset);</span>
<span class="nc" id="L327">		} catch (IOException ex) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">			if (file().isDirectory())</span>
<span class="nc" id="L329">				throw new GdxRuntimeException(&quot;Cannot open a stream to a directory: &quot; + file + &quot; (&quot; + type + &quot;)&quot;, ex);</span>
<span class="nc" id="L330">			throw new GdxRuntimeException(&quot;Error writing file: &quot; + file + &quot; (&quot; + type + &quot;)&quot;, ex);</span>
		}
	}

	/** Writes the specified string to the file using the default charset. Parent directories will be created if necessary.
	 * @param append If false, this file will be overwritten if it exists, otherwise it will be appended.
	 * @throws GdxRuntimeException if this file handle represents a directory, if it is a {@link FileType#Classpath} or
	 *            {@link FileType#Internal} file, or if it could not be written. */
	public void writeString (String string, boolean append) {
<span class="nc" id="L339">		writeString(string, append, null);</span>
<span class="nc" id="L340">	}</span>

	/** Writes the specified string to the file using the specified charset. Parent directories will be created if necessary.
	 * @param append If false, this file will be overwritten if it exists, otherwise it will be appended.
	 * @param charset May be null to use the default charset.
	 * @throws GdxRuntimeException if this file handle represents a directory, if it is a {@link FileType#Classpath} or
	 *            {@link FileType#Internal} file, or if it could not be written. */
	public void writeString (String string, boolean append, String charset) {
<span class="nc" id="L348">		Writer writer = null;</span>
		try {
<span class="nc" id="L350">			writer = writer(append, charset);</span>
<span class="nc" id="L351">			writer.write(string);</span>
<span class="nc" id="L352">		} catch (Exception ex) {</span>
<span class="nc" id="L353">			throw new GdxRuntimeException(&quot;Error writing file: &quot; + file + &quot; (&quot; + type + &quot;)&quot;, ex);</span>
		} finally {
<span class="nc" id="L355">			StreamUtils.closeQuietly(writer);</span>
<span class="nc" id="L356">		}</span>
<span class="nc" id="L357">	}</span>

	/** Writes the specified bytes to the file. Parent directories will be created if necessary.
	 * @param append If false, this file will be overwritten if it exists, otherwise it will be appended.
	 * @throws GdxRuntimeException if this file handle represents a directory, if it is a {@link FileType#Classpath} or
	 *            {@link FileType#Internal} file, or if it could not be written. */
	public void writeBytes (byte[] bytes, boolean append) {
<span class="nc" id="L364">		OutputStream output = write(append);</span>
		try {
<span class="nc" id="L366">			output.write(bytes);</span>
<span class="nc" id="L367">		} catch (IOException ex) {</span>
<span class="nc" id="L368">			throw new GdxRuntimeException(&quot;Error writing file: &quot; + file + &quot; (&quot; + type + &quot;)&quot;, ex);</span>
		} finally {
<span class="nc" id="L370">			StreamUtils.closeQuietly(output);</span>
<span class="nc" id="L371">		}</span>
<span class="nc" id="L372">	}</span>

	/** Writes the specified bytes to the file. Parent directories will be created if necessary.
	 * @param append If false, this file will be overwritten if it exists, otherwise it will be appended.
	 * @throws GdxRuntimeException if this file handle represents a directory, if it is a {@link FileType#Classpath} or
	 *            {@link FileType#Internal} file, or if it could not be written. */
	public void writeBytes (byte[] bytes, int offset, int length, boolean append) {
<span class="nc" id="L379">		OutputStream output = write(append);</span>
		try {
<span class="nc" id="L381">			output.write(bytes, offset, length);</span>
<span class="nc" id="L382">		} catch (IOException ex) {</span>
<span class="nc" id="L383">			throw new GdxRuntimeException(&quot;Error writing file: &quot; + file + &quot; (&quot; + type + &quot;)&quot;, ex);</span>
		} finally {
<span class="nc" id="L385">			StreamUtils.closeQuietly(output);</span>
<span class="nc" id="L386">		}</span>
<span class="nc" id="L387">	}</span>

	/** Returns the paths to the children of this directory. Returns an empty list if this file handle represents a file and not a
	 * directory. On the desktop, an {@link FileType#Internal} handle to a directory on the classpath will return a zero length
	 * array.
	 * @throws GdxRuntimeException if this file is an {@link FileType#Classpath} file. */
	public FileHandle[] list () {
<span class="nc bnc" id="L394" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot list a classpath directory: &quot; + file);</span>
<span class="nc" id="L395">		String[] relativePaths = file().list();</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">		if (relativePaths == null) return new FileHandle[0];</span>
<span class="nc" id="L397">		FileHandle[] handles = new FileHandle[relativePaths.length];</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">		for (int i = 0, n = relativePaths.length; i &lt; n; i++)</span>
<span class="nc" id="L399">			handles[i] = child(relativePaths[i]);</span>
<span class="nc" id="L400">		return handles;</span>
	}

	/** Returns the paths to the children of this directory that satisfy the specified filter. Returns an empty list if this file
	 * handle represents a file and not a directory. On the desktop, an {@link FileType#Internal} handle to a directory on the
	 * classpath will return a zero length array.
	 * @param filter the {@link FileFilter} to filter files
	 * @throws GdxRuntimeException if this file is an {@link FileType#Classpath} file. */
	public FileHandle[] list (FileFilter filter) {
<span class="nc bnc" id="L409" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot list a classpath directory: &quot; + file);</span>
<span class="nc" id="L410">		File file = file();</span>
<span class="nc" id="L411">		String[] relativePaths = file.list();</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">		if (relativePaths == null) return new FileHandle[0];</span>
<span class="nc" id="L413">		FileHandle[] handles = new FileHandle[relativePaths.length];</span>
<span class="nc" id="L414">		int count = 0;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">		for (int i = 0, n = relativePaths.length; i &lt; n; i++) {</span>
<span class="nc" id="L416">			String path = relativePaths[i];</span>
<span class="nc" id="L417">			FileHandle child = child(path);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">			if (!filter.accept(child.file())) continue;</span>
<span class="nc" id="L419">			handles[count] = child;</span>
<span class="nc" id="L420">			count++;</span>
		}
<span class="nc bnc" id="L422" title="All 2 branches missed.">		if (count &lt; relativePaths.length) {</span>
<span class="nc" id="L423">			FileHandle[] newHandles = new FileHandle[count];</span>
<span class="nc" id="L424">			System.arraycopy(handles, 0, newHandles, 0, count);</span>
<span class="nc" id="L425">			handles = newHandles;</span>
		}
<span class="nc" id="L427">		return handles;</span>
	}

	/** Returns the paths to the children of this directory that satisfy the specified filter. Returns an empty list if this file
	 * handle represents a file and not a directory. On the desktop, an {@link FileType#Internal} handle to a directory on the
	 * classpath will return a zero length array.
	 * @param filter the {@link FilenameFilter} to filter files
	 * @throws GdxRuntimeException if this file is an {@link FileType#Classpath} file. */
	public FileHandle[] list (FilenameFilter filter) {
<span class="nc bnc" id="L436" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot list a classpath directory: &quot; + file);</span>
<span class="nc" id="L437">		File file = file();</span>
<span class="nc" id="L438">		String[] relativePaths = file.list();</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">		if (relativePaths == null) return new FileHandle[0];</span>
<span class="nc" id="L440">		FileHandle[] handles = new FileHandle[relativePaths.length];</span>
<span class="nc" id="L441">		int count = 0;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">		for (int i = 0, n = relativePaths.length; i &lt; n; i++) {</span>
<span class="nc" id="L443">			String path = relativePaths[i];</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">			if (!filter.accept(file, path)) continue;</span>
<span class="nc" id="L445">			handles[count] = child(path);</span>
<span class="nc" id="L446">			count++;</span>
		}
<span class="nc bnc" id="L448" title="All 2 branches missed.">		if (count &lt; relativePaths.length) {</span>
<span class="nc" id="L449">			FileHandle[] newHandles = new FileHandle[count];</span>
<span class="nc" id="L450">			System.arraycopy(handles, 0, newHandles, 0, count);</span>
<span class="nc" id="L451">			handles = newHandles;</span>
		}
<span class="nc" id="L453">		return handles;</span>
	}

	/** Returns the paths to the children of this directory with the specified suffix. Returns an empty list if this file handle
	 * represents a file and not a directory. On the desktop, an {@link FileType#Internal} handle to a directory on the classpath
	 * will return a zero length array.
	 * @throws GdxRuntimeException if this file is an {@link FileType#Classpath} file. */
	public FileHandle[] list (String suffix) {
<span class="nc bnc" id="L461" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot list a classpath directory: &quot; + file);</span>
<span class="nc" id="L462">		String[] relativePaths = file().list();</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">		if (relativePaths == null) return new FileHandle[0];</span>
<span class="nc" id="L464">		FileHandle[] handles = new FileHandle[relativePaths.length];</span>
<span class="nc" id="L465">		int count = 0;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">		for (int i = 0, n = relativePaths.length; i &lt; n; i++) {</span>
<span class="nc" id="L467">			String path = relativePaths[i];</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">			if (!path.endsWith(suffix)) continue;</span>
<span class="nc" id="L469">			handles[count] = child(path);</span>
<span class="nc" id="L470">			count++;</span>
		}
<span class="nc bnc" id="L472" title="All 2 branches missed.">		if (count &lt; relativePaths.length) {</span>
<span class="nc" id="L473">			FileHandle[] newHandles = new FileHandle[count];</span>
<span class="nc" id="L474">			System.arraycopy(handles, 0, newHandles, 0, count);</span>
<span class="nc" id="L475">			handles = newHandles;</span>
		}
<span class="nc" id="L477">		return handles;</span>
	}

	/** Returns true if this file is a directory. Always returns false for classpath files. On Android, an {@link FileType#Internal}
	 * handle to an empty directory will return false. On the desktop, an {@link FileType#Internal} handle to a directory on the
	 * classpath will return false. */
	public boolean isDirectory () {
<span class="nc bnc" id="L484" title="All 2 branches missed.">		if (type == FileType.Classpath) return false;</span>
<span class="nc" id="L485">		return file().isDirectory();</span>
	}

	/** Returns a handle to the child with the specified name. */
	public FileHandle child (String name) {
<span class="nc bnc" id="L490" title="All 2 branches missed.">		if (file.getPath().length() == 0) return new FileHandle(new File(name), type);</span>
<span class="nc" id="L491">		return new FileHandle(new File(file, name), type);</span>
	}

	/** Returns a handle to the sibling with the specified name.
	 * @throws GdxRuntimeException if this file is the root. */
	public FileHandle sibling (String name) {
<span class="nc bnc" id="L497" title="All 2 branches missed.">		if (file.getPath().length() == 0) throw new GdxRuntimeException(&quot;Cannot get the sibling of the root.&quot;);</span>
<span class="nc" id="L498">		return new FileHandle(new File(file.getParent(), name), type);</span>
	}

	public FileHandle parent () {
<span class="nc" id="L502">		File parent = file.getParentFile();</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">		if (parent == null) {</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">			if (type == FileType.Absolute)</span>
<span class="nc" id="L505">				parent = new File(&quot;/&quot;);</span>
			else
<span class="nc" id="L507">				parent = new File(&quot;&quot;);</span>
		}
<span class="nc" id="L509">		return new FileHandle(parent, type);</span>
	}

	/** @throws GdxRuntimeException if this file handle is a {@link FileType#Classpath} or {@link FileType#Internal} file. */
	public void mkdirs () {
<span class="nc bnc" id="L514" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot mkdirs with a classpath file: &quot; + file);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">		if (type == FileType.Internal) throw new GdxRuntimeException(&quot;Cannot mkdirs with an internal file: &quot; + file);</span>
<span class="nc" id="L516">		file().mkdirs();</span>
<span class="nc" id="L517">	}</span>

	/** Returns true if the file exists. On Android, a {@link FileType#Classpath} or {@link FileType#Internal} handle to a directory
	 * will always return false. Note that this can be very slow for internal files on Android! */
	public boolean exists () {
<span class="nc bnc" id="L522" title="All 3 branches missed.">		switch (type) {</span>
		case Internal:
<span class="nc bnc" id="L524" title="All 2 branches missed.">			if (file().exists()) return true;</span>
			// Fall through.
		case Classpath:
<span class="nc bnc" id="L527" title="All 2 branches missed.">			return FileHandle.class.getResource(&quot;/&quot; + file.getPath().replace('\\', '/')) != null;</span>
		}
<span class="nc" id="L529">		return file().exists();</span>
	}

	/** Deletes this file or empty directory and returns success. Will not delete a directory that has children.
	 * @throws GdxRuntimeException if this file handle is a {@link FileType#Classpath} or {@link FileType#Internal} file. */
	public boolean delete () {
<span class="nc bnc" id="L535" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot delete a classpath file: &quot; + file);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">		if (type == FileType.Internal) throw new GdxRuntimeException(&quot;Cannot delete an internal file: &quot; + file);</span>
<span class="nc" id="L537">		return file().delete();</span>
	}

	/** Deletes this file or directory and all children, recursively.
	 * @throws GdxRuntimeException if this file handle is a {@link FileType#Classpath} or {@link FileType#Internal} file. */
	public boolean deleteDirectory () {
<span class="nc bnc" id="L543" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot delete a classpath file: &quot; + file);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">		if (type == FileType.Internal) throw new GdxRuntimeException(&quot;Cannot delete an internal file: &quot; + file);</span>
<span class="nc" id="L545">		return deleteDirectory(file());</span>
	}

	/** Deletes all children of this directory, recursively.
	 * @throws GdxRuntimeException if this file handle is a {@link FileType#Classpath} or {@link FileType#Internal} file. */
	public void emptyDirectory () {
<span class="nc" id="L551">		emptyDirectory(false);</span>
<span class="nc" id="L552">	}</span>

	/** Deletes all children of this directory, recursively. Optionally preserving the folder structure.
	 * @throws GdxRuntimeException if this file handle is a {@link FileType#Classpath} or {@link FileType#Internal} file. */
	public void emptyDirectory (boolean preserveTree) {
<span class="nc bnc" id="L557" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot delete a classpath file: &quot; + file);</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">		if (type == FileType.Internal) throw new GdxRuntimeException(&quot;Cannot delete an internal file: &quot; + file);</span>
<span class="nc" id="L559">		emptyDirectory(file(), preserveTree);</span>
<span class="nc" id="L560">	}</span>

	/** Copies this file or directory to the specified file or directory. If this handle is a file, then 1) if the destination is a
	 * file, it is overwritten, or 2) if the destination is a directory, this file is copied into it, or 3) if the destination
	 * doesn't exist, {@link #mkdirs()} is called on the destination's parent and this file is copied into it with a new name. If
	 * this handle is a directory, then 1) if the destination is a file, GdxRuntimeException is thrown, or 2) if the destination is
	 * a directory, this directory is copied into it recursively, overwriting existing files, or 3) if the destination doesn't
	 * exist, {@link #mkdirs()} is called on the destination and this directory is copied into it recursively.
	 * @throws GdxRuntimeException if the destination file handle is a {@link FileType#Classpath} or {@link FileType#Internal}
	 *            file, or copying failed. */
	public void copyTo (FileHandle dest) {
<span class="nc" id="L571">		boolean sourceDir = isDirectory();</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">		if (!sourceDir) {</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">			if (dest.isDirectory()) dest = dest.child(name());</span>
<span class="nc" id="L574">			copyFile(this, dest);</span>
<span class="nc" id="L575">			return;</span>
		}
<span class="nc bnc" id="L577" title="All 2 branches missed.">		if (dest.exists()) {</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">			if (!dest.isDirectory()) throw new GdxRuntimeException(&quot;Destination exists but is not a directory: &quot; + dest);</span>
		} else {
<span class="nc" id="L580">			dest.mkdirs();</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">			if (!dest.isDirectory()) throw new GdxRuntimeException(&quot;Destination directory cannot be created: &quot; + dest);</span>
		}
<span class="nc bnc" id="L583" title="All 2 branches missed.">		if (!sourceDir) dest = dest.child(name());</span>
<span class="nc" id="L584">		copyDirectory(this, dest);</span>
<span class="nc" id="L585">	}</span>

	/** Moves this file to the specified file, overwriting the file if it already exists.
	 * @throws GdxRuntimeException if the source or destination file handle is a {@link FileType#Classpath} or
	 *            {@link FileType#Internal} file. */
	public void moveTo (FileHandle dest) {
<span class="nc bnc" id="L591" title="All 2 branches missed.">		if (type == FileType.Classpath) throw new GdxRuntimeException(&quot;Cannot move a classpath file: &quot; + file);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">		if (type == FileType.Internal) throw new GdxRuntimeException(&quot;Cannot move an internal file: &quot; + file);</span>
<span class="nc" id="L593">		copyTo(dest);</span>
<span class="nc" id="L594">		delete();</span>
<span class="nc bnc" id="L595" title="All 4 branches missed.">		if (exists() &amp;&amp; isDirectory()) deleteDirectory();</span>
<span class="nc" id="L596">	}</span>

	/** Returns the length in bytes of this file, or 0 if this file is a directory, does not exist, or the size cannot otherwise be
	 * determined. */
	public long length () {
<span class="nc bnc" id="L601" title="All 6 branches missed.">		if (type == FileType.Classpath || (type == FileType.Internal &amp;&amp; !file.exists())) {</span>
<span class="nc" id="L602">			InputStream input = read();</span>
			try {
<span class="nc" id="L604">				return input.available();</span>
<span class="nc" id="L605">			} catch (Exception ignored) {</span>
			} finally {
<span class="nc" id="L607">				StreamUtils.closeQuietly(input);</span>
<span class="nc" id="L608">			}</span>
<span class="nc" id="L609">			return 0;</span>
		}
<span class="nc" id="L611">		return file().length();</span>
	}

	/** Returns the last modified time in milliseconds for this file. Zero is returned if the file doesn't exist. Zero is returned
	 * for {@link FileType#Classpath} files. On Android, zero is returned for {@link FileType#Internal} files. On the desktop, zero
	 * is returned for {@link FileType#Internal} files on the classpath. */
	public long lastModified () {
<span class="nc" id="L618">		return file().lastModified();</span>
	}

	@Override
	public boolean equals (Object obj) {
<span class="nc bnc" id="L623" title="All 2 branches missed.">		if (!(obj instanceof FileHandle)) return false;</span>
<span class="nc" id="L624">		FileHandle other = (FileHandle)obj;</span>
<span class="nc bnc" id="L625" title="All 4 branches missed.">		return type == other.type &amp;&amp; path().equals(other.path());</span>
	}

	@Override
	public int hashCode () {
<span class="nc" id="L630">		int hash = 1;</span>
<span class="nc" id="L631">		hash = hash * 37 + type.hashCode();</span>
<span class="nc" id="L632">		hash = hash * 67 + path().hashCode();</span>
<span class="nc" id="L633">		return hash;</span>
	}

	public String toString () {
<span class="nc" id="L637">		return file.getPath().replace('\\', '/');</span>
	}

	static public FileHandle tempFile (String prefix) {
		try {
<span class="nc" id="L642">			return new FileHandle(File.createTempFile(prefix, null));</span>
<span class="nc" id="L643">		} catch (IOException ex) {</span>
<span class="nc" id="L644">			throw new GdxRuntimeException(&quot;Unable to create temp file.&quot;, ex);</span>
		}
	}

	static public FileHandle tempDirectory (String prefix) {
		try {
<span class="nc" id="L650">			File file = File.createTempFile(prefix, null);</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">			if (!file.delete()) throw new IOException(&quot;Unable to delete temp file: &quot; + file);</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">			if (!file.mkdir()) throw new IOException(&quot;Unable to create temp directory: &quot; + file);</span>
<span class="nc" id="L653">			return new FileHandle(file);</span>
<span class="nc" id="L654">		} catch (IOException ex) {</span>
<span class="nc" id="L655">			throw new GdxRuntimeException(&quot;Unable to create temp file.&quot;, ex);</span>
		}
	}

	static private void emptyDirectory (File file, boolean preserveTree) {
<span class="nc bnc" id="L660" title="All 2 branches missed.">		if (file.exists()) {</span>
<span class="nc" id="L661">			File[] files = file.listFiles();</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">			if (files != null) {</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">				for (int i = 0, n = files.length; i &lt; n; i++) {</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">					if (!files[i].isDirectory())</span>
<span class="nc" id="L665">						files[i].delete();</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">					else if (preserveTree)</span>
<span class="nc" id="L667">						emptyDirectory(files[i], true);</span>
					else
<span class="nc" id="L669">						deleteDirectory(files[i]);</span>
				}
			}
		}
<span class="nc" id="L673">	}</span>

	static private boolean deleteDirectory (File file) {
<span class="nc" id="L676">		emptyDirectory(file, false);</span>
<span class="nc" id="L677">		return file.delete();</span>
	}

	static private void copyFile (FileHandle source, FileHandle dest) {
		try {
<span class="nc" id="L682">			dest.write(source.read(), false);</span>
<span class="nc" id="L683">		} catch (Exception ex) {</span>
<span class="nc" id="L684">			throw new GdxRuntimeException(&quot;Error copying source file: &quot; + source.file + &quot; (&quot; + source.type + &quot;)\n&quot; //</span>
				+ &quot;To destination: &quot; + dest.file + &quot; (&quot; + dest.type + &quot;)&quot;, ex);
<span class="nc" id="L686">		}</span>
<span class="nc" id="L687">	}</span>

	static private void copyDirectory (FileHandle sourceDir, FileHandle destDir) {
<span class="nc" id="L690">		destDir.mkdirs();</span>
<span class="nc" id="L691">		FileHandle[] files = sourceDir.list();</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">		for (int i = 0, n = files.length; i &lt; n; i++) {</span>
<span class="nc" id="L693">			FileHandle srcFile = files[i];</span>
<span class="nc" id="L694">			FileHandle destFile = destDir.child(srcFile.name());</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">			if (srcFile.isDirectory())</span>
<span class="nc" id="L696">				copyDirectory(srcFile, destFile);</span>
			else
<span class="nc" id="L698">				copyFile(srcFile, destFile);</span>
		}
<span class="nc" id="L700">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>