<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultShader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.graphics.g3d.shaders</a> &gt; <span class="el_source">DefaultShader.java</span></div><h1>DefaultShader.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.graphics.g3d.shaders;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.VertexAttribute;
import com.badlogic.gdx.graphics.VertexAttributes.Usage;
import com.badlogic.gdx.graphics.g3d.Attribute;
import com.badlogic.gdx.graphics.g3d.Attributes;
import com.badlogic.gdx.graphics.g3d.Environment;
import com.badlogic.gdx.graphics.g3d.Renderable;
import com.badlogic.gdx.graphics.g3d.Shader;
import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.CubemapAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.DepthTestAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.DirectionalLightsAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.IntAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.PointLightsAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.SpotLightsAttribute;
import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
import com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap;
import com.badlogic.gdx.graphics.g3d.environment.DirectionalLight;
import com.badlogic.gdx.graphics.g3d.environment.PointLight;
import com.badlogic.gdx.graphics.g3d.environment.SpotLight;
import com.badlogic.gdx.graphics.g3d.utils.RenderContext;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.math.Matrix3;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.GdxRuntimeException;

public class DefaultShader extends BaseShader {
	public static class Config {
		/** The uber vertex shader to use, null to use the default vertex shader. */
<span class="nc" id="L54">		public String vertexShader = null;</span>
		/** The uber fragment shader to use, null to use the default fragment shader. */
<span class="nc" id="L56">		public String fragmentShader = null;</span>
		/** The number of directional lights to use */
<span class="nc" id="L58">		public int numDirectionalLights = 2;</span>
		/** The number of point lights to use */
<span class="nc" id="L60">		public int numPointLights = 5;</span>
		/** The number of spot lights to use */
<span class="nc" id="L62">		public int numSpotLights = 0;</span>
		/** The number of bones to use */
<span class="nc" id="L64">		public int numBones = 12;</span>
		/** */
<span class="nc" id="L66">		public boolean ignoreUnimplemented = true;</span>
		/** Set to 0 to disable culling, -1 to inherit from {@link DefaultShader#defaultCullFace} */
<span class="nc" id="L68">		public int defaultCullFace = -1;</span>
		/** Set to 0 to disable depth test, -1 to inherit from {@link DefaultShader#defaultDepthFunc} */
<span class="nc" id="L70">		public int defaultDepthFunc = -1;</span>

<span class="nc" id="L72">		public Config () {</span>
<span class="nc" id="L73">		}</span>

<span class="nc" id="L75">		public Config (final String vertexShader, final String fragmentShader) {</span>
<span class="nc" id="L76">			this.vertexShader = vertexShader;</span>
<span class="nc" id="L77">			this.fragmentShader = fragmentShader;</span>
<span class="nc" id="L78">		}</span>
	}

<span class="nc" id="L81">	public static class Inputs {</span>
<span class="nc" id="L82">		public final static Uniform projTrans = new Uniform(&quot;u_projTrans&quot;);</span>
<span class="nc" id="L83">		public final static Uniform viewTrans = new Uniform(&quot;u_viewTrans&quot;);</span>
<span class="nc" id="L84">		public final static Uniform projViewTrans = new Uniform(&quot;u_projViewTrans&quot;);</span>
<span class="nc" id="L85">		public final static Uniform cameraPosition = new Uniform(&quot;u_cameraPosition&quot;);</span>
<span class="nc" id="L86">		public final static Uniform cameraDirection = new Uniform(&quot;u_cameraDirection&quot;);</span>
<span class="nc" id="L87">		public final static Uniform cameraUp = new Uniform(&quot;u_cameraUp&quot;);</span>

<span class="nc" id="L89">		public final static Uniform worldTrans = new Uniform(&quot;u_worldTrans&quot;);</span>
<span class="nc" id="L90">		public final static Uniform viewWorldTrans = new Uniform(&quot;u_viewWorldTrans&quot;);</span>
<span class="nc" id="L91">		public final static Uniform projViewWorldTrans = new Uniform(&quot;u_projViewWorldTrans&quot;);</span>
<span class="nc" id="L92">		public final static Uniform normalMatrix = new Uniform(&quot;u_normalMatrix&quot;);</span>
<span class="nc" id="L93">		public final static Uniform bones = new Uniform(&quot;u_bones&quot;);</span>

<span class="nc" id="L95">		public final static Uniform shininess = new Uniform(&quot;u_shininess&quot;, FloatAttribute.Shininess);</span>
<span class="nc" id="L96">		public final static Uniform opacity = new Uniform(&quot;u_opacity&quot;, BlendingAttribute.Type);</span>
<span class="nc" id="L97">		public final static Uniform diffuseColor = new Uniform(&quot;u_diffuseColor&quot;, ColorAttribute.Diffuse);</span>
<span class="nc" id="L98">		public final static Uniform diffuseTexture = new Uniform(&quot;u_diffuseTexture&quot;, TextureAttribute.Diffuse);</span>
<span class="nc" id="L99">		public final static Uniform diffuseUVTransform = new Uniform(&quot;u_diffuseUVTransform&quot;, TextureAttribute.Diffuse);</span>
<span class="nc" id="L100">		public final static Uniform specularColor = new Uniform(&quot;u_specularColor&quot;, ColorAttribute.Specular);</span>
<span class="nc" id="L101">		public final static Uniform specularTexture = new Uniform(&quot;u_specularTexture&quot;, TextureAttribute.Specular);</span>
<span class="nc" id="L102">		public final static Uniform specularUVTransform = new Uniform(&quot;u_specularUVTransform&quot;, TextureAttribute.Specular);</span>
<span class="nc" id="L103">		public final static Uniform emissiveColor = new Uniform(&quot;u_emissiveColor&quot;, ColorAttribute.Emissive);</span>
<span class="nc" id="L104">		public final static Uniform emissiveTexture = new Uniform(&quot;u_emissiveTexture&quot;, TextureAttribute.Emissive);</span>
<span class="nc" id="L105">		public final static Uniform emissiveUVTransform = new Uniform(&quot;u_emissiveUVTransform&quot;, TextureAttribute.Emissive);</span>
<span class="nc" id="L106">		public final static Uniform reflectionColor = new Uniform(&quot;u_reflectionColor&quot;, ColorAttribute.Reflection);</span>
<span class="nc" id="L107">		public final static Uniform reflectionTexture = new Uniform(&quot;u_reflectionTexture&quot;, TextureAttribute.Reflection);</span>
<span class="nc" id="L108">		public final static Uniform reflectionUVTransform = new Uniform(&quot;u_reflectionUVTransform&quot;, TextureAttribute.Reflection);</span>
<span class="nc" id="L109">		public final static Uniform normalTexture = new Uniform(&quot;u_normalTexture&quot;, TextureAttribute.Normal);</span>
<span class="nc" id="L110">		public final static Uniform normalUVTransform = new Uniform(&quot;u_normalUVTransform&quot;, TextureAttribute.Normal);</span>
<span class="nc" id="L111">		public final static Uniform ambientTexture = new Uniform(&quot;u_ambientTexture&quot;, TextureAttribute.Ambient);</span>
<span class="nc" id="L112">		public final static Uniform ambientUVTransform = new Uniform(&quot;u_ambientUVTransform&quot;, TextureAttribute.Ambient);</span>
<span class="nc" id="L113">		public final static Uniform alphaTest = new Uniform(&quot;u_alphaTest&quot;);</span>

<span class="nc" id="L115">		public final static Uniform ambientCube = new Uniform(&quot;u_ambientCubemap&quot;);</span>
<span class="nc" id="L116">		public final static Uniform dirLights = new Uniform(&quot;u_dirLights&quot;);</span>
<span class="nc" id="L117">		public final static Uniform pointLights = new Uniform(&quot;u_pointLights&quot;);</span>
<span class="nc" id="L118">		public final static Uniform spotLights = new Uniform(&quot;u_spotLights&quot;);</span>
<span class="nc" id="L119">		public final static Uniform environmentCubemap = new Uniform(&quot;u_environmentCubemap&quot;);</span>
	}

<span class="nc" id="L122">	public static class Setters {</span>
<span class="nc" id="L123">		public final static Setter projTrans = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L126">				shader.set(inputID, shader.camera.projection);</span>
<span class="nc" id="L127">			}</span>
		};
<span class="nc" id="L129">		public final static Setter viewTrans = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L132">				shader.set(inputID, shader.camera.view);</span>
<span class="nc" id="L133">			}</span>
		};
<span class="nc" id="L135">		public final static Setter projViewTrans = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L138">				shader.set(inputID, shader.camera.combined);</span>
<span class="nc" id="L139">			}</span>
		};
<span class="nc" id="L141">		public final static Setter cameraPosition = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L144">				shader.set(inputID, shader.camera.position.x, shader.camera.position.y, shader.camera.position.z,</span>
					1.1881f / (shader.camera.far * shader.camera.far));
<span class="nc" id="L146">			}</span>
		};
<span class="nc" id="L148">		public final static Setter cameraDirection = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L151">				shader.set(inputID, shader.camera.direction);</span>
<span class="nc" id="L152">			}</span>
		};
<span class="nc" id="L154">		public final static Setter cameraUp = new GlobalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L157">				shader.set(inputID, shader.camera.up);</span>
<span class="nc" id="L158">			}</span>
		};
<span class="nc" id="L160">		public final static Setter worldTrans = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L163">				shader.set(inputID, renderable.worldTransform);</span>
<span class="nc" id="L164">			}</span>
		};
<span class="nc" id="L166">		public final static Setter viewWorldTrans = new LocalSetter() {</span>
<span class="nc" id="L167">			final Matrix4 temp = new Matrix4();</span>

			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L171">				shader.set(inputID, temp.set(shader.camera.view).mul(renderable.worldTransform));</span>
<span class="nc" id="L172">			}</span>
		};
<span class="nc" id="L174">		public final static Setter projViewWorldTrans = new LocalSetter() {</span>
<span class="nc" id="L175">			final Matrix4 temp = new Matrix4();</span>

			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L179">				shader.set(inputID, temp.set(shader.camera.combined).mul(renderable.worldTransform));</span>
<span class="nc" id="L180">			}</span>
		};
<span class="nc" id="L182">		public final static Setter normalMatrix = new LocalSetter() {</span>
<span class="nc" id="L183">			private final Matrix3 tmpM = new Matrix3();</span>

			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L187">				shader.set(inputID, tmpM.set(renderable.worldTransform).inv().transpose());</span>
<span class="nc" id="L188">			}</span>
		};

		public static class Bones extends LocalSetter {
<span class="nc" id="L192">			private final static Matrix4 idtMatrix = new Matrix4();</span>
			public final float bones[];

<span class="nc" id="L195">			public Bones (final int numBones) {</span>
<span class="nc" id="L196">				this.bones = new float[numBones * 16];</span>
<span class="nc" id="L197">			}</span>

			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc bnc" id="L201" title="All 2 branches missed.">				for (int i = 0; i &lt; bones.length; i++) {</span>
<span class="nc" id="L202">					final int idx = i / 16;</span>
<span class="nc bnc" id="L203" title="All 6 branches missed.">					bones[i] = (renderable.bones == null || idx &gt;= renderable.bones.length || renderable.bones[idx] == null) ? idtMatrix.val[i % 16]</span>
						: renderable.bones[idx].val[i % 16];
				}
<span class="nc" id="L206">				shader.program.setUniformMatrix4fv(shader.loc(inputID), bones, 0, bones.length);</span>
<span class="nc" id="L207">			}</span>
		}

<span class="nc" id="L210">		public final static Setter shininess = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L213">				shader.set(inputID, ((FloatAttribute)(combinedAttributes.get(FloatAttribute.Shininess))).value);</span>
<span class="nc" id="L214">			}</span>
		};
<span class="nc" id="L216">		public final static Setter diffuseColor = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L219">				shader.set(inputID, ((ColorAttribute)(combinedAttributes.get(ColorAttribute.Diffuse))).color);</span>
<span class="nc" id="L220">			}</span>
		};
<span class="nc" id="L222">		public final static Setter diffuseTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L225">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
					.get(TextureAttribute.Diffuse))).textureDescription);
<span class="nc" id="L227">				shader.set(inputID, unit);</span>
<span class="nc" id="L228">			}</span>
		};
<span class="nc" id="L230">		public final static Setter diffuseUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L233">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Diffuse));</span>
<span class="nc" id="L234">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L235">			}</span>
		};
<span class="nc" id="L237">		public final static Setter specularColor = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L240">				shader.set(inputID, ((ColorAttribute)(combinedAttributes.get(ColorAttribute.Specular))).color);</span>
<span class="nc" id="L241">			}</span>
		};
<span class="nc" id="L243">		public final static Setter specularTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L246">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
					.get(TextureAttribute.Specular))).textureDescription);
<span class="nc" id="L248">				shader.set(inputID, unit);</span>
<span class="nc" id="L249">			}</span>
		};
<span class="nc" id="L251">		public final static Setter specularUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L254">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Specular));</span>
<span class="nc" id="L255">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L256">			}</span>
		};
<span class="nc" id="L258">		public final static Setter emissiveColor = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L261">				shader.set(inputID, ((ColorAttribute)(combinedAttributes.get(ColorAttribute.Emissive))).color);</span>
<span class="nc" id="L262">			}</span>
		};
<span class="nc" id="L264">		public final static Setter emissiveTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L267">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
					.get(TextureAttribute.Emissive))).textureDescription);
<span class="nc" id="L269">				shader.set(inputID, unit);</span>
<span class="nc" id="L270">			}</span>
		};
<span class="nc" id="L272">		public final static Setter emissiveUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L275">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Emissive));</span>
<span class="nc" id="L276">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L277">			}</span>
		};
<span class="nc" id="L279">		public final static Setter reflectionColor = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L282">				shader.set(inputID, ((ColorAttribute)(combinedAttributes.get(ColorAttribute.Reflection))).color);</span>
<span class="nc" id="L283">			}</span>
		};
<span class="nc" id="L285">		public final static Setter reflectionTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L288">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
					.get(TextureAttribute.Reflection))).textureDescription);
<span class="nc" id="L290">				shader.set(inputID, unit);</span>
<span class="nc" id="L291">			}</span>
		};
<span class="nc" id="L293">		public final static Setter reflectionUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L296">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Reflection));</span>
<span class="nc" id="L297">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L298">			}</span>
		};
<span class="nc" id="L300">		public final static Setter normalTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L303">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
					.get(TextureAttribute.Normal))).textureDescription);
<span class="nc" id="L305">				shader.set(inputID, unit);</span>
<span class="nc" id="L306">			}</span>
		};
<span class="nc" id="L308">		public final static Setter normalUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L311">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Normal));</span>
<span class="nc" id="L312">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L313">			}</span>
		};
<span class="nc" id="L315">		public final static Setter ambientTexture = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L318">				final int unit = shader.context.textureBinder.bind(((TextureAttribute)(combinedAttributes</span>
					.get(TextureAttribute.Ambient))).textureDescription);
<span class="nc" id="L320">				shader.set(inputID, unit);</span>
<span class="nc" id="L321">			}</span>
		};
<span class="nc" id="L323">		public final static Setter ambientUVTransform = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc" id="L326">				final TextureAttribute ta = (TextureAttribute)(combinedAttributes.get(TextureAttribute.Ambient));</span>
<span class="nc" id="L327">				shader.set(inputID, ta.offsetU, ta.offsetV, ta.scaleU, ta.scaleV);</span>
<span class="nc" id="L328">			}</span>
		};

<span class="nc" id="L331">		public static class ACubemap extends LocalSetter {</span>
<span class="nc" id="L332">			private final static float ones[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};</span>
<span class="nc" id="L333">			private final AmbientCubemap cacheAmbientCubemap = new AmbientCubemap();</span>
<span class="nc" id="L334">			private final static Vector3 tmpV1 = new Vector3();</span>
			public final int dirLightsOffset;
			public final int pointLightsOffset;

<span class="nc" id="L338">			public ACubemap (final int dirLightsOffset, final int pointLightsOffset) {</span>
<span class="nc" id="L339">				this.dirLightsOffset = dirLightsOffset;</span>
<span class="nc" id="L340">				this.pointLightsOffset = pointLightsOffset;</span>
<span class="nc" id="L341">			}</span>

			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc bnc" id="L345" title="All 2 branches missed.">				if (renderable.environment == null)</span>
<span class="nc" id="L346">					shader.program.setUniform3fv(shader.loc(inputID), ones, 0, ones.length);</span>
				else {
<span class="nc" id="L348">					renderable.worldTransform.getTranslation(tmpV1);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">					if (combinedAttributes.has(ColorAttribute.AmbientLight))</span>
<span class="nc" id="L350">						cacheAmbientCubemap.set(((ColorAttribute)combinedAttributes.get(ColorAttribute.AmbientLight)).color);</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">					if (combinedAttributes.has(DirectionalLightsAttribute.Type)) {</span>
<span class="nc" id="L353">						Array&lt;DirectionalLight&gt; lights = ((DirectionalLightsAttribute)combinedAttributes</span>
							.get(DirectionalLightsAttribute.Type)).lights;
<span class="nc bnc" id="L355" title="All 2 branches missed.">						for (int i = dirLightsOffset; i &lt; lights.size; i++)</span>
<span class="nc" id="L356">							cacheAmbientCubemap.add(lights.get(i).color, lights.get(i).direction);</span>
					}

<span class="nc bnc" id="L359" title="All 2 branches missed.">					if (combinedAttributes.has(PointLightsAttribute.Type)) {</span>
<span class="nc" id="L360">						Array&lt;PointLight&gt; lights = ((PointLightsAttribute)combinedAttributes.get(PointLightsAttribute.Type)).lights;</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">						for (int i = pointLightsOffset; i &lt; lights.size; i++)</span>
<span class="nc" id="L362">							cacheAmbientCubemap.add(lights.get(i).color, lights.get(i).position, tmpV1, lights.get(i).intensity);</span>
					}

<span class="nc" id="L365">					cacheAmbientCubemap.clamp();</span>
<span class="nc" id="L366">					shader.program.setUniform3fv(shader.loc(inputID), cacheAmbientCubemap.data, 0, cacheAmbientCubemap.data.length);</span>
				}
<span class="nc" id="L368">			}</span>
		}

<span class="nc" id="L371">		public final static Setter environmentCubemap = new LocalSetter() {</span>
			@Override
			public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">				if (combinedAttributes.has(CubemapAttribute.EnvironmentMap)) {</span>
<span class="nc" id="L375">					shader.set(inputID, shader.context.textureBinder.bind(((CubemapAttribute)combinedAttributes</span>
						.get(CubemapAttribute.EnvironmentMap)).textureDescription));
				}
<span class="nc" id="L378">			}</span>
		};
	}

<span class="nc" id="L382">	private static String defaultVertexShader = null;</span>

	public static String getDefaultVertexShader () {
<span class="nc bnc" id="L385" title="All 2 branches missed.">		if (defaultVertexShader == null)</span>
<span class="nc" id="L386">			defaultVertexShader = Gdx.files.classpath(&quot;com/badlogic/gdx/graphics/g3d/shaders/default.vertex.glsl&quot;).readString();</span>
<span class="nc" id="L387">		return defaultVertexShader;</span>
	}

<span class="nc" id="L390">	private static String defaultFragmentShader = null;</span>

	public static String getDefaultFragmentShader () {
<span class="nc bnc" id="L393" title="All 2 branches missed.">		if (defaultFragmentShader == null)</span>
<span class="nc" id="L394">			defaultFragmentShader = Gdx.files.classpath(&quot;com/badlogic/gdx/graphics/g3d/shaders/default.fragment.glsl&quot;).readString();</span>
<span class="nc" id="L395">		return defaultFragmentShader;</span>
	}

<span class="nc" id="L398">	protected static long implementedFlags = BlendingAttribute.Type | TextureAttribute.Diffuse | ColorAttribute.Diffuse</span>
		| ColorAttribute.Specular | FloatAttribute.Shininess;

	/** @deprecated Replaced by {@link Config#defaultCullFace} Set to 0 to disable culling */
<span class="nc" id="L402">	@Deprecated public static int defaultCullFace = GL20.GL_BACK;</span>
	/** @deprecated Replaced by {@link Config#defaultDepthFunc} Set to 0 to disable depth test */
<span class="nc" id="L404">	@Deprecated public static int defaultDepthFunc = GL20.GL_LEQUAL;</span>

	// Global uniforms
	public final int u_projTrans;
	public final int u_viewTrans;
	public final int u_projViewTrans;
	public final int u_cameraPosition;
	public final int u_cameraDirection;
	public final int u_cameraUp;
	public final int u_time;
	// Object uniforms
	public final int u_worldTrans;
	public final int u_viewWorldTrans;
	public final int u_projViewWorldTrans;
	public final int u_normalMatrix;
	public final int u_bones;
	// Material uniforms
	public final int u_shininess;
	public final int u_opacity;
	public final int u_diffuseColor;
	public final int u_diffuseTexture;
	public final int u_diffuseUVTransform;
	public final int u_specularColor;
	public final int u_specularTexture;
	public final int u_specularUVTransform;
	public final int u_emissiveColor;
	public final int u_emissiveTexture;
	public final int u_emissiveUVTransform;
	public final int u_reflectionColor;
	public final int u_reflectionTexture;
	public final int u_reflectionUVTransform;
	public final int u_normalTexture;
	public final int u_normalUVTransform;
	public final int u_ambientTexture;
	public final int u_ambientUVTransform;
	public final int u_alphaTest;
	// Lighting uniforms
	protected final int u_ambientCubemap;
	protected final int u_environmentCubemap;
<span class="nc" id="L443">	protected final int u_dirLights0color = register(new Uniform(&quot;u_dirLights[0].color&quot;));</span>
<span class="nc" id="L444">	protected final int u_dirLights0direction = register(new Uniform(&quot;u_dirLights[0].direction&quot;));</span>
<span class="nc" id="L445">	protected final int u_dirLights1color = register(new Uniform(&quot;u_dirLights[1].color&quot;));</span>
<span class="nc" id="L446">	protected final int u_pointLights0color = register(new Uniform(&quot;u_pointLights[0].color&quot;));</span>
<span class="nc" id="L447">	protected final int u_pointLights0position = register(new Uniform(&quot;u_pointLights[0].position&quot;));</span>
<span class="nc" id="L448">	protected final int u_pointLights0intensity = register(new Uniform(&quot;u_pointLights[0].intensity&quot;));</span>
<span class="nc" id="L449">	protected final int u_pointLights1color = register(new Uniform(&quot;u_pointLights[1].color&quot;));</span>
<span class="nc" id="L450">	protected final int u_spotLights0color = register(new Uniform(&quot;u_spotLights[0].color&quot;));</span>
<span class="nc" id="L451">	protected final int u_spotLights0position = register(new Uniform(&quot;u_spotLights[0].position&quot;));</span>
<span class="nc" id="L452">	protected final int u_spotLights0intensity = register(new Uniform(&quot;u_spotLights[0].intensity&quot;));</span>
<span class="nc" id="L453">	protected final int u_spotLights0direction = register(new Uniform(&quot;u_spotLights[0].direction&quot;));</span>
<span class="nc" id="L454">	protected final int u_spotLights0cutoffAngle = register(new Uniform(&quot;u_spotLights[0].cutoffAngle&quot;));</span>
<span class="nc" id="L455">	protected final int u_spotLights0exponent = register(new Uniform(&quot;u_spotLights[0].exponent&quot;));</span>
<span class="nc" id="L456">	protected final int u_spotLights1color = register(new Uniform(&quot;u_spotLights[1].color&quot;));</span>
<span class="nc" id="L457">	protected final int u_fogColor = register(new Uniform(&quot;u_fogColor&quot;));</span>
<span class="nc" id="L458">	protected final int u_shadowMapProjViewTrans = register(new Uniform(&quot;u_shadowMapProjViewTrans&quot;));</span>
<span class="nc" id="L459">	protected final int u_shadowTexture = register(new Uniform(&quot;u_shadowTexture&quot;));</span>
<span class="nc" id="L460">	protected final int u_shadowPCFOffset = register(new Uniform(&quot;u_shadowPCFOffset&quot;));</span>
	// FIXME Cache vertex attribute locations...

	protected int dirLightsLoc;
	protected int dirLightsColorOffset;
	protected int dirLightsDirectionOffset;
	protected int dirLightsSize;
	protected int pointLightsLoc;
	protected int pointLightsColorOffset;
	protected int pointLightsPositionOffset;
	protected int pointLightsIntensityOffset;
	protected int pointLightsSize;
	protected int spotLightsLoc;
	protected int spotLightsColorOffset;
	protected int spotLightsPositionOffset;
	protected int spotLightsDirectionOffset;
	protected int spotLightsIntensityOffset;
	protected int spotLightsCutoffAngleOffset;
	protected int spotLightsExponentOffset;
	protected int spotLightsSize;

	protected final boolean lighting;
	protected final boolean environmentCubemap;
	protected final boolean shadowMap;
<span class="nc" id="L484">	protected final AmbientCubemap ambientCubemap = new AmbientCubemap();</span>
	protected final DirectionalLight directionalLights[];
	protected final PointLight pointLights[];
	protected final SpotLight spotLights[];

	/** The renderable used to create this shader, invalid after the call to init */
	private Renderable renderable;
	/** The attributes that this shader supports */
	protected final long attributesMask;
	private long vertexMask;
	protected final Config config;
	/** Attributes which are not required but always supported. */
<span class="nc" id="L496">	private final static long optionalAttributes = IntAttribute.CullFace | DepthTestAttribute.Type;</span>

	public DefaultShader (final Renderable renderable) {
<span class="nc" id="L499">		this(renderable, new Config());</span>
<span class="nc" id="L500">	}</span>

	public DefaultShader (final Renderable renderable, final Config config) {
<span class="nc" id="L503">		this(renderable, config, createPrefix(renderable, config));</span>
<span class="nc" id="L504">	}</span>

	public DefaultShader (final Renderable renderable, final Config config, final String prefix) {
<span class="nc bnc" id="L507" title="All 4 branches missed.">		this(renderable, config, prefix, config.vertexShader != null ? config.vertexShader : getDefaultVertexShader(),</span>
			config.fragmentShader != null ? config.fragmentShader : getDefaultFragmentShader());
<span class="nc" id="L509">	}</span>

	public DefaultShader (final Renderable renderable, final Config config, final String prefix, final String vertexShader,
		final String fragmentShader) {
<span class="nc" id="L513">		this(renderable, config, new ShaderProgram(prefix + vertexShader, prefix + fragmentShader));</span>
<span class="nc" id="L514">	}</span>

<span class="nc" id="L516">	public DefaultShader (final Renderable renderable, final Config config, final ShaderProgram shaderProgram) {</span>
<span class="nc" id="L517">		final Attributes attributes = combineAttributes(renderable);</span>
<span class="nc" id="L518">		this.config = config;</span>
<span class="nc" id="L519">		this.program = shaderProgram;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">		this.lighting = renderable.environment != null;</span>
<span class="nc bnc" id="L521" title="All 6 branches missed.">		this.environmentCubemap = attributes.has(CubemapAttribute.EnvironmentMap)</span>
			|| (lighting &amp;&amp; attributes.has(CubemapAttribute.EnvironmentMap));
<span class="nc bnc" id="L523" title="All 4 branches missed.">		this.shadowMap = lighting &amp;&amp; renderable.environment.shadowMap != null;</span>
<span class="nc" id="L524">		this.renderable = renderable;</span>
<span class="nc" id="L525">		attributesMask = attributes.getMask() | optionalAttributes;</span>
<span class="nc" id="L526">		vertexMask = renderable.meshPart.mesh.getVertexAttributes().getMask();</span>

<span class="nc bnc" id="L528" title="All 4 branches missed.">		this.directionalLights = new DirectionalLight[lighting &amp;&amp; config.numDirectionalLights &gt; 0 ? config.numDirectionalLights : 0];</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">		for (int i = 0; i &lt; directionalLights.length; i++)</span>
<span class="nc" id="L530">			directionalLights[i] = new DirectionalLight();</span>
<span class="nc bnc" id="L531" title="All 4 branches missed.">		this.pointLights = new PointLight[lighting &amp;&amp; config.numPointLights &gt; 0 ? config.numPointLights : 0];</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">		for (int i = 0; i &lt; pointLights.length; i++)</span>
<span class="nc" id="L533">			pointLights[i] = new PointLight();</span>
<span class="nc bnc" id="L534" title="All 4 branches missed.">		this.spotLights = new SpotLight[lighting &amp;&amp; config.numSpotLights &gt; 0 ? config.numSpotLights : 0];</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">		for (int i = 0; i &lt; spotLights.length; i++)</span>
<span class="nc" id="L536">			spotLights[i] = new SpotLight();</span>

<span class="nc bnc" id="L538" title="All 4 branches missed.">		if (!config.ignoreUnimplemented &amp;&amp; (implementedFlags &amp; attributesMask) != attributesMask)</span>
<span class="nc" id="L539">			throw new GdxRuntimeException(&quot;Some attributes not implemented yet (&quot; + attributesMask + &quot;)&quot;);</span>

		// Global uniforms
<span class="nc" id="L542">		u_projTrans = register(Inputs.projTrans, Setters.projTrans);</span>
<span class="nc" id="L543">		u_viewTrans = register(Inputs.viewTrans, Setters.viewTrans);</span>
<span class="nc" id="L544">		u_projViewTrans = register(Inputs.projViewTrans, Setters.projViewTrans);</span>
<span class="nc" id="L545">		u_cameraPosition = register(Inputs.cameraPosition, Setters.cameraPosition);</span>
<span class="nc" id="L546">		u_cameraDirection = register(Inputs.cameraDirection, Setters.cameraDirection);</span>
<span class="nc" id="L547">		u_cameraUp = register(Inputs.cameraUp, Setters.cameraUp);</span>
<span class="nc" id="L548">		u_time = register(new Uniform(&quot;u_time&quot;));</span>
		// Object uniforms
<span class="nc" id="L550">		u_worldTrans = register(Inputs.worldTrans, Setters.worldTrans);</span>
<span class="nc" id="L551">		u_viewWorldTrans = register(Inputs.viewWorldTrans, Setters.viewWorldTrans);</span>
<span class="nc" id="L552">		u_projViewWorldTrans = register(Inputs.projViewWorldTrans, Setters.projViewWorldTrans);</span>
<span class="nc" id="L553">		u_normalMatrix = register(Inputs.normalMatrix, Setters.normalMatrix);</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">		u_bones = (renderable.bones != null &amp;&amp; config.numBones &gt; 0) ? register(Inputs.bones, new Setters.Bones(config.numBones))</span>
			: -1;

<span class="nc" id="L557">		u_shininess = register(Inputs.shininess, Setters.shininess);</span>
<span class="nc" id="L558">		u_opacity = register(Inputs.opacity);</span>
<span class="nc" id="L559">		u_diffuseColor = register(Inputs.diffuseColor, Setters.diffuseColor);</span>
<span class="nc" id="L560">		u_diffuseTexture = register(Inputs.diffuseTexture, Setters.diffuseTexture);</span>
<span class="nc" id="L561">		u_diffuseUVTransform = register(Inputs.diffuseUVTransform, Setters.diffuseUVTransform);</span>
<span class="nc" id="L562">		u_specularColor = register(Inputs.specularColor, Setters.specularColor);</span>
<span class="nc" id="L563">		u_specularTexture = register(Inputs.specularTexture, Setters.specularTexture);</span>
<span class="nc" id="L564">		u_specularUVTransform = register(Inputs.specularUVTransform, Setters.specularUVTransform);</span>
<span class="nc" id="L565">		u_emissiveColor = register(Inputs.emissiveColor, Setters.emissiveColor);</span>
<span class="nc" id="L566">		u_emissiveTexture = register(Inputs.emissiveTexture, Setters.emissiveTexture);</span>
<span class="nc" id="L567">		u_emissiveUVTransform = register(Inputs.emissiveUVTransform, Setters.emissiveUVTransform);</span>
<span class="nc" id="L568">		u_reflectionColor = register(Inputs.reflectionColor, Setters.reflectionColor);</span>
<span class="nc" id="L569">		u_reflectionTexture = register(Inputs.reflectionTexture, Setters.reflectionTexture);</span>
<span class="nc" id="L570">		u_reflectionUVTransform = register(Inputs.reflectionUVTransform, Setters.reflectionUVTransform);</span>
<span class="nc" id="L571">		u_normalTexture = register(Inputs.normalTexture, Setters.normalTexture);</span>
<span class="nc" id="L572">		u_normalUVTransform = register(Inputs.normalUVTransform, Setters.normalUVTransform);</span>
<span class="nc" id="L573">		u_ambientTexture = register(Inputs.ambientTexture, Setters.ambientTexture);</span>
<span class="nc" id="L574">		u_ambientUVTransform = register(Inputs.ambientUVTransform, Setters.ambientUVTransform);</span>
<span class="nc" id="L575">		u_alphaTest = register(Inputs.alphaTest);</span>

<span class="nc bnc" id="L577" title="All 2 branches missed.">		u_ambientCubemap = lighting ? register(Inputs.ambientCube, new Setters.ACubemap(config.numDirectionalLights,</span>
			config.numPointLights)) : -1;
<span class="nc bnc" id="L579" title="All 2 branches missed.">		u_environmentCubemap = environmentCubemap ? register(Inputs.environmentCubemap, Setters.environmentCubemap) : -1;</span>
<span class="nc" id="L580">	}</span>

	@Override
	public void init () {
<span class="nc" id="L584">		final ShaderProgram program = this.program;</span>
<span class="nc" id="L585">		this.program = null;</span>
<span class="nc" id="L586">		init(program, renderable);</span>
<span class="nc" id="L587">		renderable = null;</span>

<span class="nc" id="L589">		dirLightsLoc = loc(u_dirLights0color);</span>
<span class="nc" id="L590">		dirLightsColorOffset = loc(u_dirLights0color) - dirLightsLoc;</span>
<span class="nc" id="L591">		dirLightsDirectionOffset = loc(u_dirLights0direction) - dirLightsLoc;</span>
<span class="nc" id="L592">		dirLightsSize = loc(u_dirLights1color) - dirLightsLoc;</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">		if (dirLightsSize &lt; 0) dirLightsSize = 0;</span>

<span class="nc" id="L595">		pointLightsLoc = loc(u_pointLights0color);</span>
<span class="nc" id="L596">		pointLightsColorOffset = loc(u_pointLights0color) - pointLightsLoc;</span>
<span class="nc" id="L597">		pointLightsPositionOffset = loc(u_pointLights0position) - pointLightsLoc;</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">		pointLightsIntensityOffset = has(u_pointLights0intensity) ? loc(u_pointLights0intensity) - pointLightsLoc : -1;</span>
<span class="nc" id="L599">		pointLightsSize = loc(u_pointLights1color) - pointLightsLoc;</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">		if (pointLightsSize &lt; 0) pointLightsSize = 0;</span>

<span class="nc" id="L602">		spotLightsLoc = loc(u_spotLights0color);</span>
<span class="nc" id="L603">		spotLightsColorOffset = loc(u_spotLights0color) - spotLightsLoc;</span>
<span class="nc" id="L604">		spotLightsPositionOffset = loc(u_spotLights0position) - spotLightsLoc;</span>
<span class="nc" id="L605">		spotLightsDirectionOffset = loc(u_spotLights0direction) - spotLightsLoc;</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">		spotLightsIntensityOffset = has(u_spotLights0intensity) ? loc(u_spotLights0intensity) - spotLightsLoc : -1;</span>
<span class="nc" id="L607">		spotLightsCutoffAngleOffset = loc(u_spotLights0cutoffAngle) - spotLightsLoc;</span>
<span class="nc" id="L608">		spotLightsExponentOffset = loc(u_spotLights0exponent) - spotLightsLoc;</span>
<span class="nc" id="L609">		spotLightsSize = loc(u_spotLights1color) - spotLightsLoc;</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">		if (spotLightsSize &lt; 0) spotLightsSize = 0;</span>
<span class="nc" id="L611">	}</span>

	private static final boolean and (final long mask, final long flag) {
<span class="nc bnc" id="L614" title="All 2 branches missed.">		return (mask &amp; flag) == flag;</span>
	}

	private static final boolean or (final long mask, final long flag) {
<span class="nc bnc" id="L618" title="All 2 branches missed.">		return (mask &amp; flag) != 0;</span>
	}

<span class="nc" id="L621">	private final static Attributes tmpAttributes = new Attributes();</span>

	// TODO: Perhaps move responsibility for combining attributes to RenderableProvider?
	private static final Attributes combineAttributes (final Renderable renderable) {
<span class="nc" id="L625">		tmpAttributes.clear();</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">		if (renderable.environment != null) tmpAttributes.set(renderable.environment);</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">		if (renderable.material != null) tmpAttributes.set(renderable.material);</span>
<span class="nc" id="L628">		return tmpAttributes;</span>
	}

	public static String createPrefix (final Renderable renderable, final Config config) {
<span class="nc" id="L632">		final Attributes attributes = combineAttributes(renderable);</span>
<span class="nc" id="L633">		String prefix = &quot;&quot;;</span>
<span class="nc" id="L634">		final long attributesMask = attributes.getMask();</span>
<span class="nc" id="L635">		final long vertexMask = renderable.meshPart.mesh.getVertexAttributes().getMask();</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">		if (and(vertexMask, Usage.Position)) prefix += &quot;#define positionFlag\n&quot;;</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">		if (or(vertexMask, Usage.ColorUnpacked | Usage.ColorPacked)) prefix += &quot;#define colorFlag\n&quot;;</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">		if (and(vertexMask, Usage.BiNormal)) prefix += &quot;#define binormalFlag\n&quot;;</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">		if (and(vertexMask, Usage.Tangent)) prefix += &quot;#define tangentFlag\n&quot;;</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">		if (and(vertexMask, Usage.Normal)) prefix += &quot;#define normalFlag\n&quot;;</span>
<span class="nc bnc" id="L641" title="All 4 branches missed.">		if (and(vertexMask, Usage.Normal) || and(vertexMask, Usage.Tangent | Usage.BiNormal)) {</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">			if (renderable.environment != null) {</span>
<span class="nc" id="L643">				prefix += &quot;#define lightingFlag\n&quot;;</span>
<span class="nc" id="L644">				prefix += &quot;#define ambientCubemapFlag\n&quot;;</span>
<span class="nc" id="L645">				prefix += &quot;#define numDirectionalLights &quot; + config.numDirectionalLights + &quot;\n&quot;;</span>
<span class="nc" id="L646">				prefix += &quot;#define numPointLights &quot; + config.numPointLights + &quot;\n&quot;;</span>
<span class="nc" id="L647">				prefix += &quot;#define numSpotLights &quot; + config.numSpotLights + &quot;\n&quot;;</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">				if (attributes.has(ColorAttribute.Fog)) {</span>
<span class="nc" id="L649">					prefix += &quot;#define fogFlag\n&quot;;</span>
				}
<span class="nc bnc" id="L651" title="All 2 branches missed.">				if (renderable.environment.shadowMap != null) prefix += &quot;#define shadowMapFlag\n&quot;;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">				if (attributes.has(CubemapAttribute.EnvironmentMap)) prefix += &quot;#define environmentCubemapFlag\n&quot;;</span>
			}
		}
<span class="nc" id="L655">		final int n = renderable.meshPart.mesh.getVertexAttributes().size();</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">		for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L657">			final VertexAttribute attr = renderable.meshPart.mesh.getVertexAttributes().get(i);</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">			if (attr.usage == Usage.BoneWeight)</span>
<span class="nc" id="L659">				prefix += &quot;#define boneWeight&quot; + attr.unit + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">			else if (attr.usage == Usage.TextureCoordinates) prefix += &quot;#define texCoord&quot; + attr.unit + &quot;Flag\n&quot;;</span>
		}
<span class="nc bnc" id="L662" title="All 2 branches missed.">		if ((attributesMask &amp; BlendingAttribute.Type) == BlendingAttribute.Type)</span>
<span class="nc" id="L663">			prefix += &quot;#define &quot; + BlendingAttribute.Alias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Diffuse) == TextureAttribute.Diffuse) {</span>
<span class="nc" id="L665">			prefix += &quot;#define &quot; + TextureAttribute.DiffuseAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L666">			prefix += &quot;#define &quot; + TextureAttribute.DiffuseAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L668" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Specular) == TextureAttribute.Specular) {</span>
<span class="nc" id="L669">			prefix += &quot;#define &quot; + TextureAttribute.SpecularAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L670">			prefix += &quot;#define &quot; + TextureAttribute.SpecularAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L672" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Normal) == TextureAttribute.Normal) {</span>
<span class="nc" id="L673">			prefix += &quot;#define &quot; + TextureAttribute.NormalAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L674">			prefix += &quot;#define &quot; + TextureAttribute.NormalAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L676" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Emissive) == TextureAttribute.Emissive) {</span>
<span class="nc" id="L677">			prefix += &quot;#define &quot; + TextureAttribute.EmissiveAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L678">			prefix += &quot;#define &quot; + TextureAttribute.EmissiveAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L680" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Reflection) == TextureAttribute.Reflection) {</span>
<span class="nc" id="L681">			prefix += &quot;#define &quot; + TextureAttribute.ReflectionAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L682">			prefix += &quot;#define &quot; + TextureAttribute.ReflectionAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if ((attributesMask &amp; TextureAttribute.Ambient) == TextureAttribute.Ambient) {</span>
<span class="nc" id="L685">			prefix += &quot;#define &quot; + TextureAttribute.AmbientAlias + &quot;Flag\n&quot;;</span>
<span class="nc" id="L686">			prefix += &quot;#define &quot; + TextureAttribute.AmbientAlias + &quot;Coord texCoord0\n&quot;; // FIXME implement UV mapping</span>
		}
<span class="nc bnc" id="L688" title="All 2 branches missed.">		if ((attributesMask &amp; ColorAttribute.Diffuse) == ColorAttribute.Diffuse)</span>
<span class="nc" id="L689">			prefix += &quot;#define &quot; + ColorAttribute.DiffuseAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">		if ((attributesMask &amp; ColorAttribute.Specular) == ColorAttribute.Specular)</span>
<span class="nc" id="L691">			prefix += &quot;#define &quot; + ColorAttribute.SpecularAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">		if ((attributesMask &amp; ColorAttribute.Emissive) == ColorAttribute.Emissive)</span>
<span class="nc" id="L693">			prefix += &quot;#define &quot; + ColorAttribute.EmissiveAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">		if ((attributesMask &amp; ColorAttribute.Reflection) == ColorAttribute.Reflection)</span>
<span class="nc" id="L695">			prefix += &quot;#define &quot; + ColorAttribute.ReflectionAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">		if ((attributesMask &amp; FloatAttribute.Shininess) == FloatAttribute.Shininess)</span>
<span class="nc" id="L697">			prefix += &quot;#define &quot; + FloatAttribute.ShininessAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">		if ((attributesMask &amp; FloatAttribute.AlphaTest) == FloatAttribute.AlphaTest)</span>
<span class="nc" id="L699">			prefix += &quot;#define &quot; + FloatAttribute.AlphaTestAlias + &quot;Flag\n&quot;;</span>
<span class="nc bnc" id="L700" title="All 4 branches missed.">		if (renderable.bones != null &amp;&amp; config.numBones &gt; 0) prefix += &quot;#define numBones &quot; + config.numBones + &quot;\n&quot;;</span>
<span class="nc" id="L701">		return prefix;</span>
	}

	@Override
	public boolean canRender (final Renderable renderable) {
<span class="nc" id="L706">		final Attributes attributes = combineAttributes(renderable);</span>
<span class="nc bnc" id="L707" title="All 8 branches missed.">		return (attributesMask == (attributes.getMask() | optionalAttributes))</span>
			&amp;&amp; (vertexMask == renderable.meshPart.mesh.getVertexAttributes().getMask()) &amp;&amp; (renderable.environment != null) == lighting;
	}

	@Override
	public int compareTo (Shader other) {
<span class="nc bnc" id="L713" title="All 2 branches missed.">		if (other == null) return -1;</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">		if (other == this) return 0;</span>
<span class="nc" id="L715">		return 0; // FIXME compare shaders on their impact on performance</span>
	}

	@Override
	public boolean equals (Object obj) {
<span class="nc bnc" id="L720" title="All 2 branches missed.">		return (obj instanceof DefaultShader) ? equals((DefaultShader)obj) : false;</span>
	}

	public boolean equals (DefaultShader obj) {
<span class="nc bnc" id="L724" title="All 2 branches missed.">		return (obj == this);</span>
	}

<span class="nc" id="L727">	private Matrix3 normalMatrix = new Matrix3();</span>
	private Camera camera;
	private float time;
	private boolean lightsSet;

	@Override
	public void begin (final Camera camera, final RenderContext context) {
<span class="nc" id="L734">		super.begin(camera, context);</span>

<span class="nc bnc" id="L736" title="All 2 branches missed.">		for (final DirectionalLight dirLight : directionalLights)</span>
<span class="nc" id="L737">			dirLight.set(0, 0, 0, 0, -1, 0);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">		for (final PointLight pointLight : pointLights)</span>
<span class="nc" id="L739">			pointLight.set(0, 0, 0, 0, 0, 0, 0);</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">		for (final SpotLight spotLight : spotLights)</span>
<span class="nc" id="L741">			spotLight.set(0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0);</span>
<span class="nc" id="L742">		lightsSet = false;</span>

<span class="nc bnc" id="L744" title="All 2 branches missed.">		if (has(u_time)) set(u_time, time += Gdx.graphics.getDeltaTime());</span>
<span class="nc" id="L745">	}</span>

	@Override
	public void render (Renderable renderable, Attributes combinedAttributes) {
<span class="nc bnc" id="L749" title="All 2 branches missed.">		if (!combinedAttributes.has(BlendingAttribute.Type))</span>
<span class="nc" id="L750">			context.setBlending(false, GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);</span>
<span class="nc" id="L751">		bindMaterial(combinedAttributes);</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">		if (lighting) bindLights(renderable, combinedAttributes);</span>
<span class="nc" id="L753">		super.render(renderable, combinedAttributes);</span>
<span class="nc" id="L754">	}</span>

	@Override
	public void end () {
<span class="nc" id="L758">		super.end();</span>
<span class="nc" id="L759">	}</span>

	protected void bindMaterial (final Attributes attributes) {
<span class="nc bnc" id="L762" title="All 2 branches missed.">		int cullFace = config.defaultCullFace == -1 ? defaultCullFace : config.defaultCullFace;</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">		int depthFunc = config.defaultDepthFunc == -1 ? defaultDepthFunc : config.defaultDepthFunc;</span>
<span class="nc" id="L764">		float depthRangeNear = 0f;</span>
<span class="nc" id="L765">		float depthRangeFar = 1f;</span>
<span class="nc" id="L766">		boolean depthMask = true;</span>

<span class="nc bnc" id="L768" title="All 2 branches missed.">		for (final Attribute attr : attributes) {</span>
<span class="nc" id="L769">			final long t = attr.type;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">			if (BlendingAttribute.is(t)) {</span>
<span class="nc" id="L771">				context.setBlending(true, ((BlendingAttribute)attr).sourceFunction, ((BlendingAttribute)attr).destFunction);</span>
<span class="nc" id="L772">				set(u_opacity, ((BlendingAttribute)attr).opacity);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">			} else if ((t &amp; IntAttribute.CullFace) == IntAttribute.CullFace)</span>
<span class="nc" id="L774">				cullFace = ((IntAttribute)attr).value;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">			else if ((t &amp; FloatAttribute.AlphaTest) == FloatAttribute.AlphaTest)</span>
<span class="nc" id="L776">				set(u_alphaTest, ((FloatAttribute)attr).value);</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">			else if ((t &amp; DepthTestAttribute.Type) == DepthTestAttribute.Type) {</span>
<span class="nc" id="L778">				DepthTestAttribute dta = (DepthTestAttribute)attr;</span>
<span class="nc" id="L779">				depthFunc = dta.depthFunc;</span>
<span class="nc" id="L780">				depthRangeNear = dta.depthRangeNear;</span>
<span class="nc" id="L781">				depthRangeFar = dta.depthRangeFar;</span>
<span class="nc" id="L782">				depthMask = dta.depthMask;</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">			} else if (!config.ignoreUnimplemented) throw new GdxRuntimeException(&quot;Unknown material attribute: &quot; + attr.toString());</span>
<span class="nc" id="L784">		}</span>

<span class="nc" id="L786">		context.setCullFace(cullFace);</span>
<span class="nc" id="L787">		context.setDepthTest(depthFunc, depthRangeNear, depthRangeFar);</span>
<span class="nc" id="L788">		context.setDepthMask(depthMask);</span>
<span class="nc" id="L789">	}</span>

<span class="nc" id="L791">	private final Vector3 tmpV1 = new Vector3();</span>

	protected void bindLights (final Renderable renderable, final Attributes attributes) {
<span class="nc" id="L794">		final Environment lights = renderable.environment;</span>
<span class="nc" id="L795">		final DirectionalLightsAttribute dla = attributes.get(DirectionalLightsAttribute.class, DirectionalLightsAttribute.Type);</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">		final Array&lt;DirectionalLight&gt; dirs = dla == null ? null : dla.lights;</span>
<span class="nc" id="L797">		final PointLightsAttribute pla = attributes.get(PointLightsAttribute.class, PointLightsAttribute.Type);</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">		final Array&lt;PointLight&gt; points = pla == null ? null : pla.lights;</span>
<span class="nc" id="L799">		final SpotLightsAttribute sla = attributes.get(SpotLightsAttribute.class, SpotLightsAttribute.Type);</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">		final Array&lt;SpotLight&gt; spots = sla == null ? null : sla.lights;</span>

<span class="nc bnc" id="L802" title="All 2 branches missed.">		if (dirLightsLoc &gt;= 0) {</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">			for (int i = 0; i &lt; directionalLights.length; i++) {</span>
<span class="nc bnc" id="L804" title="All 4 branches missed.">				if (dirs == null || i &gt;= dirs.size) {</span>
<span class="nc bnc" id="L805" title="All 8 branches missed.">					if (lightsSet &amp;&amp; directionalLights[i].color.r == 0f &amp;&amp; directionalLights[i].color.g == 0f</span>
<span class="nc" id="L806">						&amp;&amp; directionalLights[i].color.b == 0f) continue;</span>
<span class="nc" id="L807">					directionalLights[i].color.set(0, 0, 0, 1);</span>
<span class="nc bnc" id="L808" title="All 4 branches missed.">				} else if (lightsSet &amp;&amp; directionalLights[i].equals(dirs.get(i)))</span>
<span class="nc" id="L809">					continue;</span>
				else
<span class="nc" id="L811">					directionalLights[i].set(dirs.get(i));</span>

<span class="nc" id="L813">				int idx = dirLightsLoc + i * dirLightsSize;</span>
<span class="nc" id="L814">				program.setUniformf(idx + dirLightsColorOffset, directionalLights[i].color.r, directionalLights[i].color.g,</span>
					directionalLights[i].color.b);
<span class="nc" id="L816">				program.setUniformf(idx + dirLightsDirectionOffset, directionalLights[i].direction.x,</span>
					directionalLights[i].direction.y, directionalLights[i].direction.z);
<span class="nc bnc" id="L818" title="All 2 branches missed.">				if (dirLightsSize &lt;= 0) break;</span>
			}
		}

<span class="nc bnc" id="L822" title="All 2 branches missed.">		if (pointLightsLoc &gt;= 0) {</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">			for (int i = 0; i &lt; pointLights.length; i++) {</span>
<span class="nc bnc" id="L824" title="All 4 branches missed.">				if (points == null || i &gt;= points.size) {</span>
<span class="nc bnc" id="L825" title="All 4 branches missed.">					if (lightsSet &amp;&amp; pointLights[i].intensity == 0f) continue;</span>
<span class="nc" id="L826">					pointLights[i].intensity = 0f;</span>
<span class="nc bnc" id="L827" title="All 4 branches missed.">				} else if (lightsSet &amp;&amp; pointLights[i].equals(points.get(i)))</span>
<span class="nc" id="L828">					continue;</span>
				else
<span class="nc" id="L830">					pointLights[i].set(points.get(i));</span>

<span class="nc" id="L832">				int idx = pointLightsLoc + i * pointLightsSize;</span>
<span class="nc" id="L833">				program.setUniformf(idx + pointLightsColorOffset, pointLights[i].color.r * pointLights[i].intensity,</span>
					pointLights[i].color.g * pointLights[i].intensity, pointLights[i].color.b * pointLights[i].intensity);
<span class="nc" id="L835">				program.setUniformf(idx + pointLightsPositionOffset, pointLights[i].position.x, pointLights[i].position.y,</span>
					pointLights[i].position.z);
<span class="nc bnc" id="L837" title="All 2 branches missed.">				if (pointLightsIntensityOffset &gt;= 0) program.setUniformf(idx + pointLightsIntensityOffset, pointLights[i].intensity);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">				if (pointLightsSize &lt;= 0) break;</span>
			}
		}

<span class="nc bnc" id="L842" title="All 2 branches missed.">		if (spotLightsLoc &gt;= 0) {</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">			for (int i = 0; i &lt; spotLights.length; i++) {</span>
<span class="nc bnc" id="L844" title="All 4 branches missed.">				if (spots == null || i &gt;= spots.size) {</span>
<span class="nc bnc" id="L845" title="All 4 branches missed.">					if (lightsSet &amp;&amp; spotLights[i].intensity == 0f) continue;</span>
<span class="nc" id="L846">					spotLights[i].intensity = 0f;</span>
<span class="nc bnc" id="L847" title="All 4 branches missed.">				} else if (lightsSet &amp;&amp; spotLights[i].equals(spots.get(i)))</span>
<span class="nc" id="L848">					continue;</span>
				else
<span class="nc" id="L850">					spotLights[i].set(spots.get(i));</span>

<span class="nc" id="L852">				int idx = spotLightsLoc + i * spotLightsSize;</span>
<span class="nc" id="L853">				program.setUniformf(idx + spotLightsColorOffset, spotLights[i].color.r * spotLights[i].intensity,</span>
					spotLights[i].color.g * spotLights[i].intensity, spotLights[i].color.b * spotLights[i].intensity);
<span class="nc" id="L855">				program.setUniformf(idx + spotLightsPositionOffset, spotLights[i].position);</span>
<span class="nc" id="L856">				program.setUniformf(idx + spotLightsDirectionOffset, spotLights[i].direction);</span>
<span class="nc" id="L857">				program.setUniformf(idx + spotLightsCutoffAngleOffset, spotLights[i].cutoffAngle);</span>
<span class="nc" id="L858">				program.setUniformf(idx + spotLightsExponentOffset, spotLights[i].exponent);</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">				if (spotLightsIntensityOffset &gt;= 0)</span>
<span class="nc" id="L860">					program.setUniformf(idx + spotLightsIntensityOffset, spotLights[i].intensity);</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">				if (spotLightsSize &lt;= 0) break;</span>
			}
		}

<span class="nc bnc" id="L865" title="All 2 branches missed.">		if (attributes.has(ColorAttribute.Fog)) {</span>
<span class="nc" id="L866">			set(u_fogColor, ((ColorAttribute)attributes.get(ColorAttribute.Fog)).color);</span>
		}

<span class="nc bnc" id="L869" title="All 4 branches missed.">		if (lights != null &amp;&amp; lights.shadowMap != null) {</span>
<span class="nc" id="L870">			set(u_shadowMapProjViewTrans, lights.shadowMap.getProjViewTrans());</span>
<span class="nc" id="L871">			set(u_shadowTexture, lights.shadowMap.getDepthMap());</span>
<span class="nc" id="L872">			set(u_shadowPCFOffset, 1.f / (2f * lights.shadowMap.getDepthMap().texture.getWidth()));</span>
		}

<span class="nc" id="L875">		lightsSet = true;</span>
<span class="nc" id="L876">	}</span>

	@Override
	public void dispose () {
<span class="nc" id="L880">		program.dispose();</span>
<span class="nc" id="L881">		super.dispose();</span>
<span class="nc" id="L882">	}</span>

	public int getDefaultCullFace () {
<span class="nc bnc" id="L885" title="All 2 branches missed.">		return config.defaultCullFace == -1 ? defaultCullFace : config.defaultCullFace;</span>
	}

	public void setDefaultCullFace (int cullFace) {
<span class="nc" id="L889">		config.defaultCullFace = cullFace;</span>
<span class="nc" id="L890">	}</span>

	public int getDefaultDepthFunc () {
<span class="nc bnc" id="L893" title="All 2 branches missed.">		return config.defaultDepthFunc == -1 ? defaultDepthFunc : config.defaultDepthFunc;</span>
	}

	public void setDefaultDepthFunc (int depthFunc) {
<span class="nc" id="L897">		config.defaultDepthFunc = depthFunc;</span>
<span class="nc" id="L898">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>