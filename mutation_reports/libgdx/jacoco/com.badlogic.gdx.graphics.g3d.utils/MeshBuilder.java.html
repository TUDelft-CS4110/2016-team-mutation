<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MeshBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.graphics.g3d.utils</a> &gt; <span class="el_source">MeshBuilder.java</span></div><h1>MeshBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.graphics.g3d.utils;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Mesh;
import com.badlogic.gdx.graphics.VertexAttribute;
import com.badlogic.gdx.graphics.VertexAttributes;
import com.badlogic.gdx.graphics.VertexAttributes.Usage;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.g3d.model.MeshPart;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Matrix3;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.math.collision.BoundingBox;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.FloatArray;
import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.IntIntMap;
import com.badlogic.gdx.utils.NumberUtils;
import com.badlogic.gdx.utils.Pool;
import com.badlogic.gdx.utils.ShortArray;

/** Class to construct a mesh, optionally splitting it into one or more mesh parts. Before you can call any other method you must
 * call {@link #begin(VertexAttributes)} or {@link #begin(VertexAttributes, int)}. To use mesh parts you must call
 * {@link #part(String, int)} before you start building the part. The MeshPart itself is only valid after the call to
 * {@link #end()}.
 * @author Xoppa */
<span class="nc" id="L47">public class MeshBuilder implements MeshPartBuilder {</span>
<span class="nc" id="L48">	private final static ShortArray tmpIndices = new ShortArray();</span>
<span class="nc" id="L49">	private final static FloatArray tmpVertices = new FloatArray();</span>

<span class="nc" id="L51">	private final VertexInfo vertTmp1 = new VertexInfo();</span>
<span class="nc" id="L52">	private final VertexInfo vertTmp2 = new VertexInfo();</span>
<span class="nc" id="L53">	private final VertexInfo vertTmp3 = new VertexInfo();</span>
<span class="nc" id="L54">	private final VertexInfo vertTmp4 = new VertexInfo();</span>
<span class="nc" id="L55">	private final VertexInfo vertTmp5 = new VertexInfo();</span>
<span class="nc" id="L56">	private final VertexInfo vertTmp6 = new VertexInfo();</span>
<span class="nc" id="L57">	private final VertexInfo vertTmp7 = new VertexInfo();</span>
<span class="nc" id="L58">	private final VertexInfo vertTmp8 = new VertexInfo();</span>

<span class="nc" id="L60">	private final Matrix4 matTmp1 = new Matrix4();</span>

<span class="nc" id="L62">	private final Vector3 tempV1 = new Vector3();</span>
<span class="nc" id="L63">	private final Vector3 tempV2 = new Vector3();</span>
<span class="nc" id="L64">	private final Vector3 tempV3 = new Vector3();</span>
<span class="nc" id="L65">	private final Vector3 tempV4 = new Vector3();</span>
<span class="nc" id="L66">	private final Vector3 tempV5 = new Vector3();</span>
<span class="nc" id="L67">	private final Vector3 tempV6 = new Vector3();</span>
<span class="nc" id="L68">	private final Vector3 tempV7 = new Vector3();</span>
<span class="nc" id="L69">	private final Vector3 tempV8 = new Vector3();</span>

<span class="nc" id="L71">	private final Color tempC1 = new Color();</span>

	/** The vertex attributes of the resulting mesh */
	private VertexAttributes attributes;
	/** The vertices to construct, no size checking is done */
<span class="nc" id="L76">	private FloatArray vertices = new FloatArray();</span>
	/** The indices to construct, no size checking is done */
<span class="nc" id="L78">	private ShortArray indices = new ShortArray();</span>
	/** The size (in number of floats) of each vertex */
	private int stride;
	/** The current vertex index, used for indexing */
	private short vindex;
	/** The offset in the indices array when begin() was called, used to define a meshpart. */
	private int istart;
	/** The offset within an vertex to position */
	private int posOffset;
	/** The size (in number of floats) of the position attribute */
	private int posSize;
	/** The offset within an vertex to normal, or -1 if not available */
	private int norOffset;
	/** The offset within a vertex to binormal, or -1 if not available */
	private int biNorOffset;
	/** The offset within a vertex to tangent, or -1 if not available */
	private int tangentOffset;
	/** The offset within an vertex to color, or -1 if not available */
	private int colOffset;
	/** The size (in number of floats) of the color attribute */
	private int colSize;
	/** The offset within an vertex to packed color, or -1 if not available */
	private int cpOffset;
	/** The offset within an vertex to texture coordinates, or -1 if not available */
	private int uvOffset;
	/** The meshpart currently being created */
	private MeshPart part;
	/** The parts created between begin and end */
<span class="nc" id="L106">	private Array&lt;MeshPart&gt; parts = new Array&lt;MeshPart&gt;();</span>
	/** The color used if no vertex color is specified. */
<span class="nc" id="L108">	private final Color color = new Color(Color.WHITE);</span>
<span class="nc" id="L109">	private boolean hasColor = false;</span>
	/** The current primitiveType */
	private int primitiveType;
	/** The UV range used when building */
<span class="nc" id="L113">	private float uOffset = 0f, uScale = 1f, vOffset = 0f, vScale = 1f;</span>
<span class="nc" id="L114">	private boolean hasUVTransform = false;</span>
	private float[] vertex;

<span class="nc" id="L117">	private boolean vertexTransformationEnabled = false;</span>
<span class="nc" id="L118">	private final Matrix4 positionTransform = new Matrix4();</span>
<span class="nc" id="L119">	private final Matrix3 normalTransform = new Matrix3();</span>
<span class="nc" id="L120">	private final BoundingBox bounds = new BoundingBox();</span>

	/** @param usage bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal and
	 *           TextureCoordinates is supported. */
	public static VertexAttributes createAttributes (long usage) {
<span class="nc" id="L125">		final Array&lt;VertexAttribute&gt; attrs = new Array&lt;VertexAttribute&gt;();</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">		if ((usage &amp; Usage.Position) == Usage.Position)</span>
<span class="nc" id="L127">			attrs.add(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE));</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">		if ((usage &amp; Usage.ColorUnpacked) == Usage.ColorUnpacked)</span>
<span class="nc" id="L129">			attrs.add(new VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE));</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">		if ((usage &amp; Usage.ColorPacked) == Usage.ColorPacked)</span>
<span class="nc" id="L131">			attrs.add(new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE));</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">		if ((usage &amp; Usage.Normal) == Usage.Normal)</span>
<span class="nc" id="L133">			attrs.add(new VertexAttribute(Usage.Normal, 3, ShaderProgram.NORMAL_ATTRIBUTE));</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">		if ((usage &amp; Usage.TextureCoordinates) == Usage.TextureCoordinates)</span>
<span class="nc" id="L135">			attrs.add(new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + &quot;0&quot;));</span>
<span class="nc" id="L136">		final VertexAttribute attributes[] = new VertexAttribute[attrs.size];</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">		for (int i = 0; i &lt; attributes.length; i++)</span>
<span class="nc" id="L138">			attributes[i] = attrs.get(i);</span>
<span class="nc" id="L139">		return new VertexAttributes(attributes);</span>
	}

	/** Begin building a mesh. Call {@link #part(String, int)} to start a {@link MeshPart}.
	 * @param attributes bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal
	 *           and TextureCoordinates is supported. */
	public void begin (final long attributes) {
<span class="nc" id="L146">		begin(createAttributes(attributes), -1);</span>
<span class="nc" id="L147">	}</span>

	/** Begin building a mesh. Call {@link #part(String, int)} to start a {@link MeshPart}. */
	public void begin (final VertexAttributes attributes) {
<span class="nc" id="L151">		begin(attributes, -1);</span>
<span class="nc" id="L152">	}</span>

	/** Begin building a mesh.
	 * @param attributes bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal
	 *           and TextureCoordinates is supported. */
	public void begin (final long attributes, int primitiveType) {
<span class="nc" id="L158">		begin(createAttributes(attributes), primitiveType);</span>
<span class="nc" id="L159">	}</span>

	/** Begin building a mesh */
	public void begin (final VertexAttributes attributes, int primitiveType) {
<span class="nc bnc" id="L163" title="All 2 branches missed.">		if (this.attributes != null) throw new RuntimeException(&quot;Call end() first&quot;);</span>
<span class="nc" id="L164">		this.attributes = attributes;</span>
<span class="nc" id="L165">		this.vertices.clear();</span>
<span class="nc" id="L166">		this.indices.clear();</span>
<span class="nc" id="L167">		this.parts.clear();</span>
<span class="nc" id="L168">		this.vindex = 0;</span>
<span class="nc" id="L169">		this.lastIndex = -1;</span>
<span class="nc" id="L170">		this.istart = 0;</span>
<span class="nc" id="L171">		this.part = null;</span>
<span class="nc" id="L172">		this.stride = attributes.vertexSize / 4;</span>
<span class="nc bnc" id="L173" title="All 4 branches missed.">		if (this.vertex == null || this.vertex.length &lt; stride) this.vertex = new float[stride];</span>
<span class="nc" id="L174">		VertexAttribute a = attributes.findByUsage(Usage.Position);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">		if (a == null) throw new GdxRuntimeException(&quot;Cannot build mesh without position attribute&quot;);</span>
<span class="nc" id="L176">		posOffset = a.offset / 4;</span>
<span class="nc" id="L177">		posSize = a.numComponents;</span>
<span class="nc" id="L178">		a = attributes.findByUsage(Usage.Normal);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">		norOffset = a == null ? -1 : a.offset / 4;</span>
<span class="nc" id="L180">		a = attributes.findByUsage(Usage.BiNormal);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">		biNorOffset = a == null ? -1 : a.offset / 4;</span>
<span class="nc" id="L182">		a = attributes.findByUsage(Usage.Tangent);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">		tangentOffset = a == null ? -1 : a.offset / 4;</span>
<span class="nc" id="L184">		a = attributes.findByUsage(Usage.ColorUnpacked);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">		colOffset = a == null ? -1 : a.offset / 4;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">		colSize = a == null ? 0 : a.numComponents;</span>
<span class="nc" id="L187">		a = attributes.findByUsage(Usage.ColorPacked);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">		cpOffset = a == null ? -1 : a.offset / 4;</span>
<span class="nc" id="L189">		a = attributes.findByUsage(Usage.TextureCoordinates);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">		uvOffset = a == null ? -1 : a.offset / 4;</span>
<span class="nc" id="L191">		setColor(null);</span>
<span class="nc" id="L192">		setVertexTransform(null);</span>
<span class="nc" id="L193">		setUVRange(null);</span>
<span class="nc" id="L194">		this.primitiveType = primitiveType;</span>
<span class="nc" id="L195">		bounds.inf();</span>
<span class="nc" id="L196">	}</span>

	private void endpart () {
<span class="nc bnc" id="L199" title="All 2 branches missed.">		if (part != null) {</span>
<span class="nc" id="L200">			bounds.getCenter(part.center);</span>
<span class="nc" id="L201">			bounds.getDimensions(part.halfExtents).scl(0.5f);</span>
<span class="nc" id="L202">			part.radius = part.halfExtents.len();</span>
<span class="nc" id="L203">			bounds.inf();</span>
<span class="nc" id="L204">			part.offset = istart;</span>
<span class="nc" id="L205">			part.size = indices.size - istart;</span>
<span class="nc" id="L206">			istart = indices.size;</span>
<span class="nc" id="L207">			part = null;</span>
		}
<span class="nc" id="L209">	}</span>

	/** Starts a new MeshPart. The mesh part is not usable until end() is called. This will reset the current color and vertex
	 * transformation.
	 * @see #part(String, int, MeshPart) */
	public MeshPart part (final String id, int primitiveType) {
<span class="nc" id="L215">		return part(id, primitiveType, new MeshPart());</span>
	}

	/** Starts a new MeshPart. The mesh part is not usable until end() is called. This will reset the current color and vertex
	 * transformation.
	 * @param id The id (name) of the part
	 * @param primitiveType e.g. {@link GL20#GL_TRIANGLES} or {@link GL20#GL_LINES}
	 * @param meshPart The part to receive the result */
	public MeshPart part (final String id, final int primitiveType, MeshPart meshPart) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">		if (this.attributes == null) throw new RuntimeException(&quot;Call begin() first&quot;);</span>
<span class="nc" id="L225">		endpart();</span>

<span class="nc" id="L227">		part = meshPart;</span>
<span class="nc" id="L228">		part.id = id;</span>
<span class="nc" id="L229">		this.primitiveType = part.primitiveType = primitiveType;</span>
<span class="nc" id="L230">		parts.add(part);</span>

<span class="nc" id="L232">		setColor(null);</span>
<span class="nc" id="L233">		setVertexTransform(null);</span>
<span class="nc" id="L234">		setUVRange(null);</span>

<span class="nc" id="L236">		return part;</span>
	}

	/** End building the mesh and returns the mesh
	 * @param mesh The mesh to receive the built vertices and indices, must have the same attributes and must be big enough to hold
	 *           the data, any existing data will be overwritten. */
	public Mesh end (Mesh mesh) {
<span class="nc" id="L243">		endpart();</span>

<span class="nc bnc" id="L245" title="All 2 branches missed.">		if (attributes == null) throw new GdxRuntimeException(&quot;Call begin() first&quot;);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">		if (!attributes.equals(mesh.getVertexAttributes())) throw new GdxRuntimeException(&quot;Mesh attributes don't match&quot;);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">		if ((mesh.getMaxVertices() * stride) &lt; vertices.size)</span>
<span class="nc" id="L248">			throw new GdxRuntimeException(&quot;Mesh can't hold enough vertices: &quot; + mesh.getMaxVertices() + &quot; * &quot; + stride + &quot; &lt; &quot;</span>
				+ vertices.size);
<span class="nc bnc" id="L250" title="All 2 branches missed.">		if (mesh.getMaxIndices() &lt; indices.size)</span>
<span class="nc" id="L251">			throw new GdxRuntimeException(&quot;Mesh can't hold enough indices: &quot; + mesh.getMaxIndices() + &quot; &lt; &quot; + indices.size);</span>

<span class="nc" id="L253">		mesh.setVertices(vertices.items, 0, vertices.size);</span>
<span class="nc" id="L254">		mesh.setIndices(indices.items, 0, indices.size);</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">		for (MeshPart p : parts)</span>
<span class="nc" id="L257">			p.mesh = mesh;</span>
<span class="nc" id="L258">		parts.clear();</span>

<span class="nc" id="L260">		attributes = null;</span>
<span class="nc" id="L261">		vertices.clear();</span>
<span class="nc" id="L262">		indices.clear();</span>

<span class="nc" id="L264">		return mesh;</span>
	}

	/** End building the mesh and returns the mesh */
	public Mesh end () {
<span class="nc" id="L269">		return end(new Mesh(true, vertices.size / stride, indices.size, attributes));</span>
	}

	/** Clears the data being built up until now, including the vertices, indices and all parts. Must be called in between the call
	 * to #begin and #end. Any builder calls made from the last call to #begin up until now are practically discarded. The state
	 * (e.g. UV region, color, vertex transform) will remain unchanged. */
	public void clear () {
<span class="nc" id="L276">		this.vertices.clear();</span>
<span class="nc" id="L277">		this.indices.clear();</span>
<span class="nc" id="L278">		this.parts.clear();</span>
<span class="nc" id="L279">		this.vindex = 0;</span>
<span class="nc" id="L280">		this.lastIndex = -1;</span>
<span class="nc" id="L281">		this.istart = 0;</span>
<span class="nc" id="L282">		this.part = null;</span>
<span class="nc" id="L283">	}</span>

	/** @return the size in number of floats of one vertex, multiply by four to get the size in bytes. */
	public int getFloatsPerVertex () {
<span class="nc" id="L287">		return stride;</span>
	}

	/** @return The number of vertices built up until now, only valid in between the call to begin() and end(). */
	public int getNumVertices () {
<span class="nc" id="L292">		return vertices.size / stride;</span>
	}

	/** Get a copy of the vertices built so far.
	 * @param out The float array to receive the copy of the vertices, must be at least `destOffset` + {@link #getNumVertices()} *
	 *           {@link #getFloatsPerVertex()} in size.
	 * @param destOffset The offset (number of floats) in the out array where to start copying */
	public void getVertices (float[] out, int destOffset) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">		if (attributes == null) throw new GdxRuntimeException(&quot;Must be called in between #begin and #end&quot;);</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">		if ((destOffset &lt; 0) || (destOffset &gt; out.length - vertices.size))</span>
<span class="nc" id="L302">			throw new GdxRuntimeException(&quot;Array to small or offset out of range&quot;);</span>
<span class="nc" id="L303">		System.arraycopy(vertices.items, 0, out, destOffset, vertices.size);</span>
<span class="nc" id="L304">	}</span>

	/** Provides direct access to the vertices array being built, use with care. The size of the array might be bigger, do not rely
	 * on the length of the array. Instead use {@link #getFloatsPerVertex()} * {@link #getNumVertices()} to calculate the usable
	 * size of the array. Must be called in between the call to #begin and #end. */
	protected float[] getVertices () {
<span class="nc" id="L310">		return vertices.items;</span>
	}

	/** @return The number of indices built up until now, only valid in between the call to begin() and end(). */
	public int getNumIndices () {
<span class="nc" id="L315">		return indices.size;</span>
	}

	/** Get a copy of the indices built so far.
	 * @param out The short array to receive the copy of the indices, must be at least `destOffset` + {@link #getNumIndices()} in
	 *           size.
	 * @param destOffset The offset (number of shorts) in the out array where to start copying */
	public void getIndices (short[] out, int destOffset) {
<span class="nc bnc" id="L323" title="All 2 branches missed.">		if (attributes == null) throw new GdxRuntimeException(&quot;Must be called in between #begin and #end&quot;);</span>
<span class="nc bnc" id="L324" title="All 4 branches missed.">		if ((destOffset &lt; 0) || (destOffset &gt; out.length - indices.size))</span>
<span class="nc" id="L325">			throw new GdxRuntimeException(&quot;Array to small or offset out of range&quot;);</span>
<span class="nc" id="L326">		System.arraycopy(indices.items, 0, out, destOffset, indices.size);</span>
<span class="nc" id="L327">	}</span>

	/** Provides direct access to the indices array being built, use with care. The size of the array might be bigger, do not rely
	 * on the length of the array. Instead use {@link #getNumIndices()} to calculate the usable size of the array. Must be called
	 * in between the call to #begin and #end. */
	protected short[] getIndices () {
<span class="nc" id="L333">		return indices.items;</span>
	}

	@Override
	public VertexAttributes getAttributes () {
<span class="nc" id="L338">		return attributes;</span>
	}

	@Override
	public MeshPart getMeshPart () {
<span class="nc" id="L343">		return part;</span>
	}

<span class="nc" id="L346">	private final static Pool&lt;Vector3&gt; vectorPool = new Pool&lt;Vector3&gt;() {</span>
		@Override
		protected Vector3 newObject () {
<span class="nc" id="L349">			return new Vector3();</span>
		}
	};

<span class="nc" id="L353">	private final static Array&lt;Vector3&gt; vectorArray = new Array&lt;Vector3&gt;();</span>
<span class="nc" id="L354">	private final static Pool&lt;Matrix4&gt; matrices4Pool = new Pool&lt;Matrix4&gt;() {</span>
		@Override
		protected Matrix4 newObject () {
<span class="nc" id="L357">			return new Matrix4();</span>
		}
	};

<span class="nc" id="L361">	private final static Array&lt;Matrix4&gt; matrices4Array = new Array&lt;Matrix4&gt;();</span>

	private Vector3 tmp (float x, float y, float z) {
<span class="nc" id="L364">		final Vector3 result = vectorPool.obtain().set(x, y, z);</span>
<span class="nc" id="L365">		vectorArray.add(result);</span>
<span class="nc" id="L366">		return result;</span>
	}

	private Vector3 tmp (Vector3 copyFrom) {
<span class="nc" id="L370">		return tmp(copyFrom.x, copyFrom.y, copyFrom.z);</span>
	}

	private Matrix4 tmp () {
<span class="nc" id="L374">		final Matrix4 result = matrices4Pool.obtain().idt();</span>
<span class="nc" id="L375">		matrices4Array.add(result);</span>
<span class="nc" id="L376">		return result;</span>
	}

	private Matrix4 tmp (Matrix4 copyFrom) {
<span class="nc" id="L380">		return tmp().set(copyFrom);</span>
	}

	private void cleanup () {
<span class="nc" id="L384">		vectorPool.freeAll(vectorArray);</span>
<span class="nc" id="L385">		vectorArray.clear();</span>
<span class="nc" id="L386">		matrices4Pool.freeAll(matrices4Array);</span>
<span class="nc" id="L387">		matrices4Array.clear();</span>
<span class="nc" id="L388">	}</span>

	@Override
	public void setColor (float r, float g, float b, float a) {
<span class="nc" id="L392">		color.set(r, g, b, a);</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">		hasColor = !color.equals(Color.WHITE);</span>
<span class="nc" id="L394">	}</span>

	@Override
	public void setColor (final Color color) {
<span class="nc bnc" id="L398" title="All 4 branches missed.">		this.color.set(!(hasColor = (color != null)) ? Color.WHITE : color);</span>
<span class="nc" id="L399">	}</span>

	@Override
	public void setUVRange (float u1, float v1, float u2, float v2) {
<span class="nc" id="L403">		uOffset = u1;</span>
<span class="nc" id="L404">		vOffset = v1;</span>
<span class="nc" id="L405">		uScale = u2 - u1;</span>
<span class="nc" id="L406">		vScale = v2 - v1;</span>
<span class="nc bnc" id="L407" title="All 8 branches missed.">		hasUVTransform = !(MathUtils.isZero(u1) &amp;&amp; MathUtils.isZero(v1) &amp;&amp; MathUtils.isEqual(u2, 1f) &amp;&amp; MathUtils.isEqual(v2, 1f));</span>
<span class="nc" id="L408">	}</span>

	@Override
	public void setUVRange (TextureRegion region) {
<span class="nc bnc" id="L412" title="All 4 branches missed.">		if (!(hasUVTransform = (region != null))) {</span>
<span class="nc" id="L413">			uOffset = vOffset = 0f;</span>
<span class="nc" id="L414">			uScale = vScale = 1f;</span>
		} else
<span class="nc" id="L416">			setUVRange(region.getU(), region.getV(), region.getU2(), region.getV2());</span>
<span class="nc" id="L417">	}</span>

	@Override
	public Matrix4 getVertexTransform (Matrix4 out) {
<span class="nc" id="L421">		return out.set(positionTransform);</span>
	}

	@Override
	public void setVertexTransform (Matrix4 transform) {
<span class="nc bnc" id="L426" title="All 4 branches missed.">		if ((vertexTransformationEnabled = (transform != null)) == true) {</span>
<span class="nc" id="L427">			positionTransform.set(transform);</span>
<span class="nc" id="L428">			normalTransform.set(transform).inv().transpose();</span>
		} else {
<span class="nc" id="L430">			positionTransform.idt();</span>
<span class="nc" id="L431">			normalTransform.idt();</span>
		}
<span class="nc" id="L433">	}</span>

	@Override
	public boolean isVertexTransformationEnabled () {
<span class="nc" id="L437">		return vertexTransformationEnabled;</span>
	}

	@Override
	public void setVertexTransformationEnabled (boolean enabled) {
<span class="nc" id="L442">		vertexTransformationEnabled = enabled;</span>
<span class="nc" id="L443">	}</span>

	/** Increases the size of the backing vertices array to accommodate the specified number of additional vertices. Useful before
	 * adding many vertices to avoid multiple backing array resizes.
	 * @param numVertices The number of vertices you are about to add */
	public void ensureVertices (int numVertices) {
<span class="nc" id="L449">		vertices.ensureCapacity(stride * numVertices);</span>
<span class="nc" id="L450">	}</span>

	/** Increases the size of the backing indices array to accommodate the specified number of additional indices. Useful before
	 * adding many indices to avoid multiple backing array resizes.
	 * @param numIndices The number of indices you are about to add */
	public void ensureIndices (int numIndices) {
<span class="nc" id="L456">		indices.ensureCapacity(numIndices);</span>
<span class="nc" id="L457">	}</span>

	/** Increases the size of the backing vertices and indices arrays to accommodate the specified number of additional vertices and
	 * indices. Useful before adding many vertices and indices to avoid multiple backing array resizes.
	 * @param numVertices The number of vertices you are about to add
	 * @param numIndices The number of indices you are about to add */
	public void ensureCapacity (int numVertices, int numIndices) {
<span class="nc" id="L464">		ensureVertices(numVertices);</span>
<span class="nc" id="L465">		ensureIndices(numIndices);</span>
<span class="nc" id="L466">	}</span>

	/** Increases the size of the backing indices array to accommodate the specified number of additional triangles. Useful before
	 * adding many triangles to avoid multiple backing array resizes.
	 * @param numTriangles The number of triangles you are about to add */
	public void ensureTriangleIndices (int numTriangles) {
<span class="nc bnc" id="L472" title="All 2 branches missed.">		if (primitiveType == GL20.GL_LINES)</span>
<span class="nc" id="L473">			ensureIndices(6 * numTriangles);</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">		else if (primitiveType == GL20.GL_TRIANGLES || primitiveType == GL20.GL_POINTS)</span>
<span class="nc" id="L475">			ensureIndices(3 * numTriangles);</span>
		else
<span class="nc" id="L477">			throw new GdxRuntimeException(&quot;Incorrect primtive type&quot;);</span>
<span class="nc" id="L478">	}</span>

	/** Increases the size of the backing vertices and indices arrays to accommodate the specified number of additional vertices and
	 * triangles. Useful before adding many triangles to avoid multiple backing array resizes.
	 * @param numVertices The number of vertices you are about to add
	 * @param numTriangles The number of triangles you are about to add */
	public void ensureTriangles (int numVertices, int numTriangles) {
<span class="nc" id="L485">		ensureVertices(numVertices);</span>
<span class="nc" id="L486">		ensureTriangleIndices(numTriangles);</span>
<span class="nc" id="L487">	}</span>

	/** Increases the size of the backing vertices and indices arrays to accommodate the specified number of additional vertices and
	 * triangles. Useful before adding many triangles to avoid multiple backing array resizes. Assumes each triangles adds 3
	 * vertices.
	 * @param numTriangles The number of triangles you are about to add */
	public void ensureTriangles (int numTriangles) {
<span class="nc" id="L494">		ensureTriangles(3 * numTriangles, numTriangles);</span>
<span class="nc" id="L495">	}</span>

	/** Increases the size of the backing indices array to accommodate the specified number of additional rectangles. Useful before
	 * adding many rectangles to avoid multiple backing array resizes.
	 * @param numRectangles The number of rectangles you are about to add */
	public void ensureRectangleIndices (int numRectangles) {
<span class="nc bnc" id="L501" title="All 2 branches missed.">		if (primitiveType == GL20.GL_POINTS)</span>
<span class="nc" id="L502">			ensureIndices(4 * numRectangles);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">		else if (primitiveType == GL20.GL_LINES)</span>
<span class="nc" id="L504">			ensureIndices(8 * numRectangles);</span>
		else
			// GL_TRIANGLES
<span class="nc" id="L507">			ensureIndices(6 * numRectangles);</span>
<span class="nc" id="L508">	}</span>

	/** Increases the size of the backing vertices and indices arrays to accommodate the specified number of additional vertices and
	 * rectangles. Useful before adding many rectangles to avoid multiple backing array resizes.
	 * @param numVertices The number of vertices you are about to add
	 * @param numRectangles The number of rectangles you are about to add */
	public void ensureRectangles (int numVertices, int numRectangles) {
<span class="nc" id="L515">		ensureVertices(numVertices);</span>
<span class="nc" id="L516">		ensureRectangleIndices(numRectangles);</span>
<span class="nc" id="L517">	}</span>

	/** Increases the size of the backing vertices and indices arrays to accommodate the specified number of additional vertices and
	 * rectangles. Useful before adding many rectangles to avoid multiple backing array resizes. Assumes each rectangles adds 4
	 * vertices
	 * @param numRectangles The number of rectangles you are about to add */
	public void ensureRectangles (int numRectangles) {
<span class="nc" id="L524">		ensureRectangles(4 * numRectangles, numRectangles);</span>
<span class="nc" id="L525">	}</span>

<span class="nc" id="L527">	private short lastIndex = -1;</span>

	@Override
	public short lastIndex () {
<span class="nc" id="L531">		return lastIndex;</span>
	}

<span class="nc" id="L534">	private final static Vector3 vTmp = new Vector3();</span>

	private final static void transformPosition (final float[] values, final int offset, final int size, Matrix4 transform) {
<span class="nc bnc" id="L537" title="All 2 branches missed.">		if (size &gt; 2) {</span>
<span class="nc" id="L538">			vTmp.set(values[offset], values[offset + 1], values[offset + 2]).mul(transform);</span>
<span class="nc" id="L539">			values[offset] = vTmp.x;</span>
<span class="nc" id="L540">			values[offset + 1] = vTmp.y;</span>
<span class="nc" id="L541">			values[offset + 2] = vTmp.z;</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">		} else if (size &gt; 1) {</span>
<span class="nc" id="L543">			vTmp.set(values[offset], values[offset + 1], 0).mul(transform);</span>
<span class="nc" id="L544">			values[offset] = vTmp.x;</span>
<span class="nc" id="L545">			values[offset + 1] = vTmp.y;</span>
		} else
<span class="nc" id="L547">			values[offset] = vTmp.set(values[offset], 0, 0).mul(transform).x;</span>
<span class="nc" id="L548">	}</span>

	private final static void transformNormal (final float[] values, final int offset, final int size, Matrix3 transform) {
<span class="nc bnc" id="L551" title="All 2 branches missed.">		if (size &gt; 2) {</span>
<span class="nc" id="L552">			vTmp.set(values[offset], values[offset + 1], values[offset + 2]).mul(transform).nor();</span>
<span class="nc" id="L553">			values[offset] = vTmp.x;</span>
<span class="nc" id="L554">			values[offset + 1] = vTmp.y;</span>
<span class="nc" id="L555">			values[offset + 2] = vTmp.z;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">		} else if (size &gt; 1) {</span>
<span class="nc" id="L557">			vTmp.set(values[offset], values[offset + 1], 0).mul(transform).nor();</span>
<span class="nc" id="L558">			values[offset] = vTmp.x;</span>
<span class="nc" id="L559">			values[offset + 1] = vTmp.y;</span>
		} else
<span class="nc" id="L561">			values[offset] = vTmp.set(values[offset], 0, 0).mul(transform).nor().x;</span>
<span class="nc" id="L562">	}</span>

	private final void addVertex (final float[] values, final int offset) {
<span class="nc" id="L565">		final int o = vertices.size;</span>
<span class="nc" id="L566">		vertices.addAll(values, offset, stride);</span>
<span class="nc" id="L567">		lastIndex = (short)(vindex++);</span>

<span class="nc bnc" id="L569" title="All 2 branches missed.">		if (vertexTransformationEnabled) {</span>
<span class="nc" id="L570">			transformPosition(vertices.items, o + posOffset, posSize, positionTransform);</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">			if (norOffset &gt;= 0) transformNormal(vertices.items, o + norOffset, 3, normalTransform);</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">			if (biNorOffset &gt;= 0) transformNormal(vertices.items, o + biNorOffset, 3, normalTransform);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">			if (tangentOffset &gt;= 0) transformNormal(vertices.items, o + tangentOffset, 3, normalTransform);</span>
		}
		
<span class="nc" id="L576">		final float x = vertices.items[o+posOffset];</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">		final float y = (posSize &gt; 1) ? vertices.items[o+posOffset+1] : 0f;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">		final float z = (posSize &gt; 2) ? vertices.items[o+posOffset+2] : 0f;</span>
<span class="nc" id="L579">		bounds.ext(x, y, z);</span>

<span class="nc bnc" id="L581" title="All 2 branches missed.">		if (hasColor) {</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">			if (colOffset &gt;= 0) {</span>
<span class="nc" id="L583">				vertices.items[o + colOffset] *= color.r;</span>
<span class="nc" id="L584">				vertices.items[o + colOffset + 1] *= color.g;</span>
<span class="nc" id="L585">				vertices.items[o + colOffset + 2] *= color.b;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">				if (colSize &gt; 3) vertices.items[o + colOffset + 3] *= color.a;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">			} else if (cpOffset &gt;= 0) {</span>
<span class="nc" id="L588">				vertices.items[o + cpOffset] = tempC1.set(NumberUtils.floatToIntColor(vertices.items[o + cpOffset])).mul(color)</span>
					.toFloatBits();
			}
		}

<span class="nc bnc" id="L593" title="All 4 branches missed.">		if (hasUVTransform &amp;&amp; uvOffset &gt;= 0) {</span>
<span class="nc" id="L594">			vertices.items[o + uvOffset] = uOffset + uScale * vertices.items[o + uvOffset];</span>
<span class="nc" id="L595">			vertices.items[o + uvOffset + 1] = vOffset + vScale * vertices.items[o + uvOffset + 1];</span>
		}
<span class="nc" id="L597">	}</span>

<span class="nc" id="L599">	private final Vector3 tmpNormal = new Vector3();</span>

	@Override
	public short vertex (Vector3 pos, Vector3 nor, Color col, Vector2 uv) {
<span class="nc bnc" id="L603" title="All 2 branches missed.">		if (vindex &gt;= Short.MAX_VALUE) throw new GdxRuntimeException(&quot;Too many vertices used&quot;);</span>

<span class="nc" id="L605">		vertex[posOffset] = pos.x;</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">		if (posSize &gt; 1) vertex[posOffset + 1] = pos.y;</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">		if (posSize &gt; 2) vertex[posOffset + 2] = pos.z;</span>

<span class="nc bnc" id="L609" title="All 2 branches missed.">		if (norOffset &gt;= 0) {</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">			if (nor == null) nor = tmpNormal.set(pos).nor();</span>
<span class="nc" id="L611">			vertex[norOffset] = nor.x;</span>
<span class="nc" id="L612">			vertex[norOffset + 1] = nor.y;</span>
<span class="nc" id="L613">			vertex[norOffset + 2] = nor.z;</span>
		}

<span class="nc bnc" id="L616" title="All 2 branches missed.">		if (colOffset &gt;= 0) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">			if (col == null) col = Color.WHITE;</span>
<span class="nc" id="L618">			vertex[colOffset] = col.r;</span>
<span class="nc" id="L619">			vertex[colOffset + 1] = col.g;</span>
<span class="nc" id="L620">			vertex[colOffset + 2] = col.b;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">			if (colSize &gt; 3) vertex[colOffset + 3] = col.a;</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">		} else if (cpOffset &gt; 0) {</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">			if (col == null) col = Color.WHITE;</span>
<span class="nc" id="L624">			vertex[cpOffset] = col.toFloatBits(); // FIXME cache packed color?</span>
		}

<span class="nc bnc" id="L627" title="All 4 branches missed.">		if (uv != null &amp;&amp; uvOffset &gt;= 0) {</span>
<span class="nc" id="L628">			vertex[uvOffset] = uv.x;</span>
<span class="nc" id="L629">			vertex[uvOffset + 1] = uv.y;</span>
		}

<span class="nc" id="L632">		addVertex(vertex, 0);</span>
<span class="nc" id="L633">		return lastIndex;</span>
	}

	@Override
	public short vertex (final float... values) {
<span class="nc" id="L638">		final int n = values.length - stride;</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">		for (int i = 0; i &lt;= n; i += stride)</span>
<span class="nc" id="L640">			addVertex(values, i);</span>
<span class="nc" id="L641">		return lastIndex;</span>
	}

	@Override
	public short vertex (final VertexInfo info) {
<span class="nc bnc" id="L646" title="All 8 branches missed.">		return vertex(info.hasPosition ? info.position : null, info.hasNormal ? info.normal : null, info.hasColor ? info.color</span>
			: null, info.hasUV ? info.uv : null);
	}

	@Override
	public void index (final short value) {
<span class="nc" id="L652">		indices.add(value);</span>
<span class="nc" id="L653">	}</span>

	@Override
	public void index (final short value1, final short value2) {
<span class="nc" id="L657">		ensureIndices(2);</span>
<span class="nc" id="L658">		indices.add(value1);</span>
<span class="nc" id="L659">		indices.add(value2);</span>
<span class="nc" id="L660">	}</span>

	@Override
	public void index (final short value1, final short value2, final short value3) {
<span class="nc" id="L664">		ensureIndices(3);</span>
<span class="nc" id="L665">		indices.add(value1);</span>
<span class="nc" id="L666">		indices.add(value2);</span>
<span class="nc" id="L667">		indices.add(value3);</span>
<span class="nc" id="L668">	}</span>

	@Override
	public void index (final short value1, final short value2, final short value3, final short value4) {
<span class="nc" id="L672">		ensureIndices(4);</span>
<span class="nc" id="L673">		indices.add(value1);</span>
<span class="nc" id="L674">		indices.add(value2);</span>
<span class="nc" id="L675">		indices.add(value3);</span>
<span class="nc" id="L676">		indices.add(value4);</span>
<span class="nc" id="L677">	}</span>

	@Override
	public void index (short value1, short value2, short value3, short value4, short value5, short value6) {
<span class="nc" id="L681">		ensureIndices(6);</span>
<span class="nc" id="L682">		indices.add(value1);</span>
<span class="nc" id="L683">		indices.add(value2);</span>
<span class="nc" id="L684">		indices.add(value3);</span>
<span class="nc" id="L685">		indices.add(value4);</span>
<span class="nc" id="L686">		indices.add(value5);</span>
<span class="nc" id="L687">		indices.add(value6);</span>
<span class="nc" id="L688">	}</span>

	@Override
	public void index (short value1, short value2, short value3, short value4, short value5, short value6, short value7,
		short value8) {
<span class="nc" id="L693">		ensureIndices(8);</span>
<span class="nc" id="L694">		indices.add(value1);</span>
<span class="nc" id="L695">		indices.add(value2);</span>
<span class="nc" id="L696">		indices.add(value3);</span>
<span class="nc" id="L697">		indices.add(value4);</span>
<span class="nc" id="L698">		indices.add(value5);</span>
<span class="nc" id="L699">		indices.add(value6);</span>
<span class="nc" id="L700">		indices.add(value7);</span>
<span class="nc" id="L701">		indices.add(value8);</span>
<span class="nc" id="L702">	}</span>

	@Override
	public void line (short index1, short index2) {
<span class="nc bnc" id="L706" title="All 2 branches missed.">		if (primitiveType != GL20.GL_LINES) throw new GdxRuntimeException(&quot;Incorrect primitive type&quot;);</span>
<span class="nc" id="L707">		index(index1, index2);</span>
<span class="nc" id="L708">	}</span>

	@Override
	public void line (VertexInfo p1, VertexInfo p2) {
<span class="nc" id="L712">		ensureVertices(2);</span>
<span class="nc" id="L713">		line(vertex(p1), vertex(p2));</span>
<span class="nc" id="L714">	}</span>

	@Override
	public void line (Vector3 p1, Vector3 p2) {
<span class="nc" id="L718">		line(vertTmp1.set(p1, null, null, null), vertTmp2.set(p2, null, null, null));</span>
<span class="nc" id="L719">	}</span>

	@Override
	public void line (float x1, float y1, float z1, float x2, float y2, float z2) {
<span class="nc" id="L723">		line(vertTmp1.set(null, null, null, null).setPos(x1, y1, z1), vertTmp2.set(null, null, null, null).setPos(x2, y2, z2));</span>
<span class="nc" id="L724">	}</span>

	@Override
	public void line (Vector3 p1, Color c1, Vector3 p2, Color c2) {
<span class="nc" id="L728">		line(vertTmp1.set(p1, null, c1, null), vertTmp2.set(p2, null, c2, null));</span>
<span class="nc" id="L729">	}</span>

	@Override
	public void triangle (short index1, short index2, short index3) {
<span class="nc bnc" id="L733" title="All 4 branches missed.">		if (primitiveType == GL20.GL_TRIANGLES || primitiveType == GL20.GL_POINTS) {</span>
<span class="nc" id="L734">			index(index1, index2, index3);</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">		} else if (primitiveType == GL20.GL_LINES) {</span>
<span class="nc" id="L736">			index(index1, index2, index2, index3, index3, index1);</span>
		} else
<span class="nc" id="L738">			throw new GdxRuntimeException(&quot;Incorrect primitive type&quot;);</span>
<span class="nc" id="L739">	}</span>

	@Override
	public void triangle (VertexInfo p1, VertexInfo p2, VertexInfo p3) {
<span class="nc" id="L743">		ensureVertices(3);</span>
<span class="nc" id="L744">		triangle(vertex(p1), vertex(p2), vertex(p3));</span>
<span class="nc" id="L745">	}</span>

	@Override
	public void triangle (Vector3 p1, Vector3 p2, Vector3 p3) {
<span class="nc" id="L749">		triangle(vertTmp1.set(p1, null, null, null), vertTmp2.set(p2, null, null, null), vertTmp3.set(p3, null, null, null));</span>
<span class="nc" id="L750">	}</span>

	@Override
	public void triangle (Vector3 p1, Color c1, Vector3 p2, Color c2, Vector3 p3, Color c3) {
<span class="nc" id="L754">		triangle(vertTmp1.set(p1, null, c1, null), vertTmp2.set(p2, null, c2, null), vertTmp3.set(p3, null, c3, null));</span>
<span class="nc" id="L755">	}</span>

	@Override
	public void rect (short corner00, short corner10, short corner11, short corner01) {
<span class="nc bnc" id="L759" title="All 2 branches missed.">		if (primitiveType == GL20.GL_TRIANGLES) {</span>
<span class="nc" id="L760">			index(corner00, corner10, corner11, corner11, corner01, corner00);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">		} else if (primitiveType == GL20.GL_LINES) {</span>
<span class="nc" id="L762">			index(corner00, corner10, corner10, corner11, corner11, corner01, corner01, corner00);</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">		} else if (primitiveType == GL20.GL_POINTS) {</span>
<span class="nc" id="L764">			index(corner00, corner10, corner11, corner01);</span>
		} else
<span class="nc" id="L766">			throw new GdxRuntimeException(&quot;Incorrect primitive type&quot;);</span>
<span class="nc" id="L767">	}</span>

	@Override
	public void rect (VertexInfo corner00, VertexInfo corner10, VertexInfo corner11, VertexInfo corner01) {
<span class="nc" id="L771">		ensureVertices(4);</span>
<span class="nc" id="L772">		rect(vertex(corner00), vertex(corner10), vertex(corner11), vertex(corner01));</span>
<span class="nc" id="L773">	}</span>

	@Override
	public void rect (Vector3 corner00, Vector3 corner10, Vector3 corner11, Vector3 corner01, Vector3 normal) {
<span class="nc" id="L777">		rect(vertTmp1.set(corner00, normal, null, null).setUV(0f, 1f), vertTmp2.set(corner10, normal, null, null).setUV(1f, 1f),</span>
			vertTmp3.set(corner11, normal, null, null).setUV(1f, 0f), vertTmp4.set(corner01, normal, null, null).setUV(0f, 0f));
<span class="nc" id="L779">	}</span>

	@Override
	public void rect (float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11,
		float x01, float y01, float z01, float normalX, float normalY, float normalZ) {
<span class="nc" id="L784">		rect(vertTmp1.set(null, null, null, null).setPos(x00, y00, z00).setNor(normalX, normalY, normalZ).setUV(0f, 1f), vertTmp2</span>
			.set(null, null, null, null).setPos(x10, y10, z10).setNor(normalX, normalY, normalZ).setUV(1f, 1f),
			vertTmp3.set(null, null, null, null).setPos(x11, y11, z11).setNor(normalX, normalY, normalZ).setUV(1f, 0f), vertTmp4
				.set(null, null, null, null).setPos(x01, y01, z01).setNor(normalX, normalY, normalZ).setUV(0f, 0f));
<span class="nc" id="L788">	}</span>

	@Override
	public void patch (VertexInfo corner00, VertexInfo corner10, VertexInfo corner11, VertexInfo corner01, int divisionsU,
		int divisionsV) {
<span class="nc bnc" id="L793" title="All 4 branches missed.">		if (divisionsU &lt; 1 || divisionsV &lt; 1) {</span>
<span class="nc" id="L794">			throw new GdxRuntimeException(&quot;divisionsU and divisionV must be &gt; 0, u,v: &quot; + divisionsU + &quot;, &quot; + divisionsV);</span>
		}
<span class="nc" id="L796">		ensureRectangles((divisionsV + 1) * (divisionsU + 1), divisionsV * divisionsU);</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">		for (int u = 0; u &lt;= divisionsU; u++) {</span>
<span class="nc" id="L798">			final float alphaU = (float)u / (float)divisionsU;</span>
<span class="nc" id="L799">			vertTmp5.set(corner00).lerp(corner10, alphaU);</span>
<span class="nc" id="L800">			vertTmp6.set(corner01).lerp(corner11, alphaU);</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">			for (int v = 0; v &lt;= divisionsV; v++) {</span>
<span class="nc" id="L802">				final short idx = vertex(vertTmp7.set(vertTmp5).lerp(vertTmp6, (float)v / (float)divisionsV));</span>
<span class="nc bnc" id="L803" title="All 4 branches missed.">				if (u &gt; 0 &amp;&amp; v &gt; 0) rect((short)(idx - divisionsV - 2), (short)(idx - 1), idx, (short)(idx - divisionsV - 1));</span>
			}
		}
<span class="nc" id="L806">	}</span>

	@Override
	public void patch (Vector3 corner00, Vector3 corner10, Vector3 corner11, Vector3 corner01, Vector3 normal, int divisionsU,
		int divisionsV) {
<span class="nc" id="L811">		patch(vertTmp1.set(corner00, normal, null, null).setUV(0f, 1f), vertTmp2.set(corner10, normal, null, null).setUV(1f, 1f),</span>
			vertTmp3.set(corner11, normal, null, null).setUV(1f, 0f), vertTmp4.set(corner01, normal, null, null).setUV(0f, 0f),
			divisionsU, divisionsV);
<span class="nc" id="L814">	}</span>

	public void patch (float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11,
		float x01, float y01, float z01, float normalX, float normalY, float normalZ, int divisionsU, int divisionsV) {
<span class="nc" id="L818">		patch(vertTmp1.set(null).setPos(x00, y00, z00).setNor(normalX, normalY, normalZ).setUV(0f, 1f),</span>
			vertTmp2.set(null).setPos(x10, y10, z10).setNor(normalX, normalY, normalZ).setUV(1f, 1f),
			vertTmp3.set(null).setPos(x11, y11, z11).setNor(normalX, normalY, normalZ).setUV(1f, 0f),
			vertTmp4.set(null).setPos(x01, y01, z01).setNor(normalX, normalY, normalZ).setUV(0f, 0f), divisionsU, divisionsV);
<span class="nc" id="L822">	}</span>

	@Override
	public void box (VertexInfo corner000, VertexInfo corner010, VertexInfo corner100, VertexInfo corner110, VertexInfo corner001,
		VertexInfo corner011, VertexInfo corner101, VertexInfo corner111) {
<span class="nc" id="L827">		ensureVertices(8);</span>
<span class="nc" id="L828">		final short i000 = vertex(corner000);</span>
<span class="nc" id="L829">		final short i100 = vertex(corner100);</span>
<span class="nc" id="L830">		final short i110 = vertex(corner110);</span>
<span class="nc" id="L831">		final short i010 = vertex(corner010);</span>
<span class="nc" id="L832">		final short i001 = vertex(corner001);</span>
<span class="nc" id="L833">		final short i101 = vertex(corner101);</span>
<span class="nc" id="L834">		final short i111 = vertex(corner111);</span>
<span class="nc" id="L835">		final short i011 = vertex(corner011);</span>

<span class="nc bnc" id="L837" title="All 2 branches missed.">		if (primitiveType == GL20.GL_LINES) {</span>
<span class="nc" id="L838">			ensureIndices(24);</span>
<span class="nc" id="L839">			rect(i000, i100, i110, i010);</span>
<span class="nc" id="L840">			rect(i101, i001, i011, i111);</span>
<span class="nc" id="L841">			index(i000, i001, i010, i011, i110, i111, i100, i101);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">		} else if (primitiveType == GL20.GL_POINTS) {</span>
<span class="nc" id="L843">			ensureRectangleIndices(2);</span>
<span class="nc" id="L844">			rect(i000, i100, i110, i010);</span>
<span class="nc" id="L845">			rect(i101, i001, i011, i111);</span>
		} else { // GL20.GL_TRIANGLES
<span class="nc" id="L847">			ensureRectangleIndices(6);</span>
<span class="nc" id="L848">			rect(i000, i100, i110, i010);</span>
<span class="nc" id="L849">			rect(i101, i001, i011, i111);</span>
<span class="nc" id="L850">			rect(i000, i010, i011, i001);</span>
<span class="nc" id="L851">			rect(i101, i111, i110, i100);</span>
<span class="nc" id="L852">			rect(i101, i100, i000, i001);</span>
<span class="nc" id="L853">			rect(i110, i111, i011, i010);</span>
		}
<span class="nc" id="L855">	}</span>

	@Override
	public void box (Vector3 corner000, Vector3 corner010, Vector3 corner100, Vector3 corner110, Vector3 corner001,
		Vector3 corner011, Vector3 corner101, Vector3 corner111) {
<span class="nc bnc" id="L860" title="All 4 branches missed.">		if (norOffset &lt; 0 &amp;&amp; uvOffset &lt; 0) {</span>
<span class="nc" id="L861">			box(vertTmp1.set(corner000, null, null, null), vertTmp2.set(corner010, null, null, null),</span>
				vertTmp3.set(corner100, null, null, null), vertTmp4.set(corner110, null, null, null),
				vertTmp5.set(corner001, null, null, null), vertTmp6.set(corner011, null, null, null),
				vertTmp7.set(corner101, null, null, null), vertTmp8.set(corner111, null, null, null));
		} else {
<span class="nc" id="L866">			ensureRectangles(6);</span>
<span class="nc" id="L867">			Vector3 nor = tempV1.set(corner000).lerp(corner110, 0.5f).sub(tempV2.set(corner001).lerp(corner111, 0.5f)).nor();</span>
<span class="nc" id="L868">			rect(corner000, corner010, corner110, corner100, nor);</span>
<span class="nc" id="L869">			rect(corner011, corner001, corner101, corner111, nor.scl(-1));</span>
<span class="nc" id="L870">			nor = tempV1.set(corner000).lerp(corner101, 0.5f).sub(tempV2.set(corner010).lerp(corner111, 0.5f)).nor();</span>
<span class="nc" id="L871">			rect(corner001, corner000, corner100, corner101, nor);</span>
<span class="nc" id="L872">			rect(corner010, corner011, corner111, corner110, nor.scl(-1));</span>
<span class="nc" id="L873">			nor = tempV1.set(corner000).lerp(corner011, 0.5f).sub(tempV2.set(corner100).lerp(corner111, 0.5f)).nor();</span>
<span class="nc" id="L874">			rect(corner001, corner011, corner010, corner000, nor);</span>
<span class="nc" id="L875">			rect(corner100, corner110, corner111, corner101, nor.scl(-1));</span>
		}
<span class="nc" id="L877">	}</span>

	@Override
	public void box (Matrix4 transform) {
<span class="nc" id="L881">		box(tmp(-0.5f, -0.5f, -0.5f).mul(transform), tmp(-0.5f, 0.5f, -0.5f).mul(transform),</span>
			tmp(0.5f, -0.5f, -0.5f).mul(transform), tmp(0.5f, 0.5f, -0.5f).mul(transform), tmp(-0.5f, -0.5f, 0.5f).mul(transform),
			tmp(-0.5f, 0.5f, 0.5f).mul(transform), tmp(0.5f, -0.5f, 0.5f).mul(transform), tmp(0.5f, 0.5f, 0.5f).mul(transform));
<span class="nc" id="L884">		cleanup();</span>
<span class="nc" id="L885">	}</span>

	@Override
	public void box (float width, float height, float depth) {
<span class="nc" id="L889">		box(matTmp1.setToScaling(width, height, depth));</span>
<span class="nc" id="L890">	}</span>

	@Override
	public void box (float x, float y, float z, float width, float height, float depth) {
<span class="nc" id="L894">		box(matTmp1.setToScaling(width, height, depth).trn(x, y, z));</span>
<span class="nc" id="L895">	}</span>

	@Override
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ) {
<span class="nc" id="L900">		circle(radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, 0f, 360f);</span>
<span class="nc" id="L901">	}</span>

	@Override
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal) {
<span class="nc" id="L905">		circle(radius, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z);</span>
<span class="nc" id="L906">	}</span>

	@Override
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, final Vector3 tangent,
		final Vector3 binormal) {
<span class="nc" id="L911">		circle(radius, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z, tangent.x, tangent.y, tangent.z,</span>
			binormal.x, binormal.y, binormal.z);
<span class="nc" id="L913">	}</span>

	@Override
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY, float binormalZ) {
<span class="nc" id="L918">		circle(radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX, tangentY, tangentZ, binormalX,</span>
			binormalY, binormalZ, 0f, 360f);
<span class="nc" id="L920">	}</span>

	@Override
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ, float angleFrom, float angleTo) {
<span class="nc" id="L925">		ellipse(radius * 2f, radius * 2f, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, angleFrom, angleTo);</span>
<span class="nc" id="L926">	}</span>

	@Override
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, float angleFrom, float angleTo) {
<span class="nc" id="L930">		circle(radius, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z, angleFrom, angleTo);</span>
<span class="nc" id="L931">	}</span>

	@Override
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, final Vector3 tangent,
		final Vector3 binormal, float angleFrom, float angleTo) {
<span class="nc" id="L936">		circle(radius, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z, tangent.x, tangent.y, tangent.z,</span>
			binormal.x, binormal.y, binormal.z, angleFrom, angleTo);
<span class="nc" id="L938">	}</span>

	@Override
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY, float binormalZ,
		float angleFrom, float angleTo) {
<span class="nc" id="L944">		ellipse(radius * 2, radius * 2, 0, 0, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX, tangentY,</span>
			tangentZ, binormalX, binormalY, binormalZ, angleFrom, angleTo);
<span class="nc" id="L946">	}</span>

	@Override
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ) {
<span class="nc" id="L951">		ellipse(width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, 0f, 360f);</span>
<span class="nc" id="L952">	}</span>

	@Override
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal) {
<span class="nc" id="L956">		ellipse(width, height, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z);</span>
<span class="nc" id="L957">	}</span>

	@Override
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal,
		final Vector3 tangent, final Vector3 binormal) {
<span class="nc" id="L962">		ellipse(width, height, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z, tangent.x, tangent.y,</span>
			tangent.z, binormal.x, binormal.y, binormal.z);
<span class="nc" id="L964">	}</span>

	@Override
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY,
		float binormalZ) {
<span class="nc" id="L970">		ellipse(width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX, tangentY, tangentZ,</span>
			binormalX, binormalY, binormalZ, 0f, 360f);
<span class="nc" id="L972">	}</span>

	@Override
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ, float angleFrom, float angleTo) {
<span class="nc" id="L977">		ellipse(width, height, 0f, 0f, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, angleFrom, angleTo);</span>
<span class="nc" id="L978">	}</span>

	@Override
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal, float angleFrom,
		float angleTo) {
<span class="nc" id="L983">		ellipse(width, height, 0f, 0f, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z, angleFrom, angleTo);</span>
<span class="nc" id="L984">	}</span>

	@Override
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal,
		final Vector3 tangent, final Vector3 binormal, float angleFrom, float angleTo) {
<span class="nc" id="L989">		ellipse(width, height, 0f, 0f, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z, tangent.x, tangent.y,</span>
			tangent.z, binormal.x, binormal.y, binormal.z, angleFrom, angleTo);
<span class="nc" id="L991">	}</span>

	@Override
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY,
		float binormalZ, float angleFrom, float angleTo) {
<span class="nc" id="L997">		ellipse(width, height, 0f, 0f, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX, tangentY,</span>
			tangentZ, binormalX, binormalY, binormalZ, angleFrom, angleTo);
<span class="nc" id="L999">	}</span>

	@Override
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, Vector3 center,
		Vector3 normal) {
<span class="nc" id="L1004">		ellipse(width, height, innerWidth, innerHeight, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z, 0f,</span>
			360f);
<span class="nc" id="L1006">	}</span>

	@Override
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, float centerX,
		float centerY, float centerZ, float normalX, float normalY, float normalZ) {
<span class="nc" id="L1011">		ellipse(width, height, innerWidth, innerHeight, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, 0f, 360f);</span>
<span class="nc" id="L1012">	}</span>

	@Override
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, float centerX,
		float centerY, float centerZ, float normalX, float normalY, float normalZ, float angleFrom, float angleTo) {
<span class="nc" id="L1017">		tempV1.set(normalX, normalY, normalZ).crs(0, 0, 1);</span>
<span class="nc" id="L1018">		tempV2.set(normalX, normalY, normalZ).crs(0, 1, 0);</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">		if (tempV2.len2() &gt; tempV1.len2()) tempV1.set(tempV2);</span>
<span class="nc" id="L1020">		tempV2.set(tempV1.nor()).crs(normalX, normalY, normalZ).nor();</span>
<span class="nc" id="L1021">		ellipse(width, height, innerWidth, innerHeight, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tempV1.x,</span>
			tempV1.y, tempV1.z, tempV2.x, tempV2.y, tempV2.z, angleFrom, angleTo);
<span class="nc" id="L1023">	}</span>

	@Override
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, float centerX,
		float centerY, float centerZ, float normalX, float normalY, float normalZ, float tangentX, float tangentY, float tangentZ,
		float binormalX, float binormalY, float binormalZ, float angleFrom, float angleTo) {
<span class="nc bnc" id="L1029" title="All 4 branches missed.">		if (innerWidth &lt;= 0 || innerHeight &lt;= 0) {</span>
<span class="nc" id="L1030">			ensureTriangles(divisions + 2, divisions);</span>
<span class="nc bnc" id="L1031" title="All 4 branches missed.">		} else if (innerWidth == width &amp;&amp; innerHeight == height) {</span>
<span class="nc" id="L1032">			ensureVertices(divisions + 1);</span>
<span class="nc" id="L1033">			ensureIndices(divisions + 1);</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">			if (primitiveType != GL20.GL_LINES)</span>
<span class="nc" id="L1035">				throw new GdxRuntimeException(</span>
					&quot;Incorrect primitive type : expect GL_LINES because innerWidth == width &amp;&amp; innerHeight == height&quot;);
		} else {
<span class="nc" id="L1038">			ensureRectangles((divisions + 1) * 2, divisions + 1);</span>
		}

<span class="nc" id="L1041">		final float ao = MathUtils.degreesToRadians * angleFrom;</span>
<span class="nc" id="L1042">		final float step = (MathUtils.degreesToRadians * (angleTo - angleFrom)) / divisions;</span>
<span class="nc" id="L1043">		final Vector3 sxEx = tempV1.set(tangentX, tangentY, tangentZ).scl(width * 0.5f);</span>
<span class="nc" id="L1044">		final Vector3 syEx = tempV2.set(binormalX, binormalY, binormalZ).scl(height * 0.5f);</span>
<span class="nc" id="L1045">		final Vector3 sxIn = tempV3.set(tangentX, tangentY, tangentZ).scl(innerWidth * 0.5f);</span>
<span class="nc" id="L1046">		final Vector3 syIn = tempV4.set(binormalX, binormalY, binormalZ).scl(innerHeight * 0.5f);</span>
<span class="nc" id="L1047">		VertexInfo currIn = vertTmp3.set(null, null, null, null);</span>
<span class="nc" id="L1048">		currIn.hasUV = currIn.hasPosition = currIn.hasNormal = true;</span>
<span class="nc" id="L1049">		currIn.uv.set(.5f, .5f);</span>
<span class="nc" id="L1050">		currIn.position.set(centerX, centerY, centerZ);</span>
<span class="nc" id="L1051">		currIn.normal.set(normalX, normalY, normalZ);</span>
<span class="nc" id="L1052">		VertexInfo currEx = vertTmp4.set(null, null, null, null);</span>
<span class="nc" id="L1053">		currEx.hasUV = currEx.hasPosition = currEx.hasNormal = true;</span>
<span class="nc" id="L1054">		currEx.uv.set(.5f, .5f);</span>
<span class="nc" id="L1055">		currEx.position.set(centerX, centerY, centerZ);</span>
<span class="nc" id="L1056">		currEx.normal.set(normalX, normalY, normalZ);</span>
<span class="nc" id="L1057">		final short center = vertex(currEx);</span>
<span class="nc" id="L1058">		float angle = 0f;</span>
<span class="nc" id="L1059">		final float us = 0.5f * (innerWidth / width);</span>
<span class="nc" id="L1060">		final float vs = 0.5f * (innerHeight / height);</span>
<span class="nc" id="L1061">		short i1, i2 = 0, i3 = 0, i4 = 0;</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">		for (int i = 0; i &lt;= divisions; i++) {</span>
<span class="nc" id="L1063">			angle = ao + step * i;</span>
<span class="nc" id="L1064">			final float x = MathUtils.cos(angle);</span>
<span class="nc" id="L1065">			final float y = MathUtils.sin(angle);</span>
<span class="nc" id="L1066">			currEx.position.set(centerX, centerY, centerZ).add(sxEx.x * x + syEx.x * y, sxEx.y * x + syEx.y * y,</span>
				sxEx.z * x + syEx.z * y);
<span class="nc" id="L1068">			currEx.uv.set(.5f + .5f * x, .5f + .5f * y);</span>
<span class="nc" id="L1069">			i1 = vertex(currEx);</span>

<span class="nc bnc" id="L1071" title="All 4 branches missed.">			if (innerWidth &lt;= 0f || innerHeight &lt;= 0f) {</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">				if (i != 0) triangle(i1, i2, center);</span>
<span class="nc" id="L1073">				i2 = i1;</span>
<span class="nc bnc" id="L1074" title="All 4 branches missed.">			} else if (innerWidth == width &amp;&amp; innerHeight == height) {</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">				if (i != 0) line(i1, i2);</span>
<span class="nc" id="L1076">				i2 = i1;</span>
			} else {
<span class="nc" id="L1078">				currIn.position.set(centerX, centerY, centerZ).add(sxIn.x * x + syIn.x * y, sxIn.y * x + syIn.y * y,</span>
					sxIn.z * x + syIn.z * y);
<span class="nc" id="L1080">				currIn.uv.set(.5f + us * x, .5f + vs * y);</span>
<span class="nc" id="L1081">				i2 = i1;</span>
<span class="nc" id="L1082">				i1 = vertex(currIn);</span>

<span class="nc bnc" id="L1084" title="All 2 branches missed.">				if (i != 0) rect(i1, i2, i4, i3);</span>
<span class="nc" id="L1085">				i4 = i2;</span>
<span class="nc" id="L1086">				i3 = i1;</span>
			}
		}
<span class="nc" id="L1089">	}</span>

	@Override
	public void cylinder (float width, float height, float depth, int divisions) {
<span class="nc" id="L1093">		cylinder(width, height, depth, divisions, 0, 360);</span>
<span class="nc" id="L1094">	}</span>

	@Override
	public void cylinder (float width, float height, float depth, int divisions, float angleFrom, float angleTo) {
<span class="nc" id="L1098">		cylinder(width, height, depth, divisions, angleFrom, angleTo, true);</span>
<span class="nc" id="L1099">	}</span>

	/** Add a cylinder */
	public void cylinder (float width, float height, float depth, int divisions, float angleFrom, float angleTo, boolean close) {
		// FIXME create better cylinder method (- axis on which to create the cylinder (matrix?))
<span class="nc" id="L1104">		final float hw = width * 0.5f;</span>
<span class="nc" id="L1105">		final float hh = height * 0.5f;</span>
<span class="nc" id="L1106">		final float hd = depth * 0.5f;</span>
<span class="nc" id="L1107">		final float ao = MathUtils.degreesToRadians * angleFrom;</span>
<span class="nc" id="L1108">		final float step = (MathUtils.degreesToRadians * (angleTo - angleFrom)) / divisions;</span>
<span class="nc" id="L1109">		final float us = 1f / divisions;</span>
<span class="nc" id="L1110">		float u = 0f;</span>
<span class="nc" id="L1111">		float angle = 0f;</span>
<span class="nc" id="L1112">		VertexInfo curr1 = vertTmp3.set(null, null, null, null);</span>
<span class="nc" id="L1113">		curr1.hasUV = curr1.hasPosition = curr1.hasNormal = true;</span>
<span class="nc" id="L1114">		VertexInfo curr2 = vertTmp4.set(null, null, null, null);</span>
<span class="nc" id="L1115">		curr2.hasUV = curr2.hasPosition = curr2.hasNormal = true;</span>
<span class="nc" id="L1116">		short i1, i2, i3 = 0, i4 = 0;</span>

<span class="nc" id="L1118">		ensureRectangles(2 * (divisions + 1), divisions);</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">		for (int i = 0; i &lt;= divisions; i++) {</span>
<span class="nc" id="L1120">			angle = ao + step * i;</span>
<span class="nc" id="L1121">			u = 1f - us * i;</span>
<span class="nc" id="L1122">			curr1.position.set(MathUtils.cos(angle) * hw, 0f, MathUtils.sin(angle) * hd);</span>
<span class="nc" id="L1123">			curr1.normal.set(curr1.position).nor();</span>
<span class="nc" id="L1124">			curr1.position.y = -hh;</span>
<span class="nc" id="L1125">			curr1.uv.set(u, 1);</span>
<span class="nc" id="L1126">			curr2.position.set(curr1.position);</span>
<span class="nc" id="L1127">			curr2.normal.set(curr1.normal);</span>
<span class="nc" id="L1128">			curr2.position.y = hh;</span>
<span class="nc" id="L1129">			curr2.uv.set(u, 0);</span>
<span class="nc" id="L1130">			i2 = vertex(curr1);</span>
<span class="nc" id="L1131">			i1 = vertex(curr2);</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">			if (i != 0) rect(i3, i1, i2, i4); // FIXME don't duplicate lines and points</span>
<span class="nc" id="L1133">			i4 = i2;</span>
<span class="nc" id="L1134">			i3 = i1;</span>
		}
<span class="nc bnc" id="L1136" title="All 2 branches missed.">		if (close) {</span>
<span class="nc" id="L1137">			ellipse(width, depth, 0, 0, divisions, 0, hh, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, angleFrom, angleTo);</span>
<span class="nc" id="L1138">			ellipse(width, depth, 0, 0, divisions, 0, -hh, 0, 0, -1, 0, -1, 0, 0, 0, 0, 1, 180f - angleTo, 180f - angleFrom);</span>
		}
<span class="nc" id="L1140">	}</span>

	@Override
	public void cone (float width, float height, float depth, int divisions) {
<span class="nc" id="L1144">		cone(width, height, depth, divisions, 0, 360);</span>
<span class="nc" id="L1145">	}</span>

	@Override
	public void cone (float width, float height, float depth, int divisions, float angleFrom, float angleTo) {
		// FIXME create better cylinder method (- axis on which to create the cone (matrix?))
<span class="nc" id="L1150">		ensureTriangles(divisions + 2, divisions);</span>

<span class="nc" id="L1152">		final float hw = width * 0.5f;</span>
<span class="nc" id="L1153">		final float hh = height * 0.5f;</span>
<span class="nc" id="L1154">		final float hd = depth * 0.5f;</span>
<span class="nc" id="L1155">		final float ao = MathUtils.degreesToRadians * angleFrom;</span>
<span class="nc" id="L1156">		final float step = (MathUtils.degreesToRadians * (angleTo - angleFrom)) / divisions;</span>
<span class="nc" id="L1157">		final float us = 1f / divisions;</span>
<span class="nc" id="L1158">		float u = 0f;</span>
<span class="nc" id="L1159">		float angle = 0f;</span>
<span class="nc" id="L1160">		VertexInfo curr1 = vertTmp3.set(null, null, null, null);</span>
<span class="nc" id="L1161">		curr1.hasUV = curr1.hasPosition = curr1.hasNormal = true;</span>
<span class="nc" id="L1162">		VertexInfo curr2 = vertTmp4.set(null, null, null, null).setPos(0, hh, 0).setNor(0, 1, 0).setUV(0.5f, 0);</span>
<span class="nc" id="L1163">		final short base = vertex(curr2);</span>
<span class="nc" id="L1164">		short i1, i2 = 0;</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">		for (int i = 0; i &lt;= divisions; i++) {</span>
<span class="nc" id="L1166">			angle = ao + step * i;</span>
<span class="nc" id="L1167">			u = 1f - us * i;</span>
<span class="nc" id="L1168">			curr1.position.set(MathUtils.cos(angle) * hw, 0f, MathUtils.sin(angle) * hd);</span>
<span class="nc" id="L1169">			curr1.normal.set(curr1.position).nor();</span>
<span class="nc" id="L1170">			curr1.position.y = -hh;</span>
<span class="nc" id="L1171">			curr1.uv.set(u, 1);</span>
<span class="nc" id="L1172">			i1 = vertex(curr1);</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">			if (i != 0) triangle(base, i1, i2); // FIXME don't duplicate lines and points</span>
<span class="nc" id="L1174">			i2 = i1;</span>
		}
<span class="nc" id="L1176">		ellipse(width, depth, 0, 0, divisions, 0, -hh, 0, 0, -1, 0, -1, 0, 0, 0, 0, 1, 180f - angleTo, 180f - angleFrom);</span>
<span class="nc" id="L1177">	}</span>

	@Override
	public void sphere (float width, float height, float depth, int divisionsU, int divisionsV) {
<span class="nc" id="L1181">		sphere(width, height, depth, divisionsU, divisionsV, 0, 360, 0, 180);</span>
<span class="nc" id="L1182">	}</span>

	@Override
	public void sphere (final Matrix4 transform, float width, float height, float depth, int divisionsU, int divisionsV) {
<span class="nc" id="L1186">		sphere(transform, width, height, depth, divisionsU, divisionsV, 0, 360, 0, 180);</span>
<span class="nc" id="L1187">	}</span>

	@Override
	public void sphere (float width, float height, float depth, int divisionsU, int divisionsV, float angleUFrom, float angleUTo,
		float angleVFrom, float angleVTo) {
<span class="nc" id="L1192">		sphere(matTmp1.idt(), width, height, depth, divisionsU, divisionsV, angleUFrom, angleUTo, angleVFrom, angleVTo);</span>
<span class="nc" id="L1193">	}</span>

	@Override
	public void sphere (final Matrix4 transform, float width, float height, float depth, int divisionsU, int divisionsV,
		float angleUFrom, float angleUTo, float angleVFrom, float angleVTo) {
		// FIXME create better sphere method (- only one vertex for each pole, - position)
<span class="nc" id="L1199">		final float hw = width * 0.5f;</span>
<span class="nc" id="L1200">		final float hh = height * 0.5f;</span>
<span class="nc" id="L1201">		final float hd = depth * 0.5f;</span>
<span class="nc" id="L1202">		final float auo = MathUtils.degreesToRadians * angleUFrom;</span>
<span class="nc" id="L1203">		final float stepU = (MathUtils.degreesToRadians * (angleUTo - angleUFrom)) / divisionsU;</span>
<span class="nc" id="L1204">		final float avo = MathUtils.degreesToRadians * angleVFrom;</span>
<span class="nc" id="L1205">		final float stepV = (MathUtils.degreesToRadians * (angleVTo - angleVFrom)) / divisionsV;</span>
<span class="nc" id="L1206">		final float us = 1f / divisionsU;</span>
<span class="nc" id="L1207">		final float vs = 1f / divisionsV;</span>
<span class="nc" id="L1208">		float u = 0f;</span>
<span class="nc" id="L1209">		float v = 0f;</span>
<span class="nc" id="L1210">		float angleU = 0f;</span>
<span class="nc" id="L1211">		float angleV = 0f;</span>
<span class="nc" id="L1212">		VertexInfo curr1 = vertTmp3.set(null, null, null, null);</span>
<span class="nc" id="L1213">		curr1.hasUV = curr1.hasPosition = curr1.hasNormal = true;</span>

<span class="nc" id="L1215">		final int s = divisionsU + 3;</span>
<span class="nc" id="L1216">		tmpIndices.clear();</span>
<span class="nc" id="L1217">		tmpIndices.ensureCapacity(divisionsU * 2);</span>
<span class="nc" id="L1218">		tmpIndices.size = s;</span>
<span class="nc" id="L1219">		int tempOffset = 0;</span>

<span class="nc" id="L1221">		ensureRectangles((divisionsV + 1) * (divisionsU + 1), divisionsV * divisionsU);</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">		for (int iv = 0; iv &lt;= divisionsV; iv++) {</span>
<span class="nc" id="L1223">			angleV = avo + stepV * iv;</span>
<span class="nc" id="L1224">			v = vs * iv;</span>
<span class="nc" id="L1225">			final float t = MathUtils.sin(angleV);</span>
<span class="nc" id="L1226">			final float h = MathUtils.cos(angleV) * hh;</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">			for (int iu = 0; iu &lt;= divisionsU; iu++) {</span>
<span class="nc" id="L1228">				angleU = auo + stepU * iu;</span>
<span class="nc" id="L1229">				u = 1f - us * iu;</span>
<span class="nc" id="L1230">				curr1.position.set(MathUtils.cos(angleU) * hw * t, h, MathUtils.sin(angleU) * hd * t).mul(transform);</span>
<span class="nc" id="L1231">				curr1.normal.set(curr1.position).nor();</span>
<span class="nc" id="L1232">				curr1.uv.set(u, v);</span>
<span class="nc" id="L1233">				tmpIndices.set(tempOffset, vertex(curr1));</span>
<span class="nc" id="L1234">				final int o = tempOffset + s;</span>
<span class="nc bnc" id="L1235" title="All 4 branches missed.">				if ((iv &gt; 0) &amp;&amp; (iu &gt; 0)) // FIXME don't duplicate lines and points</span>
<span class="nc" id="L1236">					rect(tmpIndices.get(tempOffset), tmpIndices.get((o - 1) % s), tmpIndices.get((o - (divisionsU + 2)) % s),</span>
						tmpIndices.get((o - (divisionsU + 1)) % s));
<span class="nc" id="L1238">				tempOffset = (tempOffset + 1) % tmpIndices.size;</span>
			}
		}
<span class="nc" id="L1241">	}</span>

	@Override
	public void capsule (float radius, float height, int divisions) {
<span class="nc bnc" id="L1245" title="All 2 branches missed.">		if (height &lt; 2f * radius) throw new GdxRuntimeException(&quot;Height must be at least twice the radius&quot;);</span>
<span class="nc" id="L1246">		final float d = 2f * radius;</span>
<span class="nc" id="L1247">		cylinder(d, height - d, d, divisions, 0, 360, false);</span>
<span class="nc" id="L1248">		sphere(matTmp1.setToTranslation(0, .5f * (height - d), 0), d, d, d, divisions, divisions, 0, 360, 0, 90);</span>
<span class="nc" id="L1249">		sphere(matTmp1.setToTranslation(0, -.5f * (height - d), 0), d, d, d, divisions, divisions, 0, 360, 90, 180);</span>
<span class="nc" id="L1250">	}</span>

	@Override
	public void arrow (float x1, float y1, float z1, float x2, float y2, float z2, float capLength, float stemThickness,
		int divisions) {
<span class="nc" id="L1255">		Vector3 begin = tmp(x1, y1, z1), end = tmp(x2, y2, z2);</span>
<span class="nc" id="L1256">		float length = begin.dst(end);</span>
<span class="nc" id="L1257">		float coneHeight = length * capLength;</span>
<span class="nc" id="L1258">		float coneDiameter = 2 * (float)(coneHeight * Math.sqrt(1f / 3));</span>
<span class="nc" id="L1259">		float stemLength = length - coneHeight;</span>
<span class="nc" id="L1260">		float stemDiameter = coneDiameter * stemThickness;</span>

<span class="nc" id="L1262">		Vector3 up = tmp(end).sub(begin).nor();</span>
<span class="nc" id="L1263">		Vector3 forward = tmp(up).crs(Vector3.Z);</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">		if (forward.isZero()) forward.set(Vector3.X);</span>
<span class="nc" id="L1265">		forward.crs(up).nor();</span>
<span class="nc" id="L1266">		Vector3 left = tmp(up).crs(forward).nor();</span>
<span class="nc" id="L1267">		Vector3 direction = tmp(end).sub(begin).nor();</span>

		// Matrices
<span class="nc" id="L1270">		Matrix4 userTransform = getVertexTransform(tmp());</span>
<span class="nc" id="L1271">		Matrix4 transform = tmp();</span>
<span class="nc" id="L1272">		float[] val = transform.val;</span>
<span class="nc" id="L1273">		val[Matrix4.M00] = left.x;</span>
<span class="nc" id="L1274">		val[Matrix4.M01] = up.x;</span>
<span class="nc" id="L1275">		val[Matrix4.M02] = forward.x;</span>
<span class="nc" id="L1276">		val[Matrix4.M10] = left.y;</span>
<span class="nc" id="L1277">		val[Matrix4.M11] = up.y;</span>
<span class="nc" id="L1278">		val[Matrix4.M12] = forward.y;</span>
<span class="nc" id="L1279">		val[Matrix4.M20] = left.z;</span>
<span class="nc" id="L1280">		val[Matrix4.M21] = up.z;</span>
<span class="nc" id="L1281">		val[Matrix4.M22] = forward.z;</span>
<span class="nc" id="L1282">		Matrix4 temp = tmp();</span>

		// Stem
<span class="nc" id="L1285">		transform.setTranslation(tmp(direction).scl(stemLength / 2).add(x1, y1, z1));</span>
<span class="nc" id="L1286">		setVertexTransform(temp.set(transform).mul(userTransform));</span>
<span class="nc" id="L1287">		cylinder(stemDiameter, stemLength, stemDiameter, divisions);</span>

		// Cap
<span class="nc" id="L1290">		transform.setTranslation(tmp(direction).scl(stemLength).add(x1, y1, z1));</span>
<span class="nc" id="L1291">		setVertexTransform(temp.set(transform).mul(userTransform));</span>
<span class="nc" id="L1292">		cone(coneDiameter, coneHeight, coneDiameter, divisions);</span>

<span class="nc" id="L1294">		setVertexTransform(userTransform);</span>
<span class="nc" id="L1295">		cleanup();</span>
<span class="nc" id="L1296">	}</span>

	@Override
	public void addMesh (Mesh mesh) {
<span class="nc" id="L1300">		addMesh(mesh, 0, mesh.getNumIndices());</span>
<span class="nc" id="L1301">	}</span>

	@Override
	public void addMesh (MeshPart meshpart) {
<span class="nc bnc" id="L1305" title="All 2 branches missed.">		if (meshpart.primitiveType != primitiveType) throw new GdxRuntimeException(&quot;Primitive type doesn't match&quot;);</span>
<span class="nc" id="L1306">		addMesh(meshpart.mesh, meshpart.offset, meshpart.size);</span>
<span class="nc" id="L1307">	}</span>

	@Override
	public void addMesh (Mesh mesh, int indexOffset, int numIndices) {
<span class="nc bnc" id="L1311" title="All 2 branches missed.">		if (!attributes.equals(mesh.getVertexAttributes())) throw new GdxRuntimeException(&quot;Vertex attributes do not match&quot;);</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">		if (numIndices &lt;= 0) return; // silently ignore an empty mesh part</span>

		// FIXME don't triple copy, instead move the copy to jni
<span class="nc" id="L1315">		int numFloats = mesh.getNumVertices() * stride;</span>
<span class="nc" id="L1316">		tmpVertices.clear();</span>
<span class="nc" id="L1317">		tmpVertices.ensureCapacity(numFloats);</span>
<span class="nc" id="L1318">		tmpVertices.size = numFloats;</span>
<span class="nc" id="L1319">		mesh.getVertices(tmpVertices.items);</span>

<span class="nc" id="L1321">		tmpIndices.clear();</span>
<span class="nc" id="L1322">		tmpIndices.ensureCapacity(numIndices);</span>
<span class="nc" id="L1323">		tmpIndices.size = numIndices;</span>
<span class="nc" id="L1324">		mesh.getIndices(indexOffset, numIndices, tmpIndices.items, 0);</span>

<span class="nc" id="L1326">		addMesh(tmpVertices.items, tmpIndices.items, 0, numIndices);</span>
<span class="nc" id="L1327">	}</span>

<span class="nc" id="L1329">	private static IntIntMap indicesMap = null;</span>

	@Override
	public void addMesh (float[] vertices, short[] indices, int indexOffset, int numIndices) {
<span class="nc bnc" id="L1333" title="All 2 branches missed.">		if (indicesMap == null)</span>
<span class="nc" id="L1334">			indicesMap = new IntIntMap(numIndices);</span>
		else {
<span class="nc" id="L1336">			indicesMap.clear();</span>
<span class="nc" id="L1337">			indicesMap.ensureCapacity(numIndices);</span>
		}
<span class="nc" id="L1339">		ensureIndices(numIndices);</span>
<span class="nc" id="L1340">		final int numVertices = vertices.length / stride;</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">		ensureVertices(numVertices &lt; numIndices ? numVertices : numIndices);</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">		for (int i = 0; i &lt; numIndices; i++) {</span>
<span class="nc" id="L1343">			final int sidx = indices[i];</span>
<span class="nc" id="L1344">			int didx = indicesMap.get(sidx, -1);</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">			if (didx &lt; 0) {</span>
<span class="nc" id="L1346">				addVertex(vertices, sidx * stride);</span>
<span class="nc" id="L1347">				indicesMap.put(sidx, didx = lastIndex);</span>
			}
<span class="nc" id="L1349">			index((short)didx);</span>
		}
<span class="nc" id="L1351">	}</span>
	
	@Override
	public void addMesh (float[] vertices, short[] indices) {
<span class="nc" id="L1355">		final short offset = (short)(lastIndex + 1);</span>
		
<span class="nc" id="L1357">		final int numVertices = vertices.length / stride;</span>
<span class="nc" id="L1358">		ensureVertices(numVertices);</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">		for (int v = 0; v &lt; vertices.length; v += stride)</span>
<span class="nc" id="L1360">			addVertex(vertices, v);</span>
		
<span class="nc" id="L1362">		ensureIndices(indices.length);</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">		for (int i = 0; i &lt; indices.length; ++i)</span>
<span class="nc" id="L1364">			index((short)(indices[i] + offset));</span>
<span class="nc" id="L1365">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>