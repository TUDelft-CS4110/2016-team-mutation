<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ParticleEmitter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx.graphics.g2d</a> &gt; <span class="el_source">ParticleEmitter.java</span></div><h1>ParticleEmitter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.graphics.g2d;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Writer;

import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.collision.BoundingBox;

public class ParticleEmitter {
	static private final int UPDATE_SCALE = 1 &lt;&lt; 0;
	static private final int UPDATE_ANGLE = 1 &lt;&lt; 1;
	static private final int UPDATE_ROTATION = 1 &lt;&lt; 2;
	static private final int UPDATE_VELOCITY = 1 &lt;&lt; 3;
	static private final int UPDATE_WIND = 1 &lt;&lt; 4;
	static private final int UPDATE_GRAVITY = 1 &lt;&lt; 5;
	static private final int UPDATE_TINT = 1 &lt;&lt; 6;

<span class="nc" id="L38">	private RangedNumericValue delayValue = new RangedNumericValue();</span>
<span class="nc" id="L39">	private ScaledNumericValue lifeOffsetValue = new ScaledNumericValue();</span>
<span class="nc" id="L40">	private RangedNumericValue durationValue = new RangedNumericValue();</span>
<span class="nc" id="L41">	private ScaledNumericValue lifeValue = new ScaledNumericValue();</span>
<span class="nc" id="L42">	private ScaledNumericValue emissionValue = new ScaledNumericValue();</span>
<span class="nc" id="L43">	private ScaledNumericValue scaleValue = new ScaledNumericValue();</span>
<span class="nc" id="L44">	private ScaledNumericValue rotationValue = new ScaledNumericValue();</span>
<span class="nc" id="L45">	private ScaledNumericValue velocityValue = new ScaledNumericValue();</span>
<span class="nc" id="L46">	private ScaledNumericValue angleValue = new ScaledNumericValue();</span>
<span class="nc" id="L47">	private ScaledNumericValue windValue = new ScaledNumericValue();</span>
<span class="nc" id="L48">	private ScaledNumericValue gravityValue = new ScaledNumericValue();</span>
<span class="nc" id="L49">	private ScaledNumericValue transparencyValue = new ScaledNumericValue();</span>
<span class="nc" id="L50">	private GradientColorValue tintValue = new GradientColorValue();</span>
<span class="nc" id="L51">	private RangedNumericValue xOffsetValue = new ScaledNumericValue();</span>
<span class="nc" id="L52">	private RangedNumericValue yOffsetValue = new ScaledNumericValue();</span>
<span class="nc" id="L53">	private ScaledNumericValue spawnWidthValue = new ScaledNumericValue();</span>
<span class="nc" id="L54">	private ScaledNumericValue spawnHeightValue = new ScaledNumericValue();</span>
<span class="nc" id="L55">	private SpawnShapeValue spawnShapeValue = new SpawnShapeValue();</span>

	private float accumulator;
	private Sprite sprite;
	private Particle[] particles;
<span class="nc" id="L60">	private int minParticleCount, maxParticleCount = 4;</span>
	private float x, y;
	private String name;
	private String imagePath;
	private int activeCount;
	private boolean[] active;
	private boolean firstUpdate;
	private boolean flipX, flipY;
	private int updateFlags;
	private boolean allowCompletion;
	private BoundingBox bounds;

	private int emission, emissionDiff, emissionDelta;
	private int lifeOffset, lifeOffsetDiff;
	private int life, lifeDiff;
	private float spawnWidth, spawnWidthDiff;
	private float spawnHeight, spawnHeightDiff;
<span class="nc" id="L77">	public float duration = 1, durationTimer;</span>
	private float delay, delayTimer;

	private boolean attached;
	private boolean continuous;
	private boolean aligned;
	private boolean behind;
<span class="nc" id="L84">	private boolean additive = true;</span>
<span class="nc" id="L85">	private boolean premultipliedAlpha = false;</span>
<span class="nc" id="L86">	boolean cleansUpBlendFunction = true;</span>

<span class="nc" id="L88">	public ParticleEmitter () {</span>
<span class="nc" id="L89">		initialize();</span>
<span class="nc" id="L90">	}</span>

<span class="nc" id="L92">	public ParticleEmitter (BufferedReader reader) throws IOException {</span>
<span class="nc" id="L93">		initialize();</span>
<span class="nc" id="L94">		load(reader);</span>
<span class="nc" id="L95">	}</span>

<span class="nc" id="L97">	public ParticleEmitter (ParticleEmitter emitter) {</span>
<span class="nc" id="L98">		sprite = emitter.sprite;</span>
<span class="nc" id="L99">		name = emitter.name;</span>
<span class="nc" id="L100">		imagePath = emitter.imagePath;</span>
<span class="nc" id="L101">		setMaxParticleCount(emitter.maxParticleCount);</span>
<span class="nc" id="L102">		minParticleCount = emitter.minParticleCount;</span>
<span class="nc" id="L103">		delayValue.load(emitter.delayValue);</span>
<span class="nc" id="L104">		durationValue.load(emitter.durationValue);</span>
<span class="nc" id="L105">		emissionValue.load(emitter.emissionValue);</span>
<span class="nc" id="L106">		lifeValue.load(emitter.lifeValue);</span>
<span class="nc" id="L107">		lifeOffsetValue.load(emitter.lifeOffsetValue);</span>
<span class="nc" id="L108">		scaleValue.load(emitter.scaleValue);</span>
<span class="nc" id="L109">		rotationValue.load(emitter.rotationValue);</span>
<span class="nc" id="L110">		velocityValue.load(emitter.velocityValue);</span>
<span class="nc" id="L111">		angleValue.load(emitter.angleValue);</span>
<span class="nc" id="L112">		windValue.load(emitter.windValue);</span>
<span class="nc" id="L113">		gravityValue.load(emitter.gravityValue);</span>
<span class="nc" id="L114">		transparencyValue.load(emitter.transparencyValue);</span>
<span class="nc" id="L115">		tintValue.load(emitter.tintValue);</span>
<span class="nc" id="L116">		xOffsetValue.load(emitter.xOffsetValue);</span>
<span class="nc" id="L117">		yOffsetValue.load(emitter.yOffsetValue);</span>
<span class="nc" id="L118">		spawnWidthValue.load(emitter.spawnWidthValue);</span>
<span class="nc" id="L119">		spawnHeightValue.load(emitter.spawnHeightValue);</span>
<span class="nc" id="L120">		spawnShapeValue.load(emitter.spawnShapeValue);</span>
<span class="nc" id="L121">		attached = emitter.attached;</span>
<span class="nc" id="L122">		continuous = emitter.continuous;</span>
<span class="nc" id="L123">		aligned = emitter.aligned;</span>
<span class="nc" id="L124">		behind = emitter.behind;</span>
<span class="nc" id="L125">		additive = emitter.additive;</span>
<span class="nc" id="L126">		premultipliedAlpha = emitter.premultipliedAlpha;</span>
<span class="nc" id="L127">		cleansUpBlendFunction = emitter.cleansUpBlendFunction;</span>
<span class="nc" id="L128">	}</span>

	private void initialize () {
<span class="nc" id="L131">		durationValue.setAlwaysActive(true);</span>
<span class="nc" id="L132">		emissionValue.setAlwaysActive(true);</span>
<span class="nc" id="L133">		lifeValue.setAlwaysActive(true);</span>
<span class="nc" id="L134">		scaleValue.setAlwaysActive(true);</span>
<span class="nc" id="L135">		transparencyValue.setAlwaysActive(true);</span>
<span class="nc" id="L136">		spawnShapeValue.setAlwaysActive(true);</span>
<span class="nc" id="L137">		spawnWidthValue.setAlwaysActive(true);</span>
<span class="nc" id="L138">		spawnHeightValue.setAlwaysActive(true);</span>
<span class="nc" id="L139">	}</span>

	public void setMaxParticleCount (int maxParticleCount) {
<span class="nc" id="L142">		this.maxParticleCount = maxParticleCount;</span>
<span class="nc" id="L143">		active = new boolean[maxParticleCount];</span>
<span class="nc" id="L144">		activeCount = 0;</span>
<span class="nc" id="L145">		particles = new Particle[maxParticleCount];</span>
<span class="nc" id="L146">	}</span>

	public void addParticle () {
<span class="nc" id="L149">		int activeCount = this.activeCount;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">		if (activeCount == maxParticleCount) return;</span>
<span class="nc" id="L151">		boolean[] active = this.active;</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">		for (int i = 0, n = active.length; i &lt; n; i++) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">			if (!active[i]) {</span>
<span class="nc" id="L154">				activateParticle(i);</span>
<span class="nc" id="L155">				active[i] = true;</span>
<span class="nc" id="L156">				this.activeCount = activeCount + 1;</span>
<span class="nc" id="L157">				break;</span>
			}
		}
<span class="nc" id="L160">	}</span>

	public void addParticles (int count) {
<span class="nc" id="L163">		count = Math.min(count, maxParticleCount - activeCount);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">		if (count == 0) return;</span>
<span class="nc" id="L165">		boolean[] active = this.active;</span>
<span class="nc" id="L166">		int index = 0, n = active.length;</span>
		outer:
<span class="nc bnc" id="L168" title="All 2 branches missed.">		for (int i = 0; i &lt; count; i++) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">			for (; index &lt; n; index++) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">				if (!active[index]) {</span>
<span class="nc" id="L171">					activateParticle(index);</span>
<span class="nc" id="L172">					active[index++] = true;</span>
<span class="nc" id="L173">					continue outer;</span>
				}
			}
			break;
		}
<span class="nc" id="L178">		this.activeCount += count;</span>
<span class="nc" id="L179">	}</span>

	public void update (float delta) {
<span class="nc" id="L182">		accumulator += delta * 1000;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">		if (accumulator &lt; 1) return;</span>
<span class="nc" id="L184">		int deltaMillis = (int)accumulator;</span>
<span class="nc" id="L185">		accumulator -= deltaMillis;</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">		if (delayTimer &lt; delay) {</span>
<span class="nc" id="L188">			delayTimer += deltaMillis;</span>
		} else {
<span class="nc" id="L190">			boolean done = false;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">			if (firstUpdate) {</span>
<span class="nc" id="L192">				firstUpdate = false;</span>
<span class="nc" id="L193">				addParticle();</span>
			}

<span class="nc bnc" id="L196" title="All 2 branches missed.">			if (durationTimer &lt; duration)</span>
<span class="nc" id="L197">				durationTimer += deltaMillis;</span>
			else {
<span class="nc bnc" id="L199" title="All 4 branches missed.">				if (!continuous || allowCompletion)</span>
<span class="nc" id="L200">					done = true;</span>
				else
<span class="nc" id="L202">					restart();</span>
			}

<span class="nc bnc" id="L205" title="All 2 branches missed.">			if (!done) {</span>
<span class="nc" id="L206">				emissionDelta += deltaMillis;</span>
<span class="nc" id="L207">				float emissionTime = emission + emissionDiff * emissionValue.getScale(durationTimer / (float)duration);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">				if (emissionTime &gt; 0) {</span>
<span class="nc" id="L209">					emissionTime = 1000 / emissionTime;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">					if (emissionDelta &gt;= emissionTime) {</span>
<span class="nc" id="L211">						int emitCount = (int)(emissionDelta / emissionTime);</span>
<span class="nc" id="L212">						emitCount = Math.min(emitCount, maxParticleCount - activeCount);</span>
<span class="nc" id="L213">						emissionDelta -= emitCount * emissionTime;</span>
<span class="nc" id="L214">						emissionDelta %= emissionTime;</span>
<span class="nc" id="L215">						addParticles(emitCount);</span>
					}
				}
<span class="nc bnc" id="L218" title="All 2 branches missed.">				if (activeCount &lt; minParticleCount) addParticles(minParticleCount - activeCount);</span>
			}
		}

<span class="nc" id="L222">		boolean[] active = this.active;</span>
<span class="nc" id="L223">		int activeCount = this.activeCount;</span>
<span class="nc" id="L224">		Particle[] particles = this.particles;</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">		for (int i = 0, n = active.length; i &lt; n; i++) {</span>
<span class="nc bnc" id="L226" title="All 4 branches missed.">			if (active[i] &amp;&amp; !updateParticle(particles[i], delta, deltaMillis)) {</span>
<span class="nc" id="L227">				active[i] = false;</span>
<span class="nc" id="L228">				activeCount--;</span>
			}
		}
<span class="nc" id="L231">		this.activeCount = activeCount;</span>
<span class="nc" id="L232">	}</span>

	public void draw (Batch batch) {
<span class="nc bnc" id="L235" title="All 2 branches missed.">		if (premultipliedAlpha) {</span>
<span class="nc" id="L236">			batch.setBlendFunction(GL20.GL_ONE, GL20.GL_ONE_MINUS_SRC_ALPHA);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">		} else if (additive) {</span>
<span class="nc" id="L238">			batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE);</span>
		} else {
<span class="nc" id="L240">			batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);</span>
		}
<span class="nc" id="L242">		Particle[] particles = this.particles;</span>
<span class="nc" id="L243">		boolean[] active = this.active;</span>

<span class="nc bnc" id="L245" title="All 2 branches missed.">		for (int i = 0, n = active.length; i &lt; n; i++) {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">			if (active[i]) particles[i].draw(batch);</span>
		}

<span class="nc bnc" id="L249" title="All 6 branches missed.">		if (cleansUpBlendFunction &amp;&amp; (additive || premultipliedAlpha))</span>
<span class="nc" id="L250">			batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);</span>

<span class="nc" id="L252">	}</span>

	/** Updates and draws the particles. This is slightly more efficient than calling {@link #update(float)} and
	 * {@link #draw(Batch)} separately. */
	public void draw (Batch batch, float delta) {
<span class="nc" id="L257">		accumulator += delta * 1000;</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">		if (accumulator &lt; 1) {</span>
<span class="nc" id="L259">			draw(batch);</span>
<span class="nc" id="L260">			return;</span>
		}
<span class="nc" id="L262">		int deltaMillis = (int)accumulator;</span>
<span class="nc" id="L263">		accumulator -= deltaMillis;</span>

<span class="nc bnc" id="L265" title="All 2 branches missed.">		if (premultipliedAlpha) {</span>
<span class="nc" id="L266">			batch.setBlendFunction(GL20.GL_ONE, GL20.GL_ONE_MINUS_SRC_ALPHA);</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">		} else if (additive) {</span>
<span class="nc" id="L268">			batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE);</span>
		} else {
<span class="nc" id="L270">			batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);</span>
		}

<span class="nc" id="L273">		Particle[] particles = this.particles;</span>
<span class="nc" id="L274">		boolean[] active = this.active;</span>
<span class="nc" id="L275">		int activeCount = this.activeCount;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">		for (int i = 0, n = active.length; i &lt; n; i++) {</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">			if (active[i]) {</span>
<span class="nc" id="L278">				Particle particle = particles[i];</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">				if (updateParticle(particle, delta, deltaMillis))</span>
<span class="nc" id="L280">					particle.draw(batch);</span>
				else {
<span class="nc" id="L282">					active[i] = false;</span>
<span class="nc" id="L283">					activeCount--;</span>
				}
			}
		}
<span class="nc" id="L287">		this.activeCount = activeCount;</span>

<span class="nc bnc" id="L289" title="All 6 branches missed.">		if (cleansUpBlendFunction &amp;&amp; (additive || premultipliedAlpha))</span>
<span class="nc" id="L290">			batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);</span>

<span class="nc bnc" id="L292" title="All 2 branches missed.">		if (delayTimer &lt; delay) {</span>
<span class="nc" id="L293">			delayTimer += deltaMillis;</span>
<span class="nc" id="L294">			return;</span>
		}

<span class="nc bnc" id="L297" title="All 2 branches missed.">		if (firstUpdate) {</span>
<span class="nc" id="L298">			firstUpdate = false;</span>
<span class="nc" id="L299">			addParticle();</span>
		}

<span class="nc bnc" id="L302" title="All 2 branches missed.">		if (durationTimer &lt; duration)</span>
<span class="nc" id="L303">			durationTimer += deltaMillis;</span>
		else {
<span class="nc bnc" id="L305" title="All 4 branches missed.">			if (!continuous || allowCompletion) return;</span>
<span class="nc" id="L306">			restart();</span>
		}

<span class="nc" id="L309">		emissionDelta += deltaMillis;</span>
<span class="nc" id="L310">		float emissionTime = emission + emissionDiff * emissionValue.getScale(durationTimer / (float)duration);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">		if (emissionTime &gt; 0) {</span>
<span class="nc" id="L312">			emissionTime = 1000 / emissionTime;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">			if (emissionDelta &gt;= emissionTime) {</span>
<span class="nc" id="L314">				int emitCount = (int)(emissionDelta / emissionTime);</span>
<span class="nc" id="L315">				emitCount = Math.min(emitCount, maxParticleCount - activeCount);</span>
<span class="nc" id="L316">				emissionDelta -= emitCount * emissionTime;</span>
<span class="nc" id="L317">				emissionDelta %= emissionTime;</span>
<span class="nc" id="L318">				addParticles(emitCount);</span>
			}
		}
<span class="nc bnc" id="L321" title="All 2 branches missed.">		if (activeCount &lt; minParticleCount) addParticles(minParticleCount - activeCount);</span>
<span class="nc" id="L322">	}</span>

	public void start () {
<span class="nc" id="L325">		firstUpdate = true;</span>
<span class="nc" id="L326">		allowCompletion = false;</span>
<span class="nc" id="L327">		restart();</span>
<span class="nc" id="L328">	}</span>

	public void reset () {
<span class="nc" id="L331">		emissionDelta = 0;</span>
<span class="nc" id="L332">		durationTimer = duration;</span>
<span class="nc" id="L333">		boolean[] active = this.active;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">		for (int i = 0, n = active.length; i &lt; n; i++)</span>
<span class="nc" id="L335">			active[i] = false;</span>
<span class="nc" id="L336">		activeCount = 0;</span>
<span class="nc" id="L337">		start();</span>
<span class="nc" id="L338">	}</span>

	private void restart () {
<span class="nc bnc" id="L341" title="All 2 branches missed.">		delay = delayValue.active ? delayValue.newLowValue() : 0;</span>
<span class="nc" id="L342">		delayTimer = 0;</span>

<span class="nc" id="L344">		durationTimer -= duration;</span>
<span class="nc" id="L345">		duration = durationValue.newLowValue();</span>

<span class="nc" id="L347">		emission = (int)emissionValue.newLowValue();</span>
<span class="nc" id="L348">		emissionDiff = (int)emissionValue.newHighValue();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">		if (!emissionValue.isRelative()) emissionDiff -= emission;</span>

<span class="nc" id="L351">		life = (int)lifeValue.newLowValue();</span>
<span class="nc" id="L352">		lifeDiff = (int)lifeValue.newHighValue();</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">		if (!lifeValue.isRelative()) lifeDiff -= life;</span>

<span class="nc bnc" id="L355" title="All 2 branches missed.">		lifeOffset = lifeOffsetValue.active ? (int)lifeOffsetValue.newLowValue() : 0;</span>
<span class="nc" id="L356">		lifeOffsetDiff = (int)lifeOffsetValue.newHighValue();</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">		if (!lifeOffsetValue.isRelative()) lifeOffsetDiff -= lifeOffset;</span>

<span class="nc" id="L359">		spawnWidth = spawnWidthValue.newLowValue();</span>
<span class="nc" id="L360">		spawnWidthDiff = spawnWidthValue.newHighValue();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">		if (!spawnWidthValue.isRelative()) spawnWidthDiff -= spawnWidth;</span>

<span class="nc" id="L363">		spawnHeight = spawnHeightValue.newLowValue();</span>
<span class="nc" id="L364">		spawnHeightDiff = spawnHeightValue.newHighValue();</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">		if (!spawnHeightValue.isRelative()) spawnHeightDiff -= spawnHeight;</span>

<span class="nc" id="L367">		updateFlags = 0;</span>
<span class="nc bnc" id="L368" title="All 4 branches missed.">		if (angleValue.active &amp;&amp; angleValue.timeline.length &gt; 1) updateFlags |= UPDATE_ANGLE;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">		if (velocityValue.active) updateFlags |= UPDATE_VELOCITY;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">		if (scaleValue.timeline.length &gt; 1) updateFlags |= UPDATE_SCALE;</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">		if (rotationValue.active &amp;&amp; rotationValue.timeline.length &gt; 1) updateFlags |= UPDATE_ROTATION;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">		if (windValue.active) updateFlags |= UPDATE_WIND;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">		if (gravityValue.active) updateFlags |= UPDATE_GRAVITY;</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">		if (tintValue.timeline.length &gt; 1) updateFlags |= UPDATE_TINT;</span>
<span class="nc" id="L375">	}</span>

	protected Particle newParticle (Sprite sprite) {
<span class="nc" id="L378">		return new Particle(sprite);</span>
	}

	private void activateParticle (int index) {
<span class="nc" id="L382">		Particle particle = particles[index];</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">		if (particle == null) {</span>
<span class="nc" id="L384">			particles[index] = particle = newParticle(sprite);</span>
<span class="nc" id="L385">			particle.flip(flipX, flipY);</span>
		}

<span class="nc" id="L388">		float percent = durationTimer / (float)duration;</span>
<span class="nc" id="L389">		int updateFlags = this.updateFlags;</span>

<span class="nc" id="L391">		particle.currentLife = particle.life = life + (int)(lifeDiff * lifeValue.getScale(percent));</span>

<span class="nc bnc" id="L393" title="All 2 branches missed.">		if (velocityValue.active) {</span>
<span class="nc" id="L394">			particle.velocity = velocityValue.newLowValue();</span>
<span class="nc" id="L395">			particle.velocityDiff = velocityValue.newHighValue();</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">			if (!velocityValue.isRelative()) particle.velocityDiff -= particle.velocity;</span>
		}

<span class="nc" id="L399">		particle.angle = angleValue.newLowValue();</span>
<span class="nc" id="L400">		particle.angleDiff = angleValue.newHighValue();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">		if (!angleValue.isRelative()) particle.angleDiff -= particle.angle;</span>
<span class="nc" id="L402">		float angle = 0;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">		if ((updateFlags &amp; UPDATE_ANGLE) == 0) {</span>
<span class="nc" id="L404">			angle = particle.angle + particle.angleDiff * angleValue.getScale(0);</span>
<span class="nc" id="L405">			particle.angle = angle;</span>
<span class="nc" id="L406">			particle.angleCos = MathUtils.cosDeg(angle);</span>
<span class="nc" id="L407">			particle.angleSin = MathUtils.sinDeg(angle);</span>
		}

<span class="nc" id="L410">		float spriteWidth = sprite.getWidth();</span>
<span class="nc" id="L411">		particle.scale = scaleValue.newLowValue() / spriteWidth;</span>
<span class="nc" id="L412">		particle.scaleDiff = scaleValue.newHighValue() / spriteWidth;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">		if (!scaleValue.isRelative()) particle.scaleDiff -= particle.scale;</span>
<span class="nc" id="L414">		particle.setScale(particle.scale + particle.scaleDiff * scaleValue.getScale(0));</span>

<span class="nc bnc" id="L416" title="All 2 branches missed.">		if (rotationValue.active) {</span>
<span class="nc" id="L417">			particle.rotation = rotationValue.newLowValue();</span>
<span class="nc" id="L418">			particle.rotationDiff = rotationValue.newHighValue();</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">			if (!rotationValue.isRelative()) particle.rotationDiff -= particle.rotation;</span>
<span class="nc" id="L420">			float rotation = particle.rotation + particle.rotationDiff * rotationValue.getScale(0);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">			if (aligned) rotation += angle;</span>
<span class="nc" id="L422">			particle.setRotation(rotation);</span>
		}

<span class="nc bnc" id="L425" title="All 2 branches missed.">		if (windValue.active) {</span>
<span class="nc" id="L426">			particle.wind = windValue.newLowValue();</span>
<span class="nc" id="L427">			particle.windDiff = windValue.newHighValue();</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">			if (!windValue.isRelative()) particle.windDiff -= particle.wind;</span>
		}

<span class="nc bnc" id="L431" title="All 2 branches missed.">		if (gravityValue.active) {</span>
<span class="nc" id="L432">			particle.gravity = gravityValue.newLowValue();</span>
<span class="nc" id="L433">			particle.gravityDiff = gravityValue.newHighValue();</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">			if (!gravityValue.isRelative()) particle.gravityDiff -= particle.gravity;</span>
		}

<span class="nc" id="L437">		float[] color = particle.tint;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">		if (color == null) particle.tint = color = new float[3];</span>
<span class="nc" id="L439">		float[] temp = tintValue.getColor(0);</span>
<span class="nc" id="L440">		color[0] = temp[0];</span>
<span class="nc" id="L441">		color[1] = temp[1];</span>
<span class="nc" id="L442">		color[2] = temp[2];</span>

<span class="nc" id="L444">		particle.transparency = transparencyValue.newLowValue();</span>
<span class="nc" id="L445">		particle.transparencyDiff = transparencyValue.newHighValue() - particle.transparency;</span>

		// Spawn.
<span class="nc" id="L448">		float x = this.x;</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">		if (xOffsetValue.active) x += xOffsetValue.newLowValue();</span>
<span class="nc" id="L450">		float y = this.y;</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">		if (yOffsetValue.active) y += yOffsetValue.newLowValue();</span>
<span class="nc bnc" id="L452" title="All 4 branches missed.">		switch (spawnShapeValue.shape) {</span>
		case square: {
<span class="nc" id="L454">			float width = spawnWidth + (spawnWidthDiff * spawnWidthValue.getScale(percent));</span>
<span class="nc" id="L455">			float height = spawnHeight + (spawnHeightDiff * spawnHeightValue.getScale(percent));</span>
<span class="nc" id="L456">			x += MathUtils.random(width) - width / 2;</span>
<span class="nc" id="L457">			y += MathUtils.random(height) - height / 2;</span>
<span class="nc" id="L458">			break;</span>
		}
		case ellipse: {
<span class="nc" id="L461">			float width = spawnWidth + (spawnWidthDiff * spawnWidthValue.getScale(percent));</span>
<span class="nc" id="L462">			float height = spawnHeight + (spawnHeightDiff * spawnHeightValue.getScale(percent));</span>
<span class="nc" id="L463">			float radiusX = width / 2;</span>
<span class="nc" id="L464">			float radiusY = height / 2;</span>
<span class="nc bnc" id="L465" title="All 4 branches missed.">			if (radiusX == 0 || radiusY == 0) break;</span>
<span class="nc" id="L466">			float scaleY = radiusX / (float)radiusY;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">			if (spawnShapeValue.edges) {</span>
				float spawnAngle;
<span class="nc bnc" id="L469" title="All 3 branches missed.">				switch (spawnShapeValue.side) {</span>
				case top:
<span class="nc" id="L471">					spawnAngle = -MathUtils.random(179f);</span>
<span class="nc" id="L472">					break;</span>
				case bottom:
<span class="nc" id="L474">					spawnAngle = MathUtils.random(179f);</span>
<span class="nc" id="L475">					break;</span>
				default:
<span class="nc" id="L477">					spawnAngle = MathUtils.random(360f);</span>
					break;
				}
<span class="nc" id="L480">				float cosDeg = MathUtils.cosDeg(spawnAngle);</span>
<span class="nc" id="L481">				float sinDeg = MathUtils.sinDeg(spawnAngle);</span>
<span class="nc" id="L482">				x += cosDeg * radiusX;</span>
<span class="nc" id="L483">				y += sinDeg * radiusX / scaleY;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">				if ((updateFlags &amp; UPDATE_ANGLE) == 0) {</span>
<span class="nc" id="L485">					particle.angle = spawnAngle;</span>
<span class="nc" id="L486">					particle.angleCos = cosDeg;</span>
<span class="nc" id="L487">					particle.angleSin = sinDeg;</span>
				}
<span class="nc" id="L489">			} else {</span>
<span class="nc" id="L490">				float radius2 = radiusX * radiusX;</span>
				while (true) {
<span class="nc" id="L492">					float px = MathUtils.random(width) - radiusX;</span>
<span class="nc" id="L493">					float py = MathUtils.random(height) - radiusY;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">					if (px * px + py * py &lt;= radius2) {</span>
<span class="nc" id="L495">						x += px;</span>
<span class="nc" id="L496">						y += py / scaleY;</span>
<span class="nc" id="L497">						break;</span>
					}
<span class="nc" id="L499">				}</span>
			}
<span class="nc" id="L501">			break;</span>
		}
		case line: {
<span class="nc" id="L504">			float width = spawnWidth + (spawnWidthDiff * spawnWidthValue.getScale(percent));</span>
<span class="nc" id="L505">			float height = spawnHeight + (spawnHeightDiff * spawnHeightValue.getScale(percent));</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">			if (width != 0) {</span>
<span class="nc" id="L507">				float lineX = width * MathUtils.random();</span>
<span class="nc" id="L508">				x += lineX;</span>
<span class="nc" id="L509">				y += lineX * (height / (float)width);</span>
<span class="nc" id="L510">			} else</span>
<span class="nc" id="L511">				y += height * MathUtils.random();</span>
<span class="nc" id="L512">			break;</span>
		}
		}

<span class="nc" id="L516">		float spriteHeight = sprite.getHeight();</span>
<span class="nc" id="L517">		particle.setBounds(x - spriteWidth / 2, y - spriteHeight / 2, spriteWidth, spriteHeight);</span>

<span class="nc" id="L519">		int offsetTime = (int)(lifeOffset + lifeOffsetDiff * lifeOffsetValue.getScale(percent));</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">		if (offsetTime &gt; 0) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">			if (offsetTime &gt;= particle.currentLife) offsetTime = particle.currentLife - 1;</span>
<span class="nc" id="L522">			updateParticle(particle, offsetTime / 1000f, offsetTime);</span>
		}
<span class="nc" id="L524">	}</span>

	private boolean updateParticle (Particle particle, float delta, int deltaMillis) {
<span class="nc" id="L527">		int life = particle.currentLife - deltaMillis;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">		if (life &lt;= 0) return false;</span>
<span class="nc" id="L529">		particle.currentLife = life;</span>

<span class="nc" id="L531">		float percent = 1 - particle.currentLife / (float)particle.life;</span>
<span class="nc" id="L532">		int updateFlags = this.updateFlags;</span>

<span class="nc bnc" id="L534" title="All 2 branches missed.">		if ((updateFlags &amp; UPDATE_SCALE) != 0)</span>
<span class="nc" id="L535">			particle.setScale(particle.scale + particle.scaleDiff * scaleValue.getScale(percent));</span>

<span class="nc bnc" id="L537" title="All 2 branches missed.">		if ((updateFlags &amp; UPDATE_VELOCITY) != 0) {</span>
<span class="nc" id="L538">			float velocity = (particle.velocity + particle.velocityDiff * velocityValue.getScale(percent)) * delta;</span>

			float velocityX, velocityY;
<span class="nc bnc" id="L541" title="All 2 branches missed.">			if ((updateFlags &amp; UPDATE_ANGLE) != 0) {</span>
<span class="nc" id="L542">				float angle = particle.angle + particle.angleDiff * angleValue.getScale(percent);</span>
<span class="nc" id="L543">				velocityX = velocity * MathUtils.cosDeg(angle);</span>
<span class="nc" id="L544">				velocityY = velocity * MathUtils.sinDeg(angle);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">				if ((updateFlags &amp; UPDATE_ROTATION) != 0) {</span>
<span class="nc" id="L546">					float rotation = particle.rotation + particle.rotationDiff * rotationValue.getScale(percent);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">					if (aligned) rotation += angle;</span>
<span class="nc" id="L548">					particle.setRotation(rotation);</span>
				}
<span class="nc" id="L550">			} else {</span>
<span class="nc" id="L551">				velocityX = velocity * particle.angleCos;</span>
<span class="nc" id="L552">				velocityY = velocity * particle.angleSin;</span>
<span class="nc bnc" id="L553" title="All 4 branches missed.">				if (aligned || (updateFlags &amp; UPDATE_ROTATION) != 0) {</span>
<span class="nc" id="L554">					float rotation = particle.rotation + particle.rotationDiff * rotationValue.getScale(percent);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">					if (aligned) rotation += particle.angle;</span>
<span class="nc" id="L556">					particle.setRotation(rotation);</span>
				}
			}

<span class="nc bnc" id="L560" title="All 2 branches missed.">			if ((updateFlags &amp; UPDATE_WIND) != 0)</span>
<span class="nc" id="L561">				velocityX += (particle.wind + particle.windDiff * windValue.getScale(percent)) * delta;</span>

<span class="nc bnc" id="L563" title="All 2 branches missed.">			if ((updateFlags &amp; UPDATE_GRAVITY) != 0)</span>
<span class="nc" id="L564">				velocityY += (particle.gravity + particle.gravityDiff * gravityValue.getScale(percent)) * delta;</span>

<span class="nc" id="L566">			particle.translate(velocityX, velocityY);</span>
<span class="nc" id="L567">		} else {</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">			if ((updateFlags &amp; UPDATE_ROTATION) != 0)</span>
<span class="nc" id="L569">				particle.setRotation(particle.rotation + particle.rotationDiff * rotationValue.getScale(percent));</span>
		}

		float[] color;
<span class="nc bnc" id="L573" title="All 2 branches missed.">		if ((updateFlags &amp; UPDATE_TINT) != 0)</span>
<span class="nc" id="L574">			color = tintValue.getColor(percent);</span>
		else
<span class="nc" id="L576">			color = particle.tint;</span>

<span class="nc bnc" id="L578" title="All 2 branches missed.">		if (premultipliedAlpha) {</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">			float alphaMultiplier = additive ? 0 : 1;</span>
<span class="nc" id="L580">			float a = particle.transparency + particle.transparencyDiff * transparencyValue.getScale(percent);</span>
<span class="nc" id="L581">			particle.setColor(color[0] * a, color[1] * a, color[2] * a, a * alphaMultiplier);</span>
<span class="nc" id="L582">		} else {</span>
<span class="nc" id="L583">			particle.setColor(color[0], color[1], color[2],</span>
				particle.transparency + particle.transparencyDiff * transparencyValue.getScale(percent));
		}
<span class="nc" id="L586">		return true;</span>
	}

	public void setPosition (float x, float y) {
<span class="nc bnc" id="L590" title="All 2 branches missed.">		if (attached) {</span>
<span class="nc" id="L591">			float xAmount = x - this.x;</span>
<span class="nc" id="L592">			float yAmount = y - this.y;</span>
<span class="nc" id="L593">			boolean[] active = this.active;</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">			for (int i = 0, n = active.length; i &lt; n; i++)</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">				if (active[i]) particles[i].translate(xAmount, yAmount);</span>
		}
<span class="nc" id="L597">		this.x = x;</span>
<span class="nc" id="L598">		this.y = y;</span>
<span class="nc" id="L599">	}</span>

	public void setSprite (Sprite sprite) {
<span class="nc" id="L602">		this.sprite = sprite;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">		if (sprite == null) return;</span>
<span class="nc" id="L604">		float originX = sprite.getOriginX();</span>
<span class="nc" id="L605">		float originY = sprite.getOriginY();</span>
<span class="nc" id="L606">		Texture texture = sprite.getTexture();</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">		for (int i = 0, n = particles.length; i &lt; n; i++) {</span>
<span class="nc" id="L608">			Particle particle = particles[i];</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">			if (particle == null) break;</span>
<span class="nc" id="L610">			particle.setTexture(texture);</span>
<span class="nc" id="L611">			particle.setOrigin(originX, originY);</span>
		}
<span class="nc" id="L613">	}</span>

	/** Ignores the {@link #setContinuous(boolean) continuous} setting until the emitter is started again. This allows the emitter
	 * to stop smoothly. */
	public void allowCompletion () {
<span class="nc" id="L618">		allowCompletion = true;</span>
<span class="nc" id="L619">		durationTimer = duration;</span>
<span class="nc" id="L620">	}</span>

	public Sprite getSprite () {
<span class="nc" id="L623">		return sprite;</span>
	}

	public String getName () {
<span class="nc" id="L627">		return name;</span>
	}

	public void setName (String name) {
<span class="nc" id="L631">		this.name = name;</span>
<span class="nc" id="L632">	}</span>

	public ScaledNumericValue getLife () {
<span class="nc" id="L635">		return lifeValue;</span>
	}

	public ScaledNumericValue getScale () {
<span class="nc" id="L639">		return scaleValue;</span>
	}

	public ScaledNumericValue getRotation () {
<span class="nc" id="L643">		return rotationValue;</span>
	}

	public GradientColorValue getTint () {
<span class="nc" id="L647">		return tintValue;</span>
	}

	public ScaledNumericValue getVelocity () {
<span class="nc" id="L651">		return velocityValue;</span>
	}

	public ScaledNumericValue getWind () {
<span class="nc" id="L655">		return windValue;</span>
	}

	public ScaledNumericValue getGravity () {
<span class="nc" id="L659">		return gravityValue;</span>
	}

	public ScaledNumericValue getAngle () {
<span class="nc" id="L663">		return angleValue;</span>
	}

	public ScaledNumericValue getEmission () {
<span class="nc" id="L667">		return emissionValue;</span>
	}

	public ScaledNumericValue getTransparency () {
<span class="nc" id="L671">		return transparencyValue;</span>
	}

	public RangedNumericValue getDuration () {
<span class="nc" id="L675">		return durationValue;</span>
	}

	public RangedNumericValue getDelay () {
<span class="nc" id="L679">		return delayValue;</span>
	}

	public ScaledNumericValue getLifeOffset () {
<span class="nc" id="L683">		return lifeOffsetValue;</span>
	}

	public RangedNumericValue getXOffsetValue () {
<span class="nc" id="L687">		return xOffsetValue;</span>
	}

	public RangedNumericValue getYOffsetValue () {
<span class="nc" id="L691">		return yOffsetValue;</span>
	}

	public ScaledNumericValue getSpawnWidth () {
<span class="nc" id="L695">		return spawnWidthValue;</span>
	}

	public ScaledNumericValue getSpawnHeight () {
<span class="nc" id="L699">		return spawnHeightValue;</span>
	}

	public SpawnShapeValue getSpawnShape () {
<span class="nc" id="L703">		return spawnShapeValue;</span>
	}

	public boolean isAttached () {
<span class="nc" id="L707">		return attached;</span>
	}

	public void setAttached (boolean attached) {
<span class="nc" id="L711">		this.attached = attached;</span>
<span class="nc" id="L712">	}</span>

	public boolean isContinuous () {
<span class="nc" id="L715">		return continuous;</span>
	}

	public void setContinuous (boolean continuous) {
<span class="nc" id="L719">		this.continuous = continuous;</span>
<span class="nc" id="L720">	}</span>

	public boolean isAligned () {
<span class="nc" id="L723">		return aligned;</span>
	}

	public void setAligned (boolean aligned) {
<span class="nc" id="L727">		this.aligned = aligned;</span>
<span class="nc" id="L728">	}</span>

	public boolean isAdditive () {
<span class="nc" id="L731">		return additive;</span>
	}

	public void setAdditive (boolean additive) {
<span class="nc" id="L735">		this.additive = additive;</span>
<span class="nc" id="L736">	}</span>

	/** @return Whether this ParticleEmitter automatically returns the {@link com.badlogic.gdx.graphics.g2d.Batch Batch}'s blend
	 *         function to the alpha-blending default (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) when done drawing. */
	public boolean cleansUpBlendFunction () {
<span class="nc" id="L741">		return cleansUpBlendFunction;</span>
	}

	/** Set whether to automatically return the {@link com.badlogic.gdx.graphics.g2d.Batch Batch}'s blend function to the
	 * alpha-blending default (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) when done drawing. Is true by default. If set to false, the
	 * Batch's blend function is left as it was for drawing this ParticleEmitter, which prevents the Batch from being flushed
	 * repeatedly if consecutive ParticleEmitters with the same additive or pre-multiplied alpha state are drawn in a row.
	 * &lt;p&gt;
	 * IMPORTANT: If set to false and if the next object to use this Batch expects alpha blending, you are responsible for setting
	 * the Batch's blend function to (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) before that next object is drawn.
	 * @param cleansUpBlendFunction */
	public void setCleansUpBlendFunction (boolean cleansUpBlendFunction) {
<span class="nc" id="L753">		this.cleansUpBlendFunction = cleansUpBlendFunction;</span>
<span class="nc" id="L754">	}</span>

	public boolean isBehind () {
<span class="nc" id="L757">		return behind;</span>
	}

	public void setBehind (boolean behind) {
<span class="nc" id="L761">		this.behind = behind;</span>
<span class="nc" id="L762">	}</span>

	public boolean isPremultipliedAlpha () {
<span class="nc" id="L765">		return premultipliedAlpha;</span>
	}

	public void setPremultipliedAlpha (boolean premultipliedAlpha) {
<span class="nc" id="L769">		this.premultipliedAlpha = premultipliedAlpha;</span>
<span class="nc" id="L770">	}</span>

	public int getMinParticleCount () {
<span class="nc" id="L773">		return minParticleCount;</span>
	}

	public void setMinParticleCount (int minParticleCount) {
<span class="nc" id="L777">		this.minParticleCount = minParticleCount;</span>
<span class="nc" id="L778">	}</span>

	public int getMaxParticleCount () {
<span class="nc" id="L781">		return maxParticleCount;</span>
	}

	public boolean isComplete () {
<span class="nc bnc" id="L785" title="All 2 branches missed.">		if (continuous) return false;</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">		if (delayTimer &lt; delay) return false;</span>
<span class="nc bnc" id="L787" title="All 4 branches missed.">		return durationTimer &gt;= duration &amp;&amp; activeCount == 0;</span>
	}

	public float getPercentComplete () {
<span class="nc bnc" id="L791" title="All 2 branches missed.">		if (delayTimer &lt; delay) return 0;</span>
<span class="nc" id="L792">		return Math.min(1, durationTimer / (float)duration);</span>
	}

	public float getX () {
<span class="nc" id="L796">		return x;</span>
	}

	public float getY () {
<span class="nc" id="L800">		return y;</span>
	}

	public int getActiveCount () {
<span class="nc" id="L804">		return activeCount;</span>
	}

	public String getImagePath () {
<span class="nc" id="L808">		return imagePath;</span>
	}

	public void setImagePath (String imagePath) {
<span class="nc" id="L812">		this.imagePath = imagePath;</span>
<span class="nc" id="L813">	}</span>

	public void setFlip (boolean flipX, boolean flipY) {
<span class="nc" id="L816">		this.flipX = flipX;</span>
<span class="nc" id="L817">		this.flipY = flipY;</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">		if (particles == null) return;</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">		for (int i = 0, n = particles.length; i &lt; n; i++) {</span>
<span class="nc" id="L820">			Particle particle = particles[i];</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">			if (particle != null) particle.flip(flipX, flipY);</span>
		}
<span class="nc" id="L823">	}</span>

	public void flipY () {
<span class="nc" id="L826">		angleValue.setHigh(-angleValue.getHighMin(), -angleValue.getHighMax());</span>
<span class="nc" id="L827">		angleValue.setLow(-angleValue.getLowMin(), -angleValue.getLowMax());</span>

<span class="nc" id="L829">		gravityValue.setHigh(-gravityValue.getHighMin(), -gravityValue.getHighMax());</span>
<span class="nc" id="L830">		gravityValue.setLow(-gravityValue.getLowMin(), -gravityValue.getLowMax());</span>

<span class="nc" id="L832">		windValue.setHigh(-windValue.getHighMin(), -windValue.getHighMax());</span>
<span class="nc" id="L833">		windValue.setLow(-windValue.getLowMin(), -windValue.getLowMax());</span>

<span class="nc" id="L835">		rotationValue.setHigh(-rotationValue.getHighMin(), -rotationValue.getHighMax());</span>
<span class="nc" id="L836">		rotationValue.setLow(-rotationValue.getLowMin(), -rotationValue.getLowMax());</span>

<span class="nc" id="L838">		yOffsetValue.setLow(-yOffsetValue.getLowMin(), -yOffsetValue.getLowMax());</span>
<span class="nc" id="L839">	}</span>

	/** Returns the bounding box for all active particles. z axis will always be zero. */
	public BoundingBox getBoundingBox () {
<span class="nc bnc" id="L843" title="All 2 branches missed.">		if (bounds == null) bounds = new BoundingBox();</span>

<span class="nc" id="L845">		Particle[] particles = this.particles;</span>
<span class="nc" id="L846">		boolean[] active = this.active;</span>
<span class="nc" id="L847">		BoundingBox bounds = this.bounds;</span>

<span class="nc" id="L849">		bounds.inf();</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">		for (int i = 0, n = active.length; i &lt; n; i++)</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">			if (active[i]) {</span>
<span class="nc" id="L852">				Rectangle r = particles[i].getBoundingRectangle();</span>
<span class="nc" id="L853">				bounds.ext(r.x, r.y, 0);</span>
<span class="nc" id="L854">				bounds.ext(r.x + r.width, r.y + r.height, 0);</span>
			}

<span class="nc" id="L857">		return bounds;</span>
	}

	public void save (Writer output) throws IOException {
<span class="nc" id="L861">		output.write(name + &quot;\n&quot;);</span>
<span class="nc" id="L862">		output.write(&quot;- Delay -\n&quot;);</span>
<span class="nc" id="L863">		delayValue.save(output);</span>
<span class="nc" id="L864">		output.write(&quot;- Duration - \n&quot;);</span>
<span class="nc" id="L865">		durationValue.save(output);</span>
<span class="nc" id="L866">		output.write(&quot;- Count - \n&quot;);</span>
<span class="nc" id="L867">		output.write(&quot;min: &quot; + minParticleCount + &quot;\n&quot;);</span>
<span class="nc" id="L868">		output.write(&quot;max: &quot; + maxParticleCount + &quot;\n&quot;);</span>
<span class="nc" id="L869">		output.write(&quot;- Emission - \n&quot;);</span>
<span class="nc" id="L870">		emissionValue.save(output);</span>
<span class="nc" id="L871">		output.write(&quot;- Life - \n&quot;);</span>
<span class="nc" id="L872">		lifeValue.save(output);</span>
<span class="nc" id="L873">		output.write(&quot;- Life Offset - \n&quot;);</span>
<span class="nc" id="L874">		lifeOffsetValue.save(output);</span>
<span class="nc" id="L875">		output.write(&quot;- X Offset - \n&quot;);</span>
<span class="nc" id="L876">		xOffsetValue.save(output);</span>
<span class="nc" id="L877">		output.write(&quot;- Y Offset - \n&quot;);</span>
<span class="nc" id="L878">		yOffsetValue.save(output);</span>
<span class="nc" id="L879">		output.write(&quot;- Spawn Shape - \n&quot;);</span>
<span class="nc" id="L880">		spawnShapeValue.save(output);</span>
<span class="nc" id="L881">		output.write(&quot;- Spawn Width - \n&quot;);</span>
<span class="nc" id="L882">		spawnWidthValue.save(output);</span>
<span class="nc" id="L883">		output.write(&quot;- Spawn Height - \n&quot;);</span>
<span class="nc" id="L884">		spawnHeightValue.save(output);</span>
<span class="nc" id="L885">		output.write(&quot;- Scale - \n&quot;);</span>
<span class="nc" id="L886">		scaleValue.save(output);</span>
<span class="nc" id="L887">		output.write(&quot;- Velocity - \n&quot;);</span>
<span class="nc" id="L888">		velocityValue.save(output);</span>
<span class="nc" id="L889">		output.write(&quot;- Angle - \n&quot;);</span>
<span class="nc" id="L890">		angleValue.save(output);</span>
<span class="nc" id="L891">		output.write(&quot;- Rotation - \n&quot;);</span>
<span class="nc" id="L892">		rotationValue.save(output);</span>
<span class="nc" id="L893">		output.write(&quot;- Wind - \n&quot;);</span>
<span class="nc" id="L894">		windValue.save(output);</span>
<span class="nc" id="L895">		output.write(&quot;- Gravity - \n&quot;);</span>
<span class="nc" id="L896">		gravityValue.save(output);</span>
<span class="nc" id="L897">		output.write(&quot;- Tint - \n&quot;);</span>
<span class="nc" id="L898">		tintValue.save(output);</span>
<span class="nc" id="L899">		output.write(&quot;- Transparency - \n&quot;);</span>
<span class="nc" id="L900">		transparencyValue.save(output);</span>
<span class="nc" id="L901">		output.write(&quot;- Options - \n&quot;);</span>
<span class="nc" id="L902">		output.write(&quot;attached: &quot; + attached + &quot;\n&quot;);</span>
<span class="nc" id="L903">		output.write(&quot;continuous: &quot; + continuous + &quot;\n&quot;);</span>
<span class="nc" id="L904">		output.write(&quot;aligned: &quot; + aligned + &quot;\n&quot;);</span>
<span class="nc" id="L905">		output.write(&quot;additive: &quot; + additive + &quot;\n&quot;);</span>
<span class="nc" id="L906">		output.write(&quot;behind: &quot; + behind + &quot;\n&quot;);</span>
<span class="nc" id="L907">		output.write(&quot;premultipliedAlpha: &quot; + premultipliedAlpha + &quot;\n&quot;);</span>
<span class="nc" id="L908">		output.write(&quot;- Image Path -\n&quot;);</span>
<span class="nc" id="L909">		output.write(imagePath + &quot;\n&quot;);</span>
<span class="nc" id="L910">	}</span>

	public void load (BufferedReader reader) throws IOException {
		try {
<span class="nc" id="L914">			name = readString(reader, &quot;name&quot;);</span>
<span class="nc" id="L915">			reader.readLine();</span>
<span class="nc" id="L916">			delayValue.load(reader);</span>
<span class="nc" id="L917">			reader.readLine();</span>
<span class="nc" id="L918">			durationValue.load(reader);</span>
<span class="nc" id="L919">			reader.readLine();</span>
<span class="nc" id="L920">			setMinParticleCount(readInt(reader, &quot;minParticleCount&quot;));</span>
<span class="nc" id="L921">			setMaxParticleCount(readInt(reader, &quot;maxParticleCount&quot;));</span>
<span class="nc" id="L922">			reader.readLine();</span>
<span class="nc" id="L923">			emissionValue.load(reader);</span>
<span class="nc" id="L924">			reader.readLine();</span>
<span class="nc" id="L925">			lifeValue.load(reader);</span>
<span class="nc" id="L926">			reader.readLine();</span>
<span class="nc" id="L927">			lifeOffsetValue.load(reader);</span>
<span class="nc" id="L928">			reader.readLine();</span>
<span class="nc" id="L929">			xOffsetValue.load(reader);</span>
<span class="nc" id="L930">			reader.readLine();</span>
<span class="nc" id="L931">			yOffsetValue.load(reader);</span>
<span class="nc" id="L932">			reader.readLine();</span>
<span class="nc" id="L933">			spawnShapeValue.load(reader);</span>
<span class="nc" id="L934">			reader.readLine();</span>
<span class="nc" id="L935">			spawnWidthValue.load(reader);</span>
<span class="nc" id="L936">			reader.readLine();</span>
<span class="nc" id="L937">			spawnHeightValue.load(reader);</span>
<span class="nc" id="L938">			reader.readLine();</span>
<span class="nc" id="L939">			scaleValue.load(reader);</span>
<span class="nc" id="L940">			reader.readLine();</span>
<span class="nc" id="L941">			velocityValue.load(reader);</span>
<span class="nc" id="L942">			reader.readLine();</span>
<span class="nc" id="L943">			angleValue.load(reader);</span>
<span class="nc" id="L944">			reader.readLine();</span>
<span class="nc" id="L945">			rotationValue.load(reader);</span>
<span class="nc" id="L946">			reader.readLine();</span>
<span class="nc" id="L947">			windValue.load(reader);</span>
<span class="nc" id="L948">			reader.readLine();</span>
<span class="nc" id="L949">			gravityValue.load(reader);</span>
<span class="nc" id="L950">			reader.readLine();</span>
<span class="nc" id="L951">			tintValue.load(reader);</span>
<span class="nc" id="L952">			reader.readLine();</span>
<span class="nc" id="L953">			transparencyValue.load(reader);</span>
<span class="nc" id="L954">			reader.readLine();</span>
<span class="nc" id="L955">			attached = readBoolean(reader, &quot;attached&quot;);</span>
<span class="nc" id="L956">			continuous = readBoolean(reader, &quot;continuous&quot;);</span>
<span class="nc" id="L957">			aligned = readBoolean(reader, &quot;aligned&quot;);</span>
<span class="nc" id="L958">			additive = readBoolean(reader, &quot;additive&quot;);</span>
<span class="nc" id="L959">			behind = readBoolean(reader, &quot;behind&quot;);</span>

			// Backwards compatibility
<span class="nc" id="L962">			String line = reader.readLine();</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">			if (line.startsWith(&quot;premultipliedAlpha&quot;)) {</span>
<span class="nc" id="L964">				premultipliedAlpha = readBoolean(line);</span>
<span class="nc" id="L965">				reader.readLine();</span>
			}
<span class="nc" id="L967">			setImagePath(reader.readLine());</span>
<span class="nc" id="L968">		} catch (RuntimeException ex) {</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">			if (name == null) throw ex;</span>
<span class="nc" id="L970">			throw new RuntimeException(&quot;Error parsing emitter: &quot; + name, ex);</span>
<span class="nc" id="L971">		}</span>
<span class="nc" id="L972">	}</span>

	static String readString (String line) throws IOException {
<span class="nc" id="L975">		return line.substring(line.indexOf(&quot;:&quot;) + 1).trim();</span>
	}

	static String readString (BufferedReader reader, String name) throws IOException {
<span class="nc" id="L979">		String line = reader.readLine();</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">		if (line == null) throw new IOException(&quot;Missing value: &quot; + name);</span>
<span class="nc" id="L981">		return readString(line);</span>
	}

	static boolean readBoolean (String line) throws IOException {
<span class="nc" id="L985">		return Boolean.parseBoolean(readString(line));</span>
	}

	static boolean readBoolean (BufferedReader reader, String name) throws IOException {
<span class="nc" id="L989">		return Boolean.parseBoolean(readString(reader, name));</span>
	}

	static int readInt (BufferedReader reader, String name) throws IOException {
<span class="nc" id="L993">		return Integer.parseInt(readString(reader, name));</span>
	}

	static float readFloat (BufferedReader reader, String name) throws IOException {
<span class="nc" id="L997">		return Float.parseFloat(readString(reader, name));</span>
	}

	public static class Particle extends Sprite {
		protected int life, currentLife;
		protected float scale, scaleDiff;
		protected float rotation, rotationDiff;
		protected float velocity, velocityDiff;
		protected float angle, angleDiff;
		protected float angleCos, angleSin;
		protected float transparency, transparencyDiff;
		protected float wind, windDiff;
		protected float gravity, gravityDiff;
		protected float[] tint;

		public Particle (Sprite sprite) {
<span class="nc" id="L1013">			super(sprite);</span>
<span class="nc" id="L1014">		}</span>
	}

<span class="nc" id="L1017">	static public class ParticleValue {</span>
		boolean active;
		boolean alwaysActive;

		public void setAlwaysActive (boolean alwaysActive) {
<span class="nc" id="L1022">			this.alwaysActive = alwaysActive;</span>
<span class="nc" id="L1023">		}</span>

		public boolean isAlwaysActive () {
<span class="nc" id="L1026">			return alwaysActive;</span>
		}

		public boolean isActive () {
<span class="nc bnc" id="L1030" title="All 4 branches missed.">			return alwaysActive || active;</span>
		}

		public void setActive (boolean active) {
<span class="nc" id="L1034">			this.active = active;</span>
<span class="nc" id="L1035">		}</span>

		public void save (Writer output) throws IOException {
<span class="nc bnc" id="L1038" title="All 2 branches missed.">			if (!alwaysActive)</span>
<span class="nc" id="L1039">				output.write(&quot;active: &quot; + active + &quot;\n&quot;);</span>
			else
<span class="nc" id="L1041">				active = true;</span>
<span class="nc" id="L1042">		}</span>

		public void load (BufferedReader reader) throws IOException {
<span class="nc bnc" id="L1045" title="All 2 branches missed.">			if (!alwaysActive)</span>
<span class="nc" id="L1046">				active = readBoolean(reader, &quot;active&quot;);</span>
			else
<span class="nc" id="L1048">				active = true;</span>
<span class="nc" id="L1049">		}</span>

		public void load (ParticleValue value) {
<span class="nc" id="L1052">			active = value.active;</span>
<span class="nc" id="L1053">			alwaysActive = value.alwaysActive;</span>
<span class="nc" id="L1054">		}</span>
	}

<span class="nc" id="L1057">	static public class NumericValue extends ParticleValue {</span>
		private float value;

		public float getValue () {
<span class="nc" id="L1061">			return value;</span>
		}

		public void setValue (float value) {
<span class="nc" id="L1065">			this.value = value;</span>
<span class="nc" id="L1066">		}</span>

		public void save (Writer output) throws IOException {
<span class="nc" id="L1069">			super.save(output);</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">			if (!active) return;</span>
<span class="nc" id="L1071">			output.write(&quot;value: &quot; + value + &quot;\n&quot;);</span>
<span class="nc" id="L1072">		}</span>

		public void load (BufferedReader reader) throws IOException {
<span class="nc" id="L1075">			super.load(reader);</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">			if (!active) return;</span>
<span class="nc" id="L1077">			value = readFloat(reader, &quot;value&quot;);</span>
<span class="nc" id="L1078">		}</span>

		public void load (NumericValue value) {
<span class="nc" id="L1081">			super.load(value);</span>
<span class="nc" id="L1082">			this.value = value.value;</span>
<span class="nc" id="L1083">		}</span>
	}

<span class="nc" id="L1086">	static public class RangedNumericValue extends ParticleValue {</span>
		private float lowMin, lowMax;

		public float newLowValue () {
<span class="nc" id="L1090">			return lowMin + (lowMax - lowMin) * MathUtils.random();</span>
		}

		public void setLow (float value) {
<span class="nc" id="L1094">			lowMin = value;</span>
<span class="nc" id="L1095">			lowMax = value;</span>
<span class="nc" id="L1096">		}</span>

		public void setLow (float min, float max) {
<span class="nc" id="L1099">			lowMin = min;</span>
<span class="nc" id="L1100">			lowMax = max;</span>
<span class="nc" id="L1101">		}</span>

		public float getLowMin () {
<span class="nc" id="L1104">			return lowMin;</span>
		}

		public void setLowMin (float lowMin) {
<span class="nc" id="L1108">			this.lowMin = lowMin;</span>
<span class="nc" id="L1109">		}</span>

		public float getLowMax () {
<span class="nc" id="L1112">			return lowMax;</span>
		}

		public void setLowMax (float lowMax) {
<span class="nc" id="L1116">			this.lowMax = lowMax;</span>
<span class="nc" id="L1117">		}</span>

		public void save (Writer output) throws IOException {
<span class="nc" id="L1120">			super.save(output);</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">			if (!active) return;</span>
<span class="nc" id="L1122">			output.write(&quot;lowMin: &quot; + lowMin + &quot;\n&quot;);</span>
<span class="nc" id="L1123">			output.write(&quot;lowMax: &quot; + lowMax + &quot;\n&quot;);</span>
<span class="nc" id="L1124">		}</span>

		public void load (BufferedReader reader) throws IOException {
<span class="nc" id="L1127">			super.load(reader);</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">			if (!active) return;</span>
<span class="nc" id="L1129">			lowMin = readFloat(reader, &quot;lowMin&quot;);</span>
<span class="nc" id="L1130">			lowMax = readFloat(reader, &quot;lowMax&quot;);</span>
<span class="nc" id="L1131">		}</span>

		public void load (RangedNumericValue value) {
<span class="nc" id="L1134">			super.load(value);</span>
<span class="nc" id="L1135">			lowMax = value.lowMax;</span>
<span class="nc" id="L1136">			lowMin = value.lowMin;</span>
<span class="nc" id="L1137">		}</span>
	}

<span class="nc" id="L1140">	static public class ScaledNumericValue extends RangedNumericValue {</span>
<span class="nc" id="L1141">		private float[] scaling = {1};</span>
<span class="nc" id="L1142">		float[] timeline = {0};</span>
		private float highMin, highMax;
		private boolean relative;

		public float newHighValue () {
<span class="nc" id="L1147">			return highMin + (highMax - highMin) * MathUtils.random();</span>
		}

		public void setHigh (float value) {
<span class="nc" id="L1151">			highMin = value;</span>
<span class="nc" id="L1152">			highMax = value;</span>
<span class="nc" id="L1153">		}</span>

		public void setHigh (float min, float max) {
<span class="nc" id="L1156">			highMin = min;</span>
<span class="nc" id="L1157">			highMax = max;</span>
<span class="nc" id="L1158">		}</span>

		public float getHighMin () {
<span class="nc" id="L1161">			return highMin;</span>
		}

		public void setHighMin (float highMin) {
<span class="nc" id="L1165">			this.highMin = highMin;</span>
<span class="nc" id="L1166">		}</span>

		public float getHighMax () {
<span class="nc" id="L1169">			return highMax;</span>
		}

		public void setHighMax (float highMax) {
<span class="nc" id="L1173">			this.highMax = highMax;</span>
<span class="nc" id="L1174">		}</span>

		public float[] getScaling () {
<span class="nc" id="L1177">			return scaling;</span>
		}

		public void setScaling (float[] values) {
<span class="nc" id="L1181">			this.scaling = values;</span>
<span class="nc" id="L1182">		}</span>

		public float[] getTimeline () {
<span class="nc" id="L1185">			return timeline;</span>
		}

		public void setTimeline (float[] timeline) {
<span class="nc" id="L1189">			this.timeline = timeline;</span>
<span class="nc" id="L1190">		}</span>

		public boolean isRelative () {
<span class="nc" id="L1193">			return relative;</span>
		}

		public void setRelative (boolean relative) {
<span class="nc" id="L1197">			this.relative = relative;</span>
<span class="nc" id="L1198">		}</span>

		public float getScale (float percent) {
<span class="nc" id="L1201">			int endIndex = -1;</span>
<span class="nc" id="L1202">			float[] timeline = this.timeline;</span>
<span class="nc" id="L1203">			int n = timeline.length;</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">			for (int i = 1; i &lt; n; i++) {</span>
<span class="nc" id="L1205">				float t = timeline[i];</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">				if (t &gt; percent) {</span>
<span class="nc" id="L1207">					endIndex = i;</span>
<span class="nc" id="L1208">					break;</span>
				}
			}
<span class="nc bnc" id="L1211" title="All 2 branches missed.">			if (endIndex == -1) return scaling[n - 1];</span>
<span class="nc" id="L1212">			float[] scaling = this.scaling;</span>
<span class="nc" id="L1213">			int startIndex = endIndex - 1;</span>
<span class="nc" id="L1214">			float startValue = scaling[startIndex];</span>
<span class="nc" id="L1215">			float startTime = timeline[startIndex];</span>
<span class="nc" id="L1216">			return startValue + (scaling[endIndex] - startValue) * ((percent - startTime) / (timeline[endIndex] - startTime));</span>
		}

		public void save (Writer output) throws IOException {
<span class="nc" id="L1220">			super.save(output);</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">			if (!active) return;</span>
<span class="nc" id="L1222">			output.write(&quot;highMin: &quot; + highMin + &quot;\n&quot;);</span>
<span class="nc" id="L1223">			output.write(&quot;highMax: &quot; + highMax + &quot;\n&quot;);</span>
<span class="nc" id="L1224">			output.write(&quot;relative: &quot; + relative + &quot;\n&quot;);</span>
<span class="nc" id="L1225">			output.write(&quot;scalingCount: &quot; + scaling.length + &quot;\n&quot;);</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">			for (int i = 0; i &lt; scaling.length; i++)</span>
<span class="nc" id="L1227">				output.write(&quot;scaling&quot; + i + &quot;: &quot; + scaling[i] + &quot;\n&quot;);</span>
<span class="nc" id="L1228">			output.write(&quot;timelineCount: &quot; + timeline.length + &quot;\n&quot;);</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">			for (int i = 0; i &lt; timeline.length; i++)</span>
<span class="nc" id="L1230">				output.write(&quot;timeline&quot; + i + &quot;: &quot; + timeline[i] + &quot;\n&quot;);</span>
<span class="nc" id="L1231">		}</span>

		public void load (BufferedReader reader) throws IOException {
<span class="nc" id="L1234">			super.load(reader);</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">			if (!active) return;</span>
<span class="nc" id="L1236">			highMin = readFloat(reader, &quot;highMin&quot;);</span>
<span class="nc" id="L1237">			highMax = readFloat(reader, &quot;highMax&quot;);</span>
<span class="nc" id="L1238">			relative = readBoolean(reader, &quot;relative&quot;);</span>
<span class="nc" id="L1239">			scaling = new float[readInt(reader, &quot;scalingCount&quot;)];</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">			for (int i = 0; i &lt; scaling.length; i++)</span>
<span class="nc" id="L1241">				scaling[i] = readFloat(reader, &quot;scaling&quot; + i);</span>
<span class="nc" id="L1242">			timeline = new float[readInt(reader, &quot;timelineCount&quot;)];</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">			for (int i = 0; i &lt; timeline.length; i++)</span>
<span class="nc" id="L1244">				timeline[i] = readFloat(reader, &quot;timeline&quot; + i);</span>
<span class="nc" id="L1245">		}</span>

		public void load (ScaledNumericValue value) {
<span class="nc" id="L1248">			super.load(value);</span>
<span class="nc" id="L1249">			highMax = value.highMax;</span>
<span class="nc" id="L1250">			highMin = value.highMin;</span>
<span class="nc" id="L1251">			scaling = new float[value.scaling.length];</span>
<span class="nc" id="L1252">			System.arraycopy(value.scaling, 0, scaling, 0, scaling.length);</span>
<span class="nc" id="L1253">			timeline = new float[value.timeline.length];</span>
<span class="nc" id="L1254">			System.arraycopy(value.timeline, 0, timeline, 0, timeline.length);</span>
<span class="nc" id="L1255">			relative = value.relative;</span>
<span class="nc" id="L1256">		}</span>
	}

	static public class GradientColorValue extends ParticleValue {
<span class="nc" id="L1260">		static private float[] temp = new float[4];</span>

<span class="nc" id="L1262">		private float[] colors = {1, 1, 1};</span>
<span class="nc" id="L1263">		float[] timeline = {0};</span>

<span class="nc" id="L1265">		public GradientColorValue () {</span>
<span class="nc" id="L1266">			alwaysActive = true;</span>
<span class="nc" id="L1267">		}</span>

		public float[] getTimeline () {
<span class="nc" id="L1270">			return timeline;</span>
		}

		public void setTimeline (float[] timeline) {
<span class="nc" id="L1274">			this.timeline = timeline;</span>
<span class="nc" id="L1275">		}</span>

		/** @return the r, g and b values for every timeline position */
		public float[] getColors () {
<span class="nc" id="L1279">			return colors;</span>
		}

		/** @param colors the r, g and b values for every timeline position */
		public void setColors (float[] colors) {
<span class="nc" id="L1284">			this.colors = colors;</span>
<span class="nc" id="L1285">		}</span>

		public float[] getColor (float percent) {
<span class="nc" id="L1288">			int startIndex = 0, endIndex = -1;</span>
<span class="nc" id="L1289">			float[] timeline = this.timeline;</span>
<span class="nc" id="L1290">			int n = timeline.length;</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">			for (int i = 1; i &lt; n; i++) {</span>
<span class="nc" id="L1292">				float t = timeline[i];</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">				if (t &gt; percent) {</span>
<span class="nc" id="L1294">					endIndex = i;</span>
<span class="nc" id="L1295">					break;</span>
				}
<span class="nc" id="L1297">				startIndex = i;</span>
			}
<span class="nc" id="L1299">			float startTime = timeline[startIndex];</span>
<span class="nc" id="L1300">			startIndex *= 3;</span>
<span class="nc" id="L1301">			float r1 = colors[startIndex];</span>
<span class="nc" id="L1302">			float g1 = colors[startIndex + 1];</span>
<span class="nc" id="L1303">			float b1 = colors[startIndex + 2];</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">			if (endIndex == -1) {</span>
<span class="nc" id="L1305">				temp[0] = r1;</span>
<span class="nc" id="L1306">				temp[1] = g1;</span>
<span class="nc" id="L1307">				temp[2] = b1;</span>
<span class="nc" id="L1308">				return temp;</span>
			}
<span class="nc" id="L1310">			float factor = (percent - startTime) / (timeline[endIndex] - startTime);</span>
<span class="nc" id="L1311">			endIndex *= 3;</span>
<span class="nc" id="L1312">			temp[0] = r1 + (colors[endIndex] - r1) * factor;</span>
<span class="nc" id="L1313">			temp[1] = g1 + (colors[endIndex + 1] - g1) * factor;</span>
<span class="nc" id="L1314">			temp[2] = b1 + (colors[endIndex + 2] - b1) * factor;</span>
<span class="nc" id="L1315">			return temp;</span>
		}

		public void save (Writer output) throws IOException {
<span class="nc" id="L1319">			super.save(output);</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">			if (!active) return;</span>
<span class="nc" id="L1321">			output.write(&quot;colorsCount: &quot; + colors.length + &quot;\n&quot;);</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">			for (int i = 0; i &lt; colors.length; i++)</span>
<span class="nc" id="L1323">				output.write(&quot;colors&quot; + i + &quot;: &quot; + colors[i] + &quot;\n&quot;);</span>
<span class="nc" id="L1324">			output.write(&quot;timelineCount: &quot; + timeline.length + &quot;\n&quot;);</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">			for (int i = 0; i &lt; timeline.length; i++)</span>
<span class="nc" id="L1326">				output.write(&quot;timeline&quot; + i + &quot;: &quot; + timeline[i] + &quot;\n&quot;);</span>
<span class="nc" id="L1327">		}</span>

		public void load (BufferedReader reader) throws IOException {
<span class="nc" id="L1330">			super.load(reader);</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">			if (!active) return;</span>
<span class="nc" id="L1332">			colors = new float[readInt(reader, &quot;colorsCount&quot;)];</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">			for (int i = 0; i &lt; colors.length; i++)</span>
<span class="nc" id="L1334">				colors[i] = readFloat(reader, &quot;colors&quot; + i);</span>
<span class="nc" id="L1335">			timeline = new float[readInt(reader, &quot;timelineCount&quot;)];</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">			for (int i = 0; i &lt; timeline.length; i++)</span>
<span class="nc" id="L1337">				timeline[i] = readFloat(reader, &quot;timeline&quot; + i);</span>
<span class="nc" id="L1338">		}</span>

		public void load (GradientColorValue value) {
<span class="nc" id="L1341">			super.load(value);</span>
<span class="nc" id="L1342">			colors = new float[value.colors.length];</span>
<span class="nc" id="L1343">			System.arraycopy(value.colors, 0, colors, 0, colors.length);</span>
<span class="nc" id="L1344">			timeline = new float[value.timeline.length];</span>
<span class="nc" id="L1345">			System.arraycopy(value.timeline, 0, timeline, 0, timeline.length);</span>
<span class="nc" id="L1346">		}</span>
	}

<span class="nc" id="L1349">	static public class SpawnShapeValue extends ParticleValue {</span>
<span class="nc" id="L1350">		SpawnShape shape = SpawnShape.point;</span>
		boolean edges;
<span class="nc" id="L1352">		SpawnEllipseSide side = SpawnEllipseSide.both;</span>

		public SpawnShape getShape () {
<span class="nc" id="L1355">			return shape;</span>
		}

		public void setShape (SpawnShape shape) {
<span class="nc" id="L1359">			this.shape = shape;</span>
<span class="nc" id="L1360">		}</span>

		public boolean isEdges () {
<span class="nc" id="L1363">			return edges;</span>
		}

		public void setEdges (boolean edges) {
<span class="nc" id="L1367">			this.edges = edges;</span>
<span class="nc" id="L1368">		}</span>

		public SpawnEllipseSide getSide () {
<span class="nc" id="L1371">			return side;</span>
		}

		public void setSide (SpawnEllipseSide side) {
<span class="nc" id="L1375">			this.side = side;</span>
<span class="nc" id="L1376">		}</span>

		public void save (Writer output) throws IOException {
<span class="nc" id="L1379">			super.save(output);</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">			if (!active) return;</span>
<span class="nc" id="L1381">			output.write(&quot;shape: &quot; + shape + &quot;\n&quot;);</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">			if (shape == SpawnShape.ellipse) {</span>
<span class="nc" id="L1383">				output.write(&quot;edges: &quot; + edges + &quot;\n&quot;);</span>
<span class="nc" id="L1384">				output.write(&quot;side: &quot; + side + &quot;\n&quot;);</span>
			}
<span class="nc" id="L1386">		}</span>

		public void load (BufferedReader reader) throws IOException {
<span class="nc" id="L1389">			super.load(reader);</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">			if (!active) return;</span>
<span class="nc" id="L1391">			shape = SpawnShape.valueOf(readString(reader, &quot;shape&quot;));</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">			if (shape == SpawnShape.ellipse) {</span>
<span class="nc" id="L1393">				edges = readBoolean(reader, &quot;edges&quot;);</span>
<span class="nc" id="L1394">				side = SpawnEllipseSide.valueOf(readString(reader, &quot;side&quot;));</span>
			}
<span class="nc" id="L1396">		}</span>

		public void load (SpawnShapeValue value) {
<span class="nc" id="L1399">			super.load(value);</span>
<span class="nc" id="L1400">			shape = value.shape;</span>
<span class="nc" id="L1401">			edges = value.edges;</span>
<span class="nc" id="L1402">			side = value.side;</span>
<span class="nc" id="L1403">		}</span>
	}

<span class="nc" id="L1406">	static public enum SpawnShape {</span>
<span class="nc" id="L1407">		point, line, square, ellipse</span>
	}

<span class="nc" id="L1410">	static public enum SpawnEllipseSide {</span>
<span class="nc" id="L1411">		both, top, bottom</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>