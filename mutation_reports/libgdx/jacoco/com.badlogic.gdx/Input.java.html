<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Input.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libGDX Core</a> &gt; <a href="index.html" class="el_package">com.badlogic.gdx</a> &gt; <span class="el_source">Input.java</span></div><h1>Input.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx;

import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.utils.ObjectIntMap;

/** &lt;p&gt;
 * Interface to the input facilities. This allows polling the state of the keyboard, the touch screen and the accelerometer. On
 * some backends (desktop, gwt, etc) the touch screen is replaced by mouse input. The accelerometer is of course not available on
 * all backends.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Instead of polling for events, one can process all input events with an {@link InputProcessor}. You can set the InputProcessor
 * via the {@link #setInputProcessor(InputProcessor)} method. It will be called before the {@link ApplicationListener#render()}
 * method in each frame.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Keyboard keys are translated to the constants in {@link Keys} transparently on all systems. Do not use system specific key
 * constants.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The class also offers methods to use (and test for the presence of) other input systems like vibration, compass, on-screen
 * keyboards, and cursor capture. Support for simple input dialogs is also provided.
 * &lt;/p&gt;
 * 
 * @author mzechner */
public interface Input {
	/** Callback interface for {@link Input#getTextInput(TextInputListener, String, String, String)}
	 * 
	 * @author mzechner */
	static public interface TextInputListener {
		public void input (String text);

		public void canceled ();
	}

	/** Mouse buttons.
	 * @author mzechner */
<span class="nc" id="L57">	static public class Buttons {</span>
		public static final int LEFT = 0;
		public static final int RIGHT = 1;
		public static final int MIDDLE = 2;
		public static final int BACK = 3;
		public static final int FORWARD = 4;
	}

	/** Keys.
	 * 
	 * @author mzechner */
<span class="nc" id="L68">	static public class Keys {</span>
		public static final int ANY_KEY = -1;
		public static final int NUM_0 = 7;
		public static final int NUM_1 = 8;
		public static final int NUM_2 = 9;
		public static final int NUM_3 = 10;
		public static final int NUM_4 = 11;
		public static final int NUM_5 = 12;
		public static final int NUM_6 = 13;
		public static final int NUM_7 = 14;
		public static final int NUM_8 = 15;
		public static final int NUM_9 = 16;
		public static final int A = 29;
		public static final int ALT_LEFT = 57;
		public static final int ALT_RIGHT = 58;
		public static final int APOSTROPHE = 75;
		public static final int AT = 77;
		public static final int B = 30;
		public static final int BACK = 4;
		public static final int BACKSLASH = 73;
		public static final int C = 31;
		public static final int CALL = 5;
		public static final int CAMERA = 27;
		public static final int CLEAR = 28;
		public static final int COMMA = 55;
		public static final int D = 32;
		public static final int DEL = 67;
		public static final int BACKSPACE = 67;
		public static final int FORWARD_DEL = 112;
		public static final int DPAD_CENTER = 23;
		public static final int DPAD_DOWN = 20;
		public static final int DPAD_LEFT = 21;
		public static final int DPAD_RIGHT = 22;
		public static final int DPAD_UP = 19;
		public static final int CENTER = 23;
		public static final int DOWN = 20;
		public static final int LEFT = 21;
		public static final int RIGHT = 22;
		public static final int UP = 19;
		public static final int E = 33;
		public static final int ENDCALL = 6;
		public static final int ENTER = 66;
		public static final int ENVELOPE = 65;
		public static final int EQUALS = 70;
		public static final int EXPLORER = 64;
		public static final int F = 34;
		public static final int FOCUS = 80;
		public static final int G = 35;
		public static final int GRAVE = 68;
		public static final int H = 36;
		public static final int HEADSETHOOK = 79;
		public static final int HOME = 3;
		public static final int I = 37;
		public static final int J = 38;
		public static final int K = 39;
		public static final int L = 40;
		public static final int LEFT_BRACKET = 71;
		public static final int M = 41;
		public static final int MEDIA_FAST_FORWARD = 90;
		public static final int MEDIA_NEXT = 87;
		public static final int MEDIA_PLAY_PAUSE = 85;
		public static final int MEDIA_PREVIOUS = 88;
		public static final int MEDIA_REWIND = 89;
		public static final int MEDIA_STOP = 86;
		public static final int MENU = 82;
		public static final int MINUS = 69;
		public static final int MUTE = 91;
		public static final int N = 42;
		public static final int NOTIFICATION = 83;
		public static final int NUM = 78;
		public static final int O = 43;
		public static final int P = 44;
		public static final int PERIOD = 56;
		public static final int PLUS = 81;
		public static final int POUND = 18;
		public static final int POWER = 26;
		public static final int Q = 45;
		public static final int R = 46;
		public static final int RIGHT_BRACKET = 72;
		public static final int S = 47;
		public static final int SEARCH = 84;
		public static final int SEMICOLON = 74;
		public static final int SHIFT_LEFT = 59;
		public static final int SHIFT_RIGHT = 60;
		public static final int SLASH = 76;
		public static final int SOFT_LEFT = 1;
		public static final int SOFT_RIGHT = 2;
		public static final int SPACE = 62;
		public static final int STAR = 17;
		public static final int SYM = 63;
		public static final int T = 48;
		public static final int TAB = 61;
		public static final int U = 49;
		public static final int UNKNOWN = 0;
		public static final int V = 50;
		public static final int VOLUME_DOWN = 25;
		public static final int VOLUME_UP = 24;
		public static final int W = 51;
		public static final int X = 52;
		public static final int Y = 53;
		public static final int Z = 54;
		public static final int META_ALT_LEFT_ON = 16;
		public static final int META_ALT_ON = 2;
		public static final int META_ALT_RIGHT_ON = 32;
		public static final int META_SHIFT_LEFT_ON = 64;
		public static final int META_SHIFT_ON = 1;
		public static final int META_SHIFT_RIGHT_ON = 128;
		public static final int META_SYM_ON = 4;
		public static final int CONTROL_LEFT = 129;
		public static final int CONTROL_RIGHT = 130;
		public static final int ESCAPE = 131;
		public static final int END = 132;
		public static final int INSERT = 133;
		public static final int PAGE_UP = 92;
		public static final int PAGE_DOWN = 93;
		public static final int PICTSYMBOLS = 94;
		public static final int SWITCH_CHARSET = 95;
		public static final int BUTTON_CIRCLE = 255;
		public static final int BUTTON_A = 96;
		public static final int BUTTON_B = 97;
		public static final int BUTTON_C = 98;
		public static final int BUTTON_X = 99;
		public static final int BUTTON_Y = 100;
		public static final int BUTTON_Z = 101;
		public static final int BUTTON_L1 = 102;
		public static final int BUTTON_R1 = 103;
		public static final int BUTTON_L2 = 104;
		public static final int BUTTON_R2 = 105;
		public static final int BUTTON_THUMBL = 106;
		public static final int BUTTON_THUMBR = 107;
		public static final int BUTTON_START = 108;
		public static final int BUTTON_SELECT = 109;
		public static final int BUTTON_MODE = 110;

		public static final int NUMPAD_0 = 144;
		public static final int NUMPAD_1 = 145;
		public static final int NUMPAD_2 = 146;
		public static final int NUMPAD_3 = 147;
		public static final int NUMPAD_4 = 148;
		public static final int NUMPAD_5 = 149;
		public static final int NUMPAD_6 = 150;
		public static final int NUMPAD_7 = 151;
		public static final int NUMPAD_8 = 152;
		public static final int NUMPAD_9 = 153;

// public static final int BACKTICK = 0;
// public static final int TILDE = 0;
// public static final int UNDERSCORE = 0;
// public static final int DOT = 0;
// public static final int BREAK = 0;
// public static final int PIPE = 0;
// public static final int EXCLAMATION = 0;
// public static final int QUESTIONMARK = 0;

// ` | VK_BACKTICK
// ~ | VK_TILDE
// : | VK_COLON
// _ | VK_UNDERSCORE
// . | VK_DOT
// (break) | VK_BREAK
// | | VK_PIPE
// ! | VK_EXCLAMATION
// ? | VK_QUESTION
		public static final int COLON = 243;
		public static final int F1 = 244;
		public static final int F2 = 245;
		public static final int F3 = 246;
		public static final int F4 = 247;
		public static final int F5 = 248;
		public static final int F6 = 249;
		public static final int F7 = 250;
		public static final int F8 = 251;
		public static final int F9 = 252;
		public static final int F10 = 253;
		public static final int F11 = 254;
		public static final int F12 = 255;

		/** @return a human readable representation of the keycode. The returned value can be used in
		 *         {@link Input.Keys#valueOf(String)} */
		public static String toString (int keycode) {
<span class="nc bnc" id="L248" title="All 2 branches missed.">			if (keycode &lt; 0) throw new IllegalArgumentException(&quot;keycode cannot be negative, keycode: &quot; + keycode);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">			if (keycode &gt; 255) throw new IllegalArgumentException(&quot;keycode cannot be greater than 255, keycode: &quot; + keycode);</span>
<span class="nc bnc" id="L250" title="All 141 branches missed.">			switch (keycode) {</span>
			// META* variables should not be used with this method.
			case UNKNOWN:
<span class="nc" id="L253">				return &quot;Unknown&quot;;</span>
			case SOFT_LEFT:
<span class="nc" id="L255">				return &quot;Soft Left&quot;;</span>
			case SOFT_RIGHT:
<span class="nc" id="L257">				return &quot;Soft Right&quot;;</span>
			case HOME:
<span class="nc" id="L259">				return &quot;Home&quot;;</span>
			case BACK:
<span class="nc" id="L261">				return &quot;Back&quot;;</span>
			case CALL:
<span class="nc" id="L263">				return &quot;Call&quot;;</span>
			case ENDCALL:
<span class="nc" id="L265">				return &quot;End Call&quot;;</span>
			case NUM_0:
<span class="nc" id="L267">				return &quot;0&quot;;</span>
			case NUM_1:
<span class="nc" id="L269">				return &quot;1&quot;;</span>
			case NUM_2:
<span class="nc" id="L271">				return &quot;2&quot;;</span>
			case NUM_3:
<span class="nc" id="L273">				return &quot;3&quot;;</span>
			case NUM_4:
<span class="nc" id="L275">				return &quot;4&quot;;</span>
			case NUM_5:
<span class="nc" id="L277">				return &quot;5&quot;;</span>
			case NUM_6:
<span class="nc" id="L279">				return &quot;6&quot;;</span>
			case NUM_7:
<span class="nc" id="L281">				return &quot;7&quot;;</span>
			case NUM_8:
<span class="nc" id="L283">				return &quot;8&quot;;</span>
			case NUM_9:
<span class="nc" id="L285">				return &quot;9&quot;;</span>
			case STAR:
<span class="nc" id="L287">				return &quot;*&quot;;</span>
			case POUND:
<span class="nc" id="L289">				return &quot;#&quot;;</span>
			case UP:
<span class="nc" id="L291">				return &quot;Up&quot;;</span>
			case DOWN:
<span class="nc" id="L293">				return &quot;Down&quot;;</span>
			case LEFT:
<span class="nc" id="L295">				return &quot;Left&quot;;</span>
			case RIGHT:
<span class="nc" id="L297">				return &quot;Right&quot;;</span>
			case CENTER:
<span class="nc" id="L299">				return &quot;Center&quot;;</span>
			case VOLUME_UP:
<span class="nc" id="L301">				return &quot;Volume Up&quot;;</span>
			case VOLUME_DOWN:
<span class="nc" id="L303">				return &quot;Volume Down&quot;;</span>
			case POWER:
<span class="nc" id="L305">				return &quot;Power&quot;;</span>
			case CAMERA:
<span class="nc" id="L307">				return &quot;Camera&quot;;</span>
			case CLEAR:
<span class="nc" id="L309">				return &quot;Clear&quot;;</span>
			case A:
<span class="nc" id="L311">				return &quot;A&quot;;</span>
			case B:
<span class="nc" id="L313">				return &quot;B&quot;;</span>
			case C:
<span class="nc" id="L315">				return &quot;C&quot;;</span>
			case D:
<span class="nc" id="L317">				return &quot;D&quot;;</span>
			case E:
<span class="nc" id="L319">				return &quot;E&quot;;</span>
			case F:
<span class="nc" id="L321">				return &quot;F&quot;;</span>
			case G:
<span class="nc" id="L323">				return &quot;G&quot;;</span>
			case H:
<span class="nc" id="L325">				return &quot;H&quot;;</span>
			case I:
<span class="nc" id="L327">				return &quot;I&quot;;</span>
			case J:
<span class="nc" id="L329">				return &quot;J&quot;;</span>
			case K:
<span class="nc" id="L331">				return &quot;K&quot;;</span>
			case L:
<span class="nc" id="L333">				return &quot;L&quot;;</span>
			case M:
<span class="nc" id="L335">				return &quot;M&quot;;</span>
			case N:
<span class="nc" id="L337">				return &quot;N&quot;;</span>
			case O:
<span class="nc" id="L339">				return &quot;O&quot;;</span>
			case P:
<span class="nc" id="L341">				return &quot;P&quot;;</span>
			case Q:
<span class="nc" id="L343">				return &quot;Q&quot;;</span>
			case R:
<span class="nc" id="L345">				return &quot;R&quot;;</span>
			case S:
<span class="nc" id="L347">				return &quot;S&quot;;</span>
			case T:
<span class="nc" id="L349">				return &quot;T&quot;;</span>
			case U:
<span class="nc" id="L351">				return &quot;U&quot;;</span>
			case V:
<span class="nc" id="L353">				return &quot;V&quot;;</span>
			case W:
<span class="nc" id="L355">				return &quot;W&quot;;</span>
			case X:
<span class="nc" id="L357">				return &quot;X&quot;;</span>
			case Y:
<span class="nc" id="L359">				return &quot;Y&quot;;</span>
			case Z:
<span class="nc" id="L361">				return &quot;Z&quot;;</span>
			case COMMA:
<span class="nc" id="L363">				return &quot;,&quot;;</span>
			case PERIOD:
<span class="nc" id="L365">				return &quot;.&quot;;</span>
			case ALT_LEFT:
<span class="nc" id="L367">				return &quot;L-Alt&quot;;</span>
			case ALT_RIGHT:
<span class="nc" id="L369">				return &quot;R-Alt&quot;;</span>
			case SHIFT_LEFT:
<span class="nc" id="L371">				return &quot;L-Shift&quot;;</span>
			case SHIFT_RIGHT:
<span class="nc" id="L373">				return &quot;R-Shift&quot;;</span>
			case TAB:
<span class="nc" id="L375">				return &quot;Tab&quot;;</span>
			case SPACE:
<span class="nc" id="L377">				return &quot;Space&quot;;</span>
			case SYM:
<span class="nc" id="L379">				return &quot;SYM&quot;;</span>
			case EXPLORER:
<span class="nc" id="L381">				return &quot;Explorer&quot;;</span>
			case ENVELOPE:
<span class="nc" id="L383">				return &quot;Envelope&quot;;</span>
			case ENTER:
<span class="nc" id="L385">				return &quot;Enter&quot;;</span>
			case DEL:
<span class="nc" id="L387">				return &quot;Delete&quot;; // also BACKSPACE</span>
			case GRAVE:
<span class="nc" id="L389">				return &quot;`&quot;;</span>
			case MINUS:
<span class="nc" id="L391">				return &quot;-&quot;;</span>
			case EQUALS:
<span class="nc" id="L393">				return &quot;=&quot;;</span>
			case LEFT_BRACKET:
<span class="nc" id="L395">				return &quot;[&quot;;</span>
			case RIGHT_BRACKET:
<span class="nc" id="L397">				return &quot;]&quot;;</span>
			case BACKSLASH:
<span class="nc" id="L399">				return &quot;\\&quot;;</span>
			case SEMICOLON:
<span class="nc" id="L401">				return &quot;;&quot;;</span>
			case APOSTROPHE:
<span class="nc" id="L403">				return &quot;'&quot;;</span>
			case SLASH:
<span class="nc" id="L405">				return &quot;/&quot;;</span>
			case AT:
<span class="nc" id="L407">				return &quot;@&quot;;</span>
			case NUM:
<span class="nc" id="L409">				return &quot;Num&quot;;</span>
			case HEADSETHOOK:
<span class="nc" id="L411">				return &quot;Headset Hook&quot;;</span>
			case FOCUS:
<span class="nc" id="L413">				return &quot;Focus&quot;;</span>
			case PLUS:
<span class="nc" id="L415">				return &quot;Plus&quot;;</span>
			case MENU:
<span class="nc" id="L417">				return &quot;Menu&quot;;</span>
			case NOTIFICATION:
<span class="nc" id="L419">				return &quot;Notification&quot;;</span>
			case SEARCH:
<span class="nc" id="L421">				return &quot;Search&quot;;</span>
			case MEDIA_PLAY_PAUSE:
<span class="nc" id="L423">				return &quot;Play/Pause&quot;;</span>
			case MEDIA_STOP:
<span class="nc" id="L425">				return &quot;Stop Media&quot;;</span>
			case MEDIA_NEXT:
<span class="nc" id="L427">				return &quot;Next Media&quot;;</span>
			case MEDIA_PREVIOUS:
<span class="nc" id="L429">				return &quot;Prev Media&quot;;</span>
			case MEDIA_REWIND:
<span class="nc" id="L431">				return &quot;Rewind&quot;;</span>
			case MEDIA_FAST_FORWARD:
<span class="nc" id="L433">				return &quot;Fast Forward&quot;;</span>
			case MUTE:
<span class="nc" id="L435">				return &quot;Mute&quot;;</span>
			case PAGE_UP:
<span class="nc" id="L437">				return &quot;Page Up&quot;;</span>
			case PAGE_DOWN:
<span class="nc" id="L439">				return &quot;Page Down&quot;;</span>
			case PICTSYMBOLS:
<span class="nc" id="L441">				return &quot;PICTSYMBOLS&quot;;</span>
			case SWITCH_CHARSET:
<span class="nc" id="L443">				return &quot;SWITCH_CHARSET&quot;;</span>
			case BUTTON_A:
<span class="nc" id="L445">				return &quot;A Button&quot;;</span>
			case BUTTON_B:
<span class="nc" id="L447">				return &quot;B Button&quot;;</span>
			case BUTTON_C:
<span class="nc" id="L449">				return &quot;C Button&quot;;</span>
			case BUTTON_X:
<span class="nc" id="L451">				return &quot;X Button&quot;;</span>
			case BUTTON_Y:
<span class="nc" id="L453">				return &quot;Y Button&quot;;</span>
			case BUTTON_Z:
<span class="nc" id="L455">				return &quot;Z Button&quot;;</span>
			case BUTTON_L1:
<span class="nc" id="L457">				return &quot;L1 Button&quot;;</span>
			case BUTTON_R1:
<span class="nc" id="L459">				return &quot;R1 Button&quot;;</span>
			case BUTTON_L2:
<span class="nc" id="L461">				return &quot;L2 Button&quot;;</span>
			case BUTTON_R2:
<span class="nc" id="L463">				return &quot;R2 Button&quot;;</span>
			case BUTTON_THUMBL:
<span class="nc" id="L465">				return &quot;Left Thumb&quot;;</span>
			case BUTTON_THUMBR:
<span class="nc" id="L467">				return &quot;Right Thumb&quot;;</span>
			case BUTTON_START:
<span class="nc" id="L469">				return &quot;Start&quot;;</span>
			case BUTTON_SELECT:
<span class="nc" id="L471">				return &quot;Select&quot;;</span>
			case BUTTON_MODE:
<span class="nc" id="L473">				return &quot;Button Mode&quot;;</span>
			case FORWARD_DEL:
<span class="nc" id="L475">				return &quot;Forward Delete&quot;;</span>
			case CONTROL_LEFT:
<span class="nc" id="L477">				return &quot;L-Ctrl&quot;;</span>
			case CONTROL_RIGHT:
<span class="nc" id="L479">				return &quot;R-Ctrl&quot;;</span>
			case ESCAPE:
<span class="nc" id="L481">				return &quot;Escape&quot;;</span>
			case END:
<span class="nc" id="L483">				return &quot;End&quot;;</span>
			case INSERT:
<span class="nc" id="L485">				return &quot;Insert&quot;;</span>
			case NUMPAD_0:
<span class="nc" id="L487">				return &quot;Numpad 0&quot;;</span>
			case NUMPAD_1:
<span class="nc" id="L489">				return &quot;Numpad 1&quot;;</span>
			case NUMPAD_2:
<span class="nc" id="L491">				return &quot;Numpad 2&quot;;</span>
			case NUMPAD_3:
<span class="nc" id="L493">				return &quot;Numpad 3&quot;;</span>
			case NUMPAD_4:
<span class="nc" id="L495">				return &quot;Numpad 4&quot;;</span>
			case NUMPAD_5:
<span class="nc" id="L497">				return &quot;Numpad 5&quot;;</span>
			case NUMPAD_6:
<span class="nc" id="L499">				return &quot;Numpad 6&quot;;</span>
			case NUMPAD_7:
<span class="nc" id="L501">				return &quot;Numpad 7&quot;;</span>
			case NUMPAD_8:
<span class="nc" id="L503">				return &quot;Numpad 8&quot;;</span>
			case NUMPAD_9:
<span class="nc" id="L505">				return &quot;Numpad 9&quot;;</span>
			case COLON:
<span class="nc" id="L507">				return &quot;:&quot;;</span>
			case F1:
<span class="nc" id="L509">				return &quot;F1&quot;;</span>
			case F2:
<span class="nc" id="L511">				return &quot;F2&quot;;</span>
			case F3:
<span class="nc" id="L513">				return &quot;F3&quot;;</span>
			case F4:
<span class="nc" id="L515">				return &quot;F4&quot;;</span>
			case F5:
<span class="nc" id="L517">				return &quot;F5&quot;;</span>
			case F6:
<span class="nc" id="L519">				return &quot;F6&quot;;</span>
			case F7:
<span class="nc" id="L521">				return &quot;F7&quot;;</span>
			case F8:
<span class="nc" id="L523">				return &quot;F8&quot;;</span>
			case F9:
<span class="nc" id="L525">				return &quot;F9&quot;;</span>
			case F10:
<span class="nc" id="L527">				return &quot;F10&quot;;</span>
			case F11:
<span class="nc" id="L529">				return &quot;F11&quot;;</span>
			case F12:
<span class="nc" id="L531">				return &quot;F12&quot;;</span>
				// BUTTON_CIRCLE unhandled, as it conflicts with the more likely to be pressed F12
			default:
				// key name not found
<span class="nc" id="L535">				return null;</span>
			}
		}

		private static ObjectIntMap&lt;String&gt; keyNames;

		/** @param keyname the keyname returned by the {@link Keys#toString(int)} method
		 * @return the int keycode */
		public static int valueOf (String keyname) {
<span class="nc bnc" id="L544" title="All 2 branches missed.">			if (keyNames == null) initializeKeyNames();</span>
<span class="nc" id="L545">			return keyNames.get(keyname, -1);</span>
		}

		/** lazily intialized in {@link Keys#valueOf(String)} */
		private static void initializeKeyNames () {
<span class="nc" id="L550">			keyNames = new ObjectIntMap&lt;String&gt;();</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">			for (int i = 0; i &lt; 256; i++) {</span>
<span class="nc" id="L552">				String name = toString(i);</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">				if (name != null) keyNames.put(name, i);</span>
			}
<span class="nc" id="L555">		}</span>
	}

	/** Enumeration of potentially available peripherals. Use with {@link Input#isPeripheralAvailable(Peripheral)}.
	 * @author mzechner */
<span class="nc" id="L560">	public enum Peripheral {</span>
<span class="nc" id="L561">		HardwareKeyboard, OnscreenKeyboard, MultitouchScreen, Accelerometer, Compass, Vibrator, Gyroscope</span>
	}

	/** @return The rate of rotation around the x axis. (rad/s) */
	public float getAccelerometerX ();

	/** @return The rate of rotation around the y axis. (rad/s) */
	public float getAccelerometerY ();

	/** @return The rate of rotation around the z axis. (rad/s) */
	public float getAccelerometerZ ();

	public float getGyroscopeX ();

	public float getGyroscopeY ();

	public float getGyroscopeZ ();
	
	/** @return The x coordinate of the last touch on touch screen devices and the current mouse position on desktop for the first
	 *         pointer in screen coordinates. The screen origin is the top left corner. */
	public int getX ();

	/** Returns the x coordinate in screen coordinates of the given pointer. Pointers are indexed from 0 to n. The pointer id
	 * identifies the order in which the fingers went down on the screen, e.g. 0 is the first finger, 1 is the second and so on.
	 * When two fingers are touched down and the first one is lifted the second one keeps its index. If another finger is placed on
	 * the touch screen the first free index will be used.
	 * 
	 * @param pointer the pointer id.
	 * @return the x coordinate */
	public int getX (int pointer);

	/** @return the different between the current pointer location and the last pointer location on the x-axis. */
	public int getDeltaX ();

	/** @return the different between the current pointer location and the last pointer location on the x-axis. */
	public int getDeltaX (int pointer);

	/** @return The y coordinate of the last touch on touch screen devices and the current mouse position on desktop for the first
	 *         pointer in screen coordinates. The screen origin is the top left corner. */
	public int getY ();

	/** Returns the y coordinate in screen coordinates of the given pointer. Pointers are indexed from 0 to n. The pointer id
	 * identifies the order in which the fingers went down on the screen, e.g. 0 is the first finger, 1 is the second and so on.
	 * When two fingers are touched down and the first one is lifted the second one keeps its index. If another finger is placed on
	 * the touch screen the first free index will be used.
	 * 
	 * @param pointer the pointer id.
	 * @return the y coordinate */
	public int getY (int pointer);

	/** @return the different between the current pointer location and the last pointer location on the y-axis. */
	public int getDeltaY ();

	/** @return the different between the current pointer location and the last pointer location on the y-axis. */
	public int getDeltaY (int pointer);

	/** @return whether the screen is currently touched. */
	public boolean isTouched ();

	/** @return whether a new touch down event just occurred. */
	public boolean justTouched ();

	/** Whether the screen is currently touched by the pointer with the given index. Pointers are indexed from 0 to n. The pointer
	 * id identifies the order in which the fingers went down on the screen, e.g. 0 is the first finger, 1 is the second and so on.
	 * When two fingers are touched down and the first one is lifted the second one keeps its index. If another finger is placed on
	 * the touch screen the first free index will be used.
	 * 
	 * @param pointer the pointer
	 * @return whether the screen is touched by the pointer */
	public boolean isTouched (int pointer);

	/** Whether a given button is pressed or not. Button constants can be found in {@link Buttons}. On Android only the Button#LEFT
	 * constant is meaningful before version 4.0.
	 * @param button the button to check.
	 * @return whether the button is down or not. */
	public boolean isButtonPressed (int button);

	/** Returns whether the key is pressed.
	 * 
	 * @param key The key code as found in {@link Input.Keys}.
	 * @return true or false. */
	public boolean isKeyPressed (int key);

	/** Returns whether the key has just been pressed.
	 * 
	 * @param key The key code as found in {@link Input.Keys}.
	 * @return true or false. */
	public boolean isKeyJustPressed (int key);

	/** System dependent method to input a string of text. A dialog box will be created with the given title and the given text as a
	 * message for the user. Once the dialog has been closed the provided {@link TextInputListener} will be called on the rendering
	 * thread.
	 * 
	 * @param listener The TextInputListener.
	 * @param title The title of the text input dialog.
	 * @param text The message presented to the user. */
	public void getTextInput (TextInputListener listener, String title, String text, String hint);

	/** Sets the on-screen keyboard visible if available.
	 * 
	 * @param visible visible or not */
	public void setOnscreenKeyboardVisible (boolean visible);

	/** Vibrates for the given amount of time. Note that you'll need the permission
	 * &lt;code&gt; &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&lt;/code&gt; in your manifest file in order for this to work.
	 * 
	 * @param milliseconds the number of milliseconds to vibrate. */
	public void vibrate (int milliseconds);

	/** Vibrate with a given pattern. Pass in an array of ints that are the times at which to turn on or off the vibrator. The first
	 * one is how long to wait before turning it on, and then after that it alternates. If you want to repeat, pass the index into
	 * the pattern at which to start the repeat.
	 * @param pattern an array of longs of times to turn the vibrator on or off.
	 * @param repeat the index into pattern at which to repeat, or -1 if you don't want to repeat. */
	public void vibrate (long[] pattern, int repeat);

	/** Stops the vibrator */
	public void cancelVibrate ();

	/** The azimuth is the angle of the device's orientation around the z-axis. The positive z-axis points towards the earths
	 * center.
	 * 
	 * @see &lt;a
	 *      href=&quot;http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float[], float[], float[], float[])&quot;&gt;http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float[], float[], float[], float[])&lt;/a&gt;
	 * @return the azimuth in degrees */
	public float getAzimuth ();

	/** The pitch is the angle of the device's orientation around the x-axis. The positive x-axis roughly points to the west and is
	 * orthogonal to the z- and y-axis.
	 * @see &lt;a
	 *      href=&quot;http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float[], float[], float[], float[])&quot;&gt;http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float[], float[], float[], float[])&lt;/a&gt;
	 * @return the pitch in degrees */
	public float getPitch ();

	/** The roll is the angle of the device's orientation around the y-axis. The positive y-axis points to the magnetic north pole
	 * of the earth.
	 * @see &lt;a
	 *      href=&quot;http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float[], float[], float[], float[])&quot;&gt;http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float[], float[], float[], float[])&lt;/a&gt;
	 * @return the roll in degrees */
	public float getRoll ();

	/** Returns the rotation matrix describing the devices rotation as per &lt;a href=
	 * &quot;http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float[], float[], float[], float[])&quot;
	 * &gt;SensorManager#getRotationMatrix(float[], float[], float[], float[])&lt;/a&gt;. Does not manipulate the matrix if the platform
	 * does not have an accelerometer.
	 * @param matrix */
	public void getRotationMatrix (float[] matrix);

	/** @return the time of the event currently reported to the {@link InputProcessor}. */
	public long getCurrentEventTime ();

	/** Sets whether the BACK button on Android should be caught. This will prevent the app from being paused. Will have no effect
	 * on the desktop.
	 * 
	 * @param catchBack whether to catch the back button */
	public void setCatchBackKey (boolean catchBack);

	/** @return whether the back button is currently being caught */
	public boolean isCatchBackKey ();

	/** Sets whether the MENU button on Android should be caught. This will prevent the onscreen keyboard to show up. Will have no
	 * effect on the desktop.
	 * 
	 * @param catchMenu whether to catch the menu button */
	public void setCatchMenuKey (boolean catchMenu);
	
	/** @return whether the menu button is currently being caught */
	public boolean isCatchMenuKey ();

	/** Sets the {@link InputProcessor} that will receive all touch and key input events. It will be called before the
	 * {@link ApplicationListener#render()} method each frame.
	 * 
	 * @param processor the InputProcessor */
	public void setInputProcessor (InputProcessor processor);

	/** @return the currently set {@link InputProcessor} or null. */
	public InputProcessor getInputProcessor ();

	/** Queries whether a {@link Peripheral} is currently available. In case of Android and the {@link Peripheral#HardwareKeyboard}
	 * this returns the whether the keyboard is currently slid out or not.
	 * 
	 * @param peripheral the {@link Peripheral}
	 * @return whether the peripheral is available or not. */
	public boolean isPeripheralAvailable (Peripheral peripheral);

	/** @return the rotation of the device with respect to its native orientation. */
	public int getRotation ();

	/** @return the native orientation of the device. */
	public Orientation getNativeOrientation ();

<span class="nc" id="L752">	public enum Orientation {</span>
<span class="nc" id="L753">		Landscape, Portrait</span>
	}

	/** Only viable on the desktop. Will confine the mouse cursor location to the window and hide the mouse cursor. X and y
	 * coordinates are still reported as if the mouse was not catched.
	 * @param catched whether to catch or not to catch the mouse cursor */
	public void setCursorCatched (boolean catched);

	/** @return whether the mouse cursor is catched. */
	public boolean isCursorCatched ();

	/** Only viable on the desktop. Will set the mouse cursor location to the given window coordinates (origin top-left corner).
	 * @param x the x-position
	 * @param y the y-position */
	public void setCursorPosition (int x, int y);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.5.201112152213</span></div></body></html>