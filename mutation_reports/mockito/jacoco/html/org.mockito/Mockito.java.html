<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Mockito.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mockito</a> &gt; <a href="index.source.html" class="el_package">org.mockito</a> &gt; <span class="el_source">Mockito.java</span></div><h1>Mockito.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito;

import org.mockito.internal.MockitoCore;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.debugging.MockitoDebuggerImpl;
import org.mockito.internal.stubbing.answers.*;
import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;
import org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues;
import org.mockito.internal.verification.VerificationModeFactory;
import org.mockito.mock.SerializableMode;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.*;
import org.mockito.verification.*;
import org.mockito.junit.*;

/**
 * &lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;logo.png&quot; srcset=&quot;logo@2x.png 2x&quot; alt=&quot;Mockito logo&quot;/&gt;&lt;/p&gt;
 * The Mockito library enables mock creation, verification and stubbing.
 * &lt;p&gt;
 * This javadoc content is also available on the &lt;a href=&quot;http://mockito.org&quot;&gt;http://mockito.org&lt;/a&gt; web page.
 * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.
 * It allows access to documentation straight from the IDE even if you work offline.
 * It motivates Mockito developers to keep documentation up-to-date with the code that they write,
 * every day, with every commit.
 *
 * &lt;h1&gt;Contents&lt;/h1&gt;
 *
 * &lt;b&gt;
 *      &lt;a href=&quot;#0&quot;&gt;0. Migrating to 2.0&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#1&quot;&gt;1. Let's verify some behaviour! &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#2&quot;&gt;2. How about some stubbing? &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#3&quot;&gt;3. Argument matchers &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#4&quot;&gt;4. Verifying exact number of invocations / at least once / never &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#5&quot;&gt;5. Stubbing void methods with exceptions &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#6&quot;&gt;6. Verification in order &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#7&quot;&gt;7. Making sure interaction(s) never happened on mock &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#8&quot;&gt;8. Finding redundant invocations &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#9&quot;&gt;9. Shorthand for mocks creation - &lt;code&gt;&amp;#064;Mock&lt;/code&gt; annotation &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#10&quot;&gt;10. Stubbing consecutive calls (iterator-style stubbing) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#11&quot;&gt;11. Stubbing with callbacks &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#12&quot;&gt;12. &lt;code&gt;doReturn()&lt;/code&gt;|&lt;code&gt;doThrow()&lt;/code&gt;|&lt;code&gt;doAnswer()&lt;/code&gt;|&lt;code&gt;doNothing()&lt;/code&gt;|&lt;code&gt;doCallRealMethod()&lt;/code&gt; family of methods&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#13&quot;&gt;13. Spying on real objects &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#14&quot;&gt;14. Changing default return values of unstubbed invocations (Since 1.7) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#15&quot;&gt;15. Capturing arguments for further assertions (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#16&quot;&gt;16. Real partial mocks (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#17&quot;&gt;17. Resetting mocks (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#18&quot;&gt;18. Troubleshooting &amp; validating framework usage (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#19&quot;&gt;19. Aliases for behavior driven development (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#20&quot;&gt;20. Serializable mocks (Since 1.8.1) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#21&quot;&gt;21. New annotations: &lt;code&gt;&amp;#064;Captor&lt;/code&gt;, &lt;code&gt;&amp;#064;Spy&lt;/code&gt;, &lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt; (Since 1.8.3) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#22&quot;&gt;22. Verification with timeout (Since 1.8.5) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#23&quot;&gt;23. Automatic instantiation of &lt;code&gt;&amp;#064;Spies&lt;/code&gt;, &lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt; and constructor injection goodness (Since 1.9.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#24&quot;&gt;24. One-liner stubs (Since 1.9.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#25&quot;&gt;25. Verification ignoring stubs (Since 1.9.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#26&quot;&gt;26. Mocking details (Since 1.9.5)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#27&quot;&gt;27. Delegate calls to real instance (Since 1.9.5)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#28&quot;&gt;28. &lt;code&gt;MockMaker&lt;/code&gt; API (Since 1.9.5)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#29&quot;&gt;29. (new) BDD style verification (Since 1.10.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#30&quot;&gt;30. (new) Spying or mocking abstract classes (Since 1.10.12)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#31&quot;&gt;31. (new) Mockito mocks can be &lt;em&gt;serialized&lt;/em&gt; / &lt;em&gt;deserialized&lt;/em&gt; across classloaders (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#32&quot;&gt;32. (new) Better generic support with deep stubs (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#32&quot;&gt;33. (new) Mockito JUnit rule (Since 1.10.17)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#34&quot;&gt;34. (new) Switch &lt;em&gt;on&lt;/em&gt; or &lt;em&gt;off&lt;/em&gt; plugins (Since 1.10.15)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#35&quot;&gt;35. (new) Custom verification failure message (Since 2.0.0)&lt;/a&gt;&lt;br/&gt;
 * &lt;/b&gt;
 *
 * &lt;h3 id=&quot;0&quot;&gt;0. &lt;a class=&quot;meaningful_link&quot; href=&quot;#verification&quot;&gt;Migrating to 2.0&lt;/a&gt;&lt;/h3&gt;
 *
 * In order to continue improving Mockito and further improve the unit testing experience, we want you to upgrade to 2.0.
 * Mockito follows &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt;
 * and contains breaking changes only on major version upgrades.
 * In the lifecycle of a library, breaking changes are necessary
 * to roll out a set of brand new features that alter the existing behavior or even change the API.
 * We hope that you enjoy Mockito 2.0!
 * &lt;p&gt;
 * List of breaking changes:
 * &lt;ul&gt;
 *     &lt;li&gt;Mockito is decoupled from Hamcrest and custom matchers API has changed, see {@link ArgumentMatcher}
 *     for rationale and migration guide&lt;/li&gt;.
 *     &lt;li&gt;Stubbing API has been tweaked to avoid unavoidable compilation warnings that appeared on JDK7+ platform.
 *     This will only affect binary compatibility, compilation compatibility remains unaffected.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * The following examples mock a List, because most people are familiar with the interface (such as the
 * &lt;code&gt;add()&lt;/code&gt;, &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;clear()&lt;/code&gt; methods). &lt;br&gt;
 * In reality, please don't mock the List class. Use a real instance instead.
 *
 *
 *
 *
 * &lt;h3 id=&quot;1&quot;&gt;1. &lt;a class=&quot;meaningful_link&quot; href=&quot;#verification&quot;&gt;Let's verify some behaviour!&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //Let's import Mockito statically so that the code looks clearer
 * import static org.mockito.Mockito.*;
 *
 * //mock creation
 * List mockedList = mock(List.class);
 *
 * //using mock object
 * mockedList.add(&quot;one&quot;);
 * mockedList.clear();
 *
 * //verification
 * verify(mockedList).add(&quot;one&quot;);
 * verify(mockedList).clear();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Once created, a mock will remember all interactions. Then you can selectively
 * verify whatever interactions you are interested in.
 *
 *
 *
 *
 * &lt;h3 id=&quot;2&quot;&gt;2. &lt;a class=&quot;meaningful_link&quot; href=&quot;#stubbing&quot;&gt;How about some stubbing?&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //You can mock concrete classes, not just interfaces
 * LinkedList mockedList = mock(LinkedList.class);
 *
 * //stubbing
 * when(mockedList.get(0)).thenReturn(&quot;first&quot;);
 * when(mockedList.get(1)).thenThrow(new RuntimeException());
 *
 * //following prints &quot;first&quot;
 * System.out.println(mockedList.get(0));
 *
 * //following throws runtime exception
 * System.out.println(mockedList.get(1));
 *
 * //following prints &quot;null&quot; because get(999) was not stubbed
 * System.out.println(mockedList.get(999));
 *
 * //Although it is possible to verify a stubbed invocation, usually &lt;b&gt;it's just redundant&lt;/b&gt;
 * //If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed).
 * //If your code doesn't care what get(0) returns, then it should not be stubbed. Not convinced? See &lt;a href=&quot;http://monkeyisland.pl/2008/04/26/asking-and-telling&quot;&gt;here&lt;/a&gt;.
 * verify(mockedList).get(0);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt; By default, for all methods that return a value, a mock will return either null, a
 * a primitive/primitive wrapper value, or an empty collection, as appropriate.
 * For example 0 for an int/Integer and false for a boolean/Boolean. &lt;/li&gt;
 *
 * &lt;li&gt; Stubbing can be overridden: for example common stubbing can go to
 * fixture setup but the test methods can override it.
 * Please note that overridding stubbing is a potential code smell that points out too much stubbing&lt;/li&gt;
 *
 * &lt;li&gt; Once stubbed, the method will always return a stubbed value, regardless
 * of how many times it is called. &lt;/li&gt;
 *
 * &lt;li&gt; Last stubbing is more important - when you stubbed the same method with
 * the same arguments many times.
 * Other words: &lt;b&gt;the order of stubbing matters&lt;/b&gt; but it is only meaningful rarely,
 * e.g. when stubbing exactly the same method calls or sometimes when argument matchers are used, etc.&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 *
 *
 * &lt;h3 id=&quot;3&quot;&gt;3. &lt;a class=&quot;meaningful_link&quot; href=&quot;#argument_matchers&quot;&gt;Argument matchers&lt;/a&gt;&lt;/h3&gt;
 *
 * Mockito verifies argument values in natural java style: by using an &lt;code&gt;equals()&lt;/code&gt; method.
 * Sometimes, when extra flexibility is required then you might use argument matchers:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //stubbing using built-in anyInt() argument matcher
 * when(mockedList.get(anyInt())).thenReturn(&quot;element&quot;);
 *
 * //stubbing using custom matcher (let's say isValid() returns your own matcher implementation):
 * when(mockedList.contains(argThat(isValid()))).thenReturn(&quot;element&quot;);
 *
 * //following prints &quot;element&quot;
 * System.out.println(mockedList.get(999));
 *
 * //&lt;b&gt;you can also verify using an argument matcher&lt;/b&gt;
 * verify(mockedList).get(anyInt());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Argument matchers allow flexible verification or stubbing.
 * {@link Matchers Click here to see} more built-in matchers
 * and examples of &lt;b&gt;custom argument matchers / hamcrest matchers&lt;/b&gt;.
 * &lt;p&gt;
 * For information solely on &lt;b&gt;custom argument matchers&lt;/b&gt; check out javadoc for {@link ArgumentMatcher} class.
 * &lt;p&gt;
 * Be reasonable with using complicated argument matching.
 * The natural matching style using &lt;code&gt;equals()&lt;/code&gt; with occasional &lt;code&gt;anyX()&lt;/code&gt; matchers tend to give clean &amp; simple tests.
 * Sometimes it's just better to refactor the code to allow &lt;code&gt;equals()&lt;/code&gt; matching or even implement &lt;code&gt;equals()&lt;/code&gt; method to help out with testing.
 * &lt;p&gt;
 * Also, read &lt;a href=&quot;#15&quot;&gt;section 15&lt;/a&gt; or javadoc for {@link ArgumentCaptor} class.
 * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.
 * &lt;p&gt;
 * &lt;b&gt;Warning on argument matchers:&lt;/b&gt;
 * &lt;p&gt;
 * If you are using argument matchers, &lt;b&gt;all arguments&lt;/b&gt; have to be provided
 * by matchers.
 * &lt;p&gt;
 The following example shows verification but the same applies to stubbing:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   verify(mock).someMethod(anyInt(), anyString(), &lt;b&gt;eq(&quot;third argument&quot;)&lt;/b&gt;);
 *   //above is correct - eq() is also an argument matcher
 *
 *   verify(mock).someMethod(anyInt(), anyString(), &lt;b&gt;&quot;third argument&quot;&lt;/b&gt;);
 *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Matcher methods like &lt;code&gt;anyObject()&lt;/code&gt;, &lt;code&gt;eq()&lt;/code&gt; &lt;b&gt;do not&lt;/b&gt; return matchers.
 * Internally, they record a matcher on a stack and return a dummy value (usually null).
 * This implementation is due to static type safety imposed by the java compiler.
 * The consequence is that you cannot use &lt;code&gt;anyObject()&lt;/code&gt;, &lt;code&gt;eq()&lt;/code&gt; methods outside of verified/stubbed method.
 *
 *
 *
 *
 * &lt;h3 id=&quot;4&quot;&gt;4. &lt;a class=&quot;meaningful_link&quot; href=&quot;#exact_verification&quot;&gt;Verifying exact number of invocations&lt;/a&gt; /
 * &lt;a class=&quot;meaningful_link&quot; href=&quot;#at_least_verification&quot;&gt;at least x&lt;/a&gt; / never&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //using mock
 * mockedList.add(&quot;once&quot;);
 *
 * mockedList.add(&quot;twice&quot;);
 * mockedList.add(&quot;twice&quot;);
 *
 * mockedList.add(&quot;three times&quot;);
 * mockedList.add(&quot;three times&quot;);
 * mockedList.add(&quot;three times&quot;);
 *
 * //following two verifications work exactly the same - times(1) is used by default
 * verify(mockedList).add(&quot;once&quot;);
 * verify(mockedList, times(1)).add(&quot;once&quot;);
 *
 * //exact number of invocations verification
 * verify(mockedList, times(2)).add(&quot;twice&quot;);
 * verify(mockedList, times(3)).add(&quot;three times&quot;);
 *
 * //verification using never(). never() is an alias to times(0)
 * verify(mockedList, never()).add(&quot;never happened&quot;);
 *
 * //verification using atLeast()/atMost()
 * verify(mockedList, atLeastOnce()).add(&quot;three times&quot;);
 * verify(mockedList, atLeast(2)).add(&quot;five times&quot;);
 * verify(mockedList, atMost(5)).add(&quot;three times&quot;);
 *
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * &lt;b&gt;times(1) is the default.&lt;/b&gt; Therefore using times(1) explicitly can be
 * omitted.
 *
 *
 *
 *
 * &lt;h3 id=&quot;5&quot;&gt;5. &lt;a class=&quot;meaningful_link&quot; href=&quot;#stubbing_with_exceptions&quot;&gt;Stubbing void methods with exceptions&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   doThrow(new RuntimeException()).when(mockedList).clear();
 *
 *   //following throws RuntimeException:
 *   mockedList.clear();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Read more about doThrow|doAnswer family of methods in paragraph 12.
 * &lt;p&gt;
 * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.
 * Currently &lt;code&gt;stubVoid()&lt;/code&gt; is deprecated in favor of {@link Mockito#doThrow(Throwable...)}.
 * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods.
 *
 *
 *
 *
 * &lt;h3 id=&quot;6&quot;&gt;6. &lt;a class=&quot;meaningful_link&quot; href=&quot;#in_order_verification&quot;&gt;Verification in order&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * // A. Single mock whose methods must be invoked in a particular order
 * List singleMock = mock(List.class);
 *
 * //using a single mock
 * singleMock.add(&quot;was added first&quot;);
 * singleMock.add(&quot;was added second&quot;);
 *
 * //create an inOrder verifier for a single mock
 * InOrder inOrder = inOrder(singleMock);
 *
 * //following will make sure that add is first called with &quot;was added first, then with &quot;was added second&quot;
 * inOrder.verify(singleMock).add(&quot;was added first&quot;);
 * inOrder.verify(singleMock).add(&quot;was added second&quot;);
 *
 * // B. Multiple mocks that must be used in a particular order
 * List firstMock = mock(List.class);
 * List secondMock = mock(List.class);
 *
 * //using mocks
 * firstMock.add(&quot;was called first&quot;);
 * secondMock.add(&quot;was called second&quot;);
 *
 * //create inOrder object passing any mocks that need to be verified in order
 * InOrder inOrder = inOrder(firstMock, secondMock);
 *
 * //following will make sure that firstMock was called before secondMock
 * inOrder.verify(firstMock).add(&quot;was called first&quot;);
 * inOrder.verify(secondMock).add(&quot;was called second&quot;);
 *
 * // Oh, and A + B can be mixed together at will
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Verification in order is flexible - &lt;b&gt;you don't have to verify all
 * interactions&lt;/b&gt; one-by-one but only those that you are interested in
 * testing in order.
 * &lt;p&gt;
 * Also, you can create an InOrder object passing only the mocks that are relevant for
 * in-order verification.
 *
 *
 *
 *
 * &lt;h3 id=&quot;7&quot;&gt;7. &lt;a class=&quot;meaningful_link&quot; href=&quot;#never_verification&quot;&gt;Making sure interaction(s) never happened on mock&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //using mocks - only mockOne is interacted
 * mockOne.add(&quot;one&quot;);
 *
 * //ordinary verification
 * verify(mockOne).add(&quot;one&quot;);
 *
 * //verify that method was never called on a mock
 * verify(mockOne, never()).add(&quot;two&quot;);
 *
 * //verify that other mocks were not interacted
 * verifyZeroInteractions(mockTwo, mockThree);
 *
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;8&quot;&gt;8. &lt;a class=&quot;meaningful_link&quot; href=&quot;#finding_redundant_invocations&quot;&gt;Finding redundant invocations&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //using mocks
 * mockedList.add(&quot;one&quot;);
 * mockedList.add(&quot;two&quot;);
 *
 * verify(mockedList).add(&quot;one&quot;);
 *
 * //following verification will fail
 * verifyNoMoreInteractions(mockedList);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * A word of &lt;b&gt;warning&lt;/b&gt;:
 * Some users who did a lot of classic, expect-run-verify mocking tend to use &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; very often, even in every test method.
 * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is not recommended to use in every test method.
 * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
 * Abusing it leads to &lt;strong&gt;overspecified&lt;/strong&gt;, &lt;strong&gt;less maintainable&lt;/strong&gt; tests. You can find further reading
 * &lt;a href=&quot;http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/&quot;&gt;here&lt;/a&gt;.
 *
 * &lt;p&gt;
 * See also {@link Mockito#never()} - it is more explicit and
 * communicates the intent well.
 * &lt;p&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;9&quot;&gt;9. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mock_annotation&quot;&gt;Shorthand for mocks creation - &lt;code&gt;&amp;#064;Mock&lt;/code&gt; annotation&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;Minimizes repetitive mock creation code.&lt;/li&gt;
 * &lt;li&gt;Makes the test class more readable.&lt;/li&gt;
 * &lt;li&gt;Makes the verification error easier to read because the &lt;b&gt;field name&lt;/b&gt;
 * is used to identify the mock.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   public class ArticleManagerTest {
 *
 *       &amp;#064;Mock private ArticleCalculator calculator;
 *       &amp;#064;Mock private ArticleDatabase database;
 *       &amp;#064;Mock private UserProvider userProvider;
 *
 *       private ArticleManager manager;
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;b&gt;Important!&lt;/b&gt; This needs to be somewhere in the base class or a test
 * runner:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * MockitoAnnotations.initMocks(testClass);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * You can use built-in runner: {@link MockitoJUnitRunner} or a rule: {@link MockitoRule}.
 * &lt;p&gt;
 * Read more here: {@link MockitoAnnotations}
 *
 *
 *
 *
 * &lt;h3 id=&quot;10&quot;&gt;10. &lt;a class=&quot;meaningful_link&quot; href=&quot;#stubbing_consecutive_calls&quot;&gt;Stubbing consecutive calls&lt;/a&gt; (iterator-style stubbing)&lt;/h3&gt;
 *
 * Sometimes we need to stub with different return value/exception for the same
 * method call. Typical use case could be mocking iterators.
 * Original version of Mockito did not have this feature to promote simple mocking.
 * For example, instead of iterators one could use {@link Iterable} or simply
 * collections. Those offer natural ways of stubbing (e.g. using real
 * collections). In rare scenarios stubbing consecutive calls could be useful,
 * though:
 * &lt;p&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * when(mock.someMethod(&quot;some arg&quot;))
 *   .thenThrow(new RuntimeException())
 *   .thenReturn(&quot;foo&quot;);
 *
 * //First call: throws runtime exception:
 * mock.someMethod(&quot;some arg&quot;);
 *
 * //Second call: prints &quot;foo&quot;
 * System.out.println(mock.someMethod(&quot;some arg&quot;));
 *
 * //Any consecutive call: prints &quot;foo&quot; as well (last stubbing wins).
 * System.out.println(mock.someMethod(&quot;some arg&quot;));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Alternative, shorter version of consecutive stubbing:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * when(mock.someMethod(&quot;some arg&quot;))
 *   .thenReturn(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;11&quot;&gt;11. &lt;a class=&quot;meaningful_link&quot; href=&quot;#answer_stubs&quot;&gt;Stubbing with callbacks&lt;/a&gt;&lt;/h3&gt;
 *
 * Allows stubbing with generic {@link Answer} interface.
 * &lt;p&gt;
 * Yet another controversial feature which was not included in Mockito
 * originally. We recommend simply stubbing with &lt;code&gt;thenReturn()&lt;/code&gt; or
 * &lt;code&gt;thenThrow()&lt;/code&gt;, which should be enough to test/test-drive
 * any clean &amp; simple code. However, if you do have a need to stub with the generic Answer interface, here is an example:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * when(mock.someMethod(anyString())).thenAnswer(new Answer() {
 *     Object answer(InvocationOnMock invocation) {
 *         Object[] args = invocation.getArguments();
 *         Object mock = invocation.getMock();
 *         return &quot;called with arguments: &quot; + args;
 *     }
 * });
 *
 * //the following prints &quot;called with arguments: foo&quot;
 * System.out.println(mock.someMethod(&quot;foo&quot;));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;12&quot;&gt;12. &lt;a class=&quot;meaningful_link&quot; href=&quot;#do_family_methods_stubs&quot;&gt;&lt;code&gt;doReturn()&lt;/code&gt;|&lt;code&gt;doThrow()&lt;/code&gt;|
 * &lt;code&gt;doAnswer()&lt;/code&gt;|&lt;code&gt;doNothing()&lt;/code&gt;|&lt;code&gt;doCallRealMethod()&lt;/code&gt; family of methods&lt;/a&gt;&lt;/h3&gt;
 *
 * Stubbing void methods requires a different approach from {@link Mockito#when(Object)} because the compiler does not
 * like void methods inside brackets...
 * &lt;p&gt;
 * {@link Mockito#doThrow(Throwable...)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids.
 * The main reason is improved readability and consistency with the family of &lt;code&gt;doAnswer()&lt;/code&gt; methods.
 * &lt;p&gt;
 * Use &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub a void method with an exception:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   doThrow(new RuntimeException()).when(mockedList).clear();
 *
 *   //following throws RuntimeException:
 *   mockedList.clear();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * You can use &lt;code&gt;doThrow()&lt;/code&gt;, &lt;code&gt;doAnswer()&lt;/code&gt;, &lt;code&gt;doNothing()&lt;/code&gt;, &lt;code&gt;doReturn()&lt;/code&gt;
 * and &lt;code&gt;doCallRealMethod()&lt;/code&gt; in place of the corresponding call with &lt;code&gt;when()&lt;/code&gt;, for any method.
 * It is necessary when you
 * &lt;ul&gt;
 *     &lt;li&gt;stub void methods&lt;/li&gt;
 *     &lt;li&gt;stub methods on spy objects (see below)&lt;/li&gt;
 *     &lt;li&gt;stub the same method more than once, to change the behaviour of a mock in the middle of a test.&lt;/li&gt;
 * &lt;/ul&gt;
 * but you may prefer to use these methods in place of the alternative with &lt;code&gt;when()&lt;/code&gt;, for all of your stubbing calls.
 * &lt;p&gt;
 * Read more about these methods:
 * &lt;p&gt;
 * {@link Mockito#doReturn(Object)}
 * &lt;p&gt;
 * {@link Mockito#doThrow(Throwable...)}
 * &lt;p&gt;
 * {@link Mockito#doThrow(Class)}
 * &lt;p&gt;
 * {@link Mockito#doAnswer(Answer)}
 * &lt;p&gt;
 * {@link Mockito#doNothing()}
 * &lt;p&gt;
 * {@link Mockito#doCallRealMethod()}
 *
 *
 *
 *
 * &lt;h3 id=&quot;13&quot;&gt;13. &lt;a class=&quot;meaningful_link&quot; href=&quot;#spy&quot;&gt;Spying on real objects&lt;/a&gt;&lt;/h3&gt;
 *
 * You can create spies of real objects. When you use the spy then the &lt;b&gt;real&lt;/b&gt; methods are called
 * (unless a method was stubbed).
 * &lt;p&gt;
 * Real spies should be used &lt;b&gt;carefully and occasionally&lt;/b&gt;, for example when dealing with legacy code.
 *
 * &lt;p&gt;
 * Spying on real objects can be associated with &quot;partial mocking&quot; concept.
 * &lt;b&gt;Before the release 1.8&lt;/b&gt;, Mockito spies were not real partial mocks.
 * The reason was we thought partial mock is a code smell.
 * At some point we found legitimate use cases for partial mocks
 * (3rd party interfaces, interim refactoring of legacy code, the full article is &lt;a href=
 * &quot;http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring&quot;
 * &gt;here&lt;/a&gt;)
 * &lt;p&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   List list = new LinkedList();
 *   List spy = spy(list);
 *
 *   //optionally, you can stub out some methods:
 *   when(spy.size()).thenReturn(100);
 *
 *   //using the spy calls &lt;b&gt;*real*&lt;/b&gt; methods
 *   spy.add(&quot;one&quot;);
 *   spy.add(&quot;two&quot;);
 *
 *   //prints &quot;one&quot; - the first element of a list
 *   System.out.println(spy.get(0));
 *
 *   //size() method was stubbed - 100 is printed
 *   System.out.println(spy.size());
 *
 *   //optionally, you can verify
 *   verify(spy).add(&quot;one&quot;);
 *   verify(spy).add(&quot;two&quot;);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h4&gt;Important gotcha on spying real objects!&lt;/h4&gt;
 * &lt;ol&gt;
 * &lt;li&gt;Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.
 * Therefore when using spies please consider &lt;code&gt;doReturn&lt;/code&gt;|&lt;code&gt;Answer&lt;/code&gt;|&lt;code&gt;Throw()&lt;/code&gt; family of
 * methods for stubbing. Example:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   List list = new LinkedList();
 *   List spy = spy(list);
 *
 *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
 *   when(spy.get(0)).thenReturn(&quot;foo&quot;);
 *
 *   //You have to use doReturn() for stubbing
 *   doReturn(&quot;foo&quot;).when(spy).get(0);
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;/li&gt;
 *
 * &lt;li&gt;Mockito &lt;b&gt;*does not*&lt;/b&gt; delegate calls to the passed real instance, instead it actually creates a copy of it.
 * So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction
 * and their effect on real instance state.
 * The corollary is that when an &lt;b&gt;*unstubbed*&lt;/b&gt; method is called &lt;b&gt;*on the spy*&lt;/b&gt; but &lt;b&gt;*not on the real instance*&lt;/b&gt;,
 * you won't see any effects on the real instance.
 * &lt;/li&gt;
 *
 * &lt;li&gt;Watch out for final methods.
 * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
 * Also you won't be able to verify those method as well.
 * &lt;/li&gt;
 * &lt;/ol&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;14&quot;&gt;14. Changing &lt;a class=&quot;meaningful_link&quot; href=&quot;#defaultreturn&quot;&gt;default return values of unstubbed invocations&lt;/a&gt; (Since 1.7)&lt;/h3&gt;
 *
 * You can create a mock with specified strategy for its return values.
 * It's quite an advanced feature and typically you don't need it to write decent tests.
 * However, it can be helpful for working with &lt;b&gt;legacy systems&lt;/b&gt;.
 * &lt;p&gt;
 * It is the default answer so it will be used &lt;b&gt;only when you don't&lt;/b&gt; stub the method call.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
 *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Read more about this interesting implementation of &lt;i&gt;Answer&lt;/i&gt;: {@link Mockito#RETURNS_SMART_NULLS}
 *
 *
 *
 *
 * &lt;h3 id=&quot;15&quot;&gt;15. &lt;a class=&quot;meaningful_link&quot; href=&quot;#captors&quot;&gt;Capturing arguments&lt;/a&gt; for further assertions (Since 1.8.0)&lt;/h3&gt;
 *
 * Mockito verifies argument values in natural java style: by using an &lt;code&gt;equals()&lt;/code&gt; method.
 * This is also the recommended way of matching arguments because it makes tests clean &amp; simple.
 * In some situations though, it is helpful to assert on certain arguments after the actual verification.
 * For example:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   ArgumentCaptor&amp;lt;Person&amp;gt; argument = ArgumentCaptor.forClass(Person.class);
 *   verify(mock).doSomething(argument.capture());
 *   assertEquals(&quot;John&quot;, argument.getValue().getName());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;b&gt;Warning:&lt;/b&gt; it is recommended to use ArgumentCaptor with verification &lt;b&gt;but not&lt;/b&gt; with stubbing.
 * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.
 * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.
 * &lt;p&gt;
 * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).
 * Both techniques can be used for making sure certain arguments where passed to mocks.
 * However, ArgumentCaptor may be a better fit if:
 * &lt;ul&gt;
 * &lt;li&gt;custom argument matcher is not likely to be reused&lt;/li&gt;
 * &lt;li&gt;you just need it to assert on argument values to complete verification&lt;/li&gt;
 * &lt;/ul&gt;
 * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.
 *
 *
 *
 *
 * &lt;h3 id=&quot;16&quot;&gt;16. &lt;a class=&quot;meaningful_link&quot; href=&quot;#partial_mocks&quot;&gt;Real partial mocks&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
 *
 *  Finally, after many internal debates &amp; discussions on the mailing list, partial mock support was added to Mockito.
 *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:
 *  &lt;a href=&quot;http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring&quot;&gt;here&lt;/a&gt;
 *  &lt;p&gt;
 *  &lt;b&gt;Before release 1.8&lt;/b&gt; &lt;code&gt;spy()&lt;/code&gt; was not producing real partial mocks and it was confusing for some users.
 *  Read more about spying: &lt;a href=&quot;#13&quot;&gt;here&lt;/a&gt; or in javadoc for {@link Mockito#spy(Object)} method.
 *  &lt;p&gt;
 *  &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *    //you can create partial mock with spy() method:
 *    List list = spy(new LinkedList());
 *
 *    //you can enable partial mock capabilities selectively on mocks:
 *    Foo mock = mock(Foo.class);
 *    //Be sure the real implementation is 'safe'.
 *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.
 *    when(mock.someMethod()).thenCallRealMethod();
 *  &lt;/code&gt;&lt;/pre&gt;
 *
 * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
 * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 * How does partial mock fit into this paradigm? Well, it just doesn't...
 * Partial mock usually means that the complexity has been moved to a different method on the same object.
 * In most cases, this is not the way you want to design your application.
 * &lt;p&gt;
 * However, there are rare cases when partial mocks come handy:
 * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 * However, I wouldn't use partial mocks for new, test-driven &amp; well-designed code.
 *
 *
 *
 *
 * &lt;h3 id=&quot;17&quot;&gt;17. &lt;a class=&quot;meaningful_link&quot; href=&quot;#resetting_mocks&quot;&gt;Resetting mocks&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
 *
 * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
 * Normally, you don't need to reset your mocks, just create new mocks for each test method.
 * &lt;p&gt;
 * Instead of &lt;code&gt;reset()&lt;/code&gt; please consider writing simple, small and focused test methods over lengthy, over-specified tests.
 * &lt;b&gt;First potential code smell is &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method.&lt;/b&gt; This probably means you're testing too much.
 * Follow the whisper of your test methods: &quot;Please keep us small &amp; focused on single behavior&quot;.
 * There are several threads about it on mockito mailing list.
 * &lt;p&gt;
 * The only reason we added &lt;code&gt;reset()&lt;/code&gt; method is to
 * make it possible to work with container-injected mocks.
 * See issue 55 (&lt;a href=&quot;http://code.google.com/p/mockito/issues/detail?id=55&quot;&gt;here&lt;/a&gt;)
 * or FAQ (&lt;a href=&quot;http://code.google.com/p/mockito/wiki/FAQ&quot;&gt;here&lt;/a&gt;).
 * &lt;p&gt;
 * &lt;b&gt;Don't harm yourself.&lt;/b&gt; &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method is a code smell (you're probably testing too much).
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   List mock = mock(List.class);
 *   when(mock.size()).thenReturn(10);
 *   mock.add(1);
 *
 *   reset(mock);
 *   //at this point the mock forgot any interactions &amp; stubbing
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;18&quot;&gt;18. &lt;a class=&quot;meaningful_link&quot; href=&quot;#framework_validation&quot;&gt;Troubleshooting &amp; validating framework usage&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
 *
 * First of all, in case of any trouble, I encourage you to read the Mockito FAQ:
 * &lt;a href=&quot;http://code.google.com/p/mockito/wiki/FAQ&quot;&gt;http://code.google.com/p/mockito/wiki/FAQ&lt;/a&gt;
 * &lt;p&gt;
 * In case of questions you may also post to mockito mailing list:
 * &lt;a href=&quot;http://groups.google.com/group/mockito&quot;&gt;http://groups.google.com/group/mockito&lt;/a&gt;
 * &lt;p&gt;
 * Next, you should know that Mockito validates if you use it correctly &lt;b&gt;all the time&lt;/b&gt;.
 * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}
 *
 *
 *
 *
 * &lt;h3 id=&quot;19&quot;&gt;19. &lt;a class=&quot;meaningful_link&quot; href=&quot;#bdd_mockito&quot;&gt;Aliases for behavior driven development&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
 *
 * Behavior Driven Development style of writing tests uses &lt;b&gt;//given //when //then&lt;/b&gt; comments as fundamental parts of your test methods.
 * This is exactly how we write our tests and we warmly encourage you to do so!
 * &lt;p&gt;
 * Start learning about BDD here: &lt;a href=&quot;http://en.wikipedia.org/wiki/Behavior_Driven_Development&quot;&gt;http://en.wikipedia.org/wiki/Behavior_Driven_Development&lt;/a&gt;
 * &lt;p&gt;
 * The problem is that current stubbing api with canonical role of &lt;b&gt;when&lt;/b&gt; word does not integrate nicely with &lt;b&gt;//given //when //then&lt;/b&gt; comments.
 * It's because stubbing belongs to &lt;b&gt;given&lt;/b&gt; component of the test and not to the &lt;b&gt;when&lt;/b&gt; component of the test.
 * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method.
 * Now it really nicely integrates with the &lt;b&gt;given&lt;/b&gt; component of a BDD style test!
 * &lt;p&gt;
 * Here is how the test might look like:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * import static org.mockito.BDDMockito.*;
 *
 * Seller seller = mock(Seller.class);
 * Shop shop = new Shop(seller);
 *
 * public void shouldBuyBread() throws Exception {
 *   //given
 *   given(seller.askForBread()).willReturn(new Bread());
 *
 *   //when
 *   Goods goods = shop.buyBread();
 *
 *   //then
 *   assertThat(goods, containBread());
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;20&quot;&gt;20. &lt;a class=&quot;meaningful_link&quot; href=&quot;#serializable_mocks&quot;&gt;Serializable mocks&lt;/a&gt; (Since 1.8.1)&lt;/h3&gt;
 *
 * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.
 * &lt;p&gt;
 * WARNING: This should be rarely used in unit testing.
 * &lt;p&gt;
 * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This
 * was in a web environment and the objects from the external dependency were being serialized to pass between layers.
 * &lt;p&gt;
 * To create serializable mock use {@link MockSettings#serializable()}:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   List serializableMock = mock(List.class, withSettings().serializable());
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * The mock can be serialized assuming all the normal &lt;a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'&gt;
 * serialization requirements&lt;/a&gt; are met by the class.
 * &lt;p&gt;
 * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version
 * which accepts MockSettings. No worries, you will hardly ever use it.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;Object&amp;gt;();
 * List&amp;lt;Object&amp;gt; spy = mock(ArrayList.class, withSettings()
 *                 .spiedInstance(list)
 *                 .defaultAnswer(CALLS_REAL_METHODS)
 *                 .serializable());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;21&quot;&gt;21. New annotations: &lt;a class=&quot;meaningful_link&quot; href=&quot;#captor_annotation&quot;&gt;&lt;code&gt;&amp;#064;Captor&lt;/code&gt;&lt;/a&gt;,
 * &lt;a class=&quot;meaningful_link&quot; href=&quot;#spy_annotation&quot;&gt;&lt;code&gt;&amp;#064;Spy&lt;/code&gt;&lt;/a&gt;,
 * &lt;a class=&quot;meaningful_link&quot; href=&quot;#injectmocks_annotation&quot;&gt;&lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt;&lt;/a&gt; (Since 1.8.3)&lt;/h3&gt;
 *
 * &lt;p&gt;
 * Release 1.8.3 brings new annotations that may be helpful on occasion:
 *
 * &lt;ul&gt;
 * &lt;li&gt;&amp;#064;{@link Captor} simplifies creation of {@link ArgumentCaptor}
 * - useful when the argument to capture is a nasty generic class and you want to avoid compiler warnings
 * &lt;li&gt;&amp;#064;{@link Spy} - you can use it instead {@link Mockito#spy(Object)}.
 * &lt;li&gt;&amp;#064;{@link InjectMocks} - injects mock or spy fields into tested object automatically.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * Note that &amp;#064;{@link InjectMocks} can also be used in combination with the &amp;#064;{@link Spy} annotation, it means
 * that Mockito will inject mocks into the partial mock under test. This complexity is another good reason why you
 * should only use partial mocks as a last resort. See point 16 about partial mocks.
 *
 * &lt;p&gt;
 * All new annotations are &lt;b&gt;*only*&lt;/b&gt; processed on {@link MockitoAnnotations#initMocks(Object)}.
 * Just like for &amp;#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner} or rule:
 * {@link MockitoRule}.
 * &lt;p&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;22&quot;&gt;22. &lt;a class=&quot;meaningful_link&quot; href=&quot;#verification_timeout&quot;&gt;Verification with timeout&lt;/a&gt; (Since 1.8.5)&lt;/h3&gt;
 * &lt;p&gt;
 * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired
 * interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent
 * conditions.
 * &lt;p&gt;
 * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system.
 * &lt;p&gt;
 * Not yet implemented to work with InOrder verification.
 * &lt;p&gt;
 * Examples:
 * &lt;p&gt;
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   //passes when someMethod() is called within given time span
 *   verify(mock, timeout(100)).someMethod();
 *   //above is an alias to:
 *   verify(mock, timeout(100).times(1)).someMethod();
 *
 *   //passes when someMethod() is called &lt;b&gt;*exactly*&lt;/b&gt; 2 times within given time span
 *   verify(mock, timeout(100).times(2)).someMethod();
 *
 *   //passes when someMethod() is called &lt;b&gt;*at least*&lt;/b&gt; 2 times within given time span
 *   verify(mock, timeout(100).atLeast(2)).someMethod();
 *
 *   //verifies someMethod() within given time span using given verification mode
 *   //useful only if you have your own custom verification modes.
 *   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;23&quot;&gt;23. &lt;a class=&quot;meaningful_link&quot; href=&quot;#automatic_instantiation&quot;&gt;Automatic instantiation of &lt;code&gt;&amp;#064;Spies&lt;/code&gt;,
 * &lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt;&lt;/a&gt; and &lt;a class=&quot;meaningful_link&quot; href=&quot;#constructor_injection&quot;&gt;constructor injection goodness&lt;/a&gt; (Since 1.9.0)&lt;/h3&gt;
 *
 * &lt;p&gt;
 * Mockito will now try to instantiate &amp;#064;{@link Spy} and will instantiate &amp;#064;{@link InjectMocks} fields
 * using &lt;b&gt;constructor&lt;/b&gt; injection, &lt;b&gt;setter&lt;/b&gt; injection, or &lt;b&gt;field&lt;/b&gt; injection.
 * &lt;p&gt;
 * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)}, {@link MockitoJUnitRunner}
 * or {@link MockitoRule}.
 * &lt;p&gt;
 * Read more about available tricks and the rules of injection in the javadoc for {@link InjectMocks}
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //instead:
 * &amp;#064;Spy BeerDrinker drinker = new BeerDrinker();
 * //you can write:
 * &amp;#064;Spy BeerDrinker drinker;
 *
 * //same applies to &amp;#064;InjectMocks annotation:
 * &amp;#064;InjectMocks LocalPub;
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;24&quot;&gt;24. &lt;a class=&quot;meaningful_link&quot; href=&quot;#one_liner_stub&quot;&gt;One-liner stubs&lt;/a&gt; (Since 1.9.0)&lt;/h3&gt;
 * &lt;p&gt;
 * Mockito will now allow you to create mocks when stubbing.
 * Basically, it allows to create a stub in one line of code.
 * This can be helpful to keep test code clean.
 * For example, some boring stub can be created &amp; stubbed at field initialization in a test:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * public class CarTest {
 *   Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();
 *
 *   &amp;#064;Test public void should... {}
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;25&quot;&gt;25. &lt;a class=&quot;meaningful_link&quot; href=&quot;#ignore_stubs_verification&quot;&gt;Verification ignoring stubs&lt;/a&gt; (Since 1.9.0)&lt;/h3&gt;
 * &lt;p&gt;
 * Mockito will now allow to ignore stubbing for the sake of verification.
 * Sometimes useful when coupled with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; or verification &lt;code&gt;inOrder()&lt;/code&gt;.
 * Helps avoiding redundant verification of stubbed calls - typically we're not interested in verifying stubs.
 * &lt;p&gt;
 * &lt;b&gt;Warning&lt;/b&gt;, &lt;code&gt;ignoreStubs()&lt;/code&gt; might lead to overuse of verifyNoMoreInteractions(ignoreStubs(...));
 * Bear in mind that Mockito does not recommend bombarding every test with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt;
 * for the reasons outlined in javadoc for {@link Mockito#verifyNoMoreInteractions(Object...)}
 * &lt;p&gt;Some examples:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * verify(mock).foo();
 * verify(mockTwo).bar();
 *
 * //ignores all stubbed methods:
 * verifyNoMoreInvocations(ignoreStubs(mock, mockTwo));
 *
 * //creates InOrder that will ignore stubbed
 * InOrder inOrder = inOrder(ignoreStubs(mock, mockTwo));
 * inOrder.verify(mock).foo();
 * inOrder.verify(mockTwo).bar();
 * inOrder.verifyNoMoreInteractions();
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * Advanced examples and more details can be found in javadoc for {@link Mockito#ignoreStubs(Object...)}
 *
 *
 *
 *
 * &lt;h3 id=&quot;26&quot;&gt;26. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mocking_details&quot;&gt;Mocking details&lt;/a&gt; (Since 1.9.5)&lt;/h3&gt;
 * &lt;p&gt;
 * To identify whether a particular object is a mock or a spy:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *     Mockito.mockingDetails(someObject).isMock();
 *     Mockito.mockingDetails(someObject).isSpy();
 * &lt;/code&gt;&lt;/pre&gt;
 * Both the {@link MockingDetails#isMock} and {@link MockingDetails#isSpy()} methods return &lt;code&gt;boolean&lt;/code&gt;.
 * As a spy is just a different kind of mock, &lt;code&gt;isMock()&lt;/code&gt; returns true if the object is a spy.
 * In future Mockito versions MockingDetails may grow and provide other useful information about the mock,
 * e.g. invocations, stubbing info, etc.
 *
 *
 *
 *
 * &lt;h3 id=&quot;27&quot;&gt;27. &lt;a class=&quot;meaningful_link&quot; href=&quot;#delegating_call_to_real_instance&quot;&gt;Delegate calls to real instance&lt;/a&gt; (Since 1.9.5)&lt;/h3&gt;
 *
 * &lt;p&gt;Useful for spies or partial mocks of objects &lt;strong&gt;that are difficult to mock or spy&lt;/strong&gt; using the usual spy API.
 * Since Mockito 1.10.11, the delegate may or may not be of the same type as the mock.
 * If the type is different, a matching method needs to be found on delegate type otherwise an exception is thrown.
 *
 * Possible use cases for this feature:
 * &lt;ul&gt;
 *     &lt;li&gt;Final classes but with an interface&lt;/li&gt;
 *     &lt;li&gt;Already custom proxied object&lt;/li&gt;
 *     &lt;li&gt;Special objects with a finalize method, i.e. to avoid executing it 2 times&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The difference with the regular spy:
 * &lt;ul&gt;
 *   &lt;li&gt;
 *     The regular spy ({@link #spy(Object)}) contains &lt;strong&gt;all&lt;/strong&gt; state from the spied instance
 *     and the methods are invoked on the spy. The spied instance is only used at mock creation to copy the state from.
 *     If you call a method on a regular spy and it internally calls other methods on this spy, those calls are remembered
 *     for verifications, and they can be effectively stubbed.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     The mock that delegates simply delegates all methods to the delegate.
 *     The delegate is used all the time as methods are delegated onto it.
 *     If you call a method on a mock that delegates and it internally calls other methods on this mock,
 *     those calls are &lt;strong&gt;not&lt;/strong&gt; remembered for verifications, stubbing does not have effect on them, too.
 *     Mock that delegates is less powerful than the regular spy but it is useful when the regular spy cannot be created.
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * See more information in docs for {@link AdditionalAnswers#delegatesTo(Object)}.
 *
 *
 *
 *
 * &lt;h3 id=&quot;28&quot;&gt;28. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mock_maker_plugin&quot;&gt;&lt;code&gt;MockMaker&lt;/code&gt; API&lt;/a&gt; (Since 1.9.5)&lt;/h3&gt;
 * &lt;p&gt;Driven by requirements and patches from Google Android guys Mockito now offers an extension point
 *   that allows replacing the proxy generation engine. By default, Mockito uses cglib to create dynamic proxies.
 * &lt;p&gt;The extension point is for advanced users that want to extend Mockito. For example, it is now possible
 *   to use Mockito for Android testing with a help of dexmaker.
 * &lt;p&gt;For more details, motivations and examples please refer to
 * the docs for {@link org.mockito.plugins.MockMaker}.
 *
 *
 *
 *
 * &lt;h3 id=&quot;29&quot;&gt;29. &lt;a class=&quot;meaningful_link&quot; href=&quot;#BDD_behavior_verification&quot;&gt;(new) BDD style verification&lt;/a&gt; (Since 1.10.0)&lt;/h3&gt;
 *
 * Enables Behavior Driven Development (BDD) style verification by starting verification with the BDD &lt;b&gt;then&lt;/b&gt; keyword.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * given(dog.bark()).willReturn(2);
 *
 * // when
 * ...
 *
 * then(person).should(times(2)).ride(bike);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For more information and an example see {@link BDDMockito#then(Object)}}
 *
 *
 *
 *
 * &lt;h3 id=&quot;30&quot;&gt;30. &lt;a class=&quot;meaningful_link&quot; href=&quot;#spying_abstract_classes&quot;&gt;(new) Spying or mocking abstract classes (Since 1.10.12)&lt;/a&gt;&lt;/h3&gt;
 *
 * It is now possible to conveniently spy on abstract classes. Note that overusing spies hints at code design smells (see {@link #spy(Object)}).
 * &lt;p&gt;
 * Previously, spying was only possible on instances of objects.
 * New API makes it possible to use constructor when creating an instance of the mock.
 * This is particularly useful for mocking abstract classes because the user is no longer required to provide an instance of the abstract class.
 * At the moment, only parameter-less constructor is supported, let us know if it is not enough.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //convenience API, new overloaded spy() method:
 * SomeAbstract spy = spy(SomeAbstract.class);
 *
 * //Robust API, via settings builder:
 * OtherAbstract spy = mock(OtherAbstract.class, withSettings()
 *    .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
 *
 * //Mocking a non-static inner abstract class:
 * InnerAbstract spy = mock(InnerAbstract.class, withSettings()
 *    .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For more information please see {@link MockSettings#useConstructor()}.
 *
 *
 *
 *
 * &lt;h3 id=&quot;31&quot;&gt;31. &lt;a class=&quot;meaningful_link&quot; href=&quot;#serilization_across_classloader&quot;&gt;(new) Mockito mocks can be &lt;em&gt;serialized&lt;/em&gt; / &lt;em&gt;deserialized&lt;/em&gt; across classloaders (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;
 *
 * Mockito introduces serialization across classloader.
 *
 * Like with any other form of serialization, all types in the mock hierarchy have to serializable, inclusing answers.
 * As this serialization mode require considerably more work, this is an opt-in setting.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * // use regular serialization
 * mock(Book.class, withSettings().serializable());
 *
 * // use serialization across classloaders
 * mock(Book.class, withSettings().serializable(ACROSS_CLASSLOADERS));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For more details see {@link MockSettings#serializable(SerializableMode)}.
 *
 *
 *
 *
 * &lt;h3 id=&quot;32&quot;&gt;32. &lt;a class=&quot;meaningful_link&quot; href=&quot;#better_generic_support_with_deep_stubs&quot;&gt;(new) Better generic support with deep stubs (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;
 *
 * Deep stubbing has been improved to find generic information if available in the class.
 * That means that classes like this can be used without having to mock the behavior.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * class Lines extends List&amp;lt;Line&amp;gt; {
 *     // ...
 * }
 *
 * lines = mock(Lines.class, RETURNS_DEEP_STUBS);
 *
 * // Now Mockito understand this is not an Object but a Line
 * Line line = lines.iterator().next();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Please note that in most scenarios a mock returning a mock is wrong.
 *
 *
 *
 *
 * &lt;h3 id=&quot;33&quot;&gt;33. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito_junit_rule&quot;&gt;(new) Mockito JUnit rule (Since 1.10.17)&lt;/a&gt;&lt;/h3&gt;
 *
 * Mockito now offers a JUnit rule. Until now in JUnit there was two wasy to initialize fields annotated by Mockito annotations
 * such as &lt;code&gt;&amp;#064;{@link Mock}&lt;/code&gt;, &lt;code&gt;&amp;#064;{@link Spy}&lt;/code&gt;, &lt;code&gt;&amp;#064;{@link InjectMocks}&lt;/code&gt;, etc.
 *
 * &lt;ul&gt;
 *     &lt;li&gt;Annotating the JUnit test class with a &lt;code&gt;&amp;#064;{@link org.junit.runner.RunWith}({@link MockitoJUnitRunner}.class)&lt;/code&gt;&lt;/li&gt;
 *     &lt;li&gt;Invoking &lt;code&gt;{@link MockitoAnnotations#initMocks(Object)}&lt;/code&gt; in the &lt;code&gt;&amp;#064;{@link org.junit.Before}&lt;/code&gt; method&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Now you can choose to use a rule :
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * &amp;#064;RunWith(YetAnotherRunner.class)
 * public class TheTest {
 *     &amp;#064;Rule public MockitoRule mockito = MockitoJUnit.rule();
 *     // ...
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For more information see {@link MockitoJUnit#rule()}.
 *
 *
 *
 *
 * &lt;h3 id=&quot;34&quot;&gt;34. &lt;a class=&quot;meaningful_link&quot; href=&quot;#plugin_switch&quot;&gt;(new) Switch &lt;em&gt;on&lt;/em&gt; or &lt;em&gt;off&lt;/em&gt; plugins (Since 1.10.15)&lt;/a&gt;&lt;/h3&gt;
 *
 * An incubating feature made it's way in mockito that will allow to toggle a mockito-plugin.
 *
 * More information here {@link org.mockito.plugins.PluginSwitch}.
 *
 *
 * &lt;h3 id=&quot;35&quot;&gt;35. &lt;a class=&quot;meaningful_link&quot; href=&quot;#BDD_behavior_verification&quot;&gt;Custom verification failure message&lt;/a&gt; (Since 2.0.0)&lt;/h3&gt;
 * &lt;p&gt;
 * Allows specifying a custom message to be printed if verification fails.
 * &lt;p&gt;
 * Examples:
 * &lt;p&gt;
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *
 * // will print a custom message on verification failure
 * verify(mock, description(&quot;This will print on failure&quot;)).someMethod();
 *
 * // will work with any verification mode
 * verify(mock, times(2).description(&quot;someMethod should be called twice&quot;)).someMethod();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * TODO rework the documentation, write about hamcrest.
 *
 */
@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1101">public class Mockito extends Matchers {</span>

<span class="fc" id="L1103">    static final MockitoCore MOCKITO_CORE = new MockitoCore();</span>

    /**
     * The default &lt;code&gt;Answer&lt;/code&gt; of every mock &lt;b&gt;if&lt;/b&gt; the mock was not stubbed.
     * Typically it just returns some empty value.
     * &lt;p&gt;
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * &lt;p&gt;
     * This implementation first tries the global configuration.
     * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)
     */
<span class="fc" id="L1114">    public static final Answer&lt;Object&gt; RETURNS_DEFAULTS = Answers.RETURNS_DEFAULTS;</span>

    /**
     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}.
     * &lt;p&gt;
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * &lt;p&gt;
     * This implementation can be helpful when working with legacy code.
     * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.
     * This implementation of Answer &lt;b&gt;returns SmartNull instead of null&lt;/b&gt;.
     * &lt;code&gt;SmartNull&lt;/code&gt; gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.
     * &lt;p&gt;
     * &lt;code&gt;ReturnsSmartNulls&lt;/code&gt; first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})
     * then it tries to return SmartNull. If the return type is final then plain null is returned.
     * &lt;p&gt;
     * &lt;code&gt;ReturnsSmartNulls&lt;/code&gt; will be probably the default return values strategy in Mockito 2.0.
     * &lt;p&gt;
     * Example:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
     *
     *   //calling unstubbed method here:
     *   Stuff stuff = mock.getStuff();
     *
     *   //using object returned by unstubbed call:
     *   stuff.doSomething();
     *
     *   //Above doesn't yield NullPointerException this time!
     *   //Instead, SmartNullPointerException is thrown.
     *   //Exception's cause links to unstubbed &lt;i&gt;mock.getStuff()&lt;/i&gt; - just click on the stack trace.
     * &lt;/code&gt;&lt;/pre&gt;
     */
<span class="fc" id="L1146">    public static final Answer&lt;Object&gt; RETURNS_SMART_NULLS = Answers.RETURNS_SMART_NULLS;</span>

    /**
     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}
     * &lt;p&gt;
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * &lt;p&gt;
     * This implementation can be helpful when working with legacy code.
     * &lt;p&gt;
     * ReturnsMocks first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})
     * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.
     * &lt;p&gt;
     */
<span class="fc" id="L1159">    public static final Answer&lt;Object&gt; RETURNS_MOCKS = Answers.RETURNS_MOCKS;</span>

    /**
     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}.
     * &lt;p&gt;
     * Example that shows how deep stub works:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);
     *
     *   // note that we're stubbing a chain of methods here: getBar().getName()
     *   when(mock.getBar().getName()).thenReturn(&quot;deep&quot;);
     *
     *   // note that we're chaining method calls: getBar().getName()
     *   assertEquals(&quot;deep&quot;, mock.getBar().getName());
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * &lt;strong&gt;WARNING: &lt;/strong&gt;
     * This feature should rarely be required for regular clean code! Leave it for legacy code.
     * Mocking a mock to return a mock, to return a mock, (...), to return something meaningful
     * hints at violation of Law of Demeter or mocking a value object (a well known anti-pattern).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Good quote I've seen one day on the web: &lt;strong&gt;every time a mock returns a mock a fairy dies&lt;/strong&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Please note that this answer will return existing mocks that matches the stub. This
     * behavior is ok with deep stubs and allows verification to work on the last mock of the chain.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   when(mock.getBar(anyString()).getThingy().getName()).thenReturn(&quot;deep&quot;);
     *
     *   mock.getBar(&quot;candy bar&quot;).getThingy().getName();
     *
     *   assertSame(mock.getBar(anyString()).getThingy().getName(), mock.getBar(anyString()).getThingy().getName());
     *   verify(mock.getBar(&quot;candy bar&quot;).getThingy()).getName();
     *   verify(mock.getBar(anyString()).getThingy()).getName();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Verification only works with the last mock in the chain. You can use verification modes.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   when(person.getAddress(anyString()).getStreet().getName()).thenReturn(&quot;deep&quot;);
     *   when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn(&quot;deep&quot;);
     *   when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn(&quot;deep&quot;);
     *
     *   person.getAddress(&quot;the docks&quot;).getStreet().getName();
     *   person.getAddress(&quot;the docks&quot;).getStreet().getLongName();
     *   person.getAddress(&quot;the docks&quot;).getStreet(Locale.ITALIAN).getName();
     *   person.getAddress(&quot;the docks&quot;).getStreet(Locale.CHINESE).getName();
     *
     *   // note that we are actually referring to the very last mock in the stubbing chain.
     *   InOrder inOrder = inOrder(
     *       person.getAddress(&quot;the docks&quot;).getStreet(),
     *       person.getAddress(&quot;the docks&quot;).getStreet(Locale.CHINESE),
     *       person.getAddress(&quot;the docks&quot;).getStreet(Locale.ITALIAN)
     *   );
     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet(), times(1)).getName();
     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet()).getLongName();
     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet(Locale.ITALIAN), atLeast(1)).getName();
     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet(Locale.CHINESE)).getName();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * How deep stub work internally?
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //this:
     *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);
     *   when(mock.getBar().getName(), &quot;deep&quot;);
     *
     *   //is equivalent of
     *   Foo foo = mock(Foo.class);
     *   Bar bar = mock(Bar.class);
     *   when(foo.getBar()).thenReturn(bar);
     *   when(bar.getName()).thenReturn(&quot;deep&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * This feature will not work when any return type of methods included in the chain cannot be mocked
     * (for example: is a primitive or a final class). This is because of java type system.
     * &lt;/p&gt;
     */
<span class="fc" id="L1246">    public static final Answer&lt;Object&gt; RETURNS_DEEP_STUBS = Answers.RETURNS_DEEP_STUBS;</span>

    /**
     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}
     * &lt;p&gt;
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * &lt;p&gt;
     * This implementation can be helpful when working with legacy code.
     * When this implementation is used, unstubbed methods will delegate to the real implementation.
     * This is a way to create a partial mock object that calls real methods by default.
     * &lt;p&gt;
     * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
     * How does partial mock fit into this paradigm? Well, it just doesn't...
     * Partial mock usually means that the complexity has been moved to a different method on the same object.
     * In most cases, this is not the way you want to design your application.
     * &lt;p&gt;
     * However, there are rare cases when partial mocks come handy:
     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
     * However, I wouldn't use partial mocks for new, test-driven &amp; well-designed code.
     * &lt;p&gt;
     * Example:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);
     *
     * // this calls the real implementation of Foo.getSomething()
     * value = mock.getSomething();
     *
     * when(mock.getSomething()).thenReturn(fakeValue);
     *
     * // now fakeValue is returned
     * value = mock.getSomething();
     * &lt;/code&gt;&lt;/pre&gt;
     */
<span class="fc" id="L1280">    public static final Answer&lt;Object&gt; CALLS_REAL_METHODS = Answers.CALLS_REAL_METHODS;</span>

    /**
     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}.
     *
     * Allows Builder mocks to return itself whenever a method is invoked that returns a Type equal
     * to the class or a superclass.
     *
     * &lt;p&gt;&lt;b&gt;Keep in mind this answer uses the return type of a method.
     * If this type is assignable to the class of the mock, it will return the mock.
     * Therefore if you have a method returning a superclass (for example {@code Object}) it will match and return the mock.&lt;/b&gt;&lt;/p&gt;
     *
     * Consider a HttpBuilder used in a HttpRequesterWithHeaders.
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * public class HttpRequesterWithHeaders {
     *
     *      private HttpBuilder builder;
     *
     *      public HttpRequesterWithHeaders(HttpBuilder builder) {
     *          this.builder = builder;
     *      }
     *
     *      public String request(String uri) {
     *          return builder.withUrl(uri)
     *                  .withHeader(&quot;Content-type: application/json&quot;)
     *                  .withHeader(&quot;Authorization: Bearer&quot;)
     *                  .request();
     *      }
     *  }
     *
     *  private static class HttpBuilder {
     *
     *      private String uri;
     *      private List&amp;lt;String&amp;gt; headers;
     *
     *      public HttpBuilder() {
     *          this.headers = new ArrayList&amp;lt;String&amp;gt;();
     *      }
     *
     *       public HttpBuilder withUrl(String uri) {
     *           this.uri = uri;
     *           return this;
     *       }
     *
     *       public HttpBuilder withHeader(String header) {
     *           this.headers.add(header);
     *           return this;
     *       }
     *
     *       public String request() {
     *          return uri + headers.toString();
     *       }
     *  }
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * The following test will succeed
     *
     * &lt;pre&gt;&lt;code&gt;
     * &amp;#064;Test
     *  public void use_full_builder_with_terminating_method() {
     *      HttpBuilder builder = mock(HttpBuilder.class, RETURNS_SELF);
     *      HttpRequesterWithHeaders requester = new HttpRequesterWithHeaders(builder);
     *      String response = &quot;StatusCode: 200&quot;;
     *
     *      when(builder.request()).thenReturn(response);
     *
     *      assertThat(requester.request(&quot;URI&quot;)).isEqualTo(response);
     *  }
     * &lt;/code&gt;&lt;/pre&gt;
     */
<span class="fc" id="L1351">    public static final Answer&lt;Object&gt; RETURNS_SELF = Answers.RETURNS_SELF;</span>

    /**
     * Creates mock object of given class or interface.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface to mock
     * @return mock object
     */
    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock) {
<span class="fc" id="L1362">        return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));</span>
    }

    /**
     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.
     * &lt;p&gt;
     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.
     * &lt;b&gt;If you have too many mocks then refactor the code&lt;/b&gt; so that it's easy to test/debug without necessity of naming mocks.
     * &lt;p&gt;
     * &lt;b&gt;If you use &lt;code&gt;&amp;#064;Mock&lt;/code&gt; annotation then you've got naming mocks for free!&lt;/b&gt; &lt;code&gt;&amp;#064;Mock&lt;/code&gt; uses field name as mock name. {@link Mock Read more.}
     * &lt;p&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface to mock
     * @param name of the mock
     * @return mock object
     */
    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock, String name) {
<span class="fc" id="L1381">        return mock(classToMock, withSettings()</span>
                .name(name)
                .defaultAnswer(RETURNS_DEFAULTS));
    }

    /**
     * Returns a MockingDetails instance that enables inspecting a particular object for Mockito related information.
     * Can be used to find out if given object is a Mockito mock
     * or to find out if a given mock is a spy or mock.
     * &lt;p&gt;
     * In future Mockito versions MockingDetails may grow and provide other useful information about the mock,
     * e.g. invocations, stubbing info, etc.
     *
     * @param toInspect - object to inspect. null input is allowed.
     * @return A {@link org.mockito.MockingDetails} instance.
     * @since 1.9.5
     */
    public static MockingDetails mockingDetails(Object toInspect) {
<span class="fc" id="L1399">        return MOCKITO_CORE.mockingDetails(toInspect);</span>
    }

    /**
     * Creates mock with a specified strategy for its answers to interactions.
     * It's quite an advanced feature and typically you don't need it to write decent tests.
     * However it can be helpful when working with legacy systems.
     * &lt;p&gt;
     * It is the default answer so it will be used &lt;b&gt;only when you don't&lt;/b&gt; stub the method call.
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt;See examples in javadoc for {@link Mockito} class&lt;/p&gt;
     *
     * @param classToMock class or interface to mock
     * @param defaultAnswer default answer for unstubbed methods
     *
     * @return mock object
     */
    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock, Answer defaultAnswer) {
<span class="fc" id="L1422">        return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));</span>
    }

    /**
     * Creates a mock with some non-standard settings.
     * &lt;p&gt;
     * The number of configuration points for a mock grows
     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.
     * Hence {@link MockSettings}.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   Listener mock = mock(Listener.class, withSettings()
     *     .name(&quot;firstListner&quot;).defaultBehavior(RETURNS_SMART_NULLS));
     *   );
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;b&gt;Use it carefully and occasionally&lt;/b&gt;. What might be reason your test needs non-standard mocks?
     * Is the code under test so complicated that it requires non-standard mocks?
     * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?
     * &lt;p&gt;
     * See also {@link Mockito#withSettings()}
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface to mock
     * @param mockSettings additional mock settings
     * @return mock object
     */
    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock, MockSettings mockSettings) {
<span class="fc" id="L1449">        return MOCKITO_CORE.mock(classToMock, mockSettings);</span>
    }

    /**
     * Creates a spy of the real object. The spy calls &lt;b&gt;real&lt;/b&gt; methods unless they are stubbed.
     * &lt;p&gt;
     * Real spies should be used &lt;b&gt;carefully and occasionally&lt;/b&gt;, for example when dealing with legacy code.
     * &lt;p&gt;
     * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
     * Object oriented programming tackles complexity by dividing the complexity into separate, specific, SRPy objects.
     * How does partial mock fit into this paradigm? Well, it just doesn't...
     * Partial mock usually means that the complexity has been moved to a different method on the same object.
     * In most cases, this is not the way you want to design your application.
     * &lt;p&gt;
     * However, there are rare cases when partial mocks come handy:
     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
     * However, I wouldn't use partial mocks for new, test-driven &amp; well-designed code.
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //optionally, you can stub out some methods:
     *   when(spy.size()).thenReturn(100);
     *
     *   //using the spy calls &lt;b&gt;real&lt;/b&gt; methods
     *   spy.add(&quot;one&quot;);
     *   spy.add(&quot;two&quot;);
     *
     *   //prints &quot;one&quot; - the first element of a list
     *   System.out.println(spy.get(0));
     *
     *   //size() method was stubbed - 100 is printed
     *   System.out.println(spy.size());
     *
     *   //optionally, you can verify
     *   verify(spy).add(&quot;one&quot;);
     *   verify(spy).add(&quot;two&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;h4&gt;Important gotcha on spying real objects!&lt;/h4&gt;
     * &lt;ol&gt;
     * &lt;li&gt;Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.
     * Therefore for spies it is recommended to always use &lt;code&gt;doReturn&lt;/code&gt;|&lt;code&gt;Answer&lt;/code&gt;|&lt;code&gt;Throw()&lt;/code&gt;|&lt;code&gt;CallRealMethod&lt;/code&gt;
     * family of methods for stubbing. Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
     *   when(spy.get(0)).thenReturn(&quot;foo&quot;);
     *
     *   //You have to use doReturn() for stubbing
     *   doReturn(&quot;foo&quot;).when(spy).get(0);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     *
     * &lt;li&gt;Mockito &lt;b&gt;*does not*&lt;/b&gt; delegate calls to the passed real instance, instead it actually creates a copy of it.
     * So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction
     * and their effect on real instance state.
     * The corollary is that when an &lt;b&gt;*unstubbed*&lt;/b&gt; method is called &lt;b&gt;*on the spy*&lt;/b&gt; but &lt;b&gt;*not on the real instance*&lt;/b&gt;,
     * you won't see any effects on the real instance.&lt;/li&gt;
     *
     * &lt;li&gt;Watch out for final methods.
     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
     * Also you won't be able to verify those method as well.
     * &lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * &lt;p&gt;Note that the spy won't have any annotations of the spied type, because CGLIB won't rewrite them.
     * It may troublesome for code that rely on the spy to have these annotations.&lt;/p&gt;
     *
     *
     * @param object
     *            to spy on
     * @return a spy of the real object
     */
    public static &lt;T&gt; T spy(T object) {
<span class="fc" id="L1532">        return MOCKITO_CORE.mock((Class&lt;T&gt;) object.getClass(), withSettings()</span>
                .spiedInstance(object)
                .defaultAnswer(CALLS_REAL_METHODS));
    }

    /**
     * Please refer to the documentation of {@link #spy(Object)}.
     * Overusing spies hints at code design smells.
     * &lt;p&gt;
     * This method, in contrast to the original {@link #spy(Object)}, creates a spy based on class instead of an object.
     * Sometimes it is more convenient to create spy based on the class and avoid providing an instance of a spied object.
     * This is particularly useful for spying on abstract classes because they cannot be instantiated.
     * See also {@link MockSettings#useConstructor()}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   SomeAbstract spy = spy(SomeAbstract.class);
     *
     *   //Robust API, via settings builder:
     *   OtherAbstract spy = mock(OtherAbstract.class, withSettings()
     *      .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
     *
     *   //Mocking a non-static inner abstract class:
     *   InnerAbstract spy = mock(InnerAbstract.class, withSettings()
     *      .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param classToSpy the class to spy
     * @param &lt;T&gt; type of the spy
     * @return a spy of the provided class
     * @since 1.10.12
     */
    @Incubating
    public static &lt;T&gt; T spy(Class&lt;T&gt; classToSpy) {
<span class="fc" id="L1566">        return MOCKITO_CORE.mock(classToSpy, withSettings()</span>
                .useConstructor()
                .defaultAnswer(CALLS_REAL_METHODS));
    }

    /**
     * Stubs a method call with return value or an exception. E.g:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * stub(mock.someMethod()).toReturn(10);
     *
     * //you can use flexible argument matchers, e.g:
     * stub(mock.someMethod(&lt;b&gt;anyString()&lt;/b&gt;)).toReturn(10);
     *
     * //setting exception to be thrown:
     * stub(mock.someMethod(&quot;some arg&quot;)).toThrow(new RuntimeException());
     *
     * //you can stub with different behavior for consecutive method calls.
     * //Last stubbing (e.g: toReturn(&quot;foo&quot;)) determines the behavior for further consecutive calls.
     * stub(mock.someMethod(&quot;some arg&quot;))
     *  .toThrow(new RuntimeException())
     *  .toReturn(&quot;foo&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * Some users find stub() confusing therefore {@link Mockito#when(Object)} is recommended over stub()
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //Instead of:
     *   stub(mock.count()).toReturn(10);
     *
     *   //You can do:
     *   when(mock.count()).thenReturn(10);
     * &lt;/code&gt;&lt;/pre&gt;
     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable...)}
     * &lt;p&gt;
     * Stubbing can be overridden: for example common stubbing can go to fixture
     * setup but the test methods can override it.
     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.
     * &lt;p&gt;
     * Once stubbed, the method will always return stubbed value regardless
     * of how many times it is called.
     * &lt;p&gt;
     * Last stubbing is more important - when you stubbed the same method with
     * the same arguments many times.
     * &lt;p&gt;
     * Although it is possible to verify a stubbed invocation, usually &lt;b&gt;it's just redundant&lt;/b&gt;.
     * Let's say you've stubbed foo.bar().
     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).
     * If your code doesn't care what get(0) returns then it should not be stubbed.
     * Not convinced? See &lt;a href=&quot;http://monkeyisland.pl/2008/04/26/asking-and-telling&quot;&gt;here&lt;/a&gt;.
     *
     * @param methodCall
     *            method call
     * @return DeprecatedOngoingStubbing object to set stubbed value/exception
     */
    public static &lt;T&gt; DeprecatedOngoingStubbing&lt;T&gt; stub(T methodCall) {
<span class="fc" id="L1621">        return MOCKITO_CORE.stub(methodCall);</span>
    }

    /**
     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called.
     * &lt;p&gt;
     * Simply put: &quot;&lt;b&gt;When&lt;/b&gt; the x method is called &lt;b&gt;then&lt;/b&gt; return y&quot;.
     * &lt;p&gt;
     * &lt;b&gt;when() is a successor of deprecated {@link Mockito#stub(Object)}&lt;/b&gt;
     * &lt;p&gt;
     * Examples:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * &lt;b&gt;when&lt;/b&gt;(mock.someMethod()).&lt;b&gt;thenReturn&lt;/b&gt;(10);
     *
     * //you can use flexible argument matchers, e.g:
     * when(mock.someMethod(&lt;b&gt;anyString()&lt;/b&gt;)).thenReturn(10);
     *
     * //setting exception to be thrown:
     * when(mock.someMethod(&quot;some arg&quot;)).thenThrow(new RuntimeException());
     *
     * //you can set different behavior for consecutive method calls.
     * //Last stubbing (e.g: thenReturn(&quot;foo&quot;)) determines the behavior of further consecutive calls.
     * when(mock.someMethod(&quot;some arg&quot;))
     *  .thenThrow(new RuntimeException())
     *  .thenReturn(&quot;foo&quot;);
     *
     * //Alternative, shorter version for consecutive stubbing:
     * when(mock.someMethod(&quot;some arg&quot;))
     *  .thenReturn(&quot;one&quot;, &quot;two&quot;);
     * //is the same as:
     * when(mock.someMethod(&quot;some arg&quot;))
     *  .thenReturn(&quot;one&quot;)
     *  .thenReturn(&quot;two&quot;);
     *
     * //shorter version for consecutive method calls throwing exceptions:
     * when(mock.someMethod(&quot;some arg&quot;))
     *  .thenThrow(new RuntimeException(), new NullPointerException();
     *
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable...)}
     * &lt;p&gt;
     * Stubbing can be overridden: for example common stubbing can go to fixture
     * setup but the test methods can override it.
     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.
     * &lt;p&gt;
     * Once stubbed, the method will always return stubbed value regardless
     * of how many times it is called.
     * &lt;p&gt;
     * Last stubbing is more important - when you stubbed the same method with
     * the same arguments many times.
     * &lt;p&gt;
     * Although it is possible to verify a stubbed invocation, usually &lt;b&gt;it's just redundant&lt;/b&gt;.
     * Let's say you've stubbed &lt;code&gt;foo.bar()&lt;/code&gt;.
     * If your code cares what &lt;code&gt;foo.bar()&lt;/code&gt; returns then something else breaks(often before even &lt;code&gt;verify()&lt;/code&gt; gets executed).
     * If your code doesn't care what &lt;code&gt;get(0)&lt;/code&gt; returns then it should not be stubbed.
     * Not convinced? See &lt;a href=&quot;http://monkeyisland.pl/2008/04/26/asking-and-telling&quot;&gt;here&lt;/a&gt;.
     *
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     * @param methodCall method to be stubbed
     * @return OngoingStubbing object used to stub fluently.
     *         &lt;strong&gt;Do not&lt;/strong&gt; create a reference to this returned object.
     */
    public static &lt;T&gt; OngoingStubbing&lt;T&gt; when(T methodCall) {
<span class="fc" id="L1687">        return MOCKITO_CORE.when(methodCall);</span>
    }

    /**
     * Verifies certain behavior &lt;b&gt;happened once&lt;/b&gt;.
     * &lt;p&gt;
     * Alias to &lt;code&gt;verify(mock, times(1))&lt;/code&gt; E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * Above is equivalent to:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, times(1)).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * Arguments passed are compared using &lt;code&gt;equals()&lt;/code&gt; method.
     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.
     * &lt;p&gt;
     * Although it is possible to verify a stubbed invocation, usually &lt;b&gt;it's just redundant&lt;/b&gt;.
     * Let's say you've stubbed &lt;code&gt;foo.bar()&lt;/code&gt;.
     * If your code cares what &lt;code&gt;foo.bar()&lt;/code&gt; returns then something else breaks(often before even &lt;code&gt;verify()&lt;/code&gt; gets executed).
     * If your code doesn't care what &lt;code&gt;get(0)&lt;/code&gt; returns then it should not be stubbed.
     * Not convinced? See &lt;a href=&quot;http://monkeyisland.pl/2008/04/26/asking-and-telling&quot;&gt;here&lt;/a&gt;.
     *
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mock to be verified
     * @return mock object itself
     */
    public static &lt;T&gt; T verify(T mock) {
<span class="fc" id="L1718">        return MOCKITO_CORE.verify(mock, times(1));</span>
    }

    /**
     * Verifies certain behavior happened at least once / exact number of times / never. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, times(5)).someMethod(&quot;was called five times&quot;);
     *
     *   verify(mock, atLeast(2)).someMethod(&quot;was called at least two times&quot;);
     *
     *   //you can use flexible argument matchers, e.g:
     *   verify(mock, atLeastOnce()).someMethod(&lt;b&gt;anyString()&lt;/b&gt;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;b&gt;times(1) is the default&lt;/b&gt; and can be omitted
     * &lt;p&gt;
     * Arguments passed are compared using &lt;code&gt;equals()&lt;/code&gt; method.
     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.
     * &lt;p&gt;
     *
     * @param mock to be verified
     * @param mode times(x), atLeastOnce() or never()
     *
     * @return mock object itself
     */
    public static &lt;T&gt; T verify(T mock, VerificationMode mode) {
<span class="fc" id="L1744">        return MOCKITO_CORE.verify(mock, mode);</span>
    }

    /**
     * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
     * Normally, you don't need to reset your mocks, just create new mocks for each test method.
     * &lt;p&gt;
     * Instead of &lt;code&gt;#reset()&lt;/code&gt; please consider writing simple, small and focused test methods over lengthy, over-specified tests.
     * &lt;b&gt;First potential code smell is &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method.&lt;/b&gt; This probably means you're testing too much.
     * Follow the whisper of your test methods: &quot;Please keep us small &amp; focused on single behavior&quot;.
     * There are several threads about it on mockito mailing list.
     * &lt;p&gt;
     * The only reason we added &lt;code&gt;reset()&lt;/code&gt; method is to
     * make it possible to work with container-injected mocks.
     * See issue 55 (&lt;a href=&quot;http://code.google.com/p/mockito/issues/detail?id=55&quot;&gt;here&lt;/a&gt;)
     * or FAQ (&lt;a href=&quot;http://code.google.com/p/mockito/wiki/FAQ&quot;&gt;here&lt;/a&gt;).
     * &lt;p&gt;
     * &lt;b&gt;Don't harm yourself.&lt;/b&gt; &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method is a code smell (you're probably testing too much).
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List mock = mock(List.class);
     *   when(mock.size()).thenReturn(10);
     *   mock.add(1);
     *
     *   reset(mock);
     *   //at this point the mock forgot any interactions &amp; stubbing
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param &lt;T&gt; The Type of the mocks
     * @param mocks to be reset
     */
    public static &lt;T&gt; void reset(T ... mocks) {
<span class="fc" id="L1775">        MOCKITO_CORE.reset(mocks);</span>
<span class="fc" id="L1776">    }</span>

    /**
     * Use this method in order to only clear invocations, when stubbing is non-trivial. Use-cases can be:
     * &lt;ul&gt;
     *     &lt;li&gt;You are using a dependency injection framework to inject your mocks.&lt;/li&gt;
     *     &lt;li&gt;The mock is used in a stateful scenario. For example a class is Singleton which depends on your mock.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;b&gt;Try to avoid this method at all costs. Only clear invocations if you are unable to efficiently test your program.&lt;/b&gt;
     * @param &lt;T&gt; The type of the mocks
     * @param mocks The mocks to clear the invocations for
     */
    public static &lt;T&gt; void clearInvocations(T ... mocks) {
<span class="fc" id="L1790">        MOCKITO_CORE.clearInvocations(mocks);</span>
<span class="fc" id="L1791">    }</span>

    /**
     * Checks if any of given mocks has any unverified interaction.
     * &lt;p&gt;
     * You can use this method after you verified your mocks - to make sure that nothing
     * else was invoked on your mocks.
     * &lt;p&gt;
     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.
     * &lt;p&gt;
     * Stubbed invocations (if called) are also treated as interactions.
     * &lt;p&gt;
     * A word of &lt;b&gt;warning&lt;/b&gt;:
     * Some users who did a lot of classic, expect-run-verify mocking tend to use &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; very often, even in every test method.
     * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is not recommended to use in every test method.
     * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
     * Abusing it leads to overspecified, less maintainable tests. You can find further reading
     * &lt;a href=&quot;http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/&quot;&gt;here&lt;/a&gt;.
     * &lt;p&gt;
     * This method will also detect unverified invocations that occurred before the test method,
     * for example: in &lt;code&gt;setUp()&lt;/code&gt;, &lt;code&gt;&amp;#064;Before&lt;/code&gt; method or in constructor.
     * Consider writing nice code that makes interactions only in test methods.
     *
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * //interactions
     * mock.doSomething();
     * mock.doSomethingUnexpected();
     *
     * //verification
     * verify(mock).doSomething();
     *
     * //following will fail because 'doSomethingUnexpected()' is unexpected
     * verifyNoMoreInteractions(mock);
     *
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mocks to be verified
     */
    public static void verifyNoMoreInteractions(Object... mocks) {
<span class="fc" id="L1835">        MOCKITO_CORE.verifyNoMoreInteractions(mocks);</span>
<span class="fc" id="L1836">    }</span>

    /**
     * Verifies that no interactions happened on given mocks.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verifyZeroInteractions(mockOne, mockTwo);
     * &lt;/code&gt;&lt;/pre&gt;
     * This method will also detect invocations
     * that occurred before the test method, for example: in &lt;code&gt;setUp()&lt;/code&gt;, &lt;code&gt;&amp;#064;Before&lt;/code&gt; method or in constructor.
     * Consider writing nice code that makes interactions only in test methods.
     * &lt;p&gt;
     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mocks to be verified
     */
    public static void verifyZeroInteractions(Object... mocks) {
<span class="fc" id="L1854">        MOCKITO_CORE.verifyNoMoreInteractions(mocks);</span>
<span class="fc" id="L1855">    }</span>

    /**
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //Instead of:
     *   stubVoid(mock).toThrow(e).on().someVoidMethod();
     *
     *   //Please do:
     *   doThrow(e).when(mock).someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods.
     * &lt;p&gt;
     * Originally, &lt;code&gt;stubVoid()&lt;/code&gt; was used for stubbing void methods with exceptions. E.g:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();
     *
     * //you can stub with different behavior for consecutive calls.
     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.
     * stubVoid(mock)
     *   .toThrow(new RuntimeException())
     *   .toReturn()
     *   .on().someMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @deprecated Use {@link Mockito#doThrow(Throwable...)} method for stubbing voids
     *
     * @param mock
     *            to stub
     * @return stubbable object that allows stubbing with throwable
     */
    public static &lt;T&gt; VoidMethodStubbable&lt;T&gt; stubVoid(T mock) {
<span class="fc" id="L1890">        return MOCKITO_CORE.stubVoid(mock);</span>
    }

    /**
     * Use &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub the void method with an exception.
     * &lt;p&gt;
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
     * does not like void methods inside brackets...
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   doThrow(new RuntimeException()).when(mock).someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param toBeThrown to be thrown when the stubbed method is called
     * @return stubber - to select a method for stubbing
     */
    public static Stubber doThrow(Throwable... toBeThrown) {
<span class="fc" id="L1909">        return MOCKITO_CORE.stubber().doThrow(toBeThrown);</span>
    }

    /**
     * Use &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub the void method with an exception.
     * &lt;p&gt;
     * A new exception instance will be created for each method invocation.
     * &lt;p&gt;
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
     * does not like void methods inside brackets...
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   doThrow(RuntimeException.class).when(mock).someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param toBeThrown to be thrown when the stubbed method is called
     * @return stubber - to select a method for stubbing
     * @since 2.0.0
     */
    public static Stubber doThrow(Class&lt;? extends Throwable&gt; toBeThrown) {
<span class="fc" id="L1931">        return MOCKITO_CORE.stubber().doThrow(toBeThrown);</span>
    }

    /**
     * Same as {@link #doThrow(Class)} but sets consecutive exception classes to be thrown. Remember to use
     * &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub the void method to throw several exception of specified class.
     * &lt;p&gt;
     * A new exception instance will be created for each method invocation.
     * &lt;p&gt;
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
     * does not like void methods inside brackets...
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   doThrow(RuntimeException.class, BigFailure.class).when(mock).someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param toBeThrown to be thrown when the stubbed method is called
     * @param toBeThrownNext next to be thrown when the stubbed method is called
     * @return stubber - to select a method for stubbing
     * @since 2.0.0
     */
    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array creation
    @SuppressWarnings ({&quot;unchecked&quot;, &quot;varargs&quot;})
    public static Stubber doThrow(Class&lt;? extends Throwable&gt; toBeThrown, Class&lt;? extends Throwable&gt;... toBeThrownNext) {
<span class="fc" id="L1957">        return MOCKITO_CORE.stubber().doThrow(toBeThrown, toBeThrownNext);</span>
    }


    /**
     * Use &lt;code&gt;doCallRealMethod()&lt;/code&gt; when you want to call the real implementation of a method.
     * &lt;p&gt;
     * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
     * How does partial mock fit into this paradigm? Well, it just doesn't...
     * Partial mock usually means that the complexity has been moved to a different method on the same object.
     * In most cases, this is not the way you want to design your application.
     * &lt;p&gt;
     * However, there are rare cases when partial mocks come handy:
     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
     * However, I wouldn't use partial mocks for new, test-driven &amp; well-designed code.
     * &lt;p&gt;
     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks.
     * &lt;b&gt;Mockito.spy() is a recommended way of creating partial mocks.&lt;/b&gt;
     * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.
     * &lt;p&gt;
     * Example:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   Foo mock = mock(Foo.class);
     *   doCallRealMethod().when(mock).someVoidMethod();
     *
     *   // this will call the real implementation of Foo.someVoidMethod()
     *   mock.someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @return stubber - to select a method for stubbing
     * @since 1.9.5
     */
    public static Stubber doCallRealMethod() {
<span class="fc" id="L1993">        return MOCKITO_CORE.stubber().doCallRealMethod();</span>
    }

    /**
     * Use &lt;code&gt;doAnswer()&lt;/code&gt; when you want to stub a void method with generic {@link Answer}.
     * &lt;p&gt;
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *  doAnswer(new Answer() {
     *      public Object answer(InvocationOnMock invocation) {
     *          Object[] args = invocation.getArguments();
     *          Mock mock = invocation.getMock();
     *          return null;
     *      }})
     *  .when(mock).someMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param answer to answer when the stubbed method is called
     * @return stubber - to select a method for stubbing
     */
    public static Stubber doAnswer(Answer answer) {
<span class="fc" id="L2019">        return MOCKITO_CORE.stubber().doAnswer(answer);</span>
    }

    /**
     * Use &lt;code&gt;doNothing()&lt;/code&gt; for setting void methods to do nothing. &lt;b&gt;Beware that void methods on mocks do nothing by default!&lt;/b&gt;
     * However, there are rare situations when doNothing() comes handy:
     * &lt;p&gt;
     * &lt;ol&gt;
     * &lt;li&gt;Stubbing consecutive calls on a void method:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   doNothing().
     *   doThrow(new RuntimeException())
     *   .when(mock).someVoidMethod();
     *
     *   //does nothing the first time:
     *   mock.someVoidMethod();
     *
     *   //throws RuntimeException the next time:
     *   mock.someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     * &lt;li&gt;When you spy real objects and you want the void method to do nothing:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //let's make clear() do nothing
     *   doNothing().when(spy).clear();
     *
     *   spy.add(&quot;one&quot;);
     *
     *   //clear() does nothing, so the list still contains &quot;one&quot;
     *   spy.clear();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @return stubber - to select a method for stubbing
     */
    public static Stubber doNothing() {
<span class="fc" id="L2061">        return MOCKITO_CORE.stubber().doNothing();</span>
    }

    /**
     * Use &lt;code&gt;doReturn()&lt;/code&gt; in those rare occasions when you cannot use {@link Mockito#when(Object)}.
     * &lt;p&gt;
     * &lt;b&gt;Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe
     * and more readable&lt;/b&gt; (especially when stubbing consecutive calls).
     * &lt;p&gt;
     * Here are those rare occasions when doReturn() comes handy:
     * &lt;p&gt;
     *
     * &lt;ol&gt;
     * &lt;li&gt;When spying real objects and calling real methods on a spy brings side effects
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
     *   when(spy.get(0)).thenReturn(&quot;foo&quot;);
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(&quot;foo&quot;).when(spy).get(0);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     *
     * &lt;li&gt;Overriding a previous exception-stubbing:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   when(mock.foo()).thenThrow(new RuntimeException());
     *
     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
     *   when(mock.foo()).thenReturn(&quot;bar&quot;);
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(&quot;bar&quot;).when(mock).foo();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     * &lt;/ol&gt;
     *
     * Above scenarios shows a tradeoff of Mockito's elegant syntax. Note that the scenarios are very rare, though.
     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general
     * overridding stubbing is a potential code smell that points out too much stubbing.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param toBeReturned to be returned when the stubbed method is called
     * @return stubber - to select a method for stubbing
     */
    public static Stubber doReturn(Object toBeReturned) {
<span class="fc" id="L2111">        return MOCKITO_CORE.stubber().doReturn(toBeReturned);</span>
    }

    /**
     * Same as {@link #doReturn(Object)} but sets consecutive values to be returned. Remember to use
     * &lt;code&gt;doReturn()&lt;/code&gt; in those rare occasions when you cannot use {@link Mockito#when(Object)}.
     * &lt;p&gt;
     * &lt;b&gt;Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe
     * and more readable&lt;/b&gt; (especially when stubbing consecutive calls).
     * &lt;p&gt;
     * Here are those rare occasions when doReturn() comes handy:
     * &lt;p&gt;
     *
     * &lt;ol&gt;
     * &lt;li&gt;When spying real objects and calling real methods on a spy brings side effects
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
     *   when(spy.get(0)).thenReturn(&quot;foo&quot;, &quot;bar&quot;, &quot;qix&quot;);
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(&quot;foo&quot;, &quot;bar&quot;, &quot;qix&quot;).when(spy).get(0);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     *
     * &lt;li&gt;Overriding a previous exception-stubbing:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   when(mock.foo()).thenThrow(new RuntimeException());
     *
     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
     *   when(mock.foo()).thenReturn(&quot;bar&quot;, &quot;foo&quot;, &quot;qix&quot;);
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(&quot;bar&quot;, &quot;foo&quot;, &quot;qix&quot;).when(mock).foo();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     * &lt;/ol&gt;
     *
     * Above scenarios shows a trade-off of Mockito's elegant syntax. Note that the scenarios are very rare, though.
     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general
     * overridding stubbing is a potential code smell that points out too much stubbing.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param toBeReturned to be returned when the stubbed method is called
     * @param toBeReturnedNext to be returned in consecutive calls when the stubbed method is called
     * @return stubber - to select a method for stubbing
     * @since 2.0.0
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})
    public static Stubber doReturn(Object toBeReturned, Object... toBeReturnedNext) {
<span class="fc" id="L2165">        return MOCKITO_CORE.stubber().doReturn(toBeReturned, toBeReturnedNext);</span>
    }

    /**
     * Creates {@link org.mockito.InOrder} object that allows verifying mocks in order.
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   InOrder inOrder = inOrder(firstMock, secondMock);
     *
     *   inOrder.verify(firstMock).add(&quot;was called first&quot;);
     *   inOrder.verify(secondMock).add(&quot;was called second&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * Verification in order is flexible - &lt;b&gt;you don't have to verify all interactions&lt;/b&gt; one-by-one
     * but only those that you are interested in testing in order.
     * &lt;p&gt;
     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.
     * &lt;p&gt;
     * &lt;code&gt;InOrder&lt;/code&gt; verification is 'greedy'. You will hardly every notice it but
     * if you want to find out more search for 'greedy' on the Mockito
     * &lt;a href=&quot;http://code.google.com/p/mockito/w/list&quot;&gt;wiki pages&lt;/a&gt;.
     * &lt;p&gt;
     * As of Mockito 1.8.4 you can verifyNoMoreInvocations() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mocks to be verified in order
     *
     * @return InOrder object to be used to verify in order
     */
    public static InOrder inOrder(Object... mocks) {
<span class="fc" id="L2196">        return MOCKITO_CORE.inOrder(mocks);</span>
    }

    /**
     * Ignores stubbed methods of given mocks for the sake of verification.
     * Sometimes useful when coupled with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; or verification &lt;code&gt;inOrder()&lt;/code&gt;.
     * Helps avoiding redundant verification of stubbed calls - typically we're not interested in verifying stubs.
     * &lt;p&gt;
     * &lt;b&gt;Warning&lt;/b&gt;, &lt;code&gt;ignoreStubs()&lt;/code&gt; might lead to overuse of &lt;code&gt;verifyNoMoreInteractions(ignoreStubs(...));&lt;/code&gt;
     * Bear in mind that Mockito does not recommend bombarding every test with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt;
     * for the reasons outlined in javadoc for {@link Mockito#verifyNoMoreInteractions(Object...)}
     * Other words: all &lt;b&gt;*stubbed*&lt;/b&gt; methods of given mocks are marked &lt;b&gt;*verified*&lt;/b&gt; so that they don't get in a way during verifyNoMoreInteractions().
     * &lt;p&gt;
     * This method &lt;b&gt;changes the input mocks&lt;/b&gt;! This method returns input mocks just for convenience.
     * &lt;p&gt;
     * Ignored stubs will also be ignored for verification inOrder, including {@link org.mockito.InOrder#verifyNoMoreInteractions()}.
     * See the second example.
     * &lt;p&gt;
     * Example:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *  //mocking lists for the sake of the example (if you mock List in real you will burn in hell)
     *  List mock1 = mock(List.class), mock2 = mock(List.class);
     *
     *  //stubbing mocks:
     *  when(mock1.get(0)).thenReturn(10);
     *  when(mock2.get(0)).thenReturn(20);
     *
     *  //using mocks by calling stubbed get(0) methods:
     *  System.out.println(mock1.get(0)); //prints 10
     *  System.out.println(mock2.get(0)); //prints 20
     *
     *  //using mocks by calling clear() methods:
     *  mock1.clear();
     *  mock2.clear();
     *
     *  //verification:
     *  verify(mock1).clear();
     *  verify(mock2).clear();
     *
     *  //verifyNoMoreInteractions() fails because get() methods were not accounted for.
     *  try { verifyNoMoreInteractions(mock1, mock2); } catch (NoInteractionsWanted e);
     *
     *  //However, if we ignore stubbed methods then we can verifyNoMoreInteractions()
     *  verifyNoMoreInteractions(ignoreStubs(mock1, mock2));
     *
     *  //Remember that ignoreStubs() &lt;b&gt;*changes*&lt;/b&gt; the input mocks and returns them for convenience.
     * &lt;/code&gt;&lt;/pre&gt;
     * Ignoring stubs can be used with &lt;b&gt;verification in order&lt;/b&gt;:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *  List list = mock(List.class);
     *  when(mock.get(0)).thenReturn(&quot;foo&quot;);
     *
     *  list.add(0);
     *  System.out.println(list.get(0)); //we don't want to verify this
     *  list.clear();
     *
     *  InOrder inOrder = inOrder(ignoreStubs(list));
     *  inOrder.verify(list).add(0);
     *  inOrder.verify(list).clear();
     *  inOrder.verifyNoMoreInteractions();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @since 1.9.0
     * @param mocks input mocks that will be changed
     * @return the same mocks that were passed in as parameters
     */
    public static Object[] ignoreStubs(Object... mocks) {
<span class="fc" id="L2263">        return MOCKITO_CORE.ignoreStubs(mocks);</span>
    }

    /**
     * Allows verifying exact number of invocations. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, times(2)).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param wantedNumberOfInvocations wanted number of invocations
     *
     * @return verification mode
     */
    public static VerificationMode times(int wantedNumberOfInvocations) {
<span class="fc" id="L2279">        return VerificationModeFactory.times(wantedNumberOfInvocations);</span>
    }

    /**
     * Alias to &lt;code&gt;times(0)&lt;/code&gt;, see {@link Mockito#times(int)}
     * &lt;p&gt;
     * Verifies that interaction did not happen. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, never()).someMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt;
     * If you want to verify there were NO interactions with the mock
     * check out {@link Mockito#verifyZeroInteractions(Object...)}
     * or {@link Mockito#verifyNoMoreInteractions(Object...)}
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    public static VerificationMode never() {
<span class="fc" id="L2300">        return times(0);</span>
    }

    /**
     * Allows at-least-once verification. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, atLeastOnce()).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * Alias to &lt;code&gt;atLeast(1)&lt;/code&gt;.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    public static VerificationMode atLeastOnce() {
<span class="fc" id="L2315">        return VerificationModeFactory.atLeastOnce();</span>
    }

    /**
     * Allows at-least-x verification. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, atLeast(3)).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param minNumberOfInvocations minimum number of invocations
     *
     * @return verification mode
     */
    public static VerificationMode atLeast(int minNumberOfInvocations) {
<span class="fc" id="L2331">        return VerificationModeFactory.atLeast(minNumberOfInvocations);</span>
    }

    /**
     * Allows at-most-x verification. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, atMost(3)).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param maxNumberOfInvocations max number of invocations
     *
     * @return verification mode
     */
    public static VerificationMode atMost(int maxNumberOfInvocations) {
<span class="fc" id="L2347">        return VerificationModeFactory.atMost(maxNumberOfInvocations);</span>
    }

    /**
     * Allows non-greedy verification in order.  For example
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   inOrder.verify( mock, calls( 2 )).someMethod( &quot;some arg&quot; );
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;ul&gt;
     * &lt;li&gt;will not fail if the method is called 3 times, unlike times( 2 )&lt;/li&gt;
     * &lt;li&gt;will not mark the third invocation as verified, unlike atLeast( 2 )&lt;/li&gt;
     * &lt;/ul&gt;
     * This verification mode can only be used with in order verification.
     * @param wantedNumberOfInvocations number of invocations to verify
     * @return  verification mode
     */
    public static VerificationMode calls( int wantedNumberOfInvocations ){
<span class="fc" id="L2364">        return VerificationModeFactory.calls( wantedNumberOfInvocations );</span>
    }

    /**
     * Allows checking if given method was the only one invoked. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, only()).someMethod();
     *   //above is a shorthand for following 2 lines of code:
     *   verify(mock).someMethod();
     *   verifyNoMoreInvocations(mock);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt;
     * See also {@link Mockito#verifyNoMoreInteractions(Object...)}
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    public static VerificationMode only() {
<span class="fc" id="L2384">        return VerificationModeFactory.only();</span>
    }

    /**
     * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired
     * interaction rather than fails immediately if has not already happened. May be useful for testing in concurrent
     * conditions.
     * &lt;p&gt;
     * This differs from {@link Mockito#after after()} in that after() will wait the full period, unless
     * the final test result is known early (e.g. if a never() fails), whereas timeout() will stop early as soon
     * as verification passes, producing different behaviour when used with times(2), for example, which can pass
     * and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would run until
     * times(2) failed, and then fail.
     * &lt;p&gt;
     * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system
     * &lt;p&gt;
     * Not yet implemented to work with InOrder verification.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //passes when someMethod() is called within given time span
     *   verify(mock, timeout(100)).someMethod();
     *   //above is an alias to:
     *   verify(mock, timeout(100).times(1)).someMethod();
     *
     *   //passes as soon as someMethod() has been called 2 times before the given timeout
     *   verify(mock, timeout(100).times(2)).someMethod();
     *
     *   //equivalent: this also passes as soon as someMethod() has been called 2 times before the given timeout
     *   verify(mock, timeout(100).atLeast(2)).someMethod();
     *
     *   //verifies someMethod() within given time span using given verification mode
     *   //useful only if you have your own custom verification modes.
     *   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param millis - time span in milliseconds
     *
     * @return verification mode
     */
    public static VerificationWithTimeout timeout(long millis) {
<span class="fc" id="L2425">        return new Timeout(millis, VerificationModeFactory.times(1));</span>
    }

    /**
     * Allows verifying over a given period. It causes a verify to wait for a specified period of time for a desired
     * interaction rather than failing immediately if has not already happened. May be useful for testing in concurrent
     * conditions.
     * &lt;p&gt;
     * This differs from {@link Mockito#timeout timeout()} in that after() will wait the full period, whereas timeout()
     * will stop early as soon as verification passes, producing different behaviour when used with times(2), for example,
     * which can pass and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would
     * run the full time, which point it will fail, as times(2) has failed.
     * &lt;p&gt;
     * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system
     * &lt;p&gt;
     * Not yet implemented to work with InOrder verification.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //passes after 100ms, if someMethod() has only been called once at that time.
     *   verify(mock, after(100)).someMethod();
     *   //above is an alias to:
     *   verify(mock, after(100).times(1)).someMethod();
     *
     *   //passes if someMethod() is called &lt;b&gt;*exactly*&lt;/b&gt; 2 times after the given timespan
     *   verify(mock, after(100).times(2)).someMethod();
     *
     *   //passes if someMethod() has not been called after the given timespan
     *   verify(mock, after(100).never()).someMethod();
     *
     *   //verifies someMethod() after a given time span using given verification mode
     *   //useful only if you have your own custom verification modes.
     *   verify(mock, new After(100, yourOwnVerificationMode)).someMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param millis - time span in milliseconds
     *
     * @return verification mode
     */
    public static VerificationAfterDelay after(long millis) {
<span class="fc" id="L2465">        return new After(millis, VerificationModeFactory.times(1));</span>
    }

    /**
     * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: &lt;a href=&quot;http://code.google.com/p/mockito/wiki/FAQ&quot;&gt;http://code.google.com/p/mockito/wiki/FAQ&lt;/a&gt;
     * &lt;p&gt;
     * In case of questions you may also post to mockito mailing list: &lt;a href=&quot;http://groups.google.com/group/mockito&quot;&gt;http://groups.google.com/group/mockito&lt;/a&gt;
     * &lt;p&gt;
     * &lt;code&gt;validateMockitoUsage()&lt;/code&gt; &lt;b&gt;explicitly validates&lt;/b&gt; the framework state to detect invalid use of Mockito.
     * However, this feature is optional &lt;b&gt;because Mockito validates the usage all the time...&lt;/b&gt; but there is a gotcha so read on.
     * &lt;p&gt;
     * Examples of incorrect use:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * //Oops, thenReturn() part is missing:
     * when(mock.get());
     *
     * //Oops, verified method call is inside verify() where it should be on the outside:
     * verify(mock.execute());
     *
     * //Oops, missing method to verify:
     * verify(mock);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly.
     * The gotcha is that Mockito does the validation &lt;b&gt;next time&lt;/b&gt; you use the framework (e.g. next time you verify, stub, call mock etc.).
     * But even though the exception might be thrown in the next test,
     * the exception &lt;b&gt;message contains a navigable stack trace element&lt;/b&gt; with location of the defect.
     * Hence you can click and find the place where Mockito was misused.
     * &lt;p&gt;
     * Sometimes though, you might want to validate the framework usage explicitly.
     * For example, one of the users wanted to put &lt;code&gt;validateMockitoUsage()&lt;/code&gt; in his &lt;code&gt;&amp;#064;After&lt;/code&gt; method
     * so that he knows immediately when he misused Mockito.
     * Without it, he would have known about it not sooner than &lt;b&gt;next time&lt;/b&gt; he used the framework.
     * One more benefit of having &lt;code&gt;validateMockitoUsage()&lt;/code&gt; in &lt;code&gt;&amp;#064;After&lt;/code&gt; is that jUnit runner and rule will always fail in the test method with defect
     * whereas ordinary 'next-time' validation might fail the &lt;b&gt;next&lt;/b&gt; test method.
     * But even though JUnit might report next test as red, don't worry about it
     * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.
     * &lt;p&gt;
     * &lt;b&gt;Both built-in runner: {@link MockitoJUnitRunner} and rule: {@link MockitoRule}&lt;/b&gt; do validateMockitoUsage() after each test method.
     * &lt;p&gt;
     * Bear in mind that &lt;b&gt;usually you don't have to &lt;code&gt;validateMockitoUsage()&lt;/code&gt;&lt;/b&gt;
     * and framework validation triggered on next-time basis should be just enough,
     * mainly because of enhanced exception message with clickable location of defect.
     * However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure
     * (like your own runner or base class for all tests) because adding a special action to &lt;code&gt;&amp;#064;After&lt;/code&gt; has zero cost.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     */
    public static void validateMockitoUsage() {
<span class="fc" id="L2514">        MOCKITO_CORE.validateMockitoUsage();</span>
<span class="fc" id="L2515">    }</span>

    /**
     * Allows mock creation with additional mock settings.
     * &lt;p&gt;
     * Don't use it too often.
     * Consider writing simple tests that use simple mocks.
     * Repeat after me: simple tests push simple, KISSy, readable &amp; maintainable code.
     * If you cannot write a test in a simple way - refactor the code under test.
     * &lt;p&gt;
     * Examples of mock settings:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //Creates mock with different default answer &amp; name
     *   Foo mock = mock(Foo.class, withSettings()
     *       .defaultAnswer(RETURNS_SMART_NULLS)
     *       .name(&quot;cool mockie&quot;));
     *
     *   //Creates mock with different default answer, descriptive name and extra interfaces
     *   Foo mock = mock(Foo.class, withSettings()
     *       .defaultAnswer(RETURNS_SMART_NULLS)
     *       .name(&quot;cool mockie&quot;)
     *       .extraInterfaces(Bar.class));
     * &lt;/code&gt;&lt;/pre&gt;
     * {@link MockSettings} has been introduced for two reasons.
     * Firstly, to make it easy to add another mock settings when the demand comes.
     * Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.
     * &lt;p&gt;
     * See javadoc for {@link MockSettings} to learn about possible mock settings.
     * &lt;p&gt;
     *
     * @return mock settings instance with defaults.
     */
    public static MockSettings withSettings() {
<span class="fc" id="L2548">        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);</span>
    }

    /**
     * Adds a description to be printed if verification fails.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * verify(mock, description(&quot;This will print on failure&quot;)).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * @param description The description to print on failure.
     * @return verification mode
     * @since 2.0.0
     */
    public static VerificationMode description(String description) {
<span class="fc" id="L2561">        return times(1).description(description);</span>
    }

    /**
     * Helps debugging failing tests. Experimental - use at your own risk. We're not sure if this method will stay in public api.
     */
    @Deprecated
    static MockitoDebugger debug() {
<span class="nc" id="L2569">        return new MockitoDebuggerImpl();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>