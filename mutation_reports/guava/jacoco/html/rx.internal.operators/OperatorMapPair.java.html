<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>OperatorMapPair.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rxjava</a> &gt; <a href="index.source.html" class="el_package">rx.internal.operators</a> &gt; <span class="el_source">OperatorMapPair.java</span></div><h1>OperatorMapPair.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2014 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package rx.internal.operators;

import rx.Observable;
import rx.Observable.Operator;
import rx.exceptions.*;
import rx.Subscriber;
import rx.functions.Func1;
import rx.functions.Func2;

/**
 * An {@link Operator} that pairs up items emitted by a source {@link Observable} with the sequence of items
 * emitted by the {@code Observable} that is derived from each item by means of a selector, and emits the
 * results of this pairing.
 *
 * @param &lt;T&gt;
 *            the type of items emitted by the source {@code Observable}
 * @param &lt;U&gt;
 *            the type of items emitted by the derived {@code Observable}s
 * @param &lt;R&gt;
 *            the type of items to be emitted by this {@code Operator}
 */
public final class OperatorMapPair&lt;T, U, R&gt; implements Operator&lt;Observable&lt;? extends R&gt;, T&gt; {

    /**
     * Creates the function that generates a {@code Observable} based on an item emitted by another {@code Observable}.
     * 
     * @param selector
     *            a function that accepts an item and returns an {@code Iterable} of corresponding items
     * @return a function that converts an item emitted by the source {@code Observable} into an {@code Observable} that emits the items generated by {@code selector} operating on that item
     */
    public static &lt;T, U&gt; Func1&lt;T, Observable&lt;U&gt;&gt; convertSelector(final Func1&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; selector) {
<span class="fc" id="L47">        return new Func1&lt;T, Observable&lt;U&gt;&gt;() {</span>
            @Override
            public Observable&lt;U&gt; call(T t1) {
<span class="fc" id="L50">                return Observable.from(selector.call(t1));</span>
            }
        };
    }

    final Func1&lt;? super T, ? extends Observable&lt;? extends U&gt;&gt; collectionSelector;
    final Func2&lt;? super T, ? super U, ? extends R&gt; resultSelector;

<span class="fc" id="L58">    public OperatorMapPair(final Func1&lt;? super T, ? extends Observable&lt;? extends U&gt;&gt; collectionSelector, final Func2&lt;? super T, ? super U, ? extends R&gt; resultSelector) {</span>
<span class="fc" id="L59">        this.collectionSelector = collectionSelector;</span>
<span class="fc" id="L60">        this.resultSelector = resultSelector;</span>
<span class="fc" id="L61">    }</span>

    @Override
    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super Observable&lt;? extends R&gt;&gt; o) {
<span class="fc" id="L65">        return new Subscriber&lt;T&gt;(o) {</span>

            @Override
            public void onCompleted() {
<span class="fc" id="L69">                o.onCompleted();</span>
<span class="fc" id="L70">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L74">                o.onError(e);</span>
<span class="nc" id="L75">            }</span>

            @Override
            public void onNext(final T outer) {
                try {
<span class="fc" id="L80">                    o.onNext(collectionSelector.call(outer).map(new Func1&lt;U, R&gt;() {</span>

                        @Override
                        public R call(U inner) {
<span class="fc" id="L84">                            return resultSelector.call(outer, inner);</span>
                        }
                    }));
<span class="fc" id="L87">                } catch (Throwable e) {</span>
<span class="fc" id="L88">                    Exceptions.throwOrReport(e, o, outer);</span>
<span class="fc" id="L89">                }</span>
<span class="fc" id="L90">            }</span>

        };
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>