<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Observable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rxjava</a> &gt; <a href="index.source.html" class="el_package">rx</a> &gt; <span class="el_source">Observable.java</span></div><h1>Observable.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package rx;

import java.util.*;
import java.util.concurrent.*;

import rx.annotations.*;
import rx.exceptions.*;
import rx.functions.*;
import rx.internal.operators.*;
import rx.internal.producers.SingleProducer;
import rx.internal.util.*;
import rx.observables.*;
import rx.observers.SafeSubscriber;
import rx.plugins.*;
import rx.schedulers.*;
import rx.subscriptions.Subscriptions;

/**
 * The Observable class that implements the Reactive Pattern.
 * &lt;p&gt;
 * This class provides methods for subscribing to the Observable as well as delegate methods to the various
 * Observers.
 * &lt;p&gt;
 * The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;301&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/legend.png&quot; alt=&quot;&quot;&gt;
 * &lt;p&gt;
 * For more information see the &lt;a href=&quot;http://reactivex.io/documentation/observable.html&quot;&gt;ReactiveX
 * documentation&lt;/a&gt;.
 * 
 * @param &lt;T&gt;
 *            the type of the items emitted by the Observable
 */
public class Observable&lt;T&gt; {

    final OnSubscribe&lt;T&gt; onSubscribe;

    /**
     * Creates an Observable with a Function to execute when it is subscribed to.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; Use {@link #create(OnSubscribe)} to create an Observable, instead of this constructor,
     * unless you specifically have a need for inheritance.
     * 
     * @param f
     *            {@link OnSubscribe} to be executed when {@link #subscribe(Subscriber)} is called
     */
<span class="fc" id="L59">    protected Observable(OnSubscribe&lt;T&gt; f) {</span>
<span class="fc" id="L60">        this.onSubscribe = f;</span>
<span class="fc" id="L61">    }</span>

<span class="fc" id="L63">    static final RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();</span>

    /**
     * Returns an Observable that will execute the specified function when a {@link Subscriber} subscribes to
     * it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/create.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Write the function you pass to {@code create} so that it behaves as an Observable: It should invoke the
     * Subscriber's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError}, and
     * {@link Subscriber#onCompleted onCompleted} methods appropriately.
     * &lt;p&gt;
     * A well-formed Observable must invoke either the Subscriber's {@code onCompleted} method exactly once or
     * its {@code onError} method exactly once.
     * &lt;p&gt;
     * See &lt;a href=&quot;http://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;Rx Design Guidelines (PDF)&lt;/a&gt; for detailed
     * information.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code create} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;T&gt;
     *            the type of the items that this Observable emits
     * @param f
     *            a function that accepts an {@code Subscriber&lt;T&gt;}, and invokes its {@code onNext},
     *            {@code onError}, and {@code onCompleted} methods as appropriate
     * @return an Observable that, when a {@link Subscriber} subscribes to it, will execute the specified
     *         function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/create.html&quot;&gt;ReactiveX operators documentation: Create&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; create(OnSubscribe&lt;T&gt; f) {
<span class="fc" id="L95">        return new Observable&lt;T&gt;(hook.onCreate(f));</span>
    }

    /**
     * Returns an Observable that respects the back-pressure semantics. When the returned Observable is 
     * subscribed to it will initiate the given {@link SyncOnSubscribe}'s life cycle for 
     * generating events. 
     * 
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; the {@code SyncOnSubscribe} provides a generic way to fulfill data by iterating 
     * over a (potentially stateful) function (e.g. reading data off of a channel, a parser, ). If your 
     * data comes directly from an asyrchronous/potentially concurrent source then consider using the 
     * {@link Observable#create(AsyncOnSubscribe) asynchronous overload}.
     * 
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/create-sync.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * See &lt;a href=&quot;http://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;Rx Design Guidelines (PDF)&lt;/a&gt; for detailed
     * information.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code create} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;T&gt;
     *            the type of the items that this Observable emits
     * @param syncOnSubscribe
     *            an implementation of {@link SyncOnSubscribe}. There are many static creation methods 
     *            on the class for convenience.  
     * @return an Observable that, when a {@link Subscriber} subscribes to it, will execute the specified
     *         function
     * @see {@link SyncOnSubscribe} {@code static create*} methods
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/create.html&quot;&gt;ReactiveX operators documentation: Create&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    public static &lt;S, T&gt; Observable&lt;T&gt; create(SyncOnSubscribe&lt;S, T&gt; syncOnSubscribe) {
<span class="fc" id="L131">        return new Observable&lt;T&gt;(hook.onCreate(syncOnSubscribe));</span>
    }

    /**
     * Returns an Observable that respects the back-pressure semantics. When the returned Observable is 
     * subscribed to it will initiate the given {@link AsyncOnSubscribe}'s life cycle for 
     * generating events. 
     * 
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; the {@code AsyncOnSubscribe} is useful for observable sources of data that are 
     * necessarily asynchronous (RPC, external services, etc). Typically most use cases can be solved 
     * with the {@link Observable#create(SyncOnSubscribe) synchronous overload}.
     * 
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/create-async.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * See &lt;a href=&quot;http://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;Rx Design Guidelines (PDF)&lt;/a&gt; for detailed
     * information.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code create} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;T&gt;
     *            the type of the items that this Observable emits
     * @param asyncOnSubscribe
     *            an implementation of {@link AsyncOnSubscribe}. There are many static creation methods 
     *            on the class for convenience. 
     * @return an Observable that, when a {@link Subscriber} subscribes to it, will execute the specified
     *         function
     * @see {@link AsyncOnSubscribe AsyncOnSubscribe} {@code static create*} methods
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/create.html&quot;&gt;ReactiveX operators documentation: Create&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    public static &lt;S, T&gt; Observable&lt;T&gt; create(AsyncOnSubscribe&lt;S, T&gt; asyncOnSubscribe) {
<span class="nc" id="L166">        return new Observable&lt;T&gt;(hook.onCreate(asyncOnSubscribe));</span>
    }

    /**
     * Invoked when Observable.subscribe is called.
     */
    public interface OnSubscribe&lt;T&gt; extends Action1&lt;Subscriber&lt;? super T&gt;&gt; {
        // cover for generics insanity
    }

    /**
     * Operator function for lifting into an Observable.
     */
    public interface Operator&lt;R, T&gt; extends Func1&lt;Subscriber&lt;? super R&gt;, Subscriber&lt;? super T&gt;&gt; {
        // cover for generics insanity
    }

    /**
     * Passes all emitted values from this Observable to the provided conversion function to be collected and
     * returned as a single value. Note that it is legal for a conversion function to return an Observable
     * (enabling chaining). 
     * 
     * @param conversion a function that converts from this {@code Observable&lt;T&gt;} to an {@code R}
     * @return an instance of R created by the provided conversion function
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    public &lt;R&gt; R extend(Func1&lt;? super OnSubscribe&lt;T&gt;, ? extends R&gt; conversion) {
<span class="fc" id="L194">        return conversion.call(new OnSubscribe&lt;T&gt;() {</span>
            @Override
            public void call(Subscriber&lt;? super T&gt; subscriber) {
<span class="fc" id="L197">                subscriber.add(Observable.subscribe(subscriber, Observable.this));</span>
<span class="fc" id="L198">            }});</span>
    }
    
    /**
     * Lifts a function to the current Observable and returns a new Observable that when subscribed to will pass
     * the values of the current Observable through the Operator function.
     * &lt;p&gt;
     * In other words, this allows chaining Observers together on an Observable for acting on the values within
     * the Observable.
     * &lt;p&gt; {@code
     * observable.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe()
     * }
     * &lt;p&gt;
     * If the operator you are creating is designed to act on the individual items emitted by a source
     * Observable, use {@code lift}. If your operator is designed to transform the source Observable as a whole
     * (for instance, by applying a particular set of existing RxJava operators to it) use {@link #compose}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code lift} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param operator the Operator that implements the Observable-operating function to be applied to the source
     *             Observable
     * @return an Observable that is the result of applying the lifted Operator to the source Observable
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators&quot;&gt;RxJava wiki: Implementing Your Own Operators&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;? extends R, ? super T&gt; operator) {
<span class="fc" id="L225">        return new Observable&lt;R&gt;(new OnSubscribe&lt;R&gt;() {</span>
            @Override
            public void call(Subscriber&lt;? super R&gt; o) {
                try {
<span class="fc" id="L229">                    Subscriber&lt;? super T&gt; st = hook.onLift(operator).call(o);</span>
                    try {
                        // new Subscriber created and being subscribed with so 'onStart' it
<span class="fc" id="L232">                        st.onStart();</span>
<span class="fc" id="L233">                        onSubscribe.call(st);</span>
<span class="fc" id="L234">                    } catch (Throwable e) {</span>
                        // localized capture of errors rather than it skipping all operators 
                        // and ending up in the try/catch of the subscribe method which then
                        // prevents onErrorResumeNext and other similar approaches to error handling
<span class="fc" id="L238">                        Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L239">                        st.onError(e);</span>
<span class="fc" id="L240">                    }</span>
<span class="fc" id="L241">                } catch (Throwable e) {</span>
<span class="fc" id="L242">                    Exceptions.throwIfFatal(e);</span>
                    // if the lift function failed all we can do is pass the error to the final Subscriber
                    // as we don't have the operator available to us
<span class="fc" id="L245">                    o.onError(e);</span>
<span class="fc" id="L246">                }</span>
<span class="fc" id="L247">            }</span>
        });
    }
    
    /**
     * Transform an Observable by applying a particular Transformer function to it.
     * &lt;p&gt;
     * This method operates on the Observable itself whereas {@link #lift} operates on the Observable's
     * Subscribers or Observers.
     * &lt;p&gt;
     * If the operator you are creating is designed to act on the individual items emitted by a source
     * Observable, use {@link #lift}. If your operator is designed to transform the source Observable as a whole
     * (for instance, by applying a particular set of existing RxJava operators to it) use {@code compose}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code compose} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param transformer implements the function that transforms the source Observable
     * @return the source Observable, transformed by the transformer function
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators&quot;&gt;RxJava wiki: Implementing Your Own Operators&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;R&gt; Observable&lt;R&gt; compose(Transformer&lt;? super T, ? extends R&gt; transformer) {
<span class="fc" id="L271">        return ((Transformer&lt;T, R&gt;) transformer).call(this);</span>
    }

    /**
     * Transformer function used by {@link #compose}.
     * @warn more complete description needed
     */
    public interface Transformer&lt;T, R&gt; extends Func1&lt;Observable&lt;T&gt;, Observable&lt;R&gt;&gt; {
        // cover for generics insanity
    }

    /**
     * Returns a Single that emits the single item emitted by the source Observable, if that Observable
     * emits only a single item. If the source Observable emits more than one item or no items, notify of an
     * {@code IllegalArgumentException} or {@code NoSuchElementException} respectively.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;295&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.toSingle.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Single that emits the single item emitted by the source Observable
     * @throws IllegalArgumentException
     *             if the source observable emits more than one item
     * @throws NoSuchElementException
     *             if the source observable emits no items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/single.html&quot;&gt;ReactiveX documentation: Single&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Beta
    public Single&lt;T&gt; toSingle() {
<span class="fc" id="L303">        return new Single&lt;T&gt;(OnSubscribeSingle.create(this));</span>
    }

    /**
     * Returns a Completable that discards all onNext emissions (similar to
     * {@code ignoreAllElements()}) and calls onCompleted when this source observable calls
     * onCompleted. Error terminal events are propagated.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;295&quot; src=
     * &quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toCompletable.png&quot;
     * alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code toCompletable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Completable that calls onCompleted on it's subscriber when the source Observable
     *         calls onCompleted
     * @see &lt;a href=&quot;http://reactivex.io/documentation/completable.html&quot;&gt;ReactiveX documentation:
     *      Completable&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical
     *        with the release number)
     */
    @Experimental
    public Completable toCompletable() {
<span class="fc" id="L328">        return Completable.fromObservable(this);</span>
    }
    

    /* *********************************************************************************************************
     * Operators Below Here
     * *********************************************************************************************************
     */

    /**
     * Mirrors the one Observable in an Iterable of several Observables that first either emits an item or sends
     * a termination notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param sources
     *            an Iterable of Observable sources competing to react first
     * @return an Observable that emits the same sequence as whichever of the source Observables first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; amb(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources) {
<span class="nc" id="L354">        return create(OnSubscribeAmb.amb(sources));</span>
    }

    /**
     * Given two Observables, mirrors the one that first either emits an item or sends a termination
     * notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            an Observable competing to react first
     * @param o2
     *            an Observable competing to react first
     * @return an Observable that emits the same sequence as whichever of the source Observables first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2) {
<span class="fc" id="L376">        return create(OnSubscribeAmb.amb(o1, o2));</span>
    }

    /**
     * Given three Observables, mirrors the one that first either emits an item or sends a termination
     * notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            an Observable competing to react first
     * @param o2
     *            an Observable competing to react first
     * @param o3
     *            an Observable competing to react first
     * @return an Observable that emits the same sequence as whichever of the source Observables first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2, Observable&lt;? extends T&gt; o3) {
<span class="nc" id="L400">        return create(OnSubscribeAmb.amb(o1, o2, o3));</span>
    }

    /**
     * Given four Observables, mirrors the one that first either emits an item or sends a termination
     * notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            an Observable competing to react first
     * @param o2
     *            an Observable competing to react first
     * @param o3
     *            an Observable competing to react first
     * @param o4
     *            an Observable competing to react first
     * @return an Observable that emits the same sequence as whichever of the source Observables first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2, Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4) {
<span class="nc" id="L426">        return create(OnSubscribeAmb.amb(o1, o2, o3, o4));</span>
    }

    /**
     * Given five Observables, mirrors the one that first either emits an item or sends a termination
     * notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param o1
     *            an Observable competing to react first
     * @param o2
     *            an Observable competing to react first
     * @param o3
     *            an Observable competing to react first
     * @param o4
     *            an Observable competing to react first
     * @param o5
     *            an Observable competing to react first
     * @return an Observable that emits the same sequence as whichever of the source Observables first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2, Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4, Observable&lt;? extends T&gt; o5) {
<span class="nc" id="L454">        return create(OnSubscribeAmb.amb(o1, o2, o3, o4, o5));</span>
    }

    /**
     * Given six Observables, mirrors the one that first either emits an item or sends a termination
     * notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            an Observable competing to react first
     * @param o2
     *            an Observable competing to react first
     * @param o3
     *            an Observable competing to react first
     * @param o4
     *            an Observable competing to react first
     * @param o5
     *            an Observable competing to react first
     * @param o6
     *            an Observable competing to react first
     * @return an Observable that emits the same sequence as whichever of the source Observables first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2, Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4, Observable&lt;? extends T&gt; o5, Observable&lt;? extends T&gt; o6) {
<span class="nc" id="L484">        return create(OnSubscribeAmb.amb(o1, o2, o3, o4, o5, o6));</span>
    }

    /**
     * Given seven Observables, mirrors the one that first either emits an item or sends a termination
     * notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param o1
     *            an Observable competing to react first
     * @param o2
     *            an Observable competing to react first
     * @param o3
     *            an Observable competing to react first
     * @param o4
     *            an Observable competing to react first
     * @param o5
     *            an Observable competing to react first
     * @param o6
     *            an Observable competing to react first
     * @param o7
     *            an Observable competing to react first
     * @return an Observable that emits the same sequence as whichever of the source Observables first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2, Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4, Observable&lt;? extends T&gt; o5, Observable&lt;? extends T&gt; o6, Observable&lt;? extends T&gt; o7) {
<span class="nc" id="L516">        return create(OnSubscribeAmb.amb(o1, o2, o3, o4, o5, o6, o7));</span>
    }

    /**
     * Given eight Observables, mirrors the one that first either emits an item or sends a termination
     * notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param o1
     *            an Observable competing to react first
     * @param o2
     *            an Observable competing to react first
     * @param o3
     *            an Observable competing to react first
     * @param o4
     *            an Observable competing to react first
     * @param o5
     *            an Observable competing to react first
     * @param o6
     *            an Observable competing to react first
     * @param o7
     *            an Observable competing to react first
     * @param o8
     *            an observable competing to react first
     * @return an Observable that emits the same sequence as whichever of the source Observables first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2, Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4, Observable&lt;? extends T&gt; o5, Observable&lt;? extends T&gt; o6, Observable&lt;? extends T&gt; o7, Observable&lt;? extends T&gt; o8) {
<span class="nc" id="L550">        return create(OnSubscribeAmb.amb(o1, o2, o3, o4, o5, o6, o7, o8));</span>
    }

    /**
     * Given nine Observables, mirrors the one that first either emits an item or sends a termination
     * notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            an Observable competing to react first
     * @param o2
     *            an Observable competing to react first
     * @param o3
     *            an Observable competing to react first
     * @param o4
     *            an Observable competing to react first
     * @param o5
     *            an Observable competing to react first
     * @param o6
     *            an Observable competing to react first
     * @param o7
     *            an Observable competing to react first
     * @param o8
     *            an Observable competing to react first
     * @param o9
     *            an Observable competing to react first
     * @return an Observable that emits the same sequence as whichever of the source Observables first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2, Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4, Observable&lt;? extends T&gt; o5, Observable&lt;? extends T&gt; o6, Observable&lt;? extends T&gt; o7, Observable&lt;? extends T&gt; o8, Observable&lt;? extends T&gt; o9) {
<span class="nc" id="L586">        return create(OnSubscribeAmb.amb(o1, o2, o3, o4, o5, o6, o7, o8, o9));</span>
    }

    /**
     * Combines two source Observables by emitting an item that aggregates the latest values of each of the
     * source Observables each time an item is received from either of the source Observables, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param o1
     *            the first source Observable
     * @param o2
     *            the second source Observable
     * @param combineFunction
     *            the aggregation function used to combine the items emitted by the source Observables
     * @return an Observable that emits items that are the result of combining the items emitted by the source
     *         Observables by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, R&gt; Observable&lt;R&gt; combineLatest(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Func2&lt;? super T1, ? super T2, ? extends R&gt; combineFunction) {
<span class="fc" id="L612">        return combineLatest(Arrays.asList(o1, o2), Functions.fromFunc(combineFunction));</span>
    }

    /**
     * Combines three source Observables by emitting an item that aggregates the latest values of each of the
     * source Observables each time an item is received from any of the source Observables, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            the second source Observable
     * @param o3
     *            the third source Observable
     * @param combineFunction
     *            the aggregation function used to combine the items emitted by the source Observables
     * @return an Observable that emits items that are the result of combining the items emitted by the source
     *         Observables by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, R&gt; Observable&lt;R&gt; combineLatest(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Func3&lt;? super T1, ? super T2, ? super T3, ? extends R&gt; combineFunction) {
<span class="fc" id="L640">        return combineLatest(Arrays.asList(o1, o2, o3), Functions.fromFunc(combineFunction));</span>
    }

    /**
     * Combines four source Observables by emitting an item that aggregates the latest values of each of the
     * source Observables each time an item is received from any of the source Observables, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            the second source Observable
     * @param o3
     *            the third source Observable
     * @param o4
     *            the fourth source Observable
     * @param combineFunction
     *            the aggregation function used to combine the items emitted by the source Observables
     * @return an Observable that emits items that are the result of combining the items emitted by the source
     *         Observables by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, R&gt; Observable&lt;R&gt; combineLatest(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4,
            Func4&lt;? super T1, ? super T2, ? super T3, ? super T4, ? extends R&gt; combineFunction) {
<span class="fc" id="L671">        return combineLatest(Arrays.asList(o1, o2, o3, o4), Functions.fromFunc(combineFunction));</span>
    }

    /**
     * Combines five source Observables by emitting an item that aggregates the latest values of each of the
     * source Observables each time an item is received from any of the source Observables, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            the second source Observable
     * @param o3
     *            the third source Observable
     * @param o4
     *            the fourth source Observable
     * @param o5
     *            the fifth source Observable
     * @param combineFunction
     *            the aggregation function used to combine the items emitted by the source Observables
     * @return an Observable that emits items that are the result of combining the items emitted by the source
     *         Observables by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, T5, R&gt; Observable&lt;R&gt; combineLatest(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Observable&lt;? extends T5&gt; o5,
            Func5&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R&gt; combineFunction) {
<span class="fc" id="L704">        return combineLatest(Arrays.asList(o1, o2, o3, o4, o5), Functions.fromFunc(combineFunction));</span>
    }

    /**
     * Combines six source Observables by emitting an item that aggregates the latest values of each of the
     * source Observables each time an item is received from any of the source Observables, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            the second source Observable
     * @param o3
     *            the third source Observable
     * @param o4
     *            the fourth source Observable
     * @param o5
     *            the fifth source Observable
     * @param o6
     *            the sixth source Observable
     * @param combineFunction
     *            the aggregation function used to combine the items emitted by the source Observables
     * @return an Observable that emits items that are the result of combining the items emitted by the source
     *         Observables by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, T5, T6, R&gt; Observable&lt;R&gt; combineLatest(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Observable&lt;? extends T5&gt; o5, Observable&lt;? extends T6&gt; o6,
            Func6&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R&gt; combineFunction) {
<span class="fc" id="L739">        return combineLatest(Arrays.asList(o1, o2, o3, o4, o5, o6), Functions.fromFunc(combineFunction));</span>
    }

    /**
     * Combines seven source Observables by emitting an item that aggregates the latest values of each of the
     * source Observables each time an item is received from any of the source Observables, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            the second source Observable
     * @param o3
     *            the third source Observable
     * @param o4
     *            the fourth source Observable
     * @param o5
     *            the fifth source Observable
     * @param o6
     *            the sixth source Observable
     * @param o7
     *            the seventh source Observable
     * @param combineFunction
     *            the aggregation function used to combine the items emitted by the source Observables
     * @return an Observable that emits items that are the result of combining the items emitted by the source
     *         Observables by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, R&gt; Observable&lt;R&gt; combineLatest(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Observable&lt;? extends T5&gt; o5, Observable&lt;? extends T6&gt; o6, Observable&lt;? extends T7&gt; o7,
            Func7&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R&gt; combineFunction) {
<span class="fc" id="L776">        return combineLatest(Arrays.asList(o1, o2, o3, o4, o5, o6, o7), Functions.fromFunc(combineFunction));</span>
    }

    /**
     * Combines eight source Observables by emitting an item that aggregates the latest values of each of the
     * source Observables each time an item is received from any of the source Observables, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            the second source Observable
     * @param o3
     *            the third source Observable
     * @param o4
     *            the fourth source Observable
     * @param o5
     *            the fifth source Observable
     * @param o6
     *            the sixth source Observable
     * @param o7
     *            the seventh source Observable
     * @param o8
     *            the eighth source Observable
     * @param combineFunction
     *            the aggregation function used to combine the items emitted by the source Observables
     * @return an Observable that emits items that are the result of combining the items emitted by the source
     *         Observables by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; Observable&lt;R&gt; combineLatest(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Observable&lt;? extends T5&gt; o5, Observable&lt;? extends T6&gt; o6, Observable&lt;? extends T7&gt; o7, Observable&lt;? extends T8&gt; o8,
            Func8&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R&gt; combineFunction) {
<span class="fc" id="L815">        return combineLatest(Arrays.asList(o1, o2, o3, o4, o5, o6, o7, o8), Functions.fromFunc(combineFunction));</span>
    }

    /**
     * Combines nine source Observables by emitting an item that aggregates the latest values of each of the
     * source Observables each time an item is received from any of the source Observables, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            the second source Observable
     * @param o3
     *            the third source Observable
     * @param o4
     *            the fourth source Observable
     * @param o5
     *            the fifth source Observable
     * @param o6
     *            the sixth source Observable
     * @param o7
     *            the seventh source Observable
     * @param o8
     *            the eighth source Observable
     * @param o9
     *            the ninth source Observable
     * @param combineFunction
     *            the aggregation function used to combine the items emitted by the source Observables
     * @return an Observable that emits items that are the result of combining the items emitted by the source
     *         Observables by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; Observable&lt;R&gt; combineLatest(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Observable&lt;? extends T5&gt; o5, Observable&lt;? extends T6&gt; o6, Observable&lt;? extends T7&gt; o7, Observable&lt;? extends T8&gt; o8,
            Observable&lt;? extends T9&gt; o9,
            Func9&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R&gt; combineFunction) {
<span class="fc" id="L857">        return combineLatest(Arrays.asList(o1, o2, o3, o4, o5, o6, o7, o8, o9), Functions.fromFunc(combineFunction));</span>
    }
    /**
     * Combines a list of source Observables by emitting an item that aggregates the latest values of each of
     * the source Observables each time an item is received from any of the source Observables, where this
     * aggregation is defined by a specified function.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the list of source Observables
     * @param combineFunction
     *            the aggregation function used to combine the items emitted by the source Observables
     * @return an Observable that emits items that are the result of combining the items emitted by the source
     *         Observables by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    public static &lt;T, R&gt; Observable&lt;R&gt; combineLatest(List&lt;? extends Observable&lt;? extends T&gt;&gt; sources, FuncN&lt;? extends R&gt; combineFunction) {
<span class="fc" id="L881">        return create(new OnSubscribeCombineLatest&lt;T, R&gt;(sources, combineFunction));</span>
    }

    /**
     * Combines a collection of source Observables by emitting an item that aggregates the latest values of each of
     * the source Observables each time an item is received from any of the source Observables, where this
     * aggregation is defined by a specified function.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Observables
     * @param combineFunction
     *            the aggregation function used to combine the items emitted by the source Observables
     * @return an Observable that emits items that are the result of combining the items emitted by the source
     *         Observables by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    public static &lt;T, R&gt; Observable&lt;R&gt; combineLatest(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources, FuncN&lt;? extends R&gt; combineFunction) {
<span class="nc" id="L906">        return create(new OnSubscribeCombineLatest&lt;T, R&gt;(sources, combineFunction));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by each of the Observables emitted by the source
     * Observable, one after the other, without interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param observables
     *            an Observable that emits Observables
     * @return an Observable that emits items all of the items emitted by the Observables emitted by
     *         {@code observables}, one after the other, without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; observables) {
<span class="fc" id="L926">        return observables.lift(OperatorConcat.&lt;T&gt;instance());</span>
    }

    /**
     * Returns an Observable that emits the items emitted by two Observables, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param t1
     *            an Observable to be concatenated
     * @param t2
     *            an Observable to be concatenated
     * @return an Observable that emits items emitted by the two source Observables, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2) {
<span class="fc" id="L948">        return concat(just(t1, t2));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by three Observables, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param t1
     *            an Observable to be concatenated
     * @param t2
     *            an Observable to be concatenated
     * @param t3
     *            an Observable to be concatenated
     * @return an Observable that emits items emitted by the three source Observables, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3) {
<span class="nc" id="L972">        return concat(just(t1, t2, t3));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by four Observables, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be concatenated
     * @param t2
     *            an Observable to be concatenated
     * @param t3
     *            an Observable to be concatenated
     * @param t4
     *            an Observable to be concatenated
     * @return an Observable that emits items emitted by the four source Observables, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4) {
<span class="nc" id="L998">        return concat(just(t1, t2, t3, t4));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by five Observables, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param t1
     *            an Observable to be concatenated
     * @param t2
     *            an Observable to be concatenated
     * @param t3
     *            an Observable to be concatenated
     * @param t4
     *            an Observable to be concatenated
     * @param t5
     *            an Observable to be concatenated
     * @return an Observable that emits items emitted by the five source Observables, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5) {
<span class="nc" id="L1026">        return concat(just(t1, t2, t3, t4, t5));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by six Observables, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param t1
     *            an Observable to be concatenated
     * @param t2
     *            an Observable to be concatenated
     * @param t3
     *            an Observable to be concatenated
     * @param t4
     *            an Observable to be concatenated
     * @param t5
     *            an Observable to be concatenated
     * @param t6
     *            an Observable to be concatenated
     * @return an Observable that emits items emitted by the six source Observables, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6) {
<span class="nc" id="L1056">        return concat(just(t1, t2, t3, t4, t5, t6));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by seven Observables, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param t1
     *            an Observable to be concatenated
     * @param t2
     *            an Observable to be concatenated
     * @param t3
     *            an Observable to be concatenated
     * @param t4
     *            an Observable to be concatenated
     * @param t5
     *            an Observable to be concatenated
     * @param t6
     *            an Observable to be concatenated
     * @param t7
     *            an Observable to be concatenated
     * @return an Observable that emits items emitted by the seven source Observables, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6, Observable&lt;? extends T&gt; t7) {
<span class="nc" id="L1088">        return concat(just(t1, t2, t3, t4, t5, t6, t7));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by eight Observables, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be concatenated
     * @param t2
     *            an Observable to be concatenated
     * @param t3
     *            an Observable to be concatenated
     * @param t4
     *            an Observable to be concatenated
     * @param t5
     *            an Observable to be concatenated
     * @param t6
     *            an Observable to be concatenated
     * @param t7
     *            an Observable to be concatenated
     * @param t8
     *            an Observable to be concatenated
     * @return an Observable that emits items emitted by the eight source Observables, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6, Observable&lt;? extends T&gt; t7, Observable&lt;? extends T&gt; t8) {
<span class="nc" id="L1122">        return concat(just(t1, t2, t3, t4, t5, t6, t7, t8));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by nine Observables, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be concatenated
     * @param t2
     *            an Observable to be concatenated
     * @param t3
     *            an Observable to be concatenated
     * @param t4
     *            an Observable to be concatenated
     * @param t5
     *            an Observable to be concatenated
     * @param t6
     *            an Observable to be concatenated
     * @param t7
     *            an Observable to be concatenated
     * @param t8
     *            an Observable to be concatenated
     * @param t9
     *            an Observable to be concatenated
     * @return an Observable that emits items emitted by the nine source Observables, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; concat(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6, Observable&lt;? extends T&gt; t7, Observable&lt;? extends T&gt; t8, Observable&lt;? extends T&gt; t9) {
<span class="nc" id="L1158">        return concat(just(t1, t2, t3, t4, t5, t6, t7, t8, t9));</span>
    }

    /**
     * Returns an Observable that calls an Observable factory to create an Observable for each new Observer
     * that subscribes. That is, for each subscriber, the actual Observable that subscriber observes is
     * determined by the factory function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;340&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/defer.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * The defer Observer allows you to defer or delay emitting items from an Observable until such time as an
     * Observer subscribes to the Observable. This allows an {@link Observer} to easily obtain updates or a
     * refreshed version of the sequence.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code defer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param observableFactory
     *            the Observable factory function to invoke for each {@link Observer} that subscribes to the
     *            resulting Observable
     * @param &lt;T&gt;
     *            the type of the items emitted by the Observable
     * @return an Observable whose {@link Observer}s' subscriptions trigger an invocation of the given
     *         Observable factory function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/defer.html&quot;&gt;ReactiveX operators documentation: Defer&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; defer(Func0&lt;Observable&lt;T&gt;&gt; observableFactory) {
<span class="fc" id="L1186">        return create(new OnSubscribeDefer&lt;T&gt;(observableFactory));</span>
    }

    /** Lazy initialized Holder for an empty observable which just emits onCompleted to any subscriber. */
<span class="nc" id="L1190">    private static final class EmptyHolder {</span>
<span class="fc" id="L1191">        final static Observable&lt;Object&gt; INSTANCE = create(new OnSubscribe&lt;Object&gt;() {</span>
            @Override
            public void call(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1194">                subscriber.onCompleted();</span>
<span class="fc" id="L1195">            }</span>
        });
    }
    
    /**
     * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its
     * {@link Observer#onCompleted onCompleted} method.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;190&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/empty.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code empty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the type of the items (ostensibly) emitted by the Observable
     * @return an Observable that emits no items to the {@link Observer} but immediately invokes the
     *         {@link Observer}'s {@link Observer#onCompleted() onCompleted} method
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Empty&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; empty() {
<span class="fc" id="L1217">        return (Observable&lt;T&gt;) EmptyHolder.INSTANCE;</span>
    }

    /**
     * Returns an Observable that invokes an {@link Observer}'s {@link Observer#onError onError} method when the
     * Observer subscribes to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;190&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code error} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param exception
     *            the particular Throwable to pass to {@link Observer#onError onError}
     * @param &lt;T&gt;
     *            the type of the items (ostensibly) emitted by the Observable
     * @return an Observable that invokes the {@link Observer}'s {@link Observer#onError onError} method when
     *         the Observer subscribes to it
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Throw&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; error(Throwable exception) {
<span class="fc" id="L1239">        return new ThrowObservable&lt;T&gt;(exception);</span>
    }

    /**
     * Converts a {@link Future} into an Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into an Observable that emits the
     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}
     * method.
     * &lt;p&gt;
     * &lt;em&gt;Important note:&lt;/em&gt; This Observable is blocking; you cannot unsubscribe from it.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code from} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param future
     *            the source {@link Future}
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting Observable
     * @return an Observable that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; from(Future&lt;? extends T&gt; future) {
<span class="fc" id="L1266">        return create(OnSubscribeToObservableFuture.toObservableFuture(future));</span>
    }

    /**
     * Converts a {@link Future} into an Observable, with a timeout on the Future.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into an Observable that emits the
     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}
     * method.
     * &lt;p&gt;
     * &lt;em&gt;Important note:&lt;/em&gt; This Observable is blocking; you cannot unsubscribe from it.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code from} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param future
     *            the source {@link Future}
     * @param timeout
     *            the maximum time to wait before calling {@code get}
     * @param unit
     *            the {@link TimeUnit} of the {@code timeout} argument
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting Observable
     * @return an Observable that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; from(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit) {
<span class="nc" id="L1297">        return create(OnSubscribeToObservableFuture.toObservableFuture(future, timeout, unit));</span>
    }

    /**
     * Converts a {@link Future}, operating on a specified {@link Scheduler}, into an Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into an Observable that emits the
     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}
     * method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param future
     *            the source {@link Future}
     * @param scheduler
     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as
     *            {@link Schedulers#io()} that can block and wait on the Future
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting Observable
     * @return an Observable that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; from(Future&lt;? extends T&gt; future, Scheduler scheduler) {
        // TODO in a future revision the Scheduler will become important because we'll start polling instead of blocking on the Future
<span class="nc" id="L1326">        return create(OnSubscribeToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);</span>
    }

    /**
     * Converts an {@link Iterable} sequence into an Observable that emits the items in the sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code from} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param iterable
     *            the source {@link Iterable} sequence
     * @param &lt;T&gt;
     *            the type of items in the {@link Iterable} sequence and the type of items to be emitted by the
     *            resulting Observable
     * @return an Observable that emits each item in the source {@link Iterable} sequence
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; from(Iterable&lt;? extends T&gt; iterable) {
<span class="fc" id="L1347">        return create(new OnSubscribeFromIterable&lt;T&gt;(iterable));</span>
    }

    /**
     * Converts an Array into an Observable that emits the items in the Array.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code from} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param array
     *            the source Array
     * @param &lt;T&gt;
     *            the type of items in the Array and the type of items to be emitted by the resulting Observable
     * @return an Observable that emits each item in the source Array
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; from(T[] array) {
<span class="fc" id="L1367">        int n = array.length;</span>
<span class="pc bpc" id="L1368" title="1 of 2 branches missed.">        if (n == 0) {</span>
<span class="nc" id="L1369">            return empty();</span>
        } else
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">        if (n == 1) {</span>
<span class="nc" id="L1372">            return just(array[0]);</span>
        }
<span class="fc" id="L1374">        return create(new OnSubscribeFromArray&lt;T&gt;(array));</span>
    }

    /**
     * Returns an Observable that, when an observer subscribes to it, invokes a function you specify and then
     * emits the value returned from that function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;195&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCallable.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This allows you to defer the execution of the function you specify until an observer subscribes to the
     * Observable. That is to say, it makes the function &quot;lazy.&quot;
     * &lt;dl&gt;
     *   &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *   &lt;dd&gt;{@code fromCallable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param func
     *         a function, the execution of which should be deferred; {@code fromCallable} will invoke this
     *         function only when an observer subscribes to the Observable that {@code fromCallable} returns
     * @param &lt;T&gt;
     *         the type of the item emitted by the Observable
     * @return an Observable whose {@link Observer}s' subscriptions trigger an invocation of the given function
     * @see #defer(Func0)
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    public static &lt;T&gt; Observable&lt;T&gt; fromCallable(Callable&lt;? extends T&gt; func) {
<span class="fc" id="L1401">        return create(new OnSubscribeFromCallable&lt;T&gt;(func));</span>
    }

    /**
     * Returns an Observable that emits a sequential number every specified interval of time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;195&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/interval.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code interval} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param interval
     *            interval size in time units (see below)
     * @param unit
     *            time units to use for the interval size
     * @return an Observable that emits a sequential number each time interval
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/interval.html&quot;&gt;ReactiveX operators documentation: Interval&lt;/a&gt;
     */
    public static Observable&lt;Long&gt; interval(long interval, TimeUnit unit) {
<span class="fc" id="L1421">        return interval(interval, interval, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits a sequential number every specified interval of time, on a
     * specified Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/interval.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param interval
     *            interval size in time units (see below)
     * @param unit
     *            time units to use for the interval size
     * @param scheduler
     *            the Scheduler to use for scheduling the items
     * @return an Observable that emits a sequential number each time interval
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/interval.html&quot;&gt;ReactiveX operators documentation: Interval&lt;/a&gt;
     */
    public static Observable&lt;Long&gt; interval(long interval, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L1444">        return interval(interval, interval, unit, scheduler);</span>
    }

    /**
     * Returns an Observable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers
     * after each {@code period} of time thereafter.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. If the downstream needs a slower rate
     *      it should slow the timer or use something like {@link #onBackpressureDrop}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code interval} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param initialDelay
     *            the initial delay time to wait before emitting the first value of 0L
     * @param period
     *            the period of time between emissions of the subsequent numbers
     * @param unit
     *            the time unit for both {@code initialDelay} and {@code period}
     * @return an Observable that emits a 0L after the {@code initialDelay} and ever increasing numbers after
     *         each {@code period} of time thereafter
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/interval.html&quot;&gt;ReactiveX operators documentation: Interval&lt;/a&gt;
     * @since 1.0.12
     */
    public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit) {
<span class="fc" id="L1472">        return interval(initialDelay, period, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers
     * after each {@code period} of time thereafter, on a specified {@link Scheduler}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.ps.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. If the downstream needs a slower rate
     *      it should slow the timer or use something like {@link #onBackpressureDrop}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param initialDelay
     *            the initial delay time to wait before emitting the first value of 0L
     * @param period
     *            the period of time between emissions of the subsequent numbers
     * @param unit
     *            the time unit for both {@code initialDelay} and {@code period}
     * @param scheduler
     *            the Scheduler on which the waiting happens and items are emitted
     * @return an Observable that emits a 0L after the {@code initialDelay} and ever increasing numbers after
     *         each {@code period} of time thereafter, while running on the given Scheduler
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/interval.html&quot;&gt;ReactiveX operators documentation: Interval&lt;/a&gt;
     * @since 1.0.12
     */
    public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L1502">        return create(new OnSubscribeTimerPeriodically(initialDelay, period, unit, scheduler));</span>
    }

    /**
     * Returns an Observable that emits a single item and then completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * To convert any object into an Observable that emits that object, pass that object into the {@code just}
     * method.
     * &lt;p&gt;
     * This is similar to the {@link #from(java.lang.Object[])} method, except that {@code from} will convert
     * an {@link Iterable} object into an Observable that emits each of the items in the Iterable, one at a
     * time, while the {@code just} method converts an Iterable into an Observable that emits the entire
     * Iterable as a single item.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param value
     *            the item to emit
     * @param &lt;T&gt;
     *            the type of that item
     * @return an Observable that emits {@code value} as a single item and then completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; just(final T value) {
<span class="fc" id="L1530">        return ScalarSynchronousObservable.create(value);</span>
    }
    
    /**
     * Converts two items into an Observable that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            first item
     * @param t2
     *            second item
     * @param &lt;T&gt;
     *            the type of these items
     * @return an Observable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    // suppress unchecked because we are using varargs inside the method
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2) {
<span class="fc" id="L1554">        return from((T[])new Object[] { t1, t2 });</span>
    }

    /**
     * Converts three items into an Observable that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            first item
     * @param t2
     *            second item
     * @param t3
     *            third item
     * @param &lt;T&gt;
     *            the type of these items
     * @return an Observable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    // suppress unchecked because we are using varargs inside the method
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2, T t3) {
<span class="fc" id="L1580">        return from((T[])new Object[] { t1, t2, t3 });</span>
    }

    /**
     * Converts four items into an Observable that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            first item
     * @param t2
     *            second item
     * @param t3
     *            third item
     * @param t4
     *            fourth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return an Observable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    // suppress unchecked because we are using varargs inside the method
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2, T t3, T t4) {
<span class="fc" id="L1608">        return from((T[])new Object[] { t1, t2, t3, t4 });</span>
    }

    /**
     * Converts five items into an Observable that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param t1
     *            first item
     * @param t2
     *            second item
     * @param t3
     *            third item
     * @param t4
     *            fourth item
     * @param t5
     *            fifth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return an Observable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    // suppress unchecked because we are using varargs inside the method
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2, T t3, T t4, T t5) {
<span class="fc" id="L1638">        return from((T[])new Object[] { t1, t2, t3, t4, t5 });</span>
    }

    /**
     * Converts six items into an Observable that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            first item
     * @param t2
     *            second item
     * @param t3
     *            third item
     * @param t4
     *            fourth item
     * @param t5
     *            fifth item
     * @param t6
     *            sixth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return an Observable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    // suppress unchecked because we are using varargs inside the method
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2, T t3, T t4, T t5, T t6) {
<span class="fc" id="L1670">        return from((T[])new Object[] { t1, t2, t3, t4, t5, t6 });</span>
    }

    /**
     * Converts seven items into an Observable that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            first item
     * @param t2
     *            second item
     * @param t3
     *            third item
     * @param t4
     *            fourth item
     * @param t5
     *            fifth item
     * @param t6
     *            sixth item
     * @param t7
     *            seventh item
     * @param &lt;T&gt;
     *            the type of these items
     * @return an Observable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    // suppress unchecked because we are using varargs inside the method
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2, T t3, T t4, T t5, T t6, T t7) {
<span class="fc" id="L1704">        return from((T[])new Object[] { t1, t2, t3, t4, t5, t6, t7 });</span>
    }

    /**
     * Converts eight items into an Observable that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            first item
     * @param t2
     *            second item
     * @param t3
     *            third item
     * @param t4
     *            fourth item
     * @param t5
     *            fifth item
     * @param t6
     *            sixth item
     * @param t7
     *            seventh item
     * @param t8
     *            eighth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return an Observable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    // suppress unchecked because we are using varargs inside the method
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8) {
<span class="fc" id="L1740">        return from((T[])new Object[] { t1, t2, t3, t4, t5, t6, t7, t8 });</span>
    }

    /**
     * Converts nine items into an Observable that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            first item
     * @param t2
     *            second item
     * @param t3
     *            third item
     * @param t4
     *            fourth item
     * @param t5
     *            fifth item
     * @param t6
     *            sixth item
     * @param t7
     *            seventh item
     * @param t8
     *            eighth item
     * @param t9
     *            ninth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return an Observable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    // suppress unchecked because we are using varargs inside the method
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9) {
<span class="fc" id="L1778">        return from((T[])new Object[] { t1, t2, t3, t4, t5, t6, t7, t8, t9 });</span>
    }

    /**
     * Converts ten items into an Observable that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            first item
     * @param t2
     *            second item
     * @param t3
     *            third item
     * @param t4
     *            fourth item
     * @param t5
     *            fifth item
     * @param t6
     *            sixth item
     * @param t7
     *            seventh item
     * @param t8
     *            eighth item
     * @param t9
     *            ninth item
     * @param t10
     *            tenth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return an Observable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    // suppress unchecked because we are using varargs inside the method
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9, T t10) {
<span class="fc" id="L1818">        return from((T[])new Object[] { t1, t2, t3, t4, t5, t6, t7, t8, t9, t10 });</span>
    }
    
    /**
     * Flattens an Iterable of Observables into one Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param sequences
     *            the Iterable of Observables
     * @return an Observable that emits items that are the result of flattening the items emitted by the
     *         Observables in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; merge(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sequences) {
<span class="fc" id="L1840">        return merge(from(sequences));</span>
    }

    /**
     * Flattens an Iterable of Observables into one Observable, without any transformation, while limiting the
     * number of concurrent subscriptions to these Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param sequences
     *            the Iterable of Observables
     * @param maxConcurrent
     *            the maximum number of Observables that may be subscribed to concurrently
     * @return an Observable that emits items that are the result of flattening the items emitted by the
     *         Observables in the Iterable
     * @throws IllegalArgumentException
     *             if {@code maxConcurrent} is less than or equal to 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; merge(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sequences, int maxConcurrent) {
<span class="fc" id="L1867">        return merge(from(sequences), maxConcurrent);</span>
    }

    /**
     * Flattens an Observable that emits Observables into a single Observable that emits the items emitted by
     * those Observables, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.oo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param source
     *            an Observable that emits Observables
     * @return an Observable that emits items that are the result of flattening the Observables emitted by the
     *         {@code source} Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; source) {
<span class="fc bfc" id="L1891" title="All 2 branches covered.">        if (source.getClass() == ScalarSynchronousObservable.class) {</span>
<span class="fc" id="L1892">            return ((ScalarSynchronousObservable&lt;T&gt;)source).scalarFlatMap((Func1)UtilityFunctions.identity());</span>
        }
<span class="fc" id="L1894">        return source.lift(OperatorMerge.&lt;T&gt;instance(false));</span>
    }

    /**
     * Flattens an Observable that emits Observables into a single Observable that emits the items emitted by
     * those Observables, without any transformation, while limiting the maximum number of concurrent
     * subscriptions to these Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.oo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine the items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param source
     *            an Observable that emits Observables
     * @param maxConcurrent
     *            the maximum number of Observables that may be subscribed to concurrently
     * @return an Observable that emits items that are the result of flattening the Observables emitted by the
     *         {@code source} Observable
     * @throws IllegalArgumentException
     *             if {@code maxConcurrent} is less than or equal to 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @since 1.1.0
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; source, int maxConcurrent) {
<span class="pc bpc" id="L1924" title="1 of 2 branches missed.">        if (source.getClass() == ScalarSynchronousObservable.class) {</span>
<span class="nc" id="L1925">            return ((ScalarSynchronousObservable&lt;T&gt;)source).scalarFlatMap((Func1)UtilityFunctions.identity());</span>
        }
<span class="fc" id="L1927">        return source.lift(OperatorMerge.&lt;T&gt;instance(false, maxConcurrent));</span>
    }

    /**
     * Flattens two Observables into a single Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @return an Observable that emits all of the items emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2) {
<span class="fc" id="L1951">        return merge(new Observable[] { t1, t2 });</span>
    }

    /**
     * Flattens three Observables into a single Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @return an Observable that emits all of the items emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3) {
<span class="fc" id="L1977">        return merge(new Observable[] { t1, t2, t3 });</span>
    }

    /**
     * Flattens four Observables into a single Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @return an Observable that emits all of the items emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4) {
<span class="fc" id="L2005">        return merge(new Observable[] { t1, t2, t3, t4 });</span>
    }

    /**
     * Flattens five Observables into a single Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @param t5
     *            an Observable to be merged
     * @return an Observable that emits all of the items emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5) {
<span class="nc" id="L2035">        return merge(new Observable[] { t1, t2, t3, t4, t5 });</span>
    }

    /**
     * Flattens six Observables into a single Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @param t5
     *            an Observable to be merged
     * @param t6
     *            an Observable to be merged
     * @return an Observable that emits all of the items emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6) {
<span class="nc" id="L2067">        return merge(new Observable[] { t1, t2, t3, t4, t5, t6 });</span>
    }

    /**
     * Flattens seven Observables into a single Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @param t5
     *            an Observable to be merged
     * @param t6
     *            an Observable to be merged
     * @param t7
     *            an Observable to be merged
     * @return an Observable that emits all of the items emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6, Observable&lt;? extends T&gt; t7) {
<span class="nc" id="L2101">        return merge(new Observable[] { t1, t2, t3, t4, t5, t6, t7 });</span>
    }

    /**
     * Flattens eight Observables into a single Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @param t5
     *            an Observable to be merged
     * @param t6
     *            an Observable to be merged
     * @param t7
     *            an Observable to be merged
     * @param t8
     *            an Observable to be merged
     * @return an Observable that emits all of the items emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6, Observable&lt;? extends T&gt; t7, Observable&lt;? extends T&gt; t8) {
<span class="nc" id="L2137">        return merge(new Observable[] { t1, t2, t3, t4, t5, t6, t7, t8 });</span>
    }

    /**
     * Flattens nine Observables into a single Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @param t5
     *            an Observable to be merged
     * @param t6
     *            an Observable to be merged
     * @param t7
     *            an Observable to be merged
     * @param t8
     *            an Observable to be merged
     * @param t9
     *            an Observable to be merged
     * @return an Observable that emits all of the items emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6, Observable&lt;? extends T&gt; t7, Observable&lt;? extends T&gt; t8, Observable&lt;? extends T&gt; t9) {
<span class="nc" id="L2175">        return merge(new Observable[] { t1, t2, t3, t4, t5, t6, t7, t8, t9 });</span>
    }

    /**
     * Flattens an Array of Observables into one Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.io.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param sequences
     *            the Array of Observables
     * @return an Observable that emits all of the items emitted by the Observables in the Array
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends T&gt;[] sequences) {
<span class="fc" id="L2196">        return merge(from(sequences));</span>
    }
    
    /**
     * Flattens an Array of Observables into one Observable, without any transformation, while limiting the
     * number of concurrent subscriptions to these Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.io.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param sequences
     *            the Array of Observables
     * @param maxConcurrent
     *            the maximum number of Observables that may be subscribed to concurrently
     * @return an Observable that emits all of the items emitted by the Observables in the Array
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @since 1.1.0
     */
    public static &lt;T&gt; Observable&lt;T&gt; merge(Observable&lt;? extends T&gt;[] sequences, int maxConcurrent) {
<span class="nc" id="L2221">        return merge(from(sequences), maxConcurrent);</span>
    }

    /**
     * Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to
     * receive all successfully emitted items from all of the source Observables without being interrupted by
     * an error notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable)} except that if any of the merged Observables notify of an
     * error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Observables have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param source
     *            an Observable that emits Observables
     * @return an Observable that emits all of the items emitted by the Observables emitted by the
     *         {@code source} Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; source) {
<span class="fc" id="L2249">        return source.lift(OperatorMerge.&lt;T&gt;instance(true));</span>
    }

    /**
     * Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to
     * receive all successfully emitted items from all of the source Observables without being interrupted by
     * an error notification from one of them, while limiting the
     * number of concurrent subscriptions to these Observables.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable)} except that if any of the merged Observables notify of an
     * error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Observables have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param source
     *            an Observable that emits Observables
     * @param maxConcurrent
     *            the maximum number of Observables that may be subscribed to concurrently
     * @return an Observable that emits all of the items emitted by the Observables emitted by the
     *         {@code source} Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; source, int maxConcurrent) {
<span class="fc" id="L2282">        return source.lift(OperatorMerge.&lt;T&gt;instance(true, maxConcurrent));</span>
    }

   /**
     * Flattens an Iterable of Observables into one Observable, in a way that allows an Observer to receive all
     * successfully emitted items from each of the source Observables without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable)} except that if any of the merged Observables notify of an
     * error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Observables have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param sequences
     *            the Iterable of Observables
     * @return an Observable that emits items that are the result of flattening the items emitted by the
     *         Observables in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sequences) {
<span class="fc" id="L2310">        return mergeDelayError(from(sequences));</span>
    }

   /**
     * Flattens an Iterable of Observables into one Observable, in a way that allows an Observer to receive all
     * successfully emitted items from each of the source Observables without being interrupted by an error
     * notification from one of them, while limiting the number of concurrent subscriptions to these Observables.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable)} except that if any of the merged Observables notify of an
     * error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Observables have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param sequences
     *            the Iterable of Observables
     * @param maxConcurrent
     *            the maximum number of Observables that may be subscribed to concurrently
     * @return an Observable that emits items that are the result of flattening the items emitted by the
     *         Observables in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sequences, int maxConcurrent) {
<span class="nc" id="L2340">        return mergeDelayError(from(sequences), maxConcurrent);</span>
    }


    /**
     * Flattens two Observables into one Observable, in a way that allows an Observer to receive all
     * successfully emitted items from each of the source Observables without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable, Observable)} except that if any of the merged Observables
     * notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from
     * propagating that error notification until all of the merged Observables have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if both merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @return an Observable that emits all of the items that are emitted by the two source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2) {
<span class="fc" id="L2370">        return mergeDelayError(just(t1, t2));</span>
    }

    /**
     * Flattens three Observables into one Observable, in a way that allows an Observer to receive all
     * successfully emitted items from all of the source Observables without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable, Observable, Observable)} except that if any of the merged
     * Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain
     * from propagating that error notification until all of the merged Observables have finished emitting
     * items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @return an Observable that emits all of the items that are emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3) {
<span class="fc" id="L2402">        return mergeDelayError(just(t1, t2, t3));</span>
    }

    /**
     * Flattens four Observables into one Observable, in a way that allows an Observer to receive all
     * successfully emitted items from all of the source Observables without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable, Observable, Observable, Observable)} except that if any of
     * the merged Observables notify of an error via {@link Observer#onError onError}, {@code mergeDelayError}
     * will refrain from propagating that error notification until all of the merged Observables have finished
     * emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @return an Observable that emits all of the items that are emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4) {
<span class="fc" id="L2436">        return mergeDelayError(just(t1, t2, t3, t4));</span>
    }

    /**
     * Flattens five Observables into one Observable, in a way that allows an Observer to receive all
     * successfully emitted items from all of the source Observables without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable)} except that
     * if any of the merged Observables notify of an error via {@link Observer#onError onError},
     * {@code mergeDelayError} will refrain from propagating that error notification until all of the merged
     * Observables have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @param t5
     *            an Observable to be merged
     * @return an Observable that emits all of the items that are emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5) {
<span class="nc" id="L2472">        return mergeDelayError(just(t1, t2, t3, t4, t5));</span>
    }

    /**
     * Flattens six Observables into one Observable, in a way that allows an Observer to receive all
     * successfully emitted items from all of the source Observables without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable)}
     * except that if any of the merged Observables notify of an error via {@link Observer#onError onError},
     * {@code mergeDelayError} will refrain from propagating that error notification until all of the merged
     * Observables have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @param t5
     *            an Observable to be merged
     * @param t6
     *            an Observable to be merged
     * @return an Observable that emits all of the items that are emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6) {
<span class="nc" id="L2510">        return mergeDelayError(just(t1, t2, t3, t4, t5, t6));</span>
    }

    /**
     * Flattens seven Observables into one Observable, in a way that allows an Observer to receive all
     * successfully emitted items from all of the source Observables without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like
     * {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable)}
     * except that if any of the merged Observables notify of an error via {@link Observer#onError onError},
     * {@code mergeDelayError} will refrain from propagating that error notification until all of the merged
     * Observables have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @param t5
     *            an Observable to be merged
     * @param t6
     *            an Observable to be merged
     * @param t7
     *            an Observable to be merged
     * @return an Observable that emits all of the items that are emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6, Observable&lt;? extends T&gt; t7) {
<span class="nc" id="L2551">        return mergeDelayError(just(t1, t2, t3, t4, t5, t6, t7));</span>
    }

    /**
     * Flattens eight Observables into one Observable, in a way that allows an Observer to receive all
     * successfully emitted items from all of the source Observables without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable)}
     * except that if any of the merged Observables notify of an error via {@link Observer#onError onError},
     * {@code mergeDelayError} will refrain from propagating that error notification until all of the merged
     * Observables have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @param t5
     *            an Observable to be merged
     * @param t6
     *            an Observable to be merged
     * @param t7
     *            an Observable to be merged
     * @param t8
     *            an Observable to be merged
     * @return an Observable that emits all of the items that are emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    // suppress because the types are checked by the method signature before using a vararg
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6, Observable&lt;? extends T&gt; t7, Observable&lt;? extends T&gt; t8) {
<span class="nc" id="L2594">        return mergeDelayError(just(t1, t2, t3, t4, t5, t6, t7, t8));</span>
    }

    /**
     * Flattens nine Observables into one Observable, in a way that allows an Observer to receive all
     * successfully emitted items from all of the source Observables without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable)}
     * except that if any of the merged Observables notify of an error via {@link Observer#onError onError},
     * {@code mergeDelayError} will refrain from propagating that error notification until all of the merged
     * Observables have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Observables send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Observers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @param t2
     *            an Observable to be merged
     * @param t3
     *            an Observable to be merged
     * @param t4
     *            an Observable to be merged
     * @param t5
     *            an Observable to be merged
     * @param t6
     *            an Observable to be merged
     * @param t7
     *            an Observable to be merged
     * @param t8
     *            an Observable to be merged
     * @param t9
     *            an Observable to be merged
     * @return an Observable that emits all of the items that are emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; mergeDelayError(Observable&lt;? extends T&gt; t1, Observable&lt;? extends T&gt; t2, Observable&lt;? extends T&gt; t3, Observable&lt;? extends T&gt; t4, Observable&lt;? extends T&gt; t5, Observable&lt;? extends T&gt; t6, Observable&lt;? extends T&gt; t7, Observable&lt;? extends T&gt; t8, Observable&lt;? extends T&gt; t9) {
<span class="nc" id="L2638">        return mergeDelayError(just(t1, t2, t3, t4, t5, t6, t7, t8, t9));</span>
    }

    /**
     * Converts the source {@code Observable&lt;T&gt;} into an {@code Observable&lt;Observable&lt;T&gt;&gt;} that emits the
     * source Observable as its single emission.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;350&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/nest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code nest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits a single item: the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final Observable&lt;Observable&lt;T&gt;&gt; nest() {
<span class="fc" id="L2655">        return just(this);</span>
    }

    /**
     * Returns an Observable that never sends any items or notifications to an {@link Observer}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;185&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/never.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This Observable is useful primarily for testing purposes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code never} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;T&gt;
     *            the type of items (not) emitted by the Observable
     * @return an Observable that never emits any items or sends any notifications to an {@link Observer}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Never&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; never() {
<span class="fc" id="L2675">        return NeverObservable.instance();</span>
    }

    /**
     * Returns an Observable that emits a sequence of Integers within a specified range.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;195&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/range.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code range} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param start
     *            the value of the first Integer in the sequence
     * @param count
     *            the number of sequential Integers to generate
     * @return an Observable that emits a range of sequential Integers
     * @throws IllegalArgumentException
     *             if {@code count} is less than zero, or if {@code start} + {@code count} &amp;minus; 1 exceeds
     *             {@code Integer.MAX_VALUE}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/range.html&quot;&gt;ReactiveX operators documentation: Range&lt;/a&gt;
     */
    public static Observable&lt;Integer&gt; range(int start, int count) {
<span class="pc bpc" id="L2698" title="1 of 2 branches missed.">        if (count &lt; 0) {</span>
<span class="nc" id="L2699">            throw new IllegalArgumentException(&quot;Count can not be negative&quot;);</span>
        }
<span class="fc bfc" id="L2701" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L2702">            return Observable.empty();</span>
        }
<span class="fc bfc" id="L2704" title="All 2 branches covered.">        if (start &gt; Integer.MAX_VALUE - count + 1) {</span>
<span class="fc" id="L2705">            throw new IllegalArgumentException(&quot;start + count can not exceed Integer.MAX_VALUE&quot;);</span>
        }
<span class="fc bfc" id="L2707" title="All 2 branches covered.">        if(count == 1) {</span>
<span class="fc" id="L2708">            return Observable.just(start);</span>
        }
<span class="fc" id="L2710">        return Observable.create(new OnSubscribeRange(start, start + (count - 1)));</span>
    }

    /**
     * Returns an Observable that emits a sequence of Integers within a specified range, on a specified
     * Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;195&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/range.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param start
     *            the value of the first Integer in the sequence
     * @param count
     *            the number of sequential Integers to generate
     * @param scheduler
     *            the Scheduler to run the generator loop on
     * @return an Observable that emits a range of sequential Integers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/range.html&quot;&gt;ReactiveX operators documentation: Range&lt;/a&gt;
     */
    public static Observable&lt;Integer&gt; range(int start, int count, Scheduler scheduler) {
<span class="fc" id="L2733">        return range(start, count).subscribeOn(scheduler);</span>
    }

    /**
     * Returns an Observable that emits a Boolean value that indicates whether two Observable sequences are the
     * same by comparing the items emitted by each Observable pairwise.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param first
     *            the first Observable to compare
     * @param second
     *            the second Observable to compare
     * @param &lt;T&gt;
     *            the type of items emitted by each Observable
     * @return an Observable that emits a Boolean value that indicates whether the two sequences are the same
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sequenceequal.html&quot;&gt;ReactiveX operators documentation: SequenceEqual&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;Boolean&gt; sequenceEqual(Observable&lt;? extends T&gt; first, Observable&lt;? extends T&gt; second) {
<span class="fc" id="L2756">        return sequenceEqual(first, second, new Func2&lt;T, T, Boolean&gt;() {</span>
            @Override
            public final Boolean call(T first, T second) {
<span class="fc bfc" id="L2759" title="All 2 branches covered.">                if (first == null) {</span>
<span class="fc bfc" id="L2760" title="All 2 branches covered.">                    return second == null;</span>
                }
<span class="fc" id="L2762">                return first.equals(second);</span>
            }
        });
    }

    /**
     * Returns an Observable that emits a Boolean value that indicates whether two Observable sequences are the
     * same by comparing the items emitted by each Observable pairwise based on the results of a specified
     * equality function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param first
     *            the first Observable to compare
     * @param second
     *            the second Observable to compare
     * @param equality
     *            a function used to compare items emitted by each Observable
     * @param &lt;T&gt;
     *            the type of items emitted by each Observable
     * @return an Observable that emits a Boolean value that indicates whether the two Observable two sequences
     *         are the same according to the specified function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sequenceequal.html&quot;&gt;ReactiveX operators documentation: SequenceEqual&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;Boolean&gt; sequenceEqual(Observable&lt;? extends T&gt; first, Observable&lt;? extends T&gt; second, Func2&lt;? super T, ? super T, Boolean&gt; equality) {
<span class="fc" id="L2791">        return OperatorSequenceEqual.sequenceEqual(first, second, equality);</span>
    }

    /**
     * Converts an Observable that emits Observables into an Observable that emits the items emitted by the
     * most recently emitted of those Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code switchOnNext} subscribes to an Observable that emits Observables. Each time it observes one of
     * these emitted Observables, the Observable returned by {@code switchOnNext} begins emitting the items
     * emitted by that Observable. When a new Observable is emitted, {@code switchOnNext} stops emitting items
     * from the earlier-emitted Observable and begins emitting items from the new one.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;T&gt; the item type
     * @param sequenceOfSequences
     *            the source Observable that emits Observables
     * @return an Observable that emits the items emitted by the Observable most recently emitted by the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/switch.html&quot;&gt;ReactiveX operators documentation: Switch&lt;/a&gt;
     */
    public static &lt;T&gt; Observable&lt;T&gt; switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; sequenceOfSequences) {
<span class="fc" id="L2817">        return sequenceOfSequences.lift(OperatorSwitch.&lt;T&gt;instance());</span>
    }

    /**
     * Returns an Observable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers
     * after each {@code period} of time thereafter.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. If the downstream needs a slower rate
     *      it should slow the timer or use something like {@link #onBackpressureDrop}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param initialDelay
     *            the initial delay time to wait before emitting the first value of 0L
     * @param period
     *            the period of time between emissions of the subsequent numbers
     * @param unit
     *            the time unit for both {@code initialDelay} and {@code period}
     * @return an Observable that emits a 0L after the {@code initialDelay} and ever increasing numbers after
     *         each {@code period} of time thereafter
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timer.html&quot;&gt;ReactiveX operators documentation: Timer&lt;/a&gt;
     * @deprecated use {@link #interval(long, long, TimeUnit)} instead
     */
    @Deprecated
    public static Observable&lt;Long&gt; timer(long initialDelay, long period, TimeUnit unit) {
<span class="nc" id="L2846">        return interval(initialDelay, period, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbers
     * after each {@code period} of time thereafter, on a specified {@link Scheduler}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.ps.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. If the downstream needs a slower rate
     *      it should slow the timer or use something like {@link #onBackpressureDrop}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param initialDelay
     *            the initial delay time to wait before emitting the first value of 0L
     * @param period
     *            the period of time between emissions of the subsequent numbers
     * @param unit
     *            the time unit for both {@code initialDelay} and {@code period}
     * @param scheduler
     *            the Scheduler on which the waiting happens and items are emitted
     * @return an Observable that emits a 0L after the {@code initialDelay} and ever increasing numbers after
     *         each {@code period} of time thereafter, while running on the given Scheduler
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timer.html&quot;&gt;ReactiveX operators documentation: Timer&lt;/a&gt;
     * @deprecated use {@link #interval(long, long, TimeUnit, Scheduler)} instead
     */
    @Deprecated
    public static Observable&lt;Long&gt; timer(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
<span class="nc" id="L2877">        return interval(initialDelay, period, unit, scheduler);</span>
    }

    /**
     * Returns an Observable that emits one item after a specified delay, and then completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. If the downstream needs a slower rate
     *      it should slow the timer or use something like {@link #onBackpressureDrop}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param delay
     *            the initial delay before emitting a single {@code 0L}
     * @param unit
     *            time units to use for {@code delay}
     * @return an Observable that emits one item after a specified delay, and then completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timer.html&quot;&gt;ReactiveX operators documentation: Timer&lt;/a&gt;
     */
    public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit) {
<span class="fc" id="L2900">        return timer(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits one item after a specified delay, on a specified Scheduler, and then
     * completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. If the downstream needs a slower rate
     *      it should slow the timer or use something like {@link #onBackpressureDrop}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param delay
     *            the initial delay before emitting a single 0L
     * @param unit
     *            time units to use for {@code delay}
     * @param scheduler
     *            the {@link Scheduler} to use for scheduling the item
     * @return an Observable that emits one item after a specified delay, on a specified Scheduler, and then
     *         completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timer.html&quot;&gt;ReactiveX operators documentation: Timer&lt;/a&gt;
     */
    public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L2927">        return create(new OnSubscribeTimerOnce(delay, unit, scheduler));</span>
    }

    /**
     * Constructs an Observable that creates a dependent resource object which is disposed of on unsubscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/using.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code using} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param resourceFactory
     *            the factory function to create a resource object that depends on the Observable
     * @param observableFactory
     *            the factory function to create an Observable
     * @param disposeAction
     *            the function that will dispose of the resource
     * @return the Observable whose lifetime controls the lifetime of the dependent resource object
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/using.html&quot;&gt;ReactiveX operators documentation: Using&lt;/a&gt;
     */
    public static &lt;T, Resource&gt; Observable&lt;T&gt; using(
            final Func0&lt;Resource&gt; resourceFactory,
            final Func1&lt;? super Resource, ? extends Observable&lt;? extends T&gt;&gt; observableFactory,
            final Action1&lt;? super Resource&gt; disposeAction) {
<span class="fc" id="L2952">        return using(resourceFactory, observableFactory, disposeAction, false);</span>
    }
    
    /**
     * Constructs an Observable that creates a dependent resource object which is disposed of just before 
     * termination if you have set {@code disposeEagerly} to {@code true} and unsubscription does not occur
     * before termination. Otherwise resource disposal will occur on unsubscription.  Eager disposal is
     * particularly appropriate for a synchronous Observable that resuses resources. {@code disposeAction} will
     * only be called once per subscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/using.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code using} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @warn &quot;Backpressure Support&quot; section missing from javadoc
     * @param resourceFactory
     *            the factory function to create a resource object that depends on the Observable
     * @param observableFactory
     *            the factory function to create an Observable
     * @param disposeAction
     *            the function that will dispose of the resource
     * @param disposeEagerly
     *            if {@code true} then disposal will happen either on unsubscription or just before emission of 
     *            a terminal event ({@code onComplete} or {@code onError}).
     * @return the Observable whose lifetime controls the lifetime of the dependent resource object
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/using.html&quot;&gt;ReactiveX operators documentation: Using&lt;/a&gt;
     * @Experimental The behavior of this can change at any time.
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    public static &lt;T, Resource&gt; Observable&lt;T&gt; using(
            final Func0&lt;Resource&gt; resourceFactory,
            final Func1&lt;? super Resource, ? extends Observable&lt;? extends T&gt;&gt; observableFactory,
            final Action1&lt;? super Resource&gt; disposeAction, boolean disposeEagerly) {
<span class="fc" id="L2988">        return create(new OnSubscribeUsing&lt;T, Resource&gt;(resourceFactory, observableFactory, disposeAction, disposeEagerly));</span>
    }

    /**
     * Returns an Observable that emits the results of a specified combiner function applied to combinations of
     * items emitted, in sequence, by an Iterable of other Observables.
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable
     * will be the result of the function applied to the first item emitted by each of the source Observables;
     * the second item emitted by the new Observable will be the result of the function applied to the second
     * item emitted by each of those Observables; and so forth.
     * &lt;p&gt;
     * The resulting {@code Observable&lt;R&gt;} returned from {@code zip} will invoke {@code onNext} as many times as
     * the number of {@code onNext} invokations of the source Observable that emits the fewest items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param ws
     *            an Iterable of source Observables
     * @param zipFunction
     *            a function that, when applied to an item emitted by each of the source Observables, results in
     *            an item that will be emitted by the resulting Observable
     * @return an Observable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public static &lt;R&gt; Observable&lt;R&gt; zip(Iterable&lt;? extends Observable&lt;?&gt;&gt; ws, FuncN&lt;? extends R&gt; zipFunction) {
<span class="fc" id="L3018">        List&lt;Observable&lt;?&gt;&gt; os = new ArrayList&lt;Observable&lt;?&gt;&gt;();</span>
<span class="fc bfc" id="L3019" title="All 2 branches covered.">        for (Observable&lt;?&gt; o : ws) {</span>
<span class="fc" id="L3020">            os.add(o);</span>
<span class="fc" id="L3021">        }</span>
<span class="fc" id="L3022">        return Observable.just(os.toArray(new Observable&lt;?&gt;[os.size()])).lift(new OperatorZip&lt;R&gt;(zipFunction));</span>
    }

    /**
     * Returns an Observable that emits the results of a specified combiner function applied to combinations of
     * &lt;i&gt;n&lt;/i&gt; items emitted, in sequence, by the &lt;i&gt;n&lt;/i&gt; Observables emitted by a specified Observable.
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable
     * will be the result of the function applied to the first item emitted by each of the Observables emitted
     * by the source Observable; the second item emitted by the new Observable will be the result of the
     * function applied to the second item emitted by each of those Observables; and so forth.
     * &lt;p&gt;
     * The resulting {@code Observable&lt;R&gt;} returned from {@code zip} will invoke {@code onNext} as many times as
     * the number of {@code onNext} invokations of the source Observable that emits the fewest items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param ws
     *            an Observable of source Observables
     * @param zipFunction
     *            a function that, when applied to an item emitted by each of the Observables emitted by
     *            {@code ws}, results in an item that will be emitted by the resulting Observable
     * @return an Observable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public static &lt;R&gt; Observable&lt;R&gt; zip(Observable&lt;? extends Observable&lt;?&gt;&gt; ws, final FuncN&lt;? extends R&gt; zipFunction) {
<span class="fc" id="L3052">        return ws.toList().map(new Func1&lt;List&lt;? extends Observable&lt;?&gt;&gt;, Observable&lt;?&gt;[]&gt;() {</span>

            @Override
            public Observable&lt;?&gt;[] call(List&lt;? extends Observable&lt;?&gt;&gt; o) {
<span class="fc" id="L3056">                return o.toArray(new Observable&lt;?&gt;[o.size()]);</span>
            }

        }).lift(new OperatorZip&lt;R&gt;(zipFunction));
    }

    /**
     * Returns an Observable that emits the results of a specified combiner function applied to combinations of
     * two items emitted, in sequence, by two other Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable
     * will be the result of the function applied to the first item emitted by {@code o1} and the first item
     * emitted by {@code o2}; the second item emitted by the new Observable will be the result of the function
     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.
     * &lt;p&gt;
     * The resulting {@code Observable&lt;R&gt;} returned from {@code zip} will invoke {@link Observer#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Observable that emits the fewest
     * items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            a second source Observable
     * @param zipFunction
     *            a function that, when applied to an item emitted by each of the source Observables, results
     *            in an item that will be emitted by the resulting Observable
     * @return an Observable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public static &lt;T1, T2, R&gt; Observable&lt;R&gt; zip(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, final Func2&lt;? super T1, ? super T2, ? extends R&gt; zipFunction) {
<span class="fc" id="L3092">        return just(new Observable&lt;?&gt;[] { o1, o2 }).lift(new OperatorZip&lt;R&gt;(zipFunction));</span>
    }

    /**
     * Returns an Observable that emits the results of a specified combiner function applied to combinations of
     * three items emitted, in sequence, by three other Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable
     * will be the result of the function applied to the first item emitted by {@code o1}, the first item
     * emitted by {@code o2}, and the first item emitted by {@code o3}; the second item emitted by the new
     * Observable will be the result of the function applied to the second item emitted by {@code o1}, the
     * second item emitted by {@code o2}, and the second item emitted by {@code o3}; and so forth.
     * &lt;p&gt;
     * The resulting {@code Observable&lt;R&gt;} returned from {@code zip} will invoke {@link Observer#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Observable that emits the fewest
     * items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            a second source Observable
     * @param o3
     *            a third source Observable
     * @param zipFunction
     *            a function that, when applied to an item emitted by each of the source Observables, results in
     *            an item that will be emitted by the resulting Observable
     * @return an Observable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public static &lt;T1, T2, T3, R&gt; Observable&lt;R&gt; zip(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Func3&lt;? super T1, ? super T2, ? super T3, ? extends R&gt; zipFunction) {
<span class="fc" id="L3128">        return just(new Observable&lt;?&gt;[] { o1, o2, o3 }).lift(new OperatorZip&lt;R&gt;(zipFunction));</span>
    }

    /**
     * Returns an Observable that emits the results of a specified combiner function applied to combinations of
     * four items emitted, in sequence, by four other Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable
     * will be the result of the function applied to the first item emitted by {@code o1}, the first item
     * emitted by {@code o2}, the first item emitted by {@code o3}, and the first item emitted by {@code 04};
     * the second item emitted by the new Observable will be the result of the function applied to the second
     * item emitted by each of those Observables; and so forth.
     * &lt;p&gt;
     * The resulting {@code Observable&lt;R&gt;} returned from {@code zip} will invoke {@link Observer#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Observable that emits the fewest
     * items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            a second source Observable
     * @param o3
     *            a third source Observable
     * @param o4
     *            a fourth source Observable
     * @param zipFunction
     *            a function that, when applied to an item emitted by each of the source Observables, results in
     *            an item that will be emitted by the resulting Observable
     * @return an Observable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public static &lt;T1, T2, T3, T4, R&gt; Observable&lt;R&gt; zip(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Func4&lt;? super T1, ? super T2, ? super T3, ? super T4, ? extends R&gt; zipFunction) {
<span class="nc" id="L3166">        return just(new Observable&lt;?&gt;[] { o1, o2, o3, o4 }).lift(new OperatorZip&lt;R&gt;(zipFunction));</span>
    }

    /**
     * Returns an Observable that emits the results of a specified combiner function applied to combinations of
     * five items emitted, in sequence, by five other Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable
     * will be the result of the function applied to the first item emitted by {@code o1}, the first item
     * emitted by {@code o2}, the first item emitted by {@code o3}, the first item emitted by {@code o4}, and
     * the first item emitted by {@code o5}; the second item emitted by the new Observable will be the result of
     * the function applied to the second item emitted by each of those Observables; and so forth.
     * &lt;p&gt;
     * The resulting {@code Observable&lt;R&gt;} returned from {@code zip} will invoke {@link Observer#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Observable that emits the fewest
     * items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            a second source Observable
     * @param o3
     *            a third source Observable
     * @param o4
     *            a fourth source Observable
     * @param o5
     *            a fifth source Observable
     * @param zipFunction
     *            a function that, when applied to an item emitted by each of the source Observables, results in
     *            an item that will be emitted by the resulting Observable
     * @return an Observable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public static &lt;T1, T2, T3, T4, T5, R&gt; Observable&lt;R&gt; zip(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Observable&lt;? extends T5&gt; o5, Func5&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R&gt; zipFunction) {
<span class="nc" id="L3206">        return just(new Observable&lt;?&gt;[] { o1, o2, o3, o4, o5 }).lift(new OperatorZip&lt;R&gt;(zipFunction));</span>
    }

    /**
     * Returns an Observable that emits the results of a specified combiner function applied to combinations of
     * six items emitted, in sequence, by six other Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable
     * will be the result of the function applied to the first item emitted by each source Observable, the
     * second item emitted by the new Observable will be the result of the function applied to the second item
     * emitted by each of those Observables, and so forth.
     * &lt;p&gt;
     * The resulting {@code Observable&lt;R&gt;} returned from {@code zip} will invoke {@link Observer#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Observable that emits the fewest
     * items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            a second source Observable
     * @param o3
     *            a third source Observable
     * @param o4
     *            a fourth source Observable
     * @param o5
     *            a fifth source Observable
     * @param o6
     *            a sixth source Observable
     * @param zipFunction
     *            a function that, when applied to an item emitted by each of the source Observables, results in
     *            an item that will be emitted by the resulting Observable
     * @return an Observable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public static &lt;T1, T2, T3, T4, T5, T6, R&gt; Observable&lt;R&gt; zip(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Observable&lt;? extends T5&gt; o5, Observable&lt;? extends T6&gt; o6,
            Func6&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R&gt; zipFunction) {
<span class="nc" id="L3248">        return just(new Observable&lt;?&gt;[] { o1, o2, o3, o4, o5, o6 }).lift(new OperatorZip&lt;R&gt;(zipFunction));</span>
    }

    /**
     * Returns an Observable that emits the results of a specified combiner function applied to combinations of
     * seven items emitted, in sequence, by seven other Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable
     * will be the result of the function applied to the first item emitted by each source Observable, the
     * second item emitted by the new Observable will be the result of the function applied to the second item
     * emitted by each of those Observables, and so forth.
     * &lt;p&gt;
     * The resulting {@code Observable&lt;R&gt;} returned from {@code zip} will invoke {@link Observer#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Observable that emits the fewest
     * items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            a second source Observable
     * @param o3
     *            a third source Observable
     * @param o4
     *            a fourth source Observable
     * @param o5
     *            a fifth source Observable
     * @param o6
     *            a sixth source Observable
     * @param o7
     *            a seventh source Observable
     * @param zipFunction
     *            a function that, when applied to an item emitted by each of the source Observables, results in
     *            an item that will be emitted by the resulting Observable
     * @return an Observable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public static &lt;T1, T2, T3, T4, T5, T6, T7, R&gt; Observable&lt;R&gt; zip(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Observable&lt;? extends T5&gt; o5, Observable&lt;? extends T6&gt; o6, Observable&lt;? extends T7&gt; o7,
            Func7&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R&gt; zipFunction) {
<span class="nc" id="L3292">        return just(new Observable&lt;?&gt;[] { o1, o2, o3, o4, o5, o6, o7 }).lift(new OperatorZip&lt;R&gt;(zipFunction));</span>
    }

    /**
     * Returns an Observable that emits the results of a specified combiner function applied to combinations of
     * eight items emitted, in sequence, by eight other Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable
     * will be the result of the function applied to the first item emitted by each source Observable, the
     * second item emitted by the new Observable will be the result of the function applied to the second item
     * emitted by each of those Observables, and so forth.
     * &lt;p&gt;
     * The resulting {@code Observable&lt;R&gt;} returned from {@code zip} will invoke {@link Observer#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Observable that emits the fewest
     * items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            a second source Observable
     * @param o3
     *            a third source Observable
     * @param o4
     *            a fourth source Observable
     * @param o5
     *            a fifth source Observable
     * @param o6
     *            a sixth source Observable
     * @param o7
     *            a seventh source Observable
     * @param o8
     *            an eighth source Observable
     * @param zipFunction
     *            a function that, when applied to an item emitted by each of the source Observables, results in
     *            an item that will be emitted by the resulting Observable
     * @return an Observable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; Observable&lt;R&gt; zip(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Observable&lt;? extends T5&gt; o5, Observable&lt;? extends T6&gt; o6, Observable&lt;? extends T7&gt; o7, Observable&lt;? extends T8&gt; o8,
            Func8&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R&gt; zipFunction) {
<span class="nc" id="L3338">        return just(new Observable&lt;?&gt;[] { o1, o2, o3, o4, o5, o6, o7, o8 }).lift(new OperatorZip&lt;R&gt;(zipFunction));</span>
    }

    /**
     * Returns an Observable that emits the results of a specified combiner function applied to combinations of
     * nine items emitted, in sequence, by nine other Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Observable
     * will be the result of the function applied to the first item emitted by each source Observable, the
     * second item emitted by the new Observable will be the result of the function applied to the second item
     * emitted by each of those Observables, and so forth.
     * &lt;p&gt;
     * The resulting {@code Observable&lt;R&gt;} returned from {@code zip} will invoke {@link Observer#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Observable that emits the fewest
     * items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param o1
     *            the first source Observable
     * @param o2
     *            a second source Observable
     * @param o3
     *            a third source Observable
     * @param o4
     *            a fourth source Observable
     * @param o5
     *            a fifth source Observable
     * @param o6
     *            a sixth source Observable
     * @param o7
     *            a seventh source Observable
     * @param o8
     *            an eighth source Observable
     * @param o9
     *            a ninth source Observable
     * @param zipFunction
     *            a function that, when applied to an item emitted by each of the source Observables, results in
     *            an item that will be emitted by the resulting Observable
     * @return an Observable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; Observable&lt;R&gt; zip(Observable&lt;? extends T1&gt; o1, Observable&lt;? extends T2&gt; o2, Observable&lt;? extends T3&gt; o3, Observable&lt;? extends T4&gt; o4, Observable&lt;? extends T5&gt; o5, Observable&lt;? extends T6&gt; o6, Observable&lt;? extends T7&gt; o7, Observable&lt;? extends T8&gt; o8,
            Observable&lt;? extends T9&gt; o9, Func9&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R&gt; zipFunction) {
<span class="nc" id="L3386">        return just(new Observable&lt;?&gt;[] { o1, o2, o3, o4, o5, o6, o7, o8, o9 }).lift(new OperatorZip&lt;R&gt;(zipFunction));</span>
    }

    /**
     * Returns an Observable that emits a Boolean that indicates whether all of the items emitted by the source
     * Observable satisfy a condition.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code all} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param predicate
     *            a function that evaluates an item and returns a Boolean
     * @return an Observable that emits {@code true} if all items emitted by the source Observable satisfy the
     *         predicate; otherwise, {@code false}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/all.html&quot;&gt;ReactiveX operators documentation: All&lt;/a&gt;
     */
    public final Observable&lt;Boolean&gt; all(Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L3406">        return lift(new OperatorAll&lt;T&gt;(predicate));</span>
    }
    
    /**
     * Mirrors the Observable (current or provided) that first either emits an item or sends a termination
     * notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable competing to react first
     * @return an Observable that emits the same sequence as whichever of the source Observables first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    public final Observable&lt;T&gt; ambWith(Observable&lt;? extends T&gt; t1) {
<span class="fc" id="L3426">        return amb(this, t1);</span>
    }

    /**
     * Portrays a object of an Observable subclass as a simple Observable object. This is useful, for instance,
     * when you have an implementation of a subclass of Observable but you want to hide the properties and
     * methods of this subclass from whomever you are passing the Observable to.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code asObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that hides the identity of this Observable
     */
    public final Observable&lt;T&gt; asObservable() {
<span class="fc" id="L3441">        return lift(OperatorAsObservable.&lt;T&gt;instance());</span>
    }

    /**
     * Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a
     * new buffer whenever the Observable produced by the specified {@code bufferClosingSelector} emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;395&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer1.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the given Observables and
     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param bufferClosingSelector
     *            a {@link Func0} that produces an Observable that governs the boundary between buffers.
     *            Whenever this {@code Observable} emits an item, {@code buffer} emits the current buffer and
     *            begins to fill a new one
     * @return an Observable that emits a connected, non-overlapping buffer of items from the source Observable
     *         each time the Observable created with the {@code bufferClosingSelector} argument emits an item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final &lt;TClosing&gt; Observable&lt;List&lt;T&gt;&gt; buffer(Func0&lt;? extends Observable&lt;? extends TClosing&gt;&gt; bufferClosingSelector) {
<span class="fc" id="L3467">        return lift(new OperatorBufferWithSingleObservable&lt;T, TClosing&gt;(bufferClosingSelector, 16));</span>
    }

    /**
     * Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping buffers, each containing {@code count} items. When the source
     * Observable completes or encounters an error, the resulting Observable emits the current buffer and
     * propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer3.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum number of items in each buffer before it should be emitted
     * @return an Observable that emits connected, non-overlapping buffers, each containing at most
     *         {@code count} items from the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; buffer(int count) {
<span class="fc" id="L3489">        return buffer(count, count);</span>
    }

    /**
     * Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
     * Observable emits buffers every {@code skip} items, each containing {@code count} items. When the source
     * Observable completes or encounters an error, the resulting Observable emits the current buffer and
     * propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer4.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum size of each buffer before it should be emitted
     * @param skip
     *            how many items emitted by the source Observable should be skipped before starting a new
     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as
     *            {@link #buffer(int)}.
     * @return an Observable that emits buffers for every {@code skip} item from the source Observable and
     *         containing at most {@code count} items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; buffer(int count, int skip) {
<span class="fc" id="L3515">        return lift(new OperatorBufferWithSize&lt;T&gt;(count, skip));</span>
    }

    /**
     * Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
     * Observable starts a new buffer periodically, as determined by the {@code timeshift} argument. It emits
     * each buffer after a fixed timespan, specified by the {@code timespan} argument. When the source
     * Observable completes or encounters an error, the resulting Observable emits the current buffer and
     * propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each buffer collects items before it is emitted
     * @param timeshift
     *            the period of time after which a new buffer will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
     * @return an Observable that emits new buffers of items emitted by the source Observable periodically after
     *         a fixed timespan has elapsed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; buffer(long timespan, long timeshift, TimeUnit unit) {
<span class="nc" id="L3545">        return buffer(timespan, timeshift, unit,  Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
     * Observable starts a new buffer periodically, as determined by the {@code timeshift} argument, and on the
     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the
     * {@code timespan} argument. When the source Observable completes or encounters an error, the resulting
     * Observable emits the current buffer and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each buffer collects items before it is emitted
     * @param timeshift
     *            the period of time after which a new buffer will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a buffer
     * @return an Observable that emits new buffers of items emitted by the source Observable periodically after
     *         a fixed timespan has elapsed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; buffer(long timespan, long timeshift, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L3577">        return lift(new OperatorBufferWithTime&lt;T&gt;(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));</span>
    }

    /**
     * Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
     * {@code timespan} argument. When the source Observable completes or encounters an error, the resulting
     * Observable emits the current buffer and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer5.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each buffer collects items before it is emitted and replaced with a new
     *            buffer
     * @param unit
     *            the unit of time that applies to the {@code timespan} argument
     * @return an Observable that emits connected, non-overlapping buffers of items emitted by the source
     *         Observable within a fixed duration
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; buffer(long timespan, TimeUnit unit) {
<span class="fc" id="L3605">        return buffer(timespan, unit, Integer.MAX_VALUE, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached
     * first). When the source Observable completes or encounters an error, the resulting Observable emits the
     * current buffer and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each buffer collects items before it is emitted and replaced with a new
     *            buffer
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param count
     *            the maximum size of each buffer before it is emitted
     * @return an Observable that emits connected, non-overlapping buffers of items emitted by the source
     *         Observable, after a fixed duration or when the buffer reaches maximum capacity (whichever occurs
     *         first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; buffer(long timespan, TimeUnit unit, int count) {
<span class="fc" id="L3637">        return lift(new OperatorBufferWithTime&lt;T&gt;(timespan, timespan, unit, count, Schedulers.computation()));</span>
    }

    /**
     * Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by
     * the {@code count} argument (whichever is reached first). When the source Observable completes or
     * encounters an error, the resulting Observable emits the current buffer and propagates the notification
     * from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each buffer collects items before it is emitted and replaced with a new
     *            buffer
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param count
     *            the maximum size of each buffer before it is emitted
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a buffer
     * @return an Observable that emits connected, non-overlapping buffers of items emitted by the source
     *         Observable after a fixed duration or when the buffer reaches maximum capacity (whichever occurs
     *         first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; buffer(long timespan, TimeUnit unit, int count, Scheduler scheduler) {
<span class="fc" id="L3672">        return lift(new OperatorBufferWithTime&lt;T&gt;(timespan, timespan, unit, count, scheduler));</span>
    }

    /**
     * Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping buffers, each of a fixed duration specified by the
     * {@code timespan} argument and on the specified {@code scheduler}. When the source Observable completes or
     * encounters an error, the resulting Observable emits the current buffer and propagates the notification
     * from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer5.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each buffer collects items before it is emitted and replaced with a new
     *            buffer
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a buffer
     * @return an Observable that emits connected, non-overlapping buffers of items emitted by the source
     *         Observable within a fixed duration
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; buffer(long timespan, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L3703">        return buffer(timespan, timespan, unit, scheduler);</span>
    }

    /**
     * Returns an Observable that emits buffers of items it collects from the source Observable. The resulting
     * Observable emits buffers that it creates when the specified {@code bufferOpenings} Observable emits an
     * item, and closes when the Observable returned from {@code bufferClosingSelector} emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;470&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer2.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the given Observables and
     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param bufferOpenings
     *            the Observable that, when it emits an item, causes a new buffer to be created
     * @param bufferClosingSelector
     *            the {@link Func1} that is used to produce an Observable for every buffer created. When this
     *            Observable emits an item, the associated buffer is emitted.
     * @return an Observable that emits buffers, containing items from the source Observable, that are created
     *         and closed when the specified Observables emit items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final &lt;TOpening, TClosing&gt; Observable&lt;List&lt;T&gt;&gt; buffer(Observable&lt;? extends TOpening&gt; bufferOpenings, Func1&lt;? super TOpening, ? extends Observable&lt;? extends TClosing&gt;&gt; bufferClosingSelector) {
<span class="fc" id="L3730">        return lift(new OperatorBufferWithStartEndObservable&lt;T, TOpening, TClosing&gt;(bufferOpenings, bufferClosingSelector));</span>
    }

    /**
     * Returns an Observable that emits non-overlapping buffered items from the source Observable each time the
     * specified boundary Observable emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;395&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer8.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Completion of either the source or the boundary Observable causes the returned Observable to emit the
     * latest buffer and complete.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the {@code Observable}
     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey
     *      downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;B&gt;
     *            the boundary value type (ignored)
     * @param boundary
     *            the boundary Observable
     * @return an Observable that emits buffered items from the source Observable when the boundary Observable
     *         emits an item
     * @see #buffer(rx.Observable, int)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    public final &lt;B&gt; Observable&lt;List&lt;T&gt;&gt; buffer(Observable&lt;B&gt; boundary) {
<span class="fc" id="L3760">        return buffer(boundary, 16);</span>
    }

    /**
     * Returns an Observable that emits non-overlapping buffered items from the source Observable each time the
     * specified boundary Observable emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;395&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer8.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Completion of either the source or the boundary Observable causes the returned Observable to emit the
     * latest buffer and complete.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the {@code Observable}
     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey
     *      downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;B&gt;
     *            the boundary value type (ignored)
     * @param boundary
     *            the boundary Observable
     * @param initialCapacity
     *            the initial capacity of each buffer chunk
     * @return an Observable that emits buffered items from the source Observable when the boundary Observable
     *         emits an item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     * @see #buffer(rx.Observable, int)
     */
    public final &lt;B&gt; Observable&lt;List&lt;T&gt;&gt; buffer(Observable&lt;B&gt; boundary, int initialCapacity) {
<span class="fc" id="L3792">        return lift(new OperatorBufferWithSingleObservable&lt;T, B&gt;(boundary, initialCapacity));</span>
    }

    /**
     * Caches the emissions from the source Observable and replays them in order to any subsequent Subscribers.
     * This method has similar behavior to {@link #replay} except that this auto-subscribes to the source
     * Observable rather than returning a {@link ConnectableObservable} for which you must call
     * {@code connect} to activate the subscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cache.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This is useful when you want an Observable to cache responses and you can't control the
     * subscribe/unsubscribe behavior of all the {@link Subscriber}s.
     * &lt;p&gt;
     * When you call {@code cache}, it does not yet subscribe to the source Observable and so does not yet
     * begin cacheing items. This only happens when the first Subscriber calls the resulting Observable's
     * {@code subscribe} method.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; You sacrifice the ability to unsubscribe from the origin when you use the {@code cache}
     * Observer so be careful not to use this Observer on Observables that emit an infinite or very large number
     * of items that will use up memory.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support upstream backpressure as it is purposefully requesting and caching
     *      everything emitted.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code cache} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that, when first subscribed to, caches all of its items and notifications for the
     *         benefit of subsequent subscribers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final Observable&lt;T&gt; cache() {
<span class="fc" id="L3826">        return CachedObservable.from(this);</span>
    }

    /**
     * @see #cacheWithInitialCapacity(int)
     * @deprecated Use {@link #cacheWithInitialCapacity(int)} instead.
     */
    @Deprecated
    public final Observable&lt;T&gt; cache(int initialCapacity) {
<span class="nc" id="L3835">        return cacheWithInitialCapacity(initialCapacity);</span>
    }

    /**
     * Caches emissions from the source Observable and replays them in order to any subsequent Subscribers.
     * This method has similar behavior to {@link #replay} except that this auto-subscribes to the source
     * Observable rather than returning a {@link ConnectableObservable} for which you must call
     * {@code connect} to activate the subscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cache.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This is useful when you want an Observable to cache responses and you can't control the
     * subscribe/unsubscribe behavior of all the {@link Subscriber}s.
     * &lt;p&gt;
     * When you call {@code cache}, it does not yet subscribe to the source Observable and so does not yet
     * begin cacheing items. This only happens when the first Subscriber calls the resulting Observable's
     * {@code subscribe} method.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; You sacrifice the ability to unsubscribe from the origin when you use the {@code cache}
     * Observer so be careful not to use this Observer on Observables that emit an infinite or very large number
     * of items that will use up memory.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support upstream backpressure as it is purposefully requesting and caching
     *      everything emitted.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code cache} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; The capacity hint is not an upper bound on cache size. For that, consider
     * {@link #replay(int)} in combination with {@link ConnectableObservable#autoConnect()} or similar.
     * 
     * @param initialCapacity hint for number of items to cache (for optimizing underlying data structure)
     * @return an Observable that, when first subscribed to, caches all of its items and notifications for the
     *         benefit of subsequent subscribers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final Observable&lt;T&gt; cacheWithInitialCapacity(int initialCapacity) {
<span class="fc" id="L3873">        return CachedObservable.from(this, initialCapacity);</span>
    }

    /**
     * Returns an Observable that emits the items emitted by the source Observable, converted to the specified
     * type.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cast.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code cast} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param klass
     *            the target class type that {@code cast} will cast the items emitted by the source Observable
     *            into before emitting them from the resulting Observable
     * @return an Observable that emits each item from the source Observable after converting it to the
     *         specified type
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/map.html&quot;&gt;ReactiveX operators documentation: Map&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; cast(final Class&lt;R&gt; klass) {
<span class="fc" id="L3894">        return lift(new OperatorCast&lt;T, R&gt;(klass));</span>
    }

    /**
     * Collects items emitted by the source Observable into a single mutable data structure and returns an
     * Observable that emits this structure.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;330&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collect.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure because by intent it will receive all values and reduce
     *      them to a single {@code onNext}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code collect} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param stateFactory
     *           the mutable data structure that will collect the items
     * @param collector
     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}
     *           accordingly
     * @return an Observable that emits the result of collecting the values emitted by the source Observable
     *         into a single mutable data structure
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/reduce.html&quot;&gt;ReactiveX operators documentation: Reduce&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; collect(Func0&lt;R&gt; stateFactory, final Action2&lt;R, ? super T&gt; collector) {
<span class="fc" id="L3922">        Func2&lt;R, T, R&gt; accumulator = new Func2&lt;R, T, R&gt;() {</span>

            @Override
            public final R call(R state, T value) {
<span class="fc" id="L3926">                collector.call(state, value);</span>
<span class="fc" id="L3927">                return state;</span>
            }

        };
        
        /*
         * Discussion and confirmation of implementation at
         * https://github.com/ReactiveX/RxJava/issues/423#issuecomment-27642532
         * 
         * It should use last() not takeLast(1) since it needs to emit an error if the sequence is empty.
         */
<span class="fc" id="L3938">        return lift(new OperatorScan&lt;R, T&gt;(stateFactory, accumulator)).last();</span>
    }

    /**
     * Returns a new Observable that emits items resulting from applying a function that you supply to each item
     * emitted by the source Observable, where that function returns an Observable, and then emitting the items
     * that result from concatenating those resulting Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param func
     *            a function that, when applied to an item emitted by the source Observable, returns an
     *            Observable
     * @return an Observable that emits the result of applying the transformation function to each item emitted
     *         by the source Observable and concatenating the Observables obtained from this transformation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; concatMap(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; func) {
<span class="fc" id="L3960">        return concat(map(func));</span>
    }
    
    /**
     * Returns an Observable that concatenate each item emitted by the source Observable with the values in an
     * Iterable corresponding to that item that is generated by a selector.
     * &lt;p&gt;
     * 
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of item emitted by the resulting Observable
     * @param collectionSelector
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Observable
     * @return an Observable that emits the results of concatenating the items emitted by the source Observable with
     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; concatMapIterable(Func1&lt;? super T, ? extends Iterable&lt;? extends R&gt;&gt; collectionSelector) {
<span class="fc" id="L3983">        return concat(map(OperatorMapPair.convertSelector(collectionSelector)));</span>
    }
    
    /**
     * Returns an Observable that emits the items emitted from the current Observable, then the next, one after
     * the other, without interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be concatenated after the current
     * @return an Observable that emits items emitted by the two source Observables, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    public final Observable&lt;T&gt; concatWith(Observable&lt;? extends T&gt; t1) {
<span class="fc" id="L4003">        return concat(this, t1);</span>
    }

    /**
     * Returns an Observable that emits a Boolean that indicates whether the source Observable emitted a
     * specified item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/contains.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code contains} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param element
     *            the item to search for in the emissions from the source Observable
     * @return an Observable that emits {@code true} if the specified item is emitted by the source Observable,
     *         or {@code false} if the source Observable completes without emitting that item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/contains.html&quot;&gt;ReactiveX operators documentation: Contains&lt;/a&gt;
     */
    public final Observable&lt;Boolean&gt; contains(final Object element) {
<span class="fc" id="L4023">        return exists(new Func1&lt;T, Boolean&gt;() {</span>
            @Override
            public final Boolean call(T t1) {
<span class="fc bfc" id="L4026" title="All 4 branches covered.">                return element == null ? t1 == null : element.equals(t1);</span>
            }
        });
    }

    /**
     * Returns an Observable that emits the count of the total number of items emitted by the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/count.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure because by intent it will receive all values and reduce
     *      them to a single {@code onNext}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code count} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits a single item: the number of elements emitted by the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/count.html&quot;&gt;ReactiveX operators documentation: Count&lt;/a&gt;
     * @see #countLong()
     */
    public final Observable&lt;Integer&gt; count() {
<span class="fc" id="L4048">        return reduce(0, CountHolder.INSTANCE);</span>
    }
    
<span class="nc" id="L4051">    private static final class CountHolder {</span>
<span class="fc" id="L4052">        static final Func2&lt;Integer, Object, Integer&gt; INSTANCE = new Func2&lt;Integer, Object, Integer&gt;() {</span>
            @Override
            public final Integer call(Integer count, Object o) {
<span class="fc" id="L4055">                return count + 1;</span>
            }
        };
    }
    
    /**
     * Returns an Observable that counts the total number of items emitted by the source Observable and emits
     * this count as a 64-bit Long.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/longCount.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure because by intent it will receive all values and reduce
     *      them to a single {@code onNext}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code countLong} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits a single item: the number of items emitted by the source Observable as a
     *         64-bit Long item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/count.html&quot;&gt;ReactiveX operators documentation: Count&lt;/a&gt;
     * @see #count()
     */
    public final Observable&lt;Long&gt; countLong() {
<span class="nc" id="L4079">        return reduce(0L, CountLongHolder.INSTANCE);</span>
    }

<span class="nc" id="L4082">    private static final class CountLongHolder {</span>
<span class="nc" id="L4083">        static final Func2&lt;Long, Object, Long&gt; INSTANCE = new Func2&lt;Long, Object, Long&gt;() {</span>
            @Override
            public final Long call(Long count, Object o) {
<span class="nc" id="L4086">                return count + 1;</span>
            }
        };
    }
    
    /**
     * Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
     * source Observable that are followed by another item within a computed debounce duration.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;425&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses the {@code debounceSelector} to mark
     *      boundaries.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code debounce} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;U&gt;
     *            the debounce value type (ignored)
     * @param debounceSelector
     *            function to retrieve a sequence that indicates the throttle duration for each item
     * @return an Observable that omits items emitted by the source Observable that are followed by another item
     *         within a computed debounce duration
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/debounce.html&quot;&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     */
    public final &lt;U&gt; Observable&lt;T&gt; debounce(Func1&lt;? super T, ? extends Observable&lt;U&gt;&gt; debounceSelector) {
<span class="fc" id="L4114">        return lift(new OperatorDebounceWithSelector&lt;T, U&gt;(debounceSelector));</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
     * source Observable that are followed by newer items before a timeout value expires. The timer resets on
     * each emission.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; If items keep being emitted by the source Observable faster than the timeout then no items
     * will be emitted by the resulting Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Information on debounce vs throttle:
     * &lt;p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;&lt;a href=&quot;http://drupalmotion.com/article/debounce-and-throttle-visual-explanation&quot;&gt;Debounce and Throttle: visual explanation&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;http://unscriptable.com/2009/03/20/debouncing-javascript-methods/&quot;&gt;Debouncing: javascript methods&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/&quot;&gt;Javascript - don't spam your server: debounce and throttle&lt;/a&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code debounce} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timeout
     *            the time each item has to be &quot;the most recent&quot; of those emitted by the source Observable to
     *            ensure that it's not dropped
     * @param unit
     *            the {@link TimeUnit} for the timeout
     * @return an Observable that filters out items from the source Observable that are too quickly followed by
     *         newer items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/debounce.html&quot;&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #throttleWithTimeout(long, TimeUnit)
     */
    public final Observable&lt;T&gt; debounce(long timeout, TimeUnit unit) {
<span class="nc" id="L4153">        return debounce(timeout, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable, except that it drops items emitted by the
     * source Observable that are followed by newer items before a timeout value expires on a specified
     * Scheduler. The timer resets on each emission.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; If items keep being emitted by the source Observable faster than the timeout then no items
     * will be emitted by the resulting Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Information on debounce vs throttle:
     * &lt;p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;&lt;a href=&quot;http://drupalmotion.com/article/debounce-and-throttle-visual-explanation&quot;&gt;Debounce and Throttle: visual explanation&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;http://unscriptable.com/2009/03/20/debouncing-javascript-methods/&quot;&gt;Debouncing: javascript methods&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/&quot;&gt;Javascript - don't spam your server: debounce and throttle&lt;/a&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timeout
     *            the time each item has to be &quot;the most recent&quot; of those emitted by the source Observable to
     *            ensure that it's not dropped
     * @param unit
     *            the unit of time for the specified timeout
     * @param scheduler
     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each
     *            item
     * @return an Observable that filters out items from the source Observable that are too quickly followed by
     *         newer items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/debounce.html&quot;&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #throttleWithTimeout(long, TimeUnit, Scheduler)
     */
    public final Observable&lt;T&gt; debounce(long timeout, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L4195">        return lift(new OperatorDebounceWithTime&lt;T&gt;(timeout, unit, scheduler));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by the source Observable or a specified default item
     * if the source Observable is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/defaultIfEmpty.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code defaultIfEmpty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param defaultValue
     *            the item to emit if the source Observable emits no items
     * @return an Observable that emits either the specified default item if the source Observable emits no
     *         items, or the items emitted by the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/defaultifempty.html&quot;&gt;ReactiveX operators documentation: DefaultIfEmpty&lt;/a&gt;
     */
    public final Observable&lt;T&gt; defaultIfEmpty(final T defaultValue) {
        //if empty switch to an observable that emits defaultValue and supports backpressure
<span class="fc" id="L4216">        return switchIfEmpty(Observable.create(new OnSubscribe&lt;T&gt;() {</span>

            @Override
            public void call(Subscriber&lt;? super T&gt; subscriber) {
<span class="fc" id="L4220">                subscriber.setProducer(new SingleProducer&lt;T&gt;(subscriber, defaultValue));</span>
<span class="fc" id="L4221">            }}));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by the source Observable or the items of an alternate
     * Observable if the source Observable is empty.
     * &lt;p/&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param alternate
     *              the alternate Observable to subscribe to if the source does not emit any items
     * @return  an Observable that emits the items emitted by the source Observable or the items of an
     *          alternate Observable if the source Observable is empty.
     * @since 1.1.0
     */
    public final Observable&lt;T&gt; switchIfEmpty(Observable&lt;? extends T&gt; alternate) {
<span class="fc" id="L4240">        return lift(new OperatorSwitchIfEmpty&lt;T&gt;(alternate));</span>
    }

    /**
     * Returns an Observable that delays the subscription to and emissions from the souce Observable via another
     * Observable on a per-item basis.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;450&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.oo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; the resulting Observable will immediately propagate any {@code onError} notification
     * from the source Observable.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;U&gt;
     *            the subscription delay value type (ignored)
     * @param &lt;V&gt;
     *            the item delay value type (ignored)
     * @param subscriptionDelay
     *            a function that returns an Observable that triggers the subscription to the source Observable
     *            once it emits any item
     * @param itemDelay
     *            a function that returns an Observable for each item emitted by the source Observable, which is
     *            then used to delay the emission of that item by the resulting Observable until the Observable
     *            returned from {@code itemDelay} emits an item
     * @return an Observable that delays the subscription and emissions of the source Observable via another
     *         Observable on a per-item basis
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    public final &lt;U, V&gt; Observable&lt;T&gt; delay(
            Func0&lt;? extends Observable&lt;U&gt;&gt; subscriptionDelay,
            Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; itemDelay) {
<span class="fc" id="L4274">        return delaySubscription(subscriptionDelay).lift(new OperatorDelayWithSelector&lt;T, V&gt;(this, itemDelay));</span>
    }

    /**
     * Returns an Observable that delays the emissions of the source Observable via another Observable on a
     * per-item basis.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;450&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; the resulting Observable will immediately propagate any {@code onError} notification
     * from the source Observable.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;U&gt;
     *            the item delay value type (ignored)
     * @param itemDelay
     *            a function that returns an Observable for each item emitted by the source Observable, which is
     *            then used to delay the emission of that item by the resulting Observable until the Observable
     *            returned from {@code itemDelay} emits an item
     * @return an Observable that delays the emissions of the source Observable via another Observable on a
     *         per-item basis
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    public final &lt;U&gt; Observable&lt;T&gt; delay(Func1&lt;? super T, ? extends Observable&lt;U&gt;&gt; itemDelay) {
<span class="fc" id="L4301">        return lift(new OperatorDelayWithSelector&lt;T, U&gt;(this, itemDelay));</span>
    }

    /**
     * Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
     * specified delay. Error notifications from the source Observable are not delayed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delay} operates by default on the {@code compuation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param delay
     *            the delay to shift the source by
     * @param unit
     *            the {@link TimeUnit} in which {@code period} is defined
     * @return the source Observable shifted in time by the specified delay
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    public final Observable&lt;T&gt; delay(long delay, TimeUnit unit) {
<span class="fc" id="L4322">        return delay(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
     * specified delay. Error notifications from the source Observable are not delayed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param delay
     *            the delay to shift the source by
     * @param unit
     *            the time unit of {@code delay}
     * @param scheduler
     *            the {@link Scheduler} to use for delaying
     * @return the source Observable shifted in time by the specified delay
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    public final Observable&lt;T&gt; delay(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L4345">        return lift(new OperatorDelay&lt;T&gt;(delay, unit, scheduler));</span>
    }

    /**
     * Returns an Observable that delays the subscription to the source Observable by a given amount of time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delay} operates by default on the {@code compuation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param delay
     *            the time to delay the subscription
     * @param unit
     *            the time unit of {@code delay}
     * @return an Observable that delays the subscription to the source Observable by the given amount
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    public final Observable&lt;T&gt; delaySubscription(long delay, TimeUnit unit) {
<span class="fc" id="L4365">        return delaySubscription(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that delays the subscription to the source Observable by a given amount of time,
     * both waiting and subscribing on a given Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param delay
     *            the time to delay the subscription
     * @param unit
     *            the time unit of {@code delay}
     * @param scheduler
     *            the Scheduler on which the waiting and subscription will happen
     * @return an Observable that delays the subscription to the source Observable by a given
     *         amount, waiting and subscribing on the given Scheduler
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    public final Observable&lt;T&gt; delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L4389">        return create(new OnSubscribeDelaySubscription&lt;T&gt;(this, delay, unit, scheduler));</span>
    }
    
    /**
     * Returns an Observable that delays the subscription to the source Observable until a second Observable
     * emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param subscriptionDelay
     *            a function that returns an Observable that triggers the subscription to the source Observable
     *            once it emits any item
     * @return an Observable that delays the subscription to the source Observable until the Observable returned
     *         by {@code subscriptionDelay} emits an item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    public final &lt;U&gt; Observable&lt;T&gt; delaySubscription(Func0&lt;? extends Observable&lt;U&gt;&gt; subscriptionDelay) {
<span class="fc" id="L4410">        return create(new OnSubscribeDelaySubscriptionWithSelector&lt;T, U&gt;(this, subscriptionDelay));</span>
    }

    /**
     * Returns an Observable that delays the subscription to this Observable
     * until the other Observable emits an element or completes normally.
     * &lt;p&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator forwards the backpressure requests to this Observable once
     *  the subscription happens and requests Long.MAX_VALUE from the other Observable&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;U&gt; the value type of the other Observable, irrelevant
     * @param other the other Observable that should trigger the subscription
     *        to this Observable.
     * @return an Observable that delays the subscription to this Observable
     *         until the other Observable emits an element or completes normally.
     */
    @Experimental
    public final &lt;U&gt; Observable&lt;T&gt; delaySubscription(Observable&lt;U&gt; other) {
<span class="pc bpc" id="L4433" title="1 of 2 branches missed.">        if (other == null) {</span>
<span class="nc" id="L4434">            throw new NullPointerException();</span>
        }
<span class="fc" id="L4436">        return create(new OnSubscribeDelaySubscriptionOther&lt;T, U&gt;(this, other));</span>
    }
    
    /**
     * Returns an Observable that reverses the effect of {@link #materialize materialize} by transforming the
     * {@link Notification} objects emitted by the source Observable into the items or notifications they
     * represent.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;335&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/dematerialize.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code dematerialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits the items and notifications embedded in the {@link Notification} objects
     *         emitted by the source Observable
     * @throws OnErrorNotImplementedException
     *             if the source Observable is not of type {@code Observable&lt;Notification&lt;T&gt;&gt;}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/materialize-dematerialize.html&quot;&gt;ReactiveX operators documentation: Dematerialize&lt;/a&gt;
     */
    @SuppressWarnings({&quot;unchecked&quot;})
    public final &lt;T2&gt; Observable&lt;T2&gt; dematerialize() {
<span class="fc" id="L4458">        return lift(OperatorDematerialize.instance());</span>
    }

    /**
     * Returns an Observable that emits all items emitted by the source Observable that are distinct.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code distinct} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits only those items emitted by the source Observable that are distinct from
     *         each other
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/distinct.html&quot;&gt;ReactiveX operators documentation: Distinct&lt;/a&gt;
     */
    public final Observable&lt;T&gt; distinct() {
<span class="fc" id="L4475">        return lift(OperatorDistinct.&lt;T&gt; instance());</span>
    }

    /**
     * Returns an Observable that emits all items emitted by the source Observable that are distinct according
     * to a key selector function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.key.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code distinct} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            a function that projects an emitted item to a key value that is used to decide whether an item
     *            is distinct from another one or not
     * @return an Observable that emits those items emitted by the source Observable that have distinct keys
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/distinct.html&quot;&gt;ReactiveX operators documentation: Distinct&lt;/a&gt;
     */
    public final &lt;U&gt; Observable&lt;T&gt; distinct(Func1&lt;? super T, ? extends U&gt; keySelector) {
<span class="fc" id="L4495">        return lift(new OperatorDistinct&lt;T, U&gt;(keySelector));</span>
    }

    /**
     * Returns an Observable that emits all items emitted by the source Observable that are distinct from their
     * immediate predecessors.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits those items from the source Observable that are distinct from their
     *         immediate predecessors
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/distinct.html&quot;&gt;ReactiveX operators documentation: Distinct&lt;/a&gt;
     */
    public final Observable&lt;T&gt; distinctUntilChanged() {
<span class="fc" id="L4513">        return lift(OperatorDistinctUntilChanged.&lt;T&gt; instance());</span>
    }

    /**
     * Returns an Observable that emits all items emitted by the source Observable that are distinct from their
     * immediate predecessors, according to a key selector function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.key.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            a function that projects an emitted item to a key value that is used to decide whether an item
     *            is distinct from another one or not
     * @return an Observable that emits those items from the source Observable whose keys are distinct from
     *         those of their immediate predecessors
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/distinct.html&quot;&gt;ReactiveX operators documentation: Distinct&lt;/a&gt;
     */
    public final &lt;U&gt; Observable&lt;T&gt; distinctUntilChanged(Func1&lt;? super T, ? extends U&gt; keySelector) {
<span class="fc" id="L4534">        return lift(new OperatorDistinctUntilChanged&lt;T, U&gt;(keySelector));</span>
    }

    /**
     * Modifies the source Observable so that it invokes an action when it calls {@code onCompleted}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnCompleted.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnCompleted} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onCompleted
     *            the action to invoke when the source Observable calls {@code onCompleted}
     * @return the source Observable with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    public final Observable&lt;T&gt; doOnCompleted(final Action0 onCompleted) {
<span class="fc" id="L4552">        Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {</span>
            @Override
            public final void onCompleted() {
<span class="fc" id="L4555">                onCompleted.call();</span>
<span class="fc" id="L4556">            }</span>

            @Override
            public final void onError(Throwable e) {
<span class="fc" id="L4560">            }</span>

            @Override
            public final void onNext(T args) {
<span class="fc" id="L4564">            }</span>

        };

<span class="fc" id="L4568">        return lift(new OperatorDoOnEach&lt;T&gt;(observer));</span>
    }

    /**
     * Modifies the source Observable so that it invokes an action for each item it emits.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnEach.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnEach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onNotification
     *            the action to invoke for each item emitted by the source Observable
     * @return the source Observable with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    public final Observable&lt;T&gt; doOnEach(final Action1&lt;Notification&lt;? super T&gt;&gt; onNotification) {
<span class="fc" id="L4586">        Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {</span>
            @Override
            public final void onCompleted() {
<span class="fc" id="L4589">                onNotification.call(Notification.createOnCompleted());</span>
<span class="fc" id="L4590">            }</span>

            @Override
            public final void onError(Throwable e) {
<span class="fc" id="L4594">                onNotification.call(Notification.createOnError(e));</span>
<span class="fc" id="L4595">            }</span>

            @Override
            public final void onNext(T v) {
<span class="fc" id="L4599">                onNotification.call(Notification.createOnNext(v));</span>
<span class="fc" id="L4600">            }</span>

        };

<span class="fc" id="L4604">        return lift(new OperatorDoOnEach&lt;T&gt;(observer));</span>
    }

    /**
     * Modifies the source Observable so that it notifies an Observer for each item it emits.
     * &lt;p&gt;
     * In case the {@code onError} of the supplied observer throws, the downstream will receive a composite
     * exception containing the original exception and the exception thrown by {@code onError}. If either the
     * {@code onNext} or the {@code onCompleted} method of the supplied observer throws, the downstream will be
     * terminated and will receive this thrown exception.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnEach.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnEach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param observer
     *            the action to invoke for each item emitted by the source Observable
     * @return the source Observable with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    public final Observable&lt;T&gt; doOnEach(Observer&lt;? super T&gt; observer) {
<span class="fc" id="L4627">        return lift(new OperatorDoOnEach&lt;T&gt;(observer));</span>
    }

    /**
     * Modifies the source Observable so that it invokes an action if it calls {@code onError}.
     * &lt;p&gt;
     * In case the {@code onError} action throws, the downstream will receive a composite exception containing
     * the original exception and the exception thrown by {@code onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onError
     *            the action to invoke if the source Observable calls {@code onError}
     * @return the source Observable with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    public final Observable&lt;T&gt; doOnError(final Action1&lt;Throwable&gt; onError) {
<span class="fc" id="L4648">        Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {</span>
            @Override
            public final void onCompleted() {
<span class="fc" id="L4651">            }</span>

            @Override
            public final void onError(Throwable e) {
<span class="fc" id="L4655">                onError.call(e);</span>
<span class="fc" id="L4656">            }</span>

            @Override
            public final void onNext(T args) {
<span class="fc" id="L4660">            }</span>

        };

<span class="fc" id="L4664">        return lift(new OperatorDoOnEach&lt;T&gt;(observer));</span>
    }

    /**
     * Modifies the source Observable so that it invokes an action when it calls {@code onNext}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onNext
     *            the action to invoke when the source Observable calls {@code onNext}
     * @return the source Observable with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    public final Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext) {
<span class="fc" id="L4682">        Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {</span>
            @Override
            public final void onCompleted() {
<span class="fc" id="L4685">            }</span>

            @Override
            public final void onError(Throwable e) {
<span class="fc" id="L4689">            }</span>

            @Override
            public final void onNext(T args) {
<span class="fc" id="L4693">                onNext.call(args);</span>
<span class="fc" id="L4694">            }</span>

        };

<span class="fc" id="L4698">        return lift(new OperatorDoOnEach&lt;T&gt;(observer));</span>
    }

    /**
     * Modifies the source {@code Observable} so that it invokes the given action when it receives a
     * request for more items.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; This operator is for tracing the internal behavior of back-pressure request
     * patterns and generally intended for debugging use.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnRequest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onRequest
     *            the action that gets called when an observer requests items from this
     *            {@code Observable}
     * @return the source {@code Observable} modified so as to call this Action when appropriate
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators
     *      documentation: Do&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical
     *        with the release number)
     */
    @Beta
    public final Observable&lt;T&gt; doOnRequest(final Action1&lt;Long&gt; onRequest) {
<span class="fc" id="L4723">        return lift(new OperatorDoOnRequest&lt;T&gt;(onRequest));</span>
    }

    /**
     * Modifies the source {@code Observable} so that it invokes the given action when it is subscribed from
     * its subscribers. Each subscription will result in an invocation of the given action except when the
     * source {@code Observable} is reference counted, in which case the source {@code Observable} will invoke
     * the given action for the first subscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnSubscribe.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param subscribe
     *            the action that gets called when an observer subscribes to this {@code Observable}
     * @return the source {@code Observable} modified so as to call this Action when appropriate
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    public final Observable&lt;T&gt; doOnSubscribe(final Action0 subscribe) {
<span class="fc" id="L4744">        return lift(new OperatorDoOnSubscribe&lt;T&gt;(subscribe));</span>
    }
    
    /**
     * Modifies the source Observable so that it invokes an action when it calls {@code onCompleted} or
     * {@code onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This differs from {@code finallyDo} in that this happens &lt;em&gt;before&lt;/em&gt; the {@code onCompleted} or
     * {@code onError} notification.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onTerminate
     *            the action to invoke when the source Observable calls {@code onCompleted} or {@code onError}
     * @return the source Observable with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     * @see #finallyDo(Action0)
     */
    public final Observable&lt;T&gt; doOnTerminate(final Action0 onTerminate) {
<span class="fc" id="L4767">        Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {</span>
            @Override
            public final void onCompleted() {
<span class="fc" id="L4770">                onTerminate.call();</span>
<span class="fc" id="L4771">            }</span>

            @Override
            public final void onError(Throwable e) {
<span class="fc" id="L4775">                onTerminate.call();</span>
<span class="fc" id="L4776">            }</span>

            @Override
            public final void onNext(T args) {
<span class="fc" id="L4780">            }</span>

        };

<span class="fc" id="L4784">        return lift(new OperatorDoOnEach&lt;T&gt;(observer));</span>
    }
    
    /**
     * Modifies the source {@code Observable} so that it invokes the given action when it is unsubscribed from
     * its subscribers. Each un-subscription will result in an invocation of the given action except when the
     * source {@code Observable} is reference counted, in which case the source {@code Observable} will invoke
     * the given action for the very last un-subscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnUnsubscribe.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnUnsubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param unsubscribe
     *            the action that gets called when this {@code Observable} is unsubscribed
     * @return the source {@code Observable} modified so as to call this Action when appropriate
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    public final Observable&lt;T&gt; doOnUnsubscribe(final Action0 unsubscribe) {
<span class="fc" id="L4805">        return lift(new OperatorDoOnUnsubscribe&lt;T&gt;(unsubscribe));</span>
    }

    /**
     * Concatenates two source Observables eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type 
     * @param o1 the first source
     * @param o2 the second source
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2) {
<span class="fc" id="L4831">        return concatEager(Arrays.asList(o1, o2));</span>
    }
    
    /**
     * Concatenates three sources eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param o1 the first source
     * @param o2 the second source
     * @param o3 the third source
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(
            Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2,
            Observable&lt;? extends T&gt; o3
        ) {
<span class="fc" id="L4861">        return concatEager(Arrays.asList(o1, o2, o3));</span>
    }
    
    /**
     * Concatenates four sources eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param o1 the first source
     * @param o2 the second source
     * @param o3 the third source
     * @param o4 the fourth source
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(
            Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2,
            Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4
        ) {
<span class="fc" id="L4892">        return concatEager(Arrays.asList(o1, o2, o3, o4));</span>
    }
    
    /**
     * Concatenates five sources eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param o1 the first source
     * @param o2 the second source
     * @param o3 the third source
     * @param o4 the fourth source
     * @param o5 the fifth source
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(
            Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2,
            Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4,
            Observable&lt;? extends T&gt; o5
        ) {
<span class="fc" id="L4925">        return concatEager(Arrays.asList(o1, o2, o3, o4, o5));</span>
    }

    /**
     * Concatenates six sources eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param o1 the first source
     * @param o2 the second source
     * @param o3 the third source
     * @param o4 the fourth source
     * @param o5 the fifth source
     * @param o6 the sixth source
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(
            Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2,
            Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4,
            Observable&lt;? extends T&gt; o5, Observable&lt;? extends T&gt; o6
        ) {
<span class="fc" id="L4959">        return concatEager(Arrays.asList(o1, o2, o3, o4, o5, o6));</span>
    }

    /**
     * Concatenates seven sources eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param o1 the first source
     * @param o2 the second source
     * @param o3 the third source
     * @param o4 the fourth source
     * @param o5 the fifth source
     * @param o6 the sixth source
     * @param o7 the seventh source
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(
            Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2,
            Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4,
            Observable&lt;? extends T&gt; o5, Observable&lt;? extends T&gt; o6,
            Observable&lt;? extends T&gt; o7
        ) {
<span class="fc" id="L4995">        return concatEager(Arrays.asList(o1, o2, o3, o4, o5, o6, o7));</span>
    }
    
    /**
     * Concatenates eight sources eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param o1 the first source
     * @param o2 the second source
     * @param o3 the third source
     * @param o4 the fourth source
     * @param o5 the fifth source
     * @param o6 the sixth source
     * @param o7 the seventh source
     * @param o8 the eighth source
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(
            Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2,
            Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4,
            Observable&lt;? extends T&gt; o5, Observable&lt;? extends T&gt; o6,
            Observable&lt;? extends T&gt; o7, Observable&lt;? extends T&gt; o8
        ) {
<span class="fc" id="L5032">        return concatEager(Arrays.asList(o1, o2, o3, o4, o5, o6, o7, o8));</span>
    }

    /**
     * Concatenates nine sources eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param o1 the first source
     * @param o2 the second source
     * @param o3 the third source
     * @param o4 the fourth source
     * @param o5 the fifth source
     * @param o6 the sixth source
     * @param o7 the seventh source
     * @param o8 the eighth source
     * @param o9 the ninth source
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(
            Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2,
            Observable&lt;? extends T&gt; o3, Observable&lt;? extends T&gt; o4,
            Observable&lt;? extends T&gt; o5, Observable&lt;? extends T&gt; o6,
            Observable&lt;? extends T&gt; o7, Observable&lt;? extends T&gt; o8,
            Observable&lt;? extends T&gt; o9
        ) {
<span class="fc" id="L5071">        return concatEager(Arrays.asList(o1, o2, o3, o4, o5, o6, o7, o8, o9));</span>
    }

    /**
     * Concatenates a sequence of Observables eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Observables that need to be eagerly concatenated
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L5096">        return Observable.from(sources).concatMapEager((Func1)UtilityFunctions.identity());</span>
    }

    /**
     * Concatenates a sequence of Observables eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Observables that need to be eagerly concatenated
     * @param capacityHint hints about the number of expected source sequence values
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources, int capacityHint) {
<span class="nc" id="L5122">        return Observable.from(sources).concatMapEager((Func1)UtilityFunctions.identity(), capacityHint);</span>
    }
    
    /**
     * Concatenates an Observable sequence of Observables eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * emitted source Observables as they are observed. The operator buffers the values emitted by these
     * Observables and then drains them in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Observables that need to be eagerly concatenated
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; sources) {
<span class="nc" id="L5147">        return sources.concatMapEager((Func1)UtilityFunctions.identity());</span>
    }

    /**
     * Concatenates an Observable sequence of Observables eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * emitted source Observables as they are observed. The operator buffers the values emitted by these
     * Observables and then drains them in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Observables that need to be eagerly concatenated
     * @param capacityHint hints about the number of expected source sequence values
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Observable&lt;T&gt; concatEager(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; sources, int capacityHint) {
<span class="nc" id="L5173">        return sources.concatMapEager((Func1)UtilityFunctions.identity(), capacityHint);</span>
    }
    
    /**
     * Maps a sequence of values into Observables and concatenates these Observables eagerly into a single
     * Observable.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them in
     * order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the value type
     * @param mapper the function that maps a sequence of values into a sequence of Observables that will be
     *               eagerly concatenated
     * @return
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    public final &lt;R&gt; Observable&lt;R&gt; concatMapEager(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L5199">        return concatMapEager(mapper, RxRingBuffer.SIZE);</span>
    }

    /**
     * Maps a sequence of values into Observables and concatenates these Observables eagerly into a single
     * Observable.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Observables. The operator buffers the values emitted by these Observables and then drains them in
     * order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the value type
     * @param mapper the function that maps a sequence of values into a sequence of Observables that will be
     *               eagerly concatenated
     * @param capacityHint hints about the number of expected source sequence values
     * @return 
     * @warn javadoc fails to describe the return value
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    public final &lt;R&gt; Observable&lt;R&gt; concatMapEager(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; mapper, int capacityHint) {
<span class="fc bfc" id="L5226" title="All 2 branches covered.">        if (capacityHint &lt; 1) {</span>
<span class="fc" id="L5227">            throw new IllegalArgumentException(&quot;capacityHint &gt; 0 required but it was &quot; + capacityHint);</span>
        }
<span class="fc" id="L5229">        return lift(new OperatorEagerConcatMap&lt;T, R&gt;(mapper, capacityHint));</span>
    }
    
    /**
     * Returns an Observable that emits the single item at a specified index in a sequence of emissions from a
     * source Observbable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code elementAt} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param index
     *            the zero-based index of the item to retrieve
     * @return an Observable that emits a single item: the item at the specified position in the sequence of
     *         those emitted by the source Observable
     * @throws IndexOutOfBoundsException
     *             if {@code index} is greater than or equal to the number of items emitted by the source
     *             Observable, or
     *             if {@code index} is less than 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/elementat.html&quot;&gt;ReactiveX operators documentation: ElementAt&lt;/a&gt;
     */
    public final Observable&lt;T&gt; elementAt(int index) {
<span class="fc" id="L5253">        return lift(new OperatorElementAt&lt;T&gt;(index));</span>
    }

    /**
     * Returns an Observable that emits the item found at a specified index in a sequence of emissions from a
     * source Observable, or a default item if that index is out of range.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code elementAtOrDefault} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param index
     *            the zero-based index of the item to retrieve
     * @param defaultValue
     *            the default item
     * @return an Observable that emits the item at the specified position in the sequence emitted by the source
     *         Observable, or the default item if that index is outside the bounds of the source sequence
     * @throws IndexOutOfBoundsException
     *             if {@code index} is less than 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/elementat.html&quot;&gt;ReactiveX operators documentation: ElementAt&lt;/a&gt;
     */
    public final Observable&lt;T&gt; elementAtOrDefault(int index, T defaultValue) {
<span class="fc" id="L5277">        return lift(new OperatorElementAt&lt;T&gt;(index, defaultValue));</span>
    }

    /**
     * Returns an Observable that emits {@code true} if any item emitted by the source Observable satisfies a
     * specified condition, otherwise {@code false}. &lt;em&gt;Note:&lt;/em&gt; this always emits {@code false} if the
     * source Observable is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/exists.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * In Rx.Net this is the {@code any} Observer but we renamed it in RxJava to better match Java naming
     * idioms.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code exists} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param predicate
     *            the condition to test items emitted by the source Observable
     * @return an Observable that emits a Boolean that indicates whether any item emitted by the source
     *         Observable satisfies the {@code predicate}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/contains.html&quot;&gt;ReactiveX operators documentation: Contains&lt;/a&gt;
     */
    public final Observable&lt;Boolean&gt; exists(Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L5301">        return lift(new OperatorAny&lt;T&gt;(predicate, false));</span>
    }

    /**
     * Filters items emitted by an Observable by only emitting those that satisfy a specified predicate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/filter.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code filter} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param predicate
     *            a function that evaluates each item emitted by the source Observable, returning {@code true}
     *            if it passes the filter
     * @return an Observable that emits only those items emitted by the source Observable that the filter
     *         evaluates as {@code true}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/filter.html&quot;&gt;ReactiveX operators documentation: Filter&lt;/a&gt;
     */
    public final Observable&lt;T&gt; filter(Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L5321">        return lift(new OperatorFilter&lt;T&gt;(predicate));</span>
    }

    /**
     * Registers an {@link Action0} to be called when this Observable invokes either
     * {@link Observer#onCompleted onCompleted} or {@link Observer#onError onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/finallyDo.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code finallyDo} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param action
     *            an {@link Action0} to be invoked when the source Observable finishes
     * @return an Observable that emits the same items as the source Observable, then invokes the
     *         {@link Action0}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     * @see #doOnTerminate(Action0)
     * @deprecated use {@link #doAfterTerminate(Action0)} instead.
     */
    @Deprecated
    public final Observable&lt;T&gt; finallyDo(Action0 action) {
<span class="nc" id="L5344">        return lift(new OperatorDoAfterTerminate&lt;T&gt;(action));</span>
    }

    /**
     * Registers an {@link Action0} to be called when this Observable invokes either
     * {@link Observer#onCompleted onCompleted} or {@link Observer#onError onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/finallyDo.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param action
     *            an {@link Action0} to be invoked when the source Observable finishes
     * @return an Observable that emits the same items as the source Observable, then invokes the
     *         {@link Action0}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     * @see #doOnTerminate(Action0)
     */
    public final Observable&lt;T&gt; doAfterTerminate(Action0 action) {
<span class="fc" id="L5365">        return lift(new OperatorDoAfterTerminate&lt;T&gt;(action));</span>
    }

    /**
     * Returns an Observable that emits only the very first item emitted by the source Observable, or notifies
     * of an {@code NoSuchElementException} if the source Observable is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code first} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits only the very first item emitted by the source Observable, or raises an
     *         {@code NoSuchElementException} if the source Observable is empty
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    public final Observable&lt;T&gt; first() {
<span class="fc" id="L5383">        return take(1).single();</span>
    }

    /**
     * Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
     * a specified condition, or notifies of an {@code NoSuchElementException} if no such items are emitted.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstN.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code first} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param predicate
     *            the condition that an item emitted by the source Observable has to satisfy
     * @return an Observable that emits only the very first item emitted by the source Observable that satisfies
     *         the {@code predicate}, or raises an {@code NoSuchElementException} if no such items are emitted
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    public final Observable&lt;T&gt; first(Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L5403">        return takeFirst(predicate).single();</span>
    }

    /**
     * Returns an Observable that emits only the very first item emitted by the source Observable, or a default
     * item if the source Observable completes without emitting anything.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code firstOrDefault} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param defaultValue
     *            the default item to emit if the source Observable doesn't emit anything
     * @return an Observable that emits only the very first item from the source, or a default item if the
     *         source Observable completes without emitting any items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    public final Observable&lt;T&gt; firstOrDefault(T defaultValue) {
<span class="fc" id="L5423">        return take(1).singleOrDefault(defaultValue);</span>
    }

    /**
     * Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
     * a specified condition, or a default item if the source Observable emits no such items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrDefaultN.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code firstOrDefault} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param predicate
     *            the condition any item emitted by the source Observable has to satisfy
     * @param defaultValue
     *            the default item to emit if the source Observable doesn't emit anything that satisfies the
     *            {@code predicate}
     * @return an Observable that emits only the very first item emitted by the source Observable that satisfies
     *         the {@code predicate}, or a default item if the source Observable emits no such items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    public final Observable&lt;T&gt; firstOrDefault(T defaultValue, Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L5446">        return takeFirst(predicate).singleOrDefault(defaultValue);</span>
    }

    /**
     * Returns an Observable that emits items based on applying a function that you supply to each item emitted
     * by the source Observable, where that function returns an Observable, and then merging those resulting
     * Observables and emitting the results of this merger.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param func
     *            a function that, when applied to an item emitted by the source Observable, returns an
     *            Observable
     * @return an Observable that emits the result of applying the transformation function to each item emitted
     *         by the source Observable and merging the results of the Observables obtained from this
     *         transformation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; flatMap(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; func) {
<span class="fc bfc" id="L5469" title="All 2 branches covered.">        if (getClass() == ScalarSynchronousObservable.class) {</span>
<span class="fc" id="L5470">            return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarFlatMap(func);</span>
        }
<span class="fc" id="L5472">        return merge(map(func));</span>
    }

    /**
     * Returns an Observable that emits items based on applying a function that you supply to each item emitted
     * by the source Observable, where that function returns an Observable, and then merging those resulting
     * Observables and emitting the results of this merger, while limiting the maximum number of concurrent
     * subscriptions to these Observables.
     * &lt;p&gt;
     * &lt;!-- &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png&quot; alt=&quot;&quot;&gt; --&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param func
     *            a function that, when applied to an item emitted by the source Observable, returns an
     *            Observable
     * @param maxConcurrent
     *         the maximum number of Observables that may be subscribed to concurrently
     * @return an Observable that emits the result of applying the transformation function to each item emitted
     *         by the source Observable and merging the results of the Observables obtained from this
     *         transformation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Beta
    public final &lt;R&gt; Observable&lt;R&gt; flatMap(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; func, int maxConcurrent) {
<span class="pc bpc" id="L5500" title="1 of 2 branches missed.">        if (getClass() == ScalarSynchronousObservable.class) {</span>
<span class="nc" id="L5501">            return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarFlatMap(func);</span>
        }
<span class="fc" id="L5503">        return merge(map(func), maxConcurrent);</span>
    }

    /**
     * Returns an Observable that applies a function to each item emitted or notification raised by the source
     * Observable and then flattens the Observables returned from these functions and emits the resulting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.nce.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the result type
     * @param onNext
     *            a function that returns an Observable to merge for each item emitted by the source Observable
     * @param onError
     *            a function that returns an Observable to merge for an onError notification from the source
     *            Observable
     * @param onCompleted
     *            a function that returns an Observable to merge for an onCompleted notification from the source
     *            Observable
     * @return an Observable that emits the results of merging the Observables returned from applying the
     *         specified functions to the emissions and notifications of the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; flatMap(
            Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; onNext,
            Func1&lt;? super Throwable, ? extends Observable&lt;? extends R&gt;&gt; onError,
            Func0&lt;? extends Observable&lt;? extends R&gt;&gt; onCompleted) {
<span class="fc" id="L5534">        return merge(mapNotification(onNext, onError, onCompleted));</span>
    }
    /**
     * Returns an Observable that applies a function to each item emitted or notification raised by the source
     * Observable and then flattens the Observables returned from these functions and emits the resulting items, 
     * while limiting the maximum number of concurrent subscriptions to these Observables.
     * &lt;p&gt;
     * &lt;!-- &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.nce.png&quot; alt=&quot;&quot;&gt; --&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the result type
     * @param onNext
     *            a function that returns an Observable to merge for each item emitted by the source Observable
     * @param onError
     *            a function that returns an Observable to merge for an onError notification from the source
     *            Observable
     * @param onCompleted
     *            a function that returns an Observable to merge for an onCompleted notification from the source
     *            Observable
     * @param maxConcurrent
     *         the maximum number of Observables that may be subscribed to concurrently
     * @return an Observable that emits the results of merging the Observables returned from applying the
     *         specified functions to the emissions and notifications of the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Beta
    public final &lt;R&gt; Observable&lt;R&gt; flatMap(
            Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; onNext,
            Func1&lt;? super Throwable, ? extends Observable&lt;? extends R&gt;&gt; onError,
            Func0&lt;? extends Observable&lt;? extends R&gt;&gt; onCompleted, int maxConcurrent) {
<span class="fc" id="L5569">        return merge(mapNotification(onNext, onError, onCompleted), maxConcurrent);</span>
    }

    /**
     * Returns an Observable that emits the results of a specified function to the pair of values emitted by the
     * source Observable and a specified collection Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;U&gt;
     *            the type of items emitted by the collection Observable
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param collectionSelector
     *            a function that returns an Observable for each item emitted by the source Observable
     * @param resultSelector
     *            a function that combines one item emitted by each of the source and collection Observables and
     *            returns an item to be emitted by the resulting Observable
     * @return an Observable that emits the results of applying a function to a pair of values emitted by the
     *         source Observable and the collection Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    public final &lt;U, R&gt; Observable&lt;R&gt; flatMap(final Func1&lt;? super T, ? extends Observable&lt;? extends U&gt;&gt; collectionSelector,
            final Func2&lt;? super T, ? super U, ? extends R&gt; resultSelector) {
<span class="fc" id="L5597">        return merge(lift(new OperatorMapPair&lt;T, U, R&gt;(collectionSelector, resultSelector)));</span>
    }
    /**
     * Returns an Observable that emits the results of a specified function to the pair of values emitted by the
     * source Observable and a specified collection Observable, while limiting the maximum number of concurrent
     * subscriptions to these Observables.
     * &lt;p&gt;
     * &lt;!-- &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png&quot; alt=&quot;&quot;&gt; --&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;U&gt;
     *            the type of items emitted by the collection Observable
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param collectionSelector
     *            a function that returns an Observable for each item emitted by the source Observable
     * @param resultSelector
     *            a function that combines one item emitted by each of the source and collection Observables and
     *            returns an item to be emitted by the resulting Observable
     * @param maxConcurrent
     *         the maximum number of Observables that may be subscribed to concurrently
     * @return an Observable that emits the results of applying a function to a pair of values emitted by the
     *         source Observable and the collection Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Beta
    public final &lt;U, R&gt; Observable&lt;R&gt; flatMap(final Func1&lt;? super T, ? extends Observable&lt;? extends U&gt;&gt; collectionSelector,
            final Func2&lt;? super T, ? super U, ? extends R&gt; resultSelector, int maxConcurrent) {
<span class="fc" id="L5629">        return merge(lift(new OperatorMapPair&lt;T, U, R&gt;(collectionSelector, resultSelector)), maxConcurrent);</span>
    }

    /**
     * Returns an Observable that merges each item emitted by the source Observable with the values in an
     * Iterable corresponding to that item that is generated by a selector.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of item emitted by the resulting Observable
     * @param collectionSelector
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Observable
     * @return an Observable that emits the results of merging the items emitted by the source Observable with
     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; flatMapIterable(Func1&lt;? super T, ? extends Iterable&lt;? extends R&gt;&gt; collectionSelector) {
<span class="nc" id="L5652">        return merge(map(OperatorMapPair.convertSelector(collectionSelector)));</span>
    }

    /**
     * Returns an Observable that merges each item emitted by the source Observable with the values in an
     * Iterable corresponding to that item that is generated by a selector, while limiting the number of concurrent
     * subscriptions to these Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of item emitted by the resulting Observable
     * @param collectionSelector
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Observable
     * @param maxConcurrent
     *            the maximum number of Observables that may be subscribed to concurrently
     * @return an Observable that emits the results of merging the items emitted by the source Observable with
     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}
     * @throws IllegalArgumentException
     *             if {@code maxConcurrent} is less than or equal to 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Beta
    public final &lt;R&gt; Observable&lt;R&gt; flatMapIterable(Func1&lt;? super T, ? extends Iterable&lt;? extends R&gt;&gt; collectionSelector, int maxConcurrent) {
<span class="nc" id="L5682">        return merge(map(OperatorMapPair.convertSelector(collectionSelector)), maxConcurrent);</span>
    }
    
    /**
     * Returns an Observable that emits the results of applying a function to the pair of values from the source
     * Observable and an Iterable corresponding to that item that is generated by a selector.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.r.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;U&gt;
     *            the collection element type
     * @param &lt;R&gt;
     *            the type of item emited by the resulting Observable
     * @param collectionSelector
     *            a function that returns an Iterable sequence of values for each item emitted by the source
     *            Observable
     * @param resultSelector
     *            a function that returns an item based on the item emitted by the source Observable and the
     *            Iterable returned for that item by the {@code collectionSelector}
     * @return an Observable that emits the items returned by {@code resultSelector} for each item in the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    public final &lt;U, R&gt; Observable&lt;R&gt; flatMapIterable(Func1&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; collectionSelector,
            Func2&lt;? super T, ? super U, ? extends R&gt; resultSelector) {
<span class="fc" id="L5711">        return flatMap(OperatorMapPair.convertSelector(collectionSelector), resultSelector);</span>
    }

    /**
     * Returns an Observable that emits the results of applying a function to the pair of values from the source
     * Observable and an Iterable corresponding to that item that is generated by a selector, while limiting the
     * number of concurrent subscriptions to these Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMapIterable.r.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the collection element type
     * @param &lt;R&gt;
     *            the type of item emited by the resulting Observable
     * @param collectionSelector
     *            a function that returns an Iterable sequence of values for each item emitted by the source
     *            Observable
     * @param resultSelector
     *            a function that returns an item based on the item emitted by the source Observable and the
     *            Iterable returned for that item by the {@code collectionSelector}
     * @param maxConcurrent
     *            the maximum number of Observables that may be subscribed to concurrently
     * @return an Observable that emits the items returned by {@code resultSelector} for each item in the source
     *         Observable
     * @throws IllegalArgumentException
     *             if {@code maxConcurrent} is less than or equal to 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Beta
    public final &lt;U, R&gt; Observable&lt;R&gt; flatMapIterable(Func1&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; collectionSelector,
            Func2&lt;? super T, ? super U, ? extends R&gt; resultSelector, int maxConcurrent) {
<span class="nc" id="L5747">        return flatMap(OperatorMapPair.convertSelector(collectionSelector), resultSelector, maxConcurrent);</span>
    }

    /**
     * Subscribes to the {@link Observable} and receives notifications for each element.
     * &lt;p&gt;
     * Alias to {@link #subscribe(Action1)}
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code forEach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onNext
     *            {@link Action1} to execute for each item.
     * @throws IllegalArgumentException
     *             if {@code onNext} is null
     * @throws OnErrorNotImplementedException
     *             if the Observable calls {@code onError}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    public final void forEach(final Action1&lt;? super T&gt; onNext) {
<span class="fc" id="L5768">        subscribe(onNext);</span>
<span class="fc" id="L5769">    }</span>
    
    /**
     * Subscribes to the {@link Observable} and receives notifications for each element and error events.
     * &lt;p&gt;
     * Alias to {@link #subscribe(Action1, Action1)}
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code forEach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onNext
     *            {@link Action1} to execute for each item.
     * @param onError
     *            {@link Action1} to execute when an error is emitted.
     * @throws IllegalArgumentException
     *             if {@code onNext} is null, or
     *             if {@code onError} is null
     * @throws OnErrorNotImplementedException
     *             if the Observable calls {@code onError}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    public final void forEach(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError) {
<span class="nc" id="L5792">        subscribe(onNext, onError);</span>
<span class="nc" id="L5793">    }</span>
    
    /**
     * Subscribes to the {@link Observable} and receives notifications for each element and the terminal events.
     * &lt;p&gt;
     * Alias to {@link #subscribe(Action1, Action1, Action0)}
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code forEach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onNext
     *            {@link Action1} to execute for each item.
     * @param onError
     *            {@link Action1} to execute when an error is emitted.
     * @param onComplete
     *            {@link Action0} to execute when completion is signalled.
     * @throws IllegalArgumentException
     *             if {@code onNext} is null, or
     *             if {@code onError} is null, or
     *             if {@code onComplete} is null
     * @throws OnErrorNotImplementedException
     *             if the Observable calls {@code onError}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    public final void forEach(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onComplete) {
<span class="nc" id="L5819">        subscribe(onNext, onError, onComplete);</span>
<span class="nc" id="L5820">    }</span>
    
    /**
     * Groups the items emitted by an {@code Observable} according to a specified criterion, and emits these
     * grouped items as {@link GroupedObservable}s. The emitted {@code GroupedObservable} allows only a single 
     * {@link Subscriber} during its lifetime and if this {@code Subscriber} unsubscribes before the 
     * source terminates, the next emission by the source having the same key will trigger a new 
     * {@code GroupedObservable} emission.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; A {@link GroupedObservable} will cache the items it is to emit until such time as it
     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
     * {@code GroupedObservable}s that do not concern you. Instead, you can signal to them that they may
     * discard their buffers by applying an operator like {@link #ignoreElements} to them.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code groupBy} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            a function that extracts the key for each item
     * @param elementSelector
     *            a function that extracts the return element for each item
     * @param &lt;K&gt;
     *            the key type
     * @param &lt;R&gt;
     *            the element type
     * @return an {@code Observable} that emits {@link GroupedObservable}s, each of which corresponds to a
     *         unique key value and each of which emits those items from the source Observable that share that
     *         key value
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/groupby.html&quot;&gt;ReactiveX operators documentation: GroupBy&lt;/a&gt;
     */
    public final &lt;K, R&gt; Observable&lt;GroupedObservable&lt;K, R&gt;&gt; groupBy(final Func1&lt;? super T, ? extends K&gt; keySelector, final Func1&lt;? super T, ? extends R&gt; elementSelector) {
<span class="fc" id="L5854">        return lift(new OperatorGroupBy&lt;T, K, R&gt;(keySelector, elementSelector));</span>
    }
    
    /**
     * Groups the items emitted by an {@code Observable} according to a specified criterion, and emits these
     * grouped items as {@link GroupedObservable}s. The emitted {@code GroupedObservable} allows only a single 
     * {@link Subscriber} during its lifetime and if this {@code Subscriber} unsubscribes before the 
     * source terminates, the next emission by the source having the same key will trigger a new 
     * {@code GroupedObservable} emission.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; A {@link GroupedObservable} will cache the items it is to emit until such time as it
     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
     * {@code GroupedObservable}s that do not concern you. Instead, you can signal to them that they may
     * discard their buffers by applying an operator like {@link #ignoreElements} to them.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code groupBy} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            a function that extracts the key for each item
     * @param &lt;K&gt;
     *            the key type
     * @return an {@code Observable} that emits {@link GroupedObservable}s, each of which corresponds to a
     *         unique key value and each of which emits those items from the source Observable that share that
     *         key value
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/groupby.html&quot;&gt;ReactiveX operators documentation: GroupBy&lt;/a&gt;
     */
    public final &lt;K&gt; Observable&lt;GroupedObservable&lt;K, T&gt;&gt; groupBy(final Func1&lt;? super T, ? extends K&gt; keySelector) {
<span class="fc" id="L5885">        return lift(new OperatorGroupBy&lt;T, K, T&gt;(keySelector));</span>
    }

    /**
     * Returns an Observable that correlates two Observables when they overlap in time and groups the results.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupJoin.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code groupJoin} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param right
     *            the other Observable to correlate items from the source Observable with
     * @param leftDuration
     *            a function that returns an Observable whose emissions indicate the duration of the values of
     *            the source Observable
     * @param rightDuration
     *            a function that returns an Observable whose emissions indicate the duration of the values of
     *            the {@code right} Observable
     * @param resultSelector
     *            a function that takes an item emitted by each Observable and returns the value to be emitted
     *            by the resulting Observable
     * @return an Observable that emits items based on combining those items emitted by the source Observables
     *         whose durations overlap
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/join.html&quot;&gt;ReactiveX operators documentation: Join&lt;/a&gt;
     */
    public final &lt;T2, D1, D2, R&gt; Observable&lt;R&gt; groupJoin(Observable&lt;T2&gt; right, Func1&lt;? super T, ? extends Observable&lt;D1&gt;&gt; leftDuration,
            Func1&lt;? super T2, ? extends Observable&lt;D2&gt;&gt; rightDuration,
            Func2&lt;? super T, ? super Observable&lt;T2&gt;, ? extends R&gt; resultSelector) {
<span class="fc" id="L5915">        return create(new OnSubscribeGroupJoin&lt;T, T2, D1, D2, R&gt;(this, right, leftDuration, rightDuration, resultSelector));</span>
    }

    /**
     * Ignores all items emitted by the source Observable and only calls {@code onCompleted} or {@code onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ignoreElements.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ignoreElements} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an empty Observable that only calls {@code onCompleted} or {@code onError}, based on which one is
     *         called by the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/ignoreelements.html&quot;&gt;ReactiveX operators documentation: IgnoreElements&lt;/a&gt;
     */
    public final Observable&lt;T&gt; ignoreElements() {
<span class="fc" id="L5932">        return lift(OperatorIgnoreElements.&lt;T&gt; instance());</span>
    }

    /**
     * Returns an Observable that emits {@code true} if the source Observable is empty, otherwise {@code false}.
     * &lt;p&gt;
     * In Rx.Net this is negated as the {@code any} Observer but we renamed this in RxJava to better match Java
     * naming idioms.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/isEmpty.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code isEmpty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits a Boolean
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/contains.html&quot;&gt;ReactiveX operators documentation: Contains&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final Observable&lt;Boolean&gt; isEmpty() {
<span class="fc" id="L5952">        return lift((OperatorAny&lt;T&gt;) HolderAnyForEmpty.INSTANCE);</span>
    }
    
<span class="nc" id="L5955">    private static class HolderAnyForEmpty {</span>
<span class="fc" id="L5956">        static final OperatorAny&lt;?&gt; INSTANCE = new OperatorAny&lt;Object&gt;(UtilityFunctions.alwaysTrue(), true);</span>
    }

    /**
     * Correlates the items emitted by two Observables based on overlapping durations.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/join_.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code join} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param right
     *            the second Observable to join items from
     * @param leftDurationSelector
     *            a function to select a duration for each item emitted by the source Observable, used to
     *            determine overlap
     * @param rightDurationSelector
     *            a function to select a duration for each item emitted by the {@code right} Observable, used to
     *            determine overlap
     * @param resultSelector
     *            a function that computes an item to be emitted by the resulting Observable for any two
     *            overlapping items emitted by the two Observables
     * @return an Observable that emits items correlating to items emitted by the source Observables that have
     *         overlapping durations
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/join.html&quot;&gt;ReactiveX operators documentation: Join&lt;/a&gt;
     */
    public final &lt;TRight, TLeftDuration, TRightDuration, R&gt; Observable&lt;R&gt; join(Observable&lt;TRight&gt; right, Func1&lt;T, Observable&lt;TLeftDuration&gt;&gt; leftDurationSelector,
            Func1&lt;TRight, Observable&lt;TRightDuration&gt;&gt; rightDurationSelector,
            Func2&lt;T, TRight, R&gt; resultSelector) {
<span class="fc" id="L5986">        return create(new OnSubscribeJoin&lt;T, TRight, TLeftDuration, TRightDuration, R&gt;(this, right, leftDurationSelector, rightDurationSelector, resultSelector));</span>
    }

    /**
     * Returns an Observable that emits the last item emitted by the source Observable or notifies observers of
     * a {@code NoSuchElementException} if the source Observable is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/last.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code last} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits the last item from the source Observable or notifies observers of an
     *         error
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/last.html&quot;&gt;ReactiveX operators documentation: Last&lt;/a&gt;
     */
    public final Observable&lt;T&gt; last() {
<span class="fc" id="L6004">        return takeLast(1).single();</span>
    }

    /**
     * Returns an Observable that emits only the last item emitted by the source Observable that satisfies a
     * given condition, or notifies of a {@code NoSuchElementException} if no such items are emitted.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/last.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code last} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param predicate
     *            the condition any source emitted item has to satisfy
     * @return an Observable that emits only the last item satisfying the given condition from the source, or an
     *         {@code NoSuchElementException} if no such items are emitted
     * @throws IllegalArgumentException
     *             if no items that match the predicate are emitted by the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/last.html&quot;&gt;ReactiveX operators documentation: Last&lt;/a&gt;
     */
    public final Observable&lt;T&gt; last(Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L6026">        return filter(predicate).takeLast(1).single();</span>
    }

    /**
     * Returns an Observable that emits only the last item emitted by the source Observable, or a default item
     * if the source Observable completes without emitting any items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code lastOrDefault} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param defaultValue
     *            the default item to emit if the source Observable is empty
     * @return an Observable that emits only the last item emitted by the source Observable, or a default item
     *         if the source Observable is empty
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/last.html&quot;&gt;ReactiveX operators documentation: Last&lt;/a&gt;
     */
    public final Observable&lt;T&gt; lastOrDefault(T defaultValue) {
<span class="fc" id="L6046">        return takeLast(1).singleOrDefault(defaultValue);</span>
    }

    /**
     * Returns an Observable that emits only the last item emitted by the source Observable that satisfies a
     * specified condition, or a default item if no such item is emitted by the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrDefault.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code lastOrDefault} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param defaultValue
     *            the default item to emit if the source Observable doesn't emit anything that satisfies the
     *            specified {@code predicate}
     * @param predicate
     *            the condition any item emitted by the source Observable has to satisfy
     * @return an Observable that emits only the last item emitted by the source Observable that satisfies the
     *         given condition, or a default item if no such item is emitted by the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/last.html&quot;&gt;ReactiveX operators documentation: Last&lt;/a&gt;
     */
    public final Observable&lt;T&gt; lastOrDefault(T defaultValue, Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L6069">        return filter(predicate).takeLast(1).singleOrDefault(defaultValue);</span>
    }

    /**
     * Returns an Observable that emits only the first {@code count} items emitted by the source Observable.
     * &lt;p&gt;
     * Alias of {@link #take(int)} to match Java 8 Stream API naming convention.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This method returns an Observable that will invoke a subscribing {@link Observer}'s
     * {@link Observer#onNext onNext} function a maximum of {@code count} times before invoking
     * {@link Observer#onCompleted onCompleted}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code limit} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum number of items to emit
     * @return an Observable that emits only the first {@code count} items emitted by the source Observable, or
     *         all of the items from the source Observable if that Observable emits fewer than {@code count} items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/take.html&quot;&gt;ReactiveX operators documentation: Take&lt;/a&gt;
     */
    public final Observable&lt;T&gt; limit(int count) {
<span class="fc" id="L6094">        return take(count);</span>
    }
    
    /**
     * Returns an Observable that applies a specified function to each item emitted by the source Observable and
     * emits the results of these function applications.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/map.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code map} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param func
     *            a function to apply to each item emitted by the Observable
     * @return an Observable that emits the items from the source Observable, transformed by the specified
     *         function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/map.html&quot;&gt;ReactiveX operators documentation: Map&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) {
<span class="fc" id="L6114">        return lift(new OperatorMap&lt;T, R&gt;(func));</span>
    }
    
    private &lt;R&gt; Observable&lt;R&gt; mapNotification(Func1&lt;? super T, ? extends R&gt; onNext, Func1&lt;? super Throwable, ? extends R&gt; onError, Func0&lt;? extends R&gt; onCompleted) {
<span class="fc" id="L6118">        return lift(new OperatorMapNotification&lt;T, R&gt;(onNext, onError, onCompleted));</span>
    }

    /**
     * Returns an Observable that represents all of the emissions &lt;em&gt;and&lt;/em&gt; notifications from the source
     * Observable into emissions marked with their original types within {@link Notification} objects.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/materialize.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code materialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits items that are the result of materializing the items and notifications
     *         of the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/materialize-dematerialize.html&quot;&gt;ReactiveX operators documentation: Materialize&lt;/a&gt;
     */
    public final Observable&lt;Notification&lt;T&gt;&gt; materialize() {
<span class="fc" id="L6136">        return lift(OperatorMaterialize.&lt;T&gt;instance());</span>
    }

    /**
     * Flattens this and another Observable into a single Observable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Observables so that they appear as a single Observable, by
     * using the {@code mergeWith} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            an Observable to be merged
     * @return an Observable that emits all of the items emitted by the source Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    public final Observable&lt;T&gt; mergeWith(Observable&lt;? extends T&gt; t1) {
<span class="fc" id="L6157">        return merge(this, t1);</span>
    }
    
    /**
     * Modifies an Observable to perform its emissions and notifications on a specified {@link Scheduler},
     * asynchronously with a bounded buffer.
     * &lt;p&gt;Note that onError notifications will cut ahead of onNext notifications on the emission thread if Scheduler is truly
     * asynchronous. If strict event ordering is required, consider using the {@link #observeOn(Scheduler, boolean)} overload.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;308&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param scheduler
     *            the {@link Scheduler} to notify {@link Observer}s on
     * @return the source Observable modified so that its {@link Observer}s are notified on the specified
     *         {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/observeon.html&quot;&gt;ReactiveX operators documentation: ObserveOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #subscribeOn
     * @see #observeOn(Scheduler, boolean)
     */
    public final Observable&lt;T&gt; observeOn(Scheduler scheduler) {
<span class="fc bfc" id="L6182" title="All 2 branches covered.">        if (this instanceof ScalarSynchronousObservable) {</span>
<span class="fc" id="L6183">            return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler);</span>
        }
<span class="fc" id="L6185">        return lift(new OperatorObserveOn&lt;T&gt;(scheduler, false));</span>
    }

    /**
     * Modifies an Observable to perform its emissions and notifications on a specified {@link Scheduler},
     * asynchronously with a bounded buffer and optionally delays onError notifications.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;308&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param scheduler
     *            the {@link Scheduler} to notify {@link Observer}s on
     * @param delayError
     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the
     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received
     *            from upstream
     * @return the source Observable modified so that its {@link Observer}s are notified on the specified
     *         {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/observeon.html&quot;&gt;ReactiveX operators documentation: ObserveOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #subscribeOn
     * @see #observeOn(Scheduler)
     */
    public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError) {
<span class="pc bpc" id="L6212" title="1 of 2 branches missed.">        if (this instanceof ScalarSynchronousObservable) {</span>
<span class="nc" id="L6213">            return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler);</span>
        }
<span class="fc" id="L6215">        return lift(new OperatorObserveOn&lt;T&gt;(scheduler, delayError));</span>
    }

    /**
     * Filters the items emitted by an Observable, only emitting those of the specified type.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ofClass.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ofType} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param klass
     *            the class type to filter the items emitted by the source Observable
     * @return an Observable that emits items from the source Observable of type {@code klass}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/filter.html&quot;&gt;ReactiveX operators documentation: Filter&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; ofType(final Class&lt;R&gt; klass) {
<span class="fc" id="L6233">        return filter(new Func1&lt;T, Boolean&gt;() {</span>
            @Override
            public final Boolean call(T t) {
<span class="fc" id="L6236">                return klass.isInstance(t);</span>
            }
        }).cast(klass);
    }

    /**
     * Instructs an Observable that is emitting items faster than its observer can consume them to buffer these
     * items indefinitely until they can be emitted.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the source Observable modified to buffer items to the extent system resources allow
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     */
    public final Observable&lt;T&gt; onBackpressureBuffer() {
<span class="fc" id="L6255">        return lift(OperatorOnBackpressureBuffer.&lt;T&gt; instance());</span>
    }

    /**
     * Instructs an Observable that is emitting items faster than its observer can consume them to buffer up to
     * a given amount of items until they can be emitted. The resulting Observable will {@code onError} emitting
     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered
     * items, and unsubscribing from the source.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the source Observable modified to buffer items up to the given capacity
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     * @since 1.1.0
     */
    public final Observable&lt;T&gt; onBackpressureBuffer(long capacity) {
<span class="nc" id="L6275">        return lift(new OperatorOnBackpressureBuffer&lt;T&gt;(capacity));</span>
    }

    /**
     * Instructs an Observable that is emitting items faster than its observer can consume them to buffer up to
     * a given amount of items until they can be emitted. The resulting Observable will {@code onError} emitting
     * a {@code BufferOverflowException} as soon as the buffer's capacity is exceeded, dropping all undelivered
     * items, unsubscribing from the source, and notifying the producer with {@code onOverflow}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the source Observable modified to buffer items up to the given capacity
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     * @since 1.1.0
     */
    public final Observable&lt;T&gt; onBackpressureBuffer(long capacity, Action0 onOverflow) {
<span class="fc" id="L6295">        return lift(new OperatorOnBackpressureBuffer&lt;T&gt;(capacity, onOverflow));</span>
    }

    /**
     * Instructs an Observable that is emitting items faster than its observer can consume them to discard,
     * rather than emit, those items that its observer is not prepared to observe.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;245&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.drop.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the downstream request count hits 0 then the Observable will refrain from calling {@code onNext} until
     * the observer invokes {@code request(n)} again to increase the request count.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onDrop the action to invoke for each item dropped. onDrop action should be fast and should never block.
     * @return the source Observable modified to drop {@code onNext} notifications on overflow
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     * @Experimental The behavior of this can change at any time. 
     * @since 1.1.0
     */
    public final Observable&lt;T&gt; onBackpressureDrop(Action1&lt;? super T&gt; onDrop) {
<span class="fc" id="L6318">        return lift(new OperatorOnBackpressureDrop&lt;T&gt;(onDrop));</span>
    }

    /**
     * Instructs an Observable that is emitting items faster than its observer can consume them to discard,
     * rather than emit, those items that its observer is not prepared to observe.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;245&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.drop.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the downstream request count hits 0 then the Observable will refrain from calling {@code onNext} until
     * the observer invokes {@code request(n)} again to increase the request count.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return the source Observable modified to drop {@code onNext} notifications on overflow
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     */
    public final Observable&lt;T&gt; onBackpressureDrop() {
<span class="fc" id="L6338">        return lift(OperatorOnBackpressureDrop.&lt;T&gt;instance());</span>
    }
    
    /**
     * Instructs an Observable that is emitting items faster than its observer can consume them to 
     * hold onto the latest value and emit that on request.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;245&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.latest.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Its behavior is logically equivalent to {@code toBlocking().latest()} with the exception that
     * the downstream is not blocking while requesting more values.
     * &lt;p&gt;
     * Note that if the upstream Observable does support backpressure, this operator ignores that capability
     * and doesn't propagate any backpressure requests from downstream.
     * &lt;p&gt;
     * Note that due to the nature of how backpressure requests are propagated through subscribeOn/observeOn,
     * requesting more than 1 from downstream doesn't guarantee a continuous delivery of onNext events.
     *
     * @return the source Observable modified so that it emits the most recently-received item upon request
     * @since 1.1.0
     */
    public final Observable&lt;T&gt; onBackpressureLatest() {
<span class="fc" id="L6360">        return lift(OperatorOnBackpressureLatest.&lt;T&gt;instance());</span>
    }
    
    /**
     * Instructs an Observable to pass control to another Observable rather than invoking
     * {@link Observer#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when an Observable encounters an error that prevents it from emitting the expected item to
     * its {@link Observer}, the Observable invokes its Observer's {@code onError} method, and then quits
     * without invoking any more of its Observer's methods. The {@code onErrorResumeNext} method changes this
     * behavior. If you pass a function that returns an Observable ({@code resumeFunction}) to
     * {@code onErrorResumeNext}, if the original Observable encounters an error, instead of invoking its
     * Observer's {@code onError} method, it will instead relinquish control to the Observable returned from
     * {@code resumeFunction}, which will invoke the Observer's {@link Observer#onNext onNext} method if it is
     * able to do so. In such a case, because no Observable necessarily invokes {@code onError}, the Observer
     * may never know that an error happened.
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param resumeFunction
     *            a function that returns an Observable that will take over if the source Observable encounters
     *            an error
     * @return the original Observable, with appropriately modified behavior
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    public final Observable&lt;T&gt; onErrorResumeNext(final Func1&lt;Throwable, ? extends Observable&lt;? extends T&gt;&gt; resumeFunction) {
<span class="fc" id="L6393">        return lift(new OperatorOnErrorResumeNextViaFunction&lt;T&gt;(resumeFunction));</span>
    }

    /**
     * Instructs an Observable to pass control to another Observable rather than invoking
     * {@link Observer#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when an Observable encounters an error that prevents it from emitting the expected item to
     * its {@link Observer}, the Observable invokes its Observer's {@code onError} method, and then quits
     * without invoking any more of its Observer's methods. The {@code onErrorResumeNext} method changes this
     * behavior. If you pass another Observable ({@code resumeSequence}) to an Observable's
     * {@code onErrorResumeNext} method, if the original Observable encounters an error, instead of invoking its
     * Observer's {@code onError} method, it will instead relinquish control to {@code resumeSequence} which
     * will invoke the Observer's {@link Observer#onNext onNext} method if it is able to do so. In such a case,
     * because no Observable necessarily invokes {@code onError}, the Observer may never know that an error
     * happened.
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param resumeSequence
     *            a function that returns an Observable that will take over if the source Observable encounters
     *            an error
     * @return the original Observable, with appropriately modified behavior
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    public final Observable&lt;T&gt; onErrorResumeNext(final Observable&lt;? extends T&gt; resumeSequence) {
<span class="fc" id="L6426">        return lift(OperatorOnErrorResumeNextViaFunction.withOther(resumeSequence));</span>
    }

    /**
     * Instructs an Observable to emit an item (returned by a specified function) rather than invoking
     * {@link Observer#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when an Observable encounters an error that prevents it from emitting the expected item to
     * its {@link Observer}, the Observable invokes its Observer's {@code onError} method, and then quits
     * without invoking any more of its Observer's methods. The {@code onErrorReturn} method changes this
     * behavior. If you pass a function ({@code resumeFunction}) to an Observable's {@code onErrorReturn}
     * method, if the original Observable encounters an error, instead of invoking its Observer's
     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param resumeFunction
     *            a function that returns an item that the new Observable will emit if the source Observable
     *            encounters an error
     * @return the original Observable with appropriately modified behavior
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    public final Observable&lt;T&gt; onErrorReturn(Func1&lt;Throwable, ? extends T&gt; resumeFunction) {
<span class="fc" id="L6456">        return lift(OperatorOnErrorResumeNextViaFunction.withSingle(resumeFunction));</span>
    }

    /**
     * Instructs an Observable to pass control to another Observable rather than invoking
     * {@link Observer#onError onError} if it encounters an {@link java.lang.Exception}.
     * &lt;p&gt;
     * This differs from {@link #onErrorResumeNext} in that this one does not handle {@link java.lang.Throwable}
     * or {@link java.lang.Error} but lets those continue through.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onExceptionResumeNextViaObservable.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when an Observable encounters an exception that prevents it from emitting the expected item
     * to its {@link Observer}, the Observable invokes its Observer's {@code onError} method, and then quits
     * without invoking any more of its Observer's methods. The {@code onExceptionResumeNext} method changes
     * this behavior. If you pass another Observable ({@code resumeSequence}) to an Observable's
     * {@code onExceptionResumeNext} method, if the original Observable encounters an exception, instead of
     * invoking its Observer's {@code onError} method, it will instead relinquish control to
     * {@code resumeSequence} which will invoke the Observer's {@link Observer#onNext onNext} method if it is
     * able to do so. In such a case, because no Observable necessarily invokes {@code onError}, the Observer
     * may never know that an exception happened.
     * &lt;p&gt;
     * You can use this to prevent exceptions from propagating or to supply fallback data should exceptions be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onExceptionResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param resumeSequence
     *            a function that returns an Observable that will take over if the source Observable encounters
     *            an exception
     * @return the original Observable, with appropriately modified behavior
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    public final Observable&lt;T&gt; onExceptionResumeNext(final Observable&lt;? extends T&gt; resumeSequence) {
<span class="fc" id="L6492">        return lift(OperatorOnErrorResumeNextViaFunction.withException(resumeSequence));</span>
    }

    /**
     * Returns a {@link ConnectableObservable}, which is a variety of Observable that waits until its
     * {@link ConnectableObservable#connect connect} method is called before it begins emitting items to those
     * {@link Observer}s that have subscribed to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;510&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code publish} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return a {@link ConnectableObservable} that upon connection causes the source Observable to emit items
     *         to its {@link Observer}s
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/publish.html&quot;&gt;ReactiveX operators documentation: Publish&lt;/a&gt;
     */
    public final ConnectableObservable&lt;T&gt; publish() {
<span class="fc" id="L6511">        return OperatorPublish.create(this);</span>
    }

    /**
     * Returns an Observable that emits the results of invoking a specified selector on items emitted by a
     * {@link ConnectableObservable} that shares a single subscription to the underlying sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;510&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code publish} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param selector
     *            a function that can use the multicasted source sequence as many times as needed, without
     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will
     *            receive all notifications of the source from the time of the subscription forward.
     * @return an Observable that emits the results of invoking the selector on the items emitted by a {@link ConnectableObservable} that shares a single subscription to the underlying sequence
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/publish.html&quot;&gt;ReactiveX operators documentation: Publish&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; publish(Func1&lt;? super Observable&lt;T&gt;, ? extends Observable&lt;R&gt;&gt; selector) {
<span class="fc" id="L6534">        return OperatorPublish.create(this, selector);</span>
    }

    /**
     * Returns an Observable that applies a specified accumulator function to the first item emitted by a source
     * Observable, then feeds the result of that function along with the second item emitted by the source
     * Observable into the same function, and so on until all items have been emitted by the source Observable,
     * and emits the final result from the final call to your function as its sole item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduce.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This technique, which is called &quot;reduce&quot; here, is sometimes called &quot;aggregate,&quot; &quot;fold,&quot; &quot;accumulate,&quot;
     * &quot;compress,&quot; or &quot;inject&quot; in other programming contexts. Groovy, for instance, has an {@code inject} method
     * that does a similar operation on lists.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure because by intent it will receive all values and reduce
     *      them to a single {@code onNext}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code reduce} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param accumulator
     *            an accumulator function to be invoked on each item emitted by the source Observable, whose
     *            result will be used in the next accumulator call
     * @return an Observable that emits a single item that is the result of accumulating the items emitted by
     *         the source Observable
     * @throws IllegalArgumentException
     *             if the source Observable emits no items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/reduce.html&quot;&gt;ReactiveX operators documentation: Reduce&lt;/a&gt;
     * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Fold_(higher-order_function)&quot;&gt;Wikipedia: Fold (higher-order function)&lt;/a&gt;
     */
    public final Observable&lt;T&gt; reduce(Func2&lt;T, T, T&gt; accumulator) {
        /*
         * Discussion and confirmation of implementation at
         * https://github.com/ReactiveX/RxJava/issues/423#issuecomment-27642532
         * 
         * It should use last() not takeLast(1) since it needs to emit an error if the sequence is empty.
         */
<span class="fc" id="L6573">        return scan(accumulator).last();</span>
    }

    /**
     * Returns an Observable that applies a specified accumulator function to the first item emitted by a source
     * Observable and a specified seed value, then feeds the result of that function along with the second item
     * emitted by an Observable into the same function, and so on until all items have been emitted by the
     * source Observable, emitting the final result from the final call to your function as its sole item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;325&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This technique, which is called &quot;reduce&quot; here, is sometimec called &quot;aggregate,&quot; &quot;fold,&quot; &quot;accumulate,&quot;
     * &quot;compress,&quot; or &quot;inject&quot; in other programming contexts. Groovy, for instance, has an {@code inject} method
     * that does a similar operation on lists.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure because by intent it will receive all values and reduce
     *      them to a single {@code onNext}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code reduce} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param initialValue
     *            the initial (seed) accumulator value
     * @param accumulator
     *            an accumulator function to be invoked on each item emitted by the source Observable, the
     *            result of which will be used in the next accumulator call
     * @return an Observable that emits a single item that is the result of accumulating the output from the
     *         items emitted by the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/reduce.html&quot;&gt;ReactiveX operators documentation: Reduce&lt;/a&gt;
     * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Fold_(higher-order_function)&quot;&gt;Wikipedia: Fold (higher-order function)&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; reduce(R initialValue, Func2&lt;R, ? super T, R&gt; accumulator) {
<span class="fc" id="L6606">        return scan(initialValue, accumulator).takeLast(1);</span>
    }
    
    /**
     * Returns an Observable that repeats the sequence of items emitted by the source Observable indefinitely.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;309&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeat} operates by default on the {@code trampoline} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits the items emitted by the source Observable repeatedly and in sequence
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    public final Observable&lt;T&gt; repeat() {
<span class="fc" id="L6622">        return OnSubscribeRedo.&lt;T&gt;repeat(this);</span>
    }

    /**
     * Returns an Observable that repeats the sequence of items emitted by the source Observable indefinitely,
     * on a particular Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.os.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param scheduler
     *            the Scheduler to emit the items on
     * @return an Observable that emits the items emitted by the source Observable repeatedly and in sequence
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    public final Observable&lt;T&gt; repeat(Scheduler scheduler) {
<span class="fc" id="L6641">        return OnSubscribeRedo.&lt;T&gt;repeat(this, scheduler);</span>
    }

    /**
     * Returns an Observable that repeats the sequence of items emitted by the source Observable at most
     * {@code count} times.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.on.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeat} operates by default on the {@code trampoline} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the number of times the source Observable items are repeated, a count of 0 will yield an empty
     *            sequence
     * @return an Observable that repeats the sequence of items emitted by the source Observable at most
     *         {@code count} times
     * @throws IllegalArgumentException
     *             if {@code count} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    public final Observable&lt;T&gt; repeat(final long count) {
<span class="fc" id="L6664">        return OnSubscribeRedo.&lt;T&gt;repeat(this, count);</span>
    }

    /**
     * Returns an Observable that repeats the sequence of items emitted by the source Observable at most
     * {@code count} times, on a particular Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.ons.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the number of times the source Observable items are repeated, a count of 0 will yield an empty
     *            sequence
     * @param scheduler
     *            the {@link Scheduler} to emit the items on
     * @return an Observable that repeats the sequence of items emitted by the source Observable at most
     *         {@code count} times on a particular Scheduler
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    public final Observable&lt;T&gt; repeat(final long count, Scheduler scheduler) {
<span class="nc" id="L6687">        return OnSubscribeRedo.&lt;T&gt;repeat(this, count, scheduler);</span>
    }

    /**
     * Returns an Observable that emits the same values as the source Observable with the exception of an
     * {@code onCompleted}. An {@code onCompleted} notification from the source will result in the emission of
     * a {@code void} item to the Observable provided as an argument to the {@code notificationHandler}
     * function. If that Observable calls {@code onComplete} or {@code onError} then {@code repeatWhen} will
     * call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will
     * resubscribe to the source Observable, on a particular Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;430&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatWhen.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param notificationHandler
     *            receives an Observable of notifications with which a user can complete or error, aborting the repeat.
     * @param scheduler
     *            the {@link Scheduler} to emit the items on
     * @return the source Observable modified with repeat logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    public final Observable&lt;T&gt; repeatWhen(final Func1&lt;? super Observable&lt;? extends Void&gt;, ? extends Observable&lt;?&gt;&gt; notificationHandler, Scheduler scheduler) {
<span class="nc" id="L6712">        Func1&lt;? super Observable&lt;? extends Notification&lt;?&gt;&gt;, ? extends Observable&lt;?&gt;&gt; dematerializedNotificationHandler = new Func1&lt;Observable&lt;? extends Notification&lt;?&gt;&gt;, Observable&lt;?&gt;&gt;() {</span>
            @Override
            public Observable&lt;?&gt; call(Observable&lt;? extends Notification&lt;?&gt;&gt; notifications) {
<span class="nc" id="L6715">                return notificationHandler.call(notifications.map(new Func1&lt;Notification&lt;?&gt;, Void&gt;() {</span>
                    @Override
                    public Void call(Notification&lt;?&gt; notification) {
<span class="nc" id="L6718">                        return null;</span>
                    }
                }));
            }
        };
<span class="nc" id="L6723">        return OnSubscribeRedo.repeat(this, dematerializedNotificationHandler, scheduler);</span>
    }

    /**
     * Returns an Observable that emits the same values as the source Observable with the exception of an
     * {@code onCompleted}. An {@code onCompleted} notification from the source will result in the emission of
     * a {@code void} item to the Observable provided as an argument to the {@code notificationHandler}
     * function. If that Observable calls {@code onComplete} or {@code onError} then {@code repeatWhen} will
     * call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will
     * resubscribe to the source observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;430&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatWhen.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeatWhen} operates by default on the {@code trampoline} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param notificationHandler
     *            receives an Observable of notifications with which a user can complete or error, aborting the repeat.
     * @return the source Observable modified with repeat logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    public final Observable&lt;T&gt; repeatWhen(final Func1&lt;? super Observable&lt;? extends Void&gt;, ? extends Observable&lt;?&gt;&gt; notificationHandler) {
<span class="nc" id="L6746">        Func1&lt;? super Observable&lt;? extends Notification&lt;?&gt;&gt;, ? extends Observable&lt;?&gt;&gt; dematerializedNotificationHandler = new Func1&lt;Observable&lt;? extends Notification&lt;?&gt;&gt;, Observable&lt;?&gt;&gt;() {</span>
            @Override
            public Observable&lt;?&gt; call(Observable&lt;? extends Notification&lt;?&gt;&gt; notifications) {
<span class="nc" id="L6749">                return notificationHandler.call(notifications.map(new Func1&lt;Notification&lt;?&gt;, Void&gt;() {</span>
                    @Override
                    public Void call(Notification&lt;?&gt; notification) {
<span class="nc" id="L6752">                        return null;</span>
                    }
                }));
            }
        };
<span class="nc" id="L6757">        return OnSubscribeRedo.repeat(this, dematerializedNotificationHandler);</span>
    }

    /**
     * Returns a {@link ConnectableObservable} that shares a single subscription to the underlying Observable
     * that will replay all of its items and notifications to any future {@link Observer}. A Connectable
     * Observable resembles an ordinary Observable, except that it does not begin emitting items when it is
     * subscribed to, but only when its {@code connect} method is called.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return a {@link ConnectableObservable} that upon connection causes the source Observable to emit its
     *         items to its {@link Observer}s
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final ConnectableObservable&lt;T&gt; replay() {
<span class="fc" id="L6781">        return OperatorReplay.create(this);</span>
    }

    /**
     * Returns an Observable that emits items that are the results of invoking a specified selector on the items
     * emitted by a {@link ConnectableObservable} that shares a single subscription to the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;450&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param selector
     *            the selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Observable
     * @return an Observable that emits items that are the results of invoking the selector on a
     *         {@link ConnectableObservable} that shares a single subscription to the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; replay(Func1&lt;? super Observable&lt;T&gt;, ? extends Observable&lt;R&gt;&gt; selector) {
<span class="fc" id="L6808">        return OperatorReplay.multicastSelector(new Func0&lt;ConnectableObservable&lt;T&gt;&gt;() {</span>
            @Override
            public ConnectableObservable&lt;T&gt; call() {
<span class="fc" id="L6811">                return Observable.this.replay();</span>
            }
        }, selector);
    }

    /**
     * Returns an Observable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableObservable} that shares a single subscription to the source Observable,
     * replaying {@code bufferSize} notifications.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;440&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param selector
     *            the selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Observable
     * @param bufferSize
     *            the buffer size that limits the number of items the connectable observable can replay
     * @return an Observable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableObservable} that shares a single subscription to the source Observable
     *         replaying no more than {@code bufferSize} items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; replay(Func1&lt;? super Observable&lt;T&gt;, ? extends Observable&lt;R&gt;&gt; selector, final int bufferSize) {
<span class="fc" id="L6844">        return OperatorReplay.multicastSelector(new Func0&lt;ConnectableObservable&lt;T&gt;&gt;() {</span>
            @Override
            public ConnectableObservable&lt;T&gt; call() {
<span class="fc" id="L6847">                return Observable.this.replay(bufferSize);</span>
            }
        }, selector);
    }

    /**
     * Returns an Observable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableObservable} that shares a single subscription to the source Observable,
     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;445&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fnt.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Observable
     * @param bufferSize
     *            the buffer size that limits the number of items the connectable observable can replay
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @return an Observable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableObservable} that shares a single subscription to the source Observable, and
     *         replays no more than {@code bufferSize} items that were emitted within the window defined by
     *         {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; replay(Func1&lt;? super Observable&lt;T&gt;, ? extends Observable&lt;R&gt;&gt; selector, int bufferSize, long time, TimeUnit unit) {
<span class="nc" id="L6885">        return replay(selector, bufferSize, time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableObservable} that shares a single subscription to the source Observable,
     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;445&quot; height=&quot;440&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fnts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Observable
     * @param bufferSize
     *            the buffer size that limits the number of items the connectable observable can replay
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler that is the time source for the window
     * @return an Observable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableObservable} that shares a single subscription to the source Observable, and
     *         replays no more than {@code bufferSize} items that were emitted within the window defined by
     *         {@code time}
     * @throws IllegalArgumentException
     *             if {@code bufferSize} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; replay(Func1&lt;? super Observable&lt;T&gt;, ? extends Observable&lt;R&gt;&gt; selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="nc bnc" id="L6925" title="All 2 branches missed.">        if (bufferSize &lt; 0) {</span>
<span class="nc" id="L6926">            throw new IllegalArgumentException(&quot;bufferSize &lt; 0&quot;);</span>
        }
<span class="nc" id="L6928">        return OperatorReplay.multicastSelector(new Func0&lt;ConnectableObservable&lt;T&gt;&gt;() {</span>
            @Override
            public ConnectableObservable&lt;T&gt; call() {
<span class="nc" id="L6931">                return Observable.this.replay(bufferSize, time, unit, scheduler);</span>
            }
        }, selector);
    }

    /**
     * Returns an Observable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableObservable} that shares a single subscription to the source Observable,
     * replaying a maximum of {@code bufferSize} items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;440&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fns.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Observable
     * @param bufferSize
     *            the buffer size that limits the number of items the connectable observable can replay
     * @param scheduler
     *            the Scheduler on which the replay is observed
     * @return an Observable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableObservable} that shares a single subscription to the source Observable,
     *         replaying no more than {@code bufferSize} notifications
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; replay(final Func1&lt;? super Observable&lt;T&gt;, ? extends Observable&lt;R&gt;&gt; selector, final int bufferSize, final Scheduler scheduler) {
<span class="nc" id="L6966">        return OperatorReplay.multicastSelector(new Func0&lt;ConnectableObservable&lt;T&gt;&gt;() {</span>
            @Override
            public ConnectableObservable&lt;T&gt; call() {
<span class="nc" id="L6969">                return Observable.this.replay(bufferSize);</span>
            }
<span class="nc" id="L6971">        }, new Func1&lt;Observable&lt;T&gt;, Observable&lt;R&gt;&gt;() {</span>
            @Override
            public Observable&lt;R&gt; call(Observable&lt;T&gt; t) {
<span class="nc" id="L6974">                return selector.call(t).observeOn(scheduler);</span>
            }
        });
    }

    /**
     * Returns an Observable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableObservable} that shares a single subscription to the source Observable,
     * replaying all items that were emitted within a specified time window.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;435&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ft.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Observable
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @return an Observable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableObservable} that shares a single subscription to the source Observable,
     *         replaying all items that were emitted within the window defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; replay(Func1&lt;? super Observable&lt;T&gt;, ? extends Observable&lt;R&gt;&gt; selector, long time, TimeUnit unit) {
<span class="nc" id="L7009">        return replay(selector, time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableObservable} that shares a single subscription to the source Observable,
     * replaying all items that were emitted within a specified time window.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;440&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Observable
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the scheduler that is the time source for the window
     * @return an Observable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableObservable} that shares a single subscription to the source Observable,
     *         replaying all items that were emitted within the window defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; replay(Func1&lt;? super Observable&lt;T&gt;, ? extends Observable&lt;R&gt;&gt; selector, final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L7044">        return OperatorReplay.multicastSelector(new Func0&lt;ConnectableObservable&lt;T&gt;&gt;() {</span>
            @Override
            public ConnectableObservable&lt;T&gt; call() {
<span class="fc" id="L7047">                return Observable.this.replay(time, unit, scheduler);</span>
            }
        }, selector);
    }

    /**
     * Returns an Observable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableObservable} that shares a single subscription to the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;445&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fs.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Observable
     * @param scheduler
     *            the Scheduler where the replay is observed
     * @return an Observable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableObservable} that shares a single subscription to the source Observable,
     *         replaying all items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; replay(final Func1&lt;? super Observable&lt;T&gt;, ? extends Observable&lt;R&gt;&gt; selector, final Scheduler scheduler) {
<span class="nc" id="L7079">        return OperatorReplay.multicastSelector(new Func0&lt;ConnectableObservable&lt;T&gt;&gt;() {</span>
            @Override
            public ConnectableObservable&lt;T&gt; call() {
<span class="nc" id="L7082">                return Observable.this.replay();</span>
            }
<span class="nc" id="L7084">        }, new Func1&lt;Observable&lt;T&gt;, Observable&lt;R&gt;&gt;() {</span>
            @Override
            public Observable&lt;R&gt; call(Observable&lt;T&gt; t) {
<span class="nc" id="L7087">                return selector.call(t).observeOn(scheduler);</span>
            }
        });
    }

    /**
     * Returns a {@link ConnectableObservable} that shares a single subscription to the source Observable that
     * replays at most {@code bufferSize} items emitted by that Observable. A Connectable Observable resembles
     * an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only
     * when its {@code connect} method is called.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.n.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param bufferSize
     *            the buffer size that limits the number of items that can be replayed
     * @return a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     *         replays at most {@code bufferSize} items emitted by that Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final ConnectableObservable&lt;T&gt; replay(final int bufferSize) {
<span class="fc" id="L7115">        return OperatorReplay.create(this, bufferSize);</span>
    }

    /**
     * Returns a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     * replays at most {@code bufferSize} items that were emitted during a specified time window. A Connectable
     * Observable resembles an ordinary Observable, except that it does not begin emitting items when it is
     * subscribed to, but only when its {@code connect} method is called. 
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.nt.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param bufferSize
     *            the buffer size that limits the number of items that can be replayed
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @return a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     *         replays at most {@code bufferSize} items that were emitted during the window defined by
     *         {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final ConnectableObservable&lt;T&gt; replay(int bufferSize, long time, TimeUnit unit) {
<span class="nc" id="L7146">        return replay(bufferSize, time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     * that replays a maximum of {@code bufferSize} items that are emitted within a specified time window. A
     * Connectable Observable resembles an ordinary Observable, except that it does not begin emitting items
     * when it is subscribed to, but only when its {@code connect} method is called.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.nts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param bufferSize
     *            the buffer size that limits the number of items that can be replayed
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the scheduler that is used as a time source for the window
     * @return a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     *         replays at most {@code bufferSize} items that were emitted during the window defined by
     *         {@code time}
     * @throws IllegalArgumentException
     *             if {@code bufferSize} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final ConnectableObservable&lt;T&gt; replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="pc bpc" id="L7181" title="1 of 2 branches missed.">        if (bufferSize &lt; 0) {</span>
<span class="nc" id="L7182">            throw new IllegalArgumentException(&quot;bufferSize &lt; 0&quot;);</span>
        }
<span class="fc" id="L7184">        return OperatorReplay.create(this, time, unit, scheduler, bufferSize);</span>
    }

    /**
     * Returns a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     * replays at most {@code bufferSize} items emitted by that Observable. A Connectable Observable resembles
     * an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only
     * when its {@code connect} method is called. 
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ns.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param bufferSize
     *            the buffer size that limits the number of items that can be replayed
     * @param scheduler
     *            the scheduler on which the Observers will observe the emitted items
     * @return a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     *         replays at most {@code bufferSize} items that were emitted by the Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final ConnectableObservable&lt;T&gt; replay(final int bufferSize, final Scheduler scheduler) {
<span class="nc" id="L7212">        return OperatorReplay.observeOn(replay(bufferSize), scheduler);</span>
    }

    /**
     * Returns a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     * replays all items emitted by that Observable within a specified time window. A Connectable Observable
     * resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to,
     * but only when its {@code connect} method is called. 
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @return a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     *         replays the items that were emitted during the window defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final ConnectableObservable&lt;T&gt; replay(long time, TimeUnit unit) {
<span class="nc" id="L7240">        return replay(time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     * replays all items emitted by that Observable within a specified time window. A Connectable Observable
     * resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to,
     * but only when its {@code connect} method is called. 
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler that is the time source for the window
     * @return a {@link ConnectableObservable} that shares a single subscription to the source Observable and
     *         replays the items that were emitted during the window defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final ConnectableObservable&lt;T&gt; replay(final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L7270">        return OperatorReplay.create(this, time, unit, scheduler);</span>
    }

    /**
     * Returns a {@link ConnectableObservable} that shares a single subscription to the source Observable that
     * will replay all of its items and notifications to any future {@link Observer} on the given
     * {@link Scheduler}. A Connectable Observable resembles an ordinary Observable, except that it does not
     * begin emitting items when it is subscribed to, but only when its {@code connect} method is called.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Observable sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param scheduler
     *            the Scheduler on which the Observers will observe the emitted items
     * @return a {@link ConnectableObservable} that shares a single subscription to the source Observable that
     *         will replay all of its items and notifications to any future {@link Observer} on the given
     *         {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    public final ConnectableObservable&lt;T&gt; replay(final Scheduler scheduler) {
<span class="nc" id="L7297">        return OperatorReplay.observeOn(replay(), scheduler);</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable, resubscribing to it if it calls {@code onError}
     * (infinite retry count).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the source Observable calls {@link Observer#onError}, this method will resubscribe to the source
     * Observable rather than propagating the {@code onError} call.
     * &lt;p&gt;
     * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even
     * those emitted during failed subscriptions. For example, if an Observable fails at first but emits
     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence
     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onCompleted]}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} operates by default on the {@code trampoline} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return the source Observable modified with retry logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    public final Observable&lt;T&gt; retry() {
<span class="fc" id="L7322">        return OnSubscribeRedo.&lt;T&gt;retry(this);</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable, resubscribing to it if it calls {@code onError}
     * up to a specified number of retries.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the source Observable calls {@link Observer#onError}, this method will resubscribe to the source
     * Observable for a maximum of {@code count} resubscriptions rather than propagating the
     * {@code onError} call.
     * &lt;p&gt;
     * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even
     * those emitted during failed subscriptions. For example, if an Observable fails at first but emits
     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence
     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onCompleted]}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} operates by default on the {@code trampoline} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            number of retry attempts before failing
     * @return the source Observable modified with retry logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    public final Observable&lt;T&gt; retry(final long count) {
<span class="fc" id="L7350">        return OnSubscribeRedo.&lt;T&gt;retry(this, count);</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable, resubscribing to it if it calls {@code onError}
     * and the predicate returns true for that specific exception and retry count.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator honors backpressure.&lt;/td&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} operates by default on the {@code trampoline} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate
     *            the predicate that determines if a resubscription may happen in case of a specific exception
     *            and retry count
     * @return the source Observable modified with retry logic
     * @see #retry()
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    public final Observable&lt;T&gt; retry(Func2&lt;Integer, Throwable, Boolean&gt; predicate) {
<span class="fc" id="L7373">        return nest().lift(new OperatorRetryWithPredicate&lt;T&gt;(predicate));</span>
    }

    /**
     * Returns an Observable that emits the same values as the source observable with the exception of an
     * {@code onError}. An {@code onError} notification from the source will result in the emission of a
     * {@link Throwable} item to the Observable provided as an argument to the {@code notificationHandler}
     * function. If that Observable calls {@code onComplete} or {@code onError} then {@code retry} will call
     * {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will
     * resubscribe to the source Observable.    
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;430&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryWhen.f.png&quot; alt=&quot;&quot;&gt;
     * 
     * Example:
     * 
     * This retries 3 times, each time incrementing the number of seconds it waits.
     * 
     * &lt;pre&gt; {@code
     *  Observable.create((Subscriber&lt;? super String&gt; s) -&gt; {
     *      System.out.println(&quot;subscribing&quot;);
     *      s.onError(new RuntimeException(&quot;always fails&quot;));
     *  }).retryWhen(attempts -&gt; {
     *      return attempts.zipWith(Observable.range(1, 3), (n, i) -&gt; i).flatMap(i -&gt; {
     *          System.out.println(&quot;delay retry by &quot; + i + &quot; second(s)&quot;);
     *          return Observable.timer(i, TimeUnit.SECONDS);
     *      });
     *  }).toBlocking().forEach(System.out::println);
     * } &lt;/pre&gt;
     * 
     * Output is:
     *
     * &lt;pre&gt; {@code
     * subscribing
     * delay retry by 1 second(s)
     * subscribing
     * delay retry by 2 second(s)
     * subscribing
     * delay retry by 3 second(s)
     * subscribing
     * } &lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retryWhen} operates by default on the {@code trampoline} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param notificationHandler
     *            receives an Observable of notifications with which a user can complete or error, aborting the
     *            retry
     * @return the source Observable modified with retry logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    public final Observable&lt;T&gt; retryWhen(final Func1&lt;? super Observable&lt;? extends Throwable&gt;, ? extends Observable&lt;?&gt;&gt; notificationHandler) {
<span class="fc" id="L7425">        Func1&lt;? super Observable&lt;? extends Notification&lt;?&gt;&gt;, ? extends Observable&lt;?&gt;&gt; dematerializedNotificationHandler = new Func1&lt;Observable&lt;? extends Notification&lt;?&gt;&gt;, Observable&lt;?&gt;&gt;() {</span>
            @Override
            public Observable&lt;?&gt; call(Observable&lt;? extends Notification&lt;?&gt;&gt; notifications) {
<span class="fc" id="L7428">                return notificationHandler.call(notifications.map(new Func1&lt;Notification&lt;?&gt;, Throwable&gt;() {</span>
                    @Override
                    public Throwable call(Notification&lt;?&gt; notification) {
<span class="fc" id="L7431">                        return notification.getThrowable();</span>
                    }
                }));
            }
        };
<span class="fc" id="L7436">        return OnSubscribeRedo.&lt;T&gt; retry(this, dematerializedNotificationHandler);</span>
    }

    /**
     * Returns an Observable that emits the same values as the source observable with the exception of an
     * {@code onError}. An {@code onError} will cause the emission of the {@link Throwable} that cause the
     * error to the Observable returned from {@code notificationHandler}. If that Observable calls
     * {@code onComplete} or {@code onError} then {@code retry} will call {@code onCompleted} or {@code onError}
     * on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a
     * particular Scheduler.    
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;430&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryWhen.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param notificationHandler
     *            receives an Observable of notifications with which a user can complete or error, aborting the
     *            retry
     * @param scheduler
     *            the {@link Scheduler} on which to subscribe to the source Observable
     * @return the source Observable modified with retry logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    public final Observable&lt;T&gt; retryWhen(final Func1&lt;? super Observable&lt;? extends Throwable&gt;, ? extends Observable&lt;?&gt;&gt; notificationHandler, Scheduler scheduler) {
<span class="nc" id="L7463">        Func1&lt;? super Observable&lt;? extends Notification&lt;?&gt;&gt;, ? extends Observable&lt;?&gt;&gt; dematerializedNotificationHandler = new Func1&lt;Observable&lt;? extends Notification&lt;?&gt;&gt;, Observable&lt;?&gt;&gt;() {</span>
            @Override
            public Observable&lt;?&gt; call(Observable&lt;? extends Notification&lt;?&gt;&gt; notifications) {
<span class="nc" id="L7466">                return notificationHandler.call(notifications.map(new Func1&lt;Notification&lt;?&gt;, Throwable&gt;() {</span>
                    @Override
                    public Throwable call(Notification&lt;?&gt; notification) {
<span class="nc" id="L7469">                        return notification.getThrowable();</span>
                    }
                }));
            }
        };
<span class="nc" id="L7474">        return OnSubscribeRedo.&lt;T&gt; retry(this, dematerializedNotificationHandler, scheduler);</span>
    }

    /**
     * Returns an Observable that emits the most recently emitted item (if any) emitted by the source Observable
     * within periodic time intervals.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sample} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param period
     *            the sampling rate
     * @param unit
     *            the {@link TimeUnit} in which {@code period} is defined
     * @return an Observable that emits the results of sampling the items emitted by the source Observable at
     *         the specified time interval
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #throttleLast(long, TimeUnit)
     */
    public final Observable&lt;T&gt; sample(long period, TimeUnit unit) {
<span class="fc" id="L7500">        return sample(period, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits the most recently emitted item (if any) emitted by the source Observable
     * within periodic time intervals, where the intervals are defined on a particular Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param period
     *            the sampling rate
     * @param unit
     *            the {@link TimeUnit} in which {@code period} is defined
     * @param scheduler
     *            the {@link Scheduler} to use when sampling
     * @return an Observable that emits the results of sampling the items emitted by the source Observable at
     *         the specified time interval
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #throttleLast(long, TimeUnit, Scheduler)
     */
    public final Observable&lt;T&gt; sample(long period, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L7528">        return lift(new OperatorSampleWithTime&lt;T&gt;(period, unit, scheduler));</span>
    }

    /**
     * Returns an Observable that, when the specified {@code sampler} Observable emits an item or completes,
     * emits the most recently emitted item (if any) emitted by the source Observable since the previous
     * emission from the {@code sampler} Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses the emissions of the {@code sampler}
     *      Observable to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code sample} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param sampler
     *            the Observable to use for sampling the source Observable
     * @return an Observable that emits the results of sampling the items emitted by this Observable whenever
     *         the {@code sampler} Observable emits an item or completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     */
    public final &lt;U&gt; Observable&lt;T&gt; sample(Observable&lt;U&gt; sampler) {
<span class="fc" id="L7553">        return lift(new OperatorSampleWithObservable&lt;T, U&gt;(sampler));</span>
    }

    /**
     * Returns an Observable that applies a specified accumulator function to the first item emitted by a source
     * Observable, then feeds the result of that function along with the second item emitted by the source
     * Observable into the same function, and so on until all items have been emitted by the source Observable,
     * emitting the result of each of these iterations.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scan.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This sort of function is sometimes called an accumulator.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code scan} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param accumulator
     *            an accumulator function to be invoked on each item emitted by the source Observable, whose
     *            result will be emitted to {@link Observer}s via {@link Observer#onNext onNext} and used in the
     *            next accumulator call
     * @return an Observable that emits the results of each call to the accumulator function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/scan.html&quot;&gt;ReactiveX operators documentation: Scan&lt;/a&gt;
     */
    public final Observable&lt;T&gt; scan(Func2&lt;T, T, T&gt; accumulator) {
<span class="fc" id="L7578">        return lift(new OperatorScan&lt;T, T&gt;(accumulator));</span>
    }

    /**
     * Returns an Observable that applies a specified accumulator function to the first item emitted by a source
     * Observable and a seed value, then feeds the result of that function along with the second item emitted by
     * the source Observable into the same function, and so on until all items have been emitted by the source
     * Observable, emitting the result of each of these iterations.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scanSeed.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This sort of function is sometimes called an accumulator.
     * &lt;p&gt;
     * Note that the Observable that results from this method will emit {@code initialValue} as its first
     * emitted item.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code scan} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param initialValue
     *            the initial (seed) accumulator item
     * @param accumulator
     *            an accumulator function to be invoked on each item emitted by the source Observable, whose
     *            result will be emitted to {@link Observer}s via {@link Observer#onNext onNext} and used in the
     *            next accumulator call
     * @return an Observable that emits {@code initialValue} followed by the results of each call to the
     *         accumulator function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/scan.html&quot;&gt;ReactiveX operators documentation: Scan&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; scan(R initialValue, Func2&lt;R, ? super T, R&gt; accumulator) {
<span class="fc" id="L7609">        return lift(new OperatorScan&lt;R, T&gt;(initialValue, accumulator));</span>
    }

    /**
     * Forces an Observable's emissions and notifications to be serialized and for it to obey
     * &lt;a href=&quot;http://reactivex.io/documentation/contract.html&quot;&gt;the Observable contract&lt;/a&gt; in other ways.
     * &lt;p&gt;
     * It is possible for an Observable to invoke its Subscribers' methods asynchronously, perhaps from
     * different threads. This could make such an Observable poorly-behaved, in that it might try to invoke
     * {@code onCompleted} or {@code onError} before one of its {@code onNext} invocations, or it might call
     * {@code onNext} from two different threads concurrently. You can force such an Observable to be
     * well-behaved and sequential by applying the {@code serialize} method to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/synchronize.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code serialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return an {@link Observable} that is guaranteed to be well-behaved and to make only serialized calls to
     *         its observers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/serialize.html&quot;&gt;ReactiveX operators documentation: Serialize&lt;/a&gt;
     */
    public final Observable&lt;T&gt; serialize() {
<span class="fc" id="L7633">        return lift(OperatorSerialize.&lt;T&gt;instance());</span>
    }

    /**
     * Returns a new {@link Observable} that multicasts (shares) the original {@link Observable}. As long as
     * there is at least one {@link Subscriber} this {@link Observable} will be subscribed and emitting data. 
     * When all subscribers have unsubscribed it will unsubscribe from the source {@link Observable}. 
     * &lt;p&gt;
     * This is an alias for {@link #publish()}.{@link ConnectableObservable#refCount()}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;510&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure because multicasting means the stream is &quot;hot&quot; with
     *      multiple subscribers. Each child will need to manage backpressure independently using operators such
     *      as {@link #onBackpressureDrop} and {@link #onBackpressureBuffer}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code share} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an {@code Observable} that upon connection causes the source {@code Observable} to emit items
     *         to its {@link Observer}s
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/refcount.html&quot;&gt;ReactiveX operators documentation: RefCount&lt;/a&gt;
     */
    public final Observable&lt;T&gt; share() {
<span class="fc" id="L7658">        return publish().refCount();</span>
    }
    
    /**
     * Returns an Observable that emits the single item emitted by the source Observable, if that Observable
     * emits only a single item. If the source Observable emits more than one item or no items, notify of an
     * {@code IllegalArgumentException} or {@code NoSuchElementException} respectively.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/single.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code single} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits the single item emitted by the source Observable
     * @throws IllegalArgumentException
     *             if the source emits more than one item
     * @throws NoSuchElementException
     *             if the source emits no items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    public final Observable&lt;T&gt; single() {
<span class="fc" id="L7680">        return lift(OperatorSingle.&lt;T&gt; instance());</span>
    }

    /**
     * Returns an Observable that emits the single item emitted by the source Observable that matches a
     * specified predicate, if that Observable emits one such item. If the source Observable emits more than one
     * such item or no such items, notify of an {@code IllegalArgumentException} or
     * {@code NoSuchElementException} respectively.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/single.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code single} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param predicate
     *            a predicate function to evaluate items emitted by the source Observable
     * @return an Observable that emits the single item emitted by the source Observable that matches the
     *         predicate
     * @throws IllegalArgumentException
     *             if the source Observable emits more than one item that matches the predicate
     * @throws NoSuchElementException
     *             if the source Observable emits no item that matches the predicate
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    public final Observable&lt;T&gt; single(Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L7706">        return filter(predicate).single();</span>
    }

    /**
     * Returns an Observable that emits the single item emitted by the source Observable, if that Observable
     * emits only a single item, or a default item if the source Observable emits no items. If the source
     * Observable emits more than one item, throw an {@code IllegalArgumentException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code singleOrDefault} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param defaultValue
     *            a default value to emit if the source Observable emits no item
     * @return an Observable that emits the single item emitted by the source Observable, or a default item if
     *         the source Observable is empty
     * @throws IllegalArgumentException
     *             if the source Observable emits more than one item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    public final Observable&lt;T&gt; singleOrDefault(T defaultValue) {
<span class="fc" id="L7729">        return lift(new OperatorSingle&lt;T&gt;(defaultValue));</span>
    }

    /**
     * Returns an Observable that emits the single item emitted by the source Observable that matches a
     * predicate, if that Observable emits only one such item, or a default item if the source Observable emits
     * no such items. If the source Observable emits more than one such item, throw an
     * {@code IllegalArgumentException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrDefault.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code singleOrDefault} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param defaultValue
     *            a default item to emit if the source Observable emits no matching items
     * @param predicate
     *            a predicate function to evaluate items emitted by the source Observable
     * @return an Observable that emits the single item emitted by the source Observable that matches the
     *         predicate, or the default item if no emitted item matches the predicate
     * @throws IllegalArgumentException
     *             if the source Observable emits more than one item that matches the predicate
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    public final Observable&lt;T&gt; singleOrDefault(T defaultValue, Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L7755">        return filter(predicate).singleOrDefault(defaultValue);</span>
    }

    /**
     * Returns an Observable that skips the first {@code count} items emitted by the source Observable and emits
     * the remainder.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code skip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the number of items to skip
     * @return an Observable that is identical to the source Observable except that it does not emit the first
     *         {@code count} items that the source Observable emits
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skip.html&quot;&gt;ReactiveX operators documentation: Skip&lt;/a&gt;
     */
    public final Observable&lt;T&gt; skip(int count) {
<span class="fc" id="L7775">        return lift(new OperatorSkip&lt;T&gt;(count));</span>
    }

    /**
     * Returns an Observable that skips values emitted by the source Observable before a specified time window
     * elapses.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code skip} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the length of the time window to skip
     * @param unit
     *            the time unit of {@code time}
     * @return an Observable that skips values emitted by the source Observable before the time window defined
     *         by {@code time} elapses and the emits the remainder
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skip.html&quot;&gt;ReactiveX operators documentation: Skip&lt;/a&gt;
     */
    public final Observable&lt;T&gt; skip(long time, TimeUnit unit) {
<span class="nc" id="L7797">        return skip(time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that skips values emitted by the source Observable before a specified time window
     * on a specified {@link Scheduler} elapses.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the length of the time window to skip
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the {@link Scheduler} on which the timed wait happens
     * @return an Observable that skips values emitted by the source Observable before the time window defined
     *         by {@code time} and {@code scheduler} elapses, and then emits the remainder
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skip.html&quot;&gt;ReactiveX operators documentation: Skip&lt;/a&gt;
     */
    public final Observable&lt;T&gt; skip(long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L7821">        return lift(new OperatorSkipTimed&lt;T&gt;(time, unit, scheduler));</span>
    }

    /**
     * Returns an Observable that drops a specified number of items from the end of the sequence emitted by the
     * source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This Observer accumulates a queue long enough to store the first {@code count} items. As more items are
     * received, items are taken from the front of the queue and emitted by the returned Observable. This causes
     * such items to be delayed.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code skipLast} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            number of items to drop from the end of the source sequence
     * @return an Observable that emits the items emitted by the source Observable except for the dropped ones
     *         at the end
     * @throws IndexOutOfBoundsException
     *             if {@code count} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skiplast.html&quot;&gt;ReactiveX operators documentation: SkipLast&lt;/a&gt;
     */
    public final Observable&lt;T&gt; skipLast(int count) {
<span class="fc" id="L7847">        return lift(new OperatorSkipLast&lt;T&gt;(count));</span>
    }

    /**
     * Returns an Observable that drops items emitted by the source Observable during a specified time window
     * before the source completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: this action will cache the latest items arriving in the specified time window.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code skipLast} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @return an Observable that drops those items emitted by the source Observable in a time window before the
     *         source completes defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skiplast.html&quot;&gt;ReactiveX operators documentation: SkipLast&lt;/a&gt;
     */
    public final Observable&lt;T&gt; skipLast(long time, TimeUnit unit) {
<span class="nc" id="L7871">        return skipLast(time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that drops items emitted by the source Observable during a specified time window
     * (defined on a specified scheduler) before the source completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;340&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: this action will cache the latest items arriving in the specified time window.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the scheduler used as the time source
     * @return an Observable that drops those items emitted by the source Observable in a time window before the
     *         source completes defined by {@code time} and {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skiplast.html&quot;&gt;ReactiveX operators documentation: SkipLast&lt;/a&gt;
     */
    public final Observable&lt;T&gt; skipLast(long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L7897">        return lift(new OperatorSkipLastTimed&lt;T&gt;(time, unit, scheduler));</span>
    }

    /**
     * Returns an Observable that skips items emitted by the source Observable until a second Observable emits
     * an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;375&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code skipUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param other
     *            the second Observable that has to emit an item before the source Observable's elements begin
     *            to be mirrored by the resulting Observable
     * @return an Observable that skips items from the source Observable until the second Observable emits an
     *         item, then emits the remaining items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skipuntil.html&quot;&gt;ReactiveX operators documentation: SkipUntil&lt;/a&gt;
     */
    public final &lt;U&gt; Observable&lt;T&gt; skipUntil(Observable&lt;U&gt; other) {
<span class="fc" id="L7918">        return lift(new OperatorSkipUntil&lt;T, U&gt;(other));</span>
    }

    /**
     * Returns an Observable that skips all items emitted by the source Observable as long as a specified
     * condition holds true, but emits all further source items as soon as the condition becomes false.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipWhile.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code skipWhile} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param predicate
     *            a function to test each item emitted from the source Observable
     * @return an Observable that begins emitting items emitted by the source Observable when the specified
     *         predicate becomes false
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skipwhile.html&quot;&gt;ReactiveX operators documentation: SkipWhile&lt;/a&gt;
     */
    public final Observable&lt;T&gt; skipWhile(Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L7938">        return lift(new OperatorSkipWhile&lt;T&gt;(OperatorSkipWhile.toPredicate2(predicate)));</span>
    }

    /**
     * Returns an Observable that emits the items in a specified {@link Observable} before it begins to emit
     * items emitted by the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param values
     *            an Observable that contains the items you want the modified Observable to emit first
     * @return an Observable that emits the items in the specified {@link Observable} and then emits the items
     *         emitted by the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(Observable&lt;T&gt; values) {
<span class="fc" id="L7958">        return concat(values, this);</span>
    }

    /**
     * Returns an Observable that emits the items in a specified {@link Iterable} before it begins to emit items
     * emitted by the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param values
     *            an Iterable that contains the items you want the modified Observable to emit first
     * @return an Observable that emits the items in the specified {@link Iterable} and then emits the items
     *         emitted by the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(Iterable&lt;T&gt; values) {
<span class="fc" id="L7978">        return concat(Observable.&lt;T&gt; from(values), this);</span>
    }

    /**
     * Returns an Observable that emits a specified item before it begins to emit items emitted by the source
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            the item to emit
     * @return an Observable that emits the specified item before it begins to emit items emitted by the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(T t1) {
<span class="fc" id="L7998">        return concat(just(t1), this);</span>
    }

    /**
     * Returns an Observable that emits the specified items before it begins to emit items emitted by the source
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            the first item to emit
     * @param t2
     *            the second item to emit
     * @return an Observable that emits the specified items before it begins to emit items emitted by the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(T t1, T t2) {
<span class="nc" id="L8020">        return concat(just(t1, t2), this);</span>
    }

    /**
     * Returns an Observable that emits the specified items before it begins to emit items emitted by the source
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            the first item to emit
     * @param t2
     *            the second item to emit
     * @param t3
     *            the third item to emit
     * @return an Observable that emits the specified items before it begins to emit items emitted by the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(T t1, T t2, T t3) {
<span class="nc" id="L8044">        return concat(just(t1, t2, t3), this);</span>
    }

    /**
     * Returns an Observable that emits the specified items before it begins to emit items emitted by the source
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            the first item to emit
     * @param t2
     *            the second item to emit
     * @param t3
     *            the third item to emit
     * @param t4
     *            the fourth item to emit
     * @return an Observable that emits the specified items before it begins to emit items emitted by the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(T t1, T t2, T t3, T t4) {
<span class="nc" id="L8070">        return concat(just(t1, t2, t3, t4), this);</span>
    }

    /**
     * Returns an Observable that emits the specified items before it begins to emit items emitted by the source
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            the first item to emit
     * @param t2
     *            the second item to emit
     * @param t3
     *            the third item to emit
     * @param t4
     *            the fourth item to emit
     * @param t5
     *            the fifth item to emit
     * @return an Observable that emits the specified items before it begins to emit items emitted by the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(T t1, T t2, T t3, T t4, T t5) {
<span class="nc" id="L8098">        return concat(just(t1, t2, t3, t4, t5), this);</span>
    }

    /**
     * Returns an Observable that emits the specified items before it begins to emit items emitted by the source
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            the first item to emit
     * @param t2
     *            the second item to emit
     * @param t3
     *            the third item to emit
     * @param t4
     *            the fourth item to emit
     * @param t5
     *            the fifth item to emit
     * @param t6
     *            the sixth item to emit
     * @return an Observable that emits the specified items before it begins to emit items emitted
     *         by the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(T t1, T t2, T t3, T t4, T t5, T t6) {
<span class="nc" id="L8128">        return concat(just(t1, t2, t3, t4, t5, t6), this);</span>
    }

    /**
     * Returns an Observable that emits the specified items before it begins to emit items emitted by the source
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            the first item to emit
     * @param t2
     *            the second item to emit
     * @param t3
     *            the third item to emit
     * @param t4
     *            the fourth item to emit
     * @param t5
     *            the fifth item to emit
     * @param t6
     *            the sixth item to emit
     * @param t7
     *            the seventh item to emit
     * @return an Observable that emits the specified items before it begins to emit items emitted by the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(T t1, T t2, T t3, T t4, T t5, T t6, T t7) {
<span class="nc" id="L8160">        return concat(just(t1, t2, t3, t4, t5, t6, t7), this);</span>
    }

    /**
     * Returns an Observable that emits the specified items before it begins to emit items emitted by the source
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            the first item to emit
     * @param t2
     *            the second item to emit
     * @param t3
     *            the third item to emit
     * @param t4
     *            the fourth item to emit
     * @param t5
     *            the fifth item to emit
     * @param t6
     *            the sixth item to emit
     * @param t7
     *            the seventh item to emit
     * @param t8
     *            the eighth item to emit
     * @return an Observable that emits the specified items before it begins to emit items emitted by the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8) {
<span class="nc" id="L8194">        return concat(just(t1, t2, t3, t4, t5, t6, t7, t8), this);</span>
    }

    /**
     * Returns an Observable that emits the specified items before it begins to emit items emitted by the source
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param t1
     *            the first item to emit
     * @param t2
     *            the second item to emit
     * @param t3
     *            the third item to emit
     * @param t4
     *            the fourth item to emit
     * @param t5
     *            the fifth item to emit
     * @param t6
     *            the sixth item to emit
     * @param t7
     *            the seventh item to emit
     * @param t8
     *            the eighth item to emit
     * @param t9
     *            the ninth item to emit
     * @return an Observable that emits the specified items before it begins to emit items emitted by the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    public final Observable&lt;T&gt; startWith(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9) {
<span class="nc" id="L8230">        return concat(just(t1, t2, t3, t4, t5, t6, t7, t8, t9), this);</span>
    }

    /**
     * Subscribes to an Observable and ignores {@code onNext} and {@code onCompleted} emissions. If an {@code onError} emission arrives then 
     * {@link OnErrorNotImplementedException} is thrown. 
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving items before
     *         the Observable has finished sending them
     * @throws OnErrorNotImplementedException
     *             if the Observable tries to call {@code onError}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    public final Subscription subscribe() {
<span class="fc" id="L8248">        return subscribe(new Subscriber&lt;T&gt;() {</span>

            @Override
            public final void onCompleted() {
                // do nothing
<span class="fc" id="L8253">            }</span>

            @Override
            public final void onError(Throwable e) {
<span class="fc" id="L8257">                throw new OnErrorNotImplementedException(e);</span>
            }

            @Override
            public final void onNext(T args) {
                // do nothing
<span class="fc" id="L8263">            }</span>

        });
    }

    /**
     * Subscribes to an Observable and provides a callback to handle the items it emits.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onNext
     *             the {@code Action1&lt;T&gt;} you have designed to accept emissions from the Observable
     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving items before
     *         the Observable has finished sending them
     * @throws IllegalArgumentException
     *             if {@code onNext} is null
     * @throws OnErrorNotImplementedException
     *             if the Observable calls {@code onError}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    public final Subscription subscribe(final Action1&lt;? super T&gt; onNext) {
<span class="fc bfc" id="L8286" title="All 2 branches covered.">        if (onNext == null) {</span>
<span class="fc" id="L8287">            throw new IllegalArgumentException(&quot;onNext can not be null&quot;);</span>
        }

<span class="fc" id="L8290">        return subscribe(new Subscriber&lt;T&gt;() {</span>

            @Override
            public final void onCompleted() {
                // do nothing
<span class="fc" id="L8295">            }</span>

            @Override
            public final void onError(Throwable e) {
<span class="fc" id="L8299">                throw new OnErrorNotImplementedException(e);</span>
            }

            @Override
            public final void onNext(T args) {
<span class="fc" id="L8304">                onNext.call(args);</span>
<span class="fc" id="L8305">            }</span>

        });
    }

    /**
     * Subscribes to an Observable and provides callbacks to handle the items it emits and any error
     * notification it issues.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onNext
     *             the {@code Action1&lt;T&gt;} you have designed to accept emissions from the Observable
     * @param onError
     *             the {@code Action1&lt;Throwable&gt;} you have designed to accept any error notification from the
     *             Observable
     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving items before
     *         the Observable has finished sending them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     * @throws IllegalArgumentException
     *             if {@code onNext} is null, or
     *             if {@code onError} is null
     */
    public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError) {
<span class="pc bpc" id="L8331" title="1 of 2 branches missed.">        if (onNext == null) {</span>
<span class="nc" id="L8332">            throw new IllegalArgumentException(&quot;onNext can not be null&quot;);</span>
        }
<span class="pc bpc" id="L8334" title="1 of 2 branches missed.">        if (onError == null) {</span>
<span class="nc" id="L8335">            throw new IllegalArgumentException(&quot;onError can not be null&quot;);</span>
        }

<span class="fc" id="L8338">        return subscribe(new Subscriber&lt;T&gt;() {</span>

            @Override
            public final void onCompleted() {
                // do nothing
<span class="nc" id="L8343">            }</span>

            @Override
            public final void onError(Throwable e) {
<span class="fc" id="L8347">                onError.call(e);</span>
<span class="fc" id="L8348">            }</span>

            @Override
            public final void onNext(T args) {
<span class="nc" id="L8352">                onNext.call(args);</span>
<span class="nc" id="L8353">            }</span>

        });
    }

    /**
     * Subscribes to an Observable and provides callbacks to handle the items it emits and any error or
     * completion notification it issues.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param onNext
     *             the {@code Action1&lt;T&gt;} you have designed to accept emissions from the Observable
     * @param onError
     *             the {@code Action1&lt;Throwable&gt;} you have designed to accept any error notification from the
     *             Observable
     * @param onComplete
     *             the {@code Action0} you have designed to accept a completion notification from the
     *             Observable
     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving items before
     *         the Observable has finished sending them
     * @throws IllegalArgumentException
     *             if {@code onNext} is null, or
     *             if {@code onError} is null, or
     *             if {@code onComplete} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onComplete) {
<span class="pc bpc" id="L8383" title="1 of 2 branches missed.">        if (onNext == null) {</span>
<span class="nc" id="L8384">            throw new IllegalArgumentException(&quot;onNext can not be null&quot;);</span>
        }
<span class="pc bpc" id="L8386" title="1 of 2 branches missed.">        if (onError == null) {</span>
<span class="nc" id="L8387">            throw new IllegalArgumentException(&quot;onError can not be null&quot;);</span>
        }
<span class="pc bpc" id="L8389" title="1 of 2 branches missed.">        if (onComplete == null) {</span>
<span class="nc" id="L8390">            throw new IllegalArgumentException(&quot;onComplete can not be null&quot;);</span>
        }

<span class="fc" id="L8393">        return subscribe(new Subscriber&lt;T&gt;() {</span>

            @Override
            public final void onCompleted() {
<span class="fc" id="L8397">                onComplete.call();</span>
<span class="fc" id="L8398">            }</span>

            @Override
            public final void onError(Throwable e) {
<span class="nc" id="L8402">                onError.call(e);</span>
<span class="nc" id="L8403">            }</span>

            @Override
            public final void onNext(T args) {
<span class="fc" id="L8407">                onNext.call(args);</span>
<span class="fc" id="L8408">            }</span>

        });
    }

    /**
     * Subscribes to an Observable and provides an Observer that implements functions to handle the items the
     * Observable emits and any error or completion notification it issues.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param observer
     *             the Observer that will handle emissions and notifications from the Observable
     * @return a {@link Subscription} reference with which the {@link Observer} can stop receiving items before
     *         the Observable has completed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    public final Subscription subscribe(final Observer&lt;? super T&gt; observer) {
<span class="fc bfc" id="L8428" title="All 2 branches covered.">        if (observer instanceof Subscriber) {</span>
<span class="fc" id="L8429">            return subscribe((Subscriber&lt;? super T&gt;)observer);</span>
        }
<span class="fc" id="L8431">        return subscribe(new Subscriber&lt;T&gt;() {</span>

            @Override
            public void onCompleted() {
<span class="fc" id="L8435">                observer.onCompleted();</span>
<span class="fc" id="L8436">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L8440">                observer.onError(e);</span>
<span class="fc" id="L8441">            }</span>

            @Override
            public void onNext(T t) {
<span class="fc" id="L8445">                observer.onNext(t);</span>
<span class="fc" id="L8446">            }</span>

        });
    }

    /**
     * Subscribes to an Observable and invokes {@link OnSubscribe} function without any contract protection,
     * error handling, unsubscribe, or execution hooks.
     * &lt;p&gt;
     * Use this only for implementing an {@link Operator} that requires nested subscriptions. For other
     * purposes, use {@link #subscribe(Subscriber)} which ensures
     * &lt;a href=&quot;http://reactivex.io/documentation/contract.html&quot;&gt;the Observable contract&lt;/a&gt; and other
     * functionality.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code unsafeSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param subscriber
     *              the Subscriber that will handle emissions and notifications from the Observable
     * @return a {@link Subscription} reference with which the {@link Subscriber} can stop receiving items
     *         before the Observable has completed
     */
    public final Subscription unsafeSubscribe(Subscriber&lt;? super T&gt; subscriber) {
        try {
            // new Subscriber so onStart it
<span class="fc" id="L8472">            subscriber.onStart();</span>
            // allow the hook to intercept and/or decorate
<span class="fc" id="L8474">            hook.onSubscribeStart(this, onSubscribe).call(subscriber);</span>
<span class="fc" id="L8475">            return hook.onSubscribeReturn(subscriber);</span>
<span class="fc" id="L8476">        } catch (Throwable e) {</span>
            // special handling for certain Throwable/Error/Exception types
<span class="fc" id="L8478">            Exceptions.throwIfFatal(e);</span>
            // if an unhandled error occurs executing the onSubscribe we will propagate it
            try {
<span class="fc" id="L8481">                subscriber.onError(hook.onSubscribeError(e));</span>
<span class="nc" id="L8482">            } catch (Throwable e2) {</span>
<span class="nc" id="L8483">                Exceptions.throwIfFatal(e2);</span>
                // if this happens it means the onError itself failed (perhaps an invalid function implementation)
                // so we are unable to propagate the error correctly and will just throw
<span class="nc" id="L8486">                RuntimeException r = new RuntimeException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2);</span>
                // TODO could the hook be the cause of the error in the on error handling.
<span class="nc" id="L8488">                hook.onSubscribeError(r);</span>
                // TODO why aren't we throwing the hook's return value.
<span class="nc" id="L8490">                throw r;</span>
<span class="fc" id="L8491">            }</span>
<span class="fc" id="L8492">            return Subscriptions.unsubscribed();</span>
        }
    }

    /**
     * Subscribes to an Observable and provides a Subscriber that implements functions to handle the items the
     * Observable emits and any error or completion notification it issues.
     * &lt;p&gt;
     * A typical implementation of {@code subscribe} does the following:
     * &lt;ol&gt;
     * &lt;li&gt;It stores a reference to the Subscriber in a collection object, such as a {@code List&lt;T&gt;} object.&lt;/li&gt;
     * &lt;li&gt;It returns a reference to the {@link Subscription} interface. This enables Subscribers to
     * unsubscribe, that is, to stop receiving items and notifications before the Observable completes, which
     * also invokes the Subscriber's {@link Subscriber#onCompleted onCompleted} method.&lt;/li&gt;
     * &lt;/ol&gt;&lt;p&gt;
     * An {@code Observable&lt;T&gt;} instance is responsible for accepting all subscriptions and notifying all
     * Subscribers. Unless the documentation for a particular {@code Observable&lt;T&gt;} implementation indicates
     * otherwise, Subscriber should make no assumptions about the order in which multiple Subscribers will
     * receive their notifications.
     * &lt;p&gt;
     * For more information see the
     * &lt;a href=&quot;http://reactivex.io/documentation/observable.html&quot;&gt;ReactiveX documentation&lt;/a&gt;.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param subscriber
     *            the {@link Subscriber} that will handle emissions and notifications from the Observable
     * @return a {@link Subscription} reference with which Subscribers that are {@link Observer}s can
     *         unsubscribe from the Observable
     * @throws IllegalStateException
     *             if {@code subscribe} is unable to obtain an {@code OnSubscribe&lt;&gt;} function
     * @throws IllegalArgumentException
     *             if the {@link Subscriber} provided as the argument to {@code subscribe} is {@code null}
     * @throws OnErrorNotImplementedException
     *             if the {@link Subscriber}'s {@code onError} method is null
     * @throws RuntimeException
     *             if the {@link Subscriber}'s {@code onError} method itself threw a {@code Throwable}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) {
<span class="fc" id="L8534">        return Observable.subscribe(subscriber, this);</span>
    }
    
    private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {
     // validate and proceed
<span class="pc bpc" id="L8539" title="1 of 2 branches missed.">        if (subscriber == null) {</span>
<span class="nc" id="L8540">            throw new IllegalArgumentException(&quot;observer can not be null&quot;);</span>
        }
<span class="pc bpc" id="L8542" title="1 of 2 branches missed.">        if (observable.onSubscribe == null) {</span>
<span class="nc" id="L8543">            throw new IllegalStateException(&quot;onSubscribe function can not be null.&quot;);</span>
            /*
             * the subscribe function can also be overridden but generally that's not the appropriate approach
             * so I won't mention that in the exception
             */
        }
        
        // new Subscriber so onStart it
<span class="fc" id="L8551">        subscriber.onStart();</span>
        
        /*
         * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on &quot;Guideline 6.4: Protect calls
         * to user code from within an Observer&quot;
         */
        // if not already wrapped
<span class="fc bfc" id="L8558" title="All 2 branches covered.">        if (!(subscriber instanceof SafeSubscriber)) {</span>
            // assign to `observer` so we return the protected version
<span class="fc" id="L8560">            subscriber = new SafeSubscriber&lt;T&gt;(subscriber);</span>
        }

        // The code below is exactly the same an unsafeSubscribe but not used because it would 
        // add a significant depth to already huge call stacks.
        try {
            // allow the hook to intercept and/or decorate
<span class="fc" id="L8567">            hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</span>
<span class="fc" id="L8568">            return hook.onSubscribeReturn(subscriber);</span>
<span class="fc" id="L8569">        } catch (Throwable e) {</span>
            // special handling for certain Throwable/Error/Exception types
<span class="fc" id="L8571">            Exceptions.throwIfFatal(e);</span>
            // if an unhandled error occurs executing the onSubscribe we will propagate it
            try {
<span class="fc" id="L8574">                subscriber.onError(hook.onSubscribeError(e));</span>
<span class="nc" id="L8575">            } catch (Throwable e2) {</span>
<span class="nc" id="L8576">                Exceptions.throwIfFatal(e2);</span>
                // if this happens it means the onError itself failed (perhaps an invalid function implementation)
                // so we are unable to propagate the error correctly and will just throw
<span class="nc" id="L8579">                RuntimeException r = new RuntimeException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2);</span>
                // TODO could the hook be the cause of the error in the on error handling.
<span class="nc" id="L8581">                hook.onSubscribeError(r);</span>
                // TODO why aren't we throwing the hook's return value.
<span class="nc" id="L8583">                throw r;</span>
<span class="fc" id="L8584">            }</span>
<span class="fc" id="L8585">            return Subscriptions.unsubscribed();</span>
        }
    }

    /**
     * Asynchronously subscribes Observers to this Observable on the specified {@link Scheduler}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/subscribeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param scheduler
     *            the {@link Scheduler} to perform subscription actions on
     * @return the source Observable modified so that its subscriptions happen on the
     *         specified {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribeon.html&quot;&gt;ReactiveX operators documentation: SubscribeOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #observeOn
     */
    public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) {
<span class="fc bfc" id="L8607" title="All 2 branches covered.">        if (this instanceof ScalarSynchronousObservable) {</span>
<span class="fc" id="L8608">            return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler);</span>
        }
<span class="fc" id="L8610">        return create(new OperatorSubscribeOn&lt;T&gt;(this, scheduler));</span>
    }

    /**
     * Returns a new Observable by applying a function that you supply to each item emitted by the source
     * Observable that returns an Observable, and then emitting the items emitted by the most recently emitted
     * of these Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;350&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param func
     *            a function that, when applied to an item emitted by the source Observable, returns an
     *            Observable
     * @return an Observable that emits the items emitted by the Observable returned from applying {@code func} to the most recently emitted item emitted by the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    public final &lt;R&gt; Observable&lt;R&gt; switchMap(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; func) {
<span class="fc" id="L8631">        return switchOnNext(map(func));</span>
    }

    /**
     * Returns an Observable that emits only the first {@code count} items emitted by the source Observable. If the source emits fewer than 
     * {@code count} items then all of its items are emitted.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This method returns an Observable that will invoke a subscribing {@link Observer}'s
     * {@link Observer#onNext onNext} function a maximum of {@code count} times before invoking
     * {@link Observer#onCompleted onCompleted}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code take} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum number of items to emit
     * @return an Observable that emits only the first {@code count} items emitted by the source Observable, or
     *         all of the items from the source Observable if that Observable emits fewer than {@code count} items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/take.html&quot;&gt;ReactiveX operators documentation: Take&lt;/a&gt;
     */
    public final Observable&lt;T&gt; take(final int count) {
<span class="fc" id="L8655">        return lift(new OperatorTake&lt;T&gt;(count));</span>
    }

    /**
     * Returns an Observable that emits those items emitted by source Observable before a specified time runs
     * out.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code take} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @return an Observable that emits those items emitted by the source Observable before the time runs out
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/take.html&quot;&gt;ReactiveX operators documentation: Take&lt;/a&gt;
     */
    public final Observable&lt;T&gt; take(long time, TimeUnit unit) {
<span class="nc" id="L8676">        return take(time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits those items emitted by source Observable before a specified time (on a
     * specified Scheduler) runs out.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler used for time source
     * @return an Observable that emits those items emitted by the source Observable before the time runs out,
     *         according to the specified Scheduler
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/take.html&quot;&gt;ReactiveX operators documentation: Take&lt;/a&gt;
     */
    public final Observable&lt;T&gt; take(long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L8700">        return lift(new OperatorTakeTimed&lt;T&gt;(time, unit, scheduler));</span>
    }

    /**
     * Returns an Observable that emits only the very first item emitted by the source Observable that satisfies
     * a specified condition.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeFirstN.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeFirst} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param predicate
     *            the condition any item emitted by the source Observable has to satisfy
     * @return an Observable that emits only the very first item emitted by the source Observable that satisfies
     *         the given condition, or that completes without emitting anything if the source Observable
     *         completes without emitting a single condition-satisfying item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    public final Observable&lt;T&gt; takeFirst(Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L8721">        return filter(predicate).take(1);</span>
    }

    /**
     * Returns an Observable that emits at most the last {@code count} items emitted by the source Observable. If the source emits fewer than 
     * {@code count} items then all of its items are emitted.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.n.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code takeLast} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum number of items to emit from the end of the sequence of items emitted by the source
     *            Observable
     * @return an Observable that emits at most the last {@code count} items emitted by the source Observable
     * @throws IndexOutOfBoundsException
     *             if {@code count} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    public final Observable&lt;T&gt; takeLast(final int count) {
<span class="fc bfc" id="L8743" title="All 2 branches covered.">        if (count == 0)</span>
<span class="fc" id="L8744">            return ignoreElements();</span>
<span class="fc bfc" id="L8745" title="All 2 branches covered.">        else if (count == 1 )</span>
<span class="fc" id="L8746">            return lift(OperatorTakeLastOne.&lt;T&gt;instance());</span>
        else 
<span class="fc" id="L8748">            return lift(new OperatorTakeLast&lt;T&gt;(count));</span>
    }

    /**
     * Returns an Observable that emits at most a specified number of items from the source Observable that were
     * emitted in a specified window of time before the Observable completed. 
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.tn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum number of items to emit
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @return an Observable that emits at most {@code count} items from the source Observable that were emitted
     *         in a specified window of time before the Observable completed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    public final Observable&lt;T&gt; takeLast(int count, long time, TimeUnit unit) {
<span class="nc" id="L8772">        return takeLast(count, time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits at most a specified number of items from the source Observable that were
     * emitted in a specified window of time before the Observable completed, where the timing information is
     * provided by a given Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.tns.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum number of items to emit
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the {@link Scheduler} that provides the timestamps for the observed items
     * @return an Observable that emits at most {@code count} items from the source Observable that were emitted
     *         in a specified window of time before the Observable completed, where the timing information is
     *         provided by the given {@code scheduler}
     * @throws IndexOutOfBoundsException
     *             if {@code count} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    public final Observable&lt;T&gt; takeLast(int count, long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L8802">        return lift(new OperatorTakeLastTimed&lt;T&gt;(count, time, unit, scheduler));</span>
    }

    /**
     * Returns an Observable that emits the items from the source Observable that were emitted in a specified
     * window of time before the Observable completed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @return an Observable that emits the items from the source Observable that were emitted in the window of
     *         time before the Observable completed specified by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    public final Observable&lt;T&gt; takeLast(long time, TimeUnit unit) {
<span class="nc" id="L8824">        return takeLast(time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits the items from the source Observable that were emitted in a specified
     * window of time before the Observable completed, where the timing information is provided by a specified
     * Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler that provides the timestamps for the Observed items
     * @return an Observable that emits the items from the source Observable that were emitted in the window of
     *         time before the Observable completed specified by {@code time}, where the timing information is
     *         provided by {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    public final Observable&lt;T&gt; takeLast(long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L8850">        return lift(new OperatorTakeLastTimed&lt;T&gt;(time, unit, scheduler));</span>
    }

    /**
     * Returns an Observable that emits a single List containing at most the last {@code count} elements emitted by the
     * source Observable. If the source emits fewer than {@code count} items then the emitted List will contain all of the source emissions.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLastBuffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code takeLastBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum number of items to emit in the list
     * @return an Observable that emits a single list containing at most the last {@code count} elements emitted by the
     *         source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; takeLastBuffer(int count) {
<span class="nc" id="L8870">        return takeLast(count).toList();</span>
    }

    /**
     * Returns an Observable that emits a single List containing at most {@code count} items from the source
     * Observable that were emitted during a specified window of time before the source Observable completed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLastBuffer.tn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code takeLastBuffer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum number of items to emit
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @return an Observable that emits a single List containing at most {@code count} items emitted by the
     *         source Observable during the time window defined by {@code time} before the source Observable
     *         completed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; takeLastBuffer(int count, long time, TimeUnit unit) {
<span class="nc" id="L8895">        return takeLast(count, time, unit).toList();</span>
    }

    /**
     * Returns an Observable that emits a single List containing at most {@code count} items from the source
     * Observable that were emitted during a specified window of time (on a specified Scheduler) before the
     * source Observable completed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLastBuffer.tns.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum number of items to emit
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler that provides the timestamps for the observed items
     * @return an Observable that emits a single List containing at most {@code count} items emitted by the
     *         source Observable during the time window defined by {@code time} before the source Observable
     *         completed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; takeLastBuffer(int count, long time, TimeUnit unit, Scheduler scheduler) {
<span class="nc" id="L8923">        return takeLast(count, time, unit, scheduler).toList();</span>
    }

    /**
     * Returns an Observable that emits a single List containing those items from the source Observable that
     * were emitted during a specified window of time before the source Observable completed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLastBuffer.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code takeLastBuffer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @return an Observable that emits a single List containing the items emitted by the source Observable
     *         during the time window defined by {@code time} before the source Observable completed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; takeLastBuffer(long time, TimeUnit unit) {
<span class="nc" id="L8945">        return takeLast(time, unit).toList();</span>
    }

    /**
     * Returns an Observable that emits a single List containing those items from the source Observable that
     * were emitted during a specified window of time before the source Observable completed, where the timing
     * information is provided by the given Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLastBuffer.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler that provides the timestamps for the observed items
     * @return an Observable that emits a single List containing the items emitted by the source Observable
     *         during the time window defined by {@code time} before the source Observable completed, where the
     *         timing information is provided by {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; takeLastBuffer(long time, TimeUnit unit, Scheduler scheduler) {
<span class="nc" id="L8971">        return takeLast(time, unit, scheduler).toList();</span>
    }

    /**
     * Returns an Observable that emits the items emitted by the source Observable until a second Observable
     * emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param other
     *            the Observable whose first emitted item will cause {@code takeUntil} to stop emitting items
     *            from the source Observable
     * @param &lt;E&gt;
     *            the type of items emitted by {@code other}
     * @return an Observable that emits the items emitted by the source Observable until such time as {@code other} emits its first item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takeuntil.html&quot;&gt;ReactiveX operators documentation: TakeUntil&lt;/a&gt;
     */
    public final &lt;E&gt; Observable&lt;T&gt; takeUntil(Observable&lt;? extends E&gt; other) {
<span class="fc" id="L8993">        return lift(new OperatorTakeUntil&lt;T, E&gt;(other));</span>
    }

    /**
     * Returns an Observable that emits items emitted by the source Observable so long as each item satisfied a
     * specified condition, and then completes as soon as this condition is not satisfied.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeWhile.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeWhile} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param predicate
     *            a function that evaluates an item emitted by the source Observable and returns a Boolean
     * @return an Observable that emits the items from the source Observable so long as each item satisfies the
     *         condition defined by {@code predicate}, then completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takewhile.html&quot;&gt;ReactiveX operators documentation: TakeWhile&lt;/a&gt;
     * @see Observable#takeUntil(Func1)
     */
    public final Observable&lt;T&gt; takeWhile(final Func1&lt;? super T, Boolean&gt; predicate) {
<span class="fc" id="L9014">        return lift(new OperatorTakeWhile&lt;T&gt;(predicate));</span>
    }

    /**
     * Returns an Observable that emits items emitted by the source Observable, checks the specified predicate
     * for each item, and then completes if the condition is satisfied.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * The difference between this operator and {@link #takeWhile(Func1)} is that here, the condition is
     * evaluated &lt;em&gt;after&lt;/em&gt; the item is emitted.
     * 
     * @warn &quot;Scheduler&quot; and &quot;Backpressure Support&quot; sections missing from javadocs
     * @param stopPredicate 
     *            a function that evaluates an item emitted by the source Observable and returns a Boolean
     * @return an Observable that first emits items emitted by the source Observable, checks the specified
     *         condition after each item, and then completes if the condition is satisfied.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takeuntil.html&quot;&gt;ReactiveX operators documentation: TakeUntil&lt;/a&gt;
     * @see Observable#takeWhile(Func1)
     * @since 1.1.0
     */
    public final Observable&lt;T&gt; takeUntil(final Func1&lt;? super T, Boolean&gt; stopPredicate) {
<span class="fc" id="L9036">        return lift(new OperatorTakeUntilPredicate&lt;T&gt;(stopPredicate));</span>
    }
    
    /**
     * Returns an Observable that emits only the first item emitted by the source Observable during sequential
     * time windows of a specified duration.
     * &lt;p&gt;
     * This differs from {@link #throttleLast} in that this only tracks passage of time whereas
     * {@link #throttleLast} ticks at scheduled intervals.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code throttleFirst} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param windowDuration
     *            time to wait before emitting another item after emitting the last item
     * @param unit
     *            the unit of time of {@code windowDuration}
     * @return an Observable that performs the throttle operation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     */
    public final Observable&lt;T&gt; throttleFirst(long windowDuration, TimeUnit unit) {
<span class="nc" id="L9063">        return throttleFirst(windowDuration, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits only the first item emitted by the source Observable during sequential
     * time windows of a specified duration, where the windows are managed by a specified Scheduler.
     * &lt;p&gt;
     * This differs from {@link #throttleLast} in that this only tracks passage of time whereas
     * {@link #throttleLast} ticks at scheduled intervals.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param skipDuration
     *            time to wait before emitting another item after emitting the last item
     * @param unit
     *            the unit of time of {@code skipDuration}
     * @param scheduler
     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each
     *            event
     * @return an Observable that performs the throttle operation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     */
    public final Observable&lt;T&gt; throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L9093">        return lift(new OperatorThrottleFirst&lt;T&gt;(skipDuration, unit, scheduler));</span>
    }

    /**
     * Returns an Observable that emits only the last item emitted by the source Observable during sequential
     * time windows of a specified duration.
     * &lt;p&gt;
     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas
     * {@link #throttleFirst} does not tick, it just tracks passage of time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLast.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code throttleLast} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param intervalDuration
     *            duration of windows within which the last item emitted by the source Observable will be
     *            emitted
     * @param unit
     *            the unit of time of {@code intervalDuration}
     * @return an Observable that performs the throttle operation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #sample(long, TimeUnit)
     */
    public final Observable&lt;T&gt; throttleLast(long intervalDuration, TimeUnit unit) {
<span class="fc" id="L9122">        return sample(intervalDuration, unit);</span>
    }

    /**
     * Returns an Observable that emits only the last item emitted by the source Observable during sequential
     * time windows of a specified duration, where the duration is governed by a specified Scheduler.
     * &lt;p&gt;
     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas
     * {@link #throttleFirst} does not tick, it just tracks passage of time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLast.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param intervalDuration
     *            duration of windows within which the last item emitted by the source Observable will be
     *            emitted
     * @param unit
     *            the unit of time of {@code intervalDuration}
     * @param scheduler
     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each
     *            event
     * @return an Observable that performs the throttle operation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #sample(long, TimeUnit, Scheduler)
     */
    public final Observable&lt;T&gt; throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L9154">        return sample(intervalDuration, unit, scheduler);</span>
    }

    /**
     * Returns an Observable that only emits those items emitted by the source Observable that are not followed
     * by another emitted item within a specified time window.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; If the source Observable keeps emitting items more frequently than the length of the time
     * window then no items will be emitted by the resulting Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleWithTimeout.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Information on debounce vs throttle:
     * &lt;p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;&lt;a href=&quot;http://drupalmotion.com/article/debounce-and-throttle-visual-explanation&quot;&gt;Debounce and Throttle: visual explanation&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;http://unscriptable.com/2009/03/20/debouncing-javascript-methods/&quot;&gt;Debouncing: javascript methods&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/&quot;&gt;Javascript - don't spam your server: debounce and throttle&lt;/a&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code throttleWithTimeout} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timeout
     *            the length of the window of time that must pass after the emission of an item from the source
     *            Observable in which that Observable emits no items in order for the item to be emitted by the
     *            resulting Observable
     * @param unit
     *            the {@link TimeUnit} of {@code timeout}
     * @return an Observable that filters out items that are too quickly followed by newer items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/debounce.html&quot;&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #debounce(long, TimeUnit)
     */
    public final Observable&lt;T&gt; throttleWithTimeout(long timeout, TimeUnit unit) {
<span class="nc" id="L9192">        return debounce(timeout, unit);</span>
    }

    /**
     * Returns an Observable that only emits those items emitted by the source Observable that are not followed
     * by another emitted item within a specified time window, where the time window is governed by a specified
     * Scheduler.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; If the source Observable keeps emitting items more frequently than the length of the time
     * window then no items will be emitted by the resulting Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleWithTimeout.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Information on debounce vs throttle:
     * &lt;p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;&lt;a href=&quot;http://drupalmotion.com/article/debounce-and-throttle-visual-explanation&quot;&gt;Debounce and Throttle: visual explanation&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;http://unscriptable.com/2009/03/20/debouncing-javascript-methods/&quot;&gt;Debouncing: javascript methods&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/&quot;&gt;Javascript - don't spam your server: debounce and throttle&lt;/a&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timeout
     *            the length of the window of time that must pass after the emission of an item from the source
     *            Observable in which that Observable emits no items in order for the item to be emitted by the
     *            resulting Observable
     * @param unit
     *            the {@link TimeUnit} of {@code timeout}
     * @param scheduler
     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each
     *            item
     * @return an Observable that filters out items that are too quickly followed by newer items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/debounce.html&quot;&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #debounce(long, TimeUnit, Scheduler)
     */
    public final Observable&lt;T&gt; throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L9234">        return debounce(timeout, unit, scheduler);</span>
    }

    /**
     * Returns an Observable that emits records of the time interval between consecutive items emitted by the
     * source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeInterval.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeInterval} operates by default on the {@code immediate} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits time interval information items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeinterval.html&quot;&gt;ReactiveX operators documentation: TimeInterval&lt;/a&gt;
     */
    public final Observable&lt;TimeInterval&lt;T&gt;&gt; timeInterval() {
<span class="nc" id="L9251">        return timeInterval(Schedulers.immediate());</span>
    }

    /**
     * Returns an Observable that emits records of the time interval between consecutive items emitted by the
     * source Observable, where this interval is computed on a specified Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeInterval.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param scheduler
     *            the {@link Scheduler} used to compute time intervals
     * @return an Observable that emits time interval information items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeinterval.html&quot;&gt;ReactiveX operators documentation: TimeInterval&lt;/a&gt;
     */
    public final Observable&lt;TimeInterval&lt;T&gt;&gt; timeInterval(Scheduler scheduler) {
<span class="fc" id="L9270">        return lift(new OperatorTimeInterval&lt;T&gt;(scheduler));</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable, but notifies observers of a
     * {@code TimeoutException} if either the first item emitted by the source Observable or any subsequent item
     * doesn't arrive within time windows defined by other Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout5.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;U&gt;
     *            the first timeout value type (ignored)
     * @param &lt;V&gt;
     *            the subsequent timeout value type (ignored)
     * @param firstTimeoutSelector
     *            a function that returns an Observable that determines the timeout window for the first source
     *            item
     * @param timeoutSelector
     *            a function that returns an Observable for each item emitted by the source Observable and that
     *            determines the timeout window in which the subsequent source item must arrive in order to
     *            continue the sequence
     * @return an Observable that mirrors the source Observable, but notifies observers of a
     *         {@code TimeoutException} if either the first item or any subsequent item doesn't arrive within
     *         the time windows specified by the timeout selectors
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    public final &lt;U, V&gt; Observable&lt;T&gt; timeout(Func0&lt;? extends Observable&lt;U&gt;&gt; firstTimeoutSelector, Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector) {
<span class="fc" id="L9301">        return timeout(firstTimeoutSelector, timeoutSelector, null);</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable, but switches to a fallback Observable if either
     * the first item emitted by the source Observable or any subsequent item doesn't arrive within time windows
     * defined by other Observables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout6.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;U&gt;
     *            the first timeout value type (ignored)
     * @param &lt;V&gt;
     *            the subsequent timeout value type (ignored)
     * @param firstTimeoutSelector
     *            a function that returns an Observable which determines the timeout window for the first source
     *            item
     * @param timeoutSelector
     *            a function that returns an Observable for each item emitted by the source Observable and that
     *            determines the timeout window in which the subsequent source item must arrive in order to
     *            continue the sequence
     * @param other
     *            the fallback Observable to switch to if the source Observable times out
     * @return an Observable that mirrors the source Observable, but switches to the {@code other} Observable if
     *         either the first item emitted by the source Observable or any subsequent item doesn't arrive
     *         within time windows defined by the timeout selectors
     * @throws NullPointerException
     *             if {@code timeoutSelector} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    public final &lt;U, V&gt; Observable&lt;T&gt; timeout(Func0&lt;? extends Observable&lt;U&gt;&gt; firstTimeoutSelector, Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector, Observable&lt;? extends T&gt; other) {
<span class="pc bpc" id="L9336" title="1 of 2 branches missed.">        if (timeoutSelector == null) {</span>
<span class="nc" id="L9337">            throw new NullPointerException(&quot;timeoutSelector is null&quot;);</span>
        }
<span class="fc" id="L9339">        return lift(new OperatorTimeoutWithSelector&lt;T, U, V&gt;(firstTimeoutSelector, timeoutSelector, other));</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable, but notifies observers of a
     * {@code TimeoutException} if an item emitted by the source Observable doesn't arrive within a window of
     * time after the emission of the previous item, where that period of time is measured by an Observable that
     * is a function of the previous item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout3.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: The arrival of the first source item is never timed out.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;V&gt;
     *            the timeout value type (ignored)
     * @param timeoutSelector
     *            a function that returns an observable for each item emitted by the source
     *            Observable and that determines the timeout window for the subsequent item
     * @return an Observable that mirrors the source Observable, but notifies observers of a
     *         {@code TimeoutException} if an item emitted by the source Observable takes longer to arrive than
     *         the time window defined by the selector for the previously emitted item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    public final &lt;V&gt; Observable&lt;T&gt; timeout(Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector) {
<span class="nc" id="L9367">        return timeout(null, timeoutSelector, null);</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable, but that switches to a fallback Observable if
     * an item emitted by the source Observable doesn't arrive within a window of time after the emission of the
     * previous item, where that period of time is measured by an Observable that is a function of the previous
     * item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout4.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: The arrival of the first source item is never timed out.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;V&gt;
     *            the timeout value type (ignored)
     * @param timeoutSelector
     *            a function that returns an Observable, for each item emitted by the source Observable, that
     *            determines the timeout window for the subsequent item
     * @param other
     *            the fallback Observable to switch to if the source Observable times out
     * @return an Observable that mirrors the source Observable, but switches to mirroring a fallback Observable
     *         if an item emitted by the source Observable takes longer to arrive than the time window defined
     *         by the selector for the previously emitted item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    public final &lt;V&gt; Observable&lt;T&gt; timeout(Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector, Observable&lt;? extends T&gt; other) {
<span class="fc" id="L9397">        return timeout(null, timeoutSelector, other);</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,
     * the resulting Observable terminates and notifies observers of a {@code TimeoutException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timeout
     *            maximum duration between emitted items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument.
     * @return the source Observable modified to notify observers of a {@code TimeoutException} in case of a
     *         timeout
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    public final Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit) {
<span class="fc" id="L9420">        return timeout(timeout, timeUnit, null, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,
     * the resulting Observable begins instead to mirror a fallback Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.2.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timeout
     *            maximum duration between items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument
     * @param other
     *            the fallback Observable to use in case of a timeout
     * @return the source Observable modified to switch to the fallback Observable in case of a timeout
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    public final Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Observable&lt;? extends T&gt; other) {
<span class="nc" id="L9444">        return timeout(timeout, timeUnit, other, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
     * item using a specified Scheduler. If the next item isn't emitted within the specified timeout duration
     * starting from its predecessor, the resulting Observable begins instead to mirror a fallback Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.2s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timeout
     *            maximum duration between items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument
     * @param other
     *            the Observable to use as the fallback in case of a timeout
     * @param scheduler
     *            the {@link Scheduler} to run the timeout timers on
     * @return the source Observable modified so that it will switch to the fallback Observable in case of a
     *         timeout
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    public final Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Observable&lt;? extends T&gt; other, Scheduler scheduler) {
<span class="fc" id="L9471">        return lift(new OperatorTimeout&lt;T&gt;(timeout, timeUnit, other, scheduler));</span>
    }

    /**
     * Returns an Observable that mirrors the source Observable but applies a timeout policy for each emitted
     * item, where this policy is governed on a specified Scheduler. If the next item isn't emitted within the
     * specified timeout duration starting from its predecessor, the resulting Observable terminates and
     * notifies observers of a {@code TimeoutException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timeout
     *            maximum duration between items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument
     * @param scheduler
     *            the Scheduler to run the timeout timers on
     * @return the source Observable modified to notify observers of a {@code TimeoutException} in case of a
     *         timeout
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    public final Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {
<span class="fc" id="L9497">        return timeout(timeout, timeUnit, null, scheduler);</span>
    }

    /**
     * Returns an Observable that emits each item emitted by the source Observable, wrapped in a
     * {@link Timestamped} object.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timestamp.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timestamp} operates by default on the {@code immediate} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits timestamped items from the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timestamp.html&quot;&gt;ReactiveX operators documentation: Timestamp&lt;/a&gt;
     */
    public final Observable&lt;Timestamped&lt;T&gt;&gt; timestamp() {
<span class="nc" id="L9514">        return timestamp(Schedulers.immediate());</span>
    }

    /**
     * Returns an Observable that emits each item emitted by the source Observable, wrapped in a
     * {@link Timestamped} object whose timestamps are provided by a specified Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timestamp.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param scheduler
     *            the {@link Scheduler} to use as a time source
     * @return an Observable that emits timestamped items from the source Observable with timestamps provided by
     *         the {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timestamp.html&quot;&gt;ReactiveX operators documentation: Timestamp&lt;/a&gt;
     */
    public final Observable&lt;Timestamped&lt;T&gt;&gt; timestamp(Scheduler scheduler) {
<span class="fc" id="L9534">        return lift(new OperatorTimestamp&lt;T&gt;(scheduler));</span>
    }

    /**
     * Converts an Observable into a {@link BlockingObservable} (an Observable with blocking operators).
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toBlocking} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@code BlockingObservable} version of this Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final BlockingObservable&lt;T&gt; toBlocking() {
<span class="fc" id="L9548">        return BlockingObservable.from(this);</span>
    }

    /**
     * Returns an Observable that emits a single item, a list composed of all the items emitted by the source
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Normally, an Observable that returns multiple items will do so by invoking its {@link Observer}'s
     * {@link Observer#onNext onNext} method for each such item. You can change this behavior, instructing the
     * Observable to compose a list of all of these items and then to invoke the Observer's {@code onNext}
     * function once, passing it the entire list, by calling the Observable's {@code toList} method prior to
     * calling its {@link #subscribe} method.
     * &lt;p&gt;
     * Be careful not to use this operator on Observables that emit infinite or very large numbers of items, as
     * you do not have the option to unsubscribe.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator buffers everything from its upstream but it only emits the aggregated list when the downstream requests at least one item.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @return an Observable that emits a single item: a List containing all of the items emitted by the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; toList() {
<span class="fc" id="L9577">        return lift(OperatorToObservableList.&lt;T&gt;instance());</span>
    }

    /**
     * Returns an Observable that emits a single HashMap containing all items emitted by the source Observable,
     * mapped by the keys returned by a specified {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If more than one source item maps to the same key, the HashMap will contain the latest of those items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as by intent it is requesting and buffering everything.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            the function that extracts the key from a source item to be used in the HashMap
     * @return an Observable that emits a single item: a HashMap containing the mapped items from the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final &lt;K&gt; Observable&lt;Map&lt;K, T&gt;&gt; toMap(Func1&lt;? super T, ? extends K&gt; keySelector) {
<span class="fc" id="L9601">        return lift(new OperatorToMap&lt;T, K, T&gt;(keySelector, UtilityFunctions.&lt;T&gt;identity()));</span>
    }

    /**
     * Returns an Observable that emits a single HashMap containing values corresponding to items emitted by the
     * source Observable, mapped by the keys returned by a specified {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If more than one source item maps to the same key, the HashMap will contain a single entry that
     * corresponds to the latest of those items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as by intent it is requesting and buffering everything.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            the function that extracts the key from a source item to be used in the HashMap
     * @param valueSelector
     *            the function that extracts the value from a source item to be used in the HashMap
     * @return an Observable that emits a single item: a HashMap containing the mapped items from the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final &lt;K, V&gt; Observable&lt;Map&lt;K, V&gt;&gt; toMap(Func1&lt;? super T, ? extends K&gt; keySelector, Func1&lt;? super T, ? extends V&gt; valueSelector) {
<span class="fc" id="L9628">        return lift(new OperatorToMap&lt;T, K, V&gt;(keySelector, valueSelector));</span>
    }

    /**
     * Returns an Observable that emits a single Map, returned by a specified {@code mapFactory} function, that
     * contains keys and values extracted from the items emitted by the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as by intent it is requesting and buffering everything.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            the function that extracts the key from a source item to be used in the Map
     * @param valueSelector
     *            the function that extracts the value from the source items to be used as value in the Map
     * @param mapFactory
     *            the function that returns a Map instance to be used
     * @return an Observable that emits a single item: a Map that contains the mapped items emitted by the
     *         source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final &lt;K, V&gt; Observable&lt;Map&lt;K, V&gt;&gt; toMap(Func1&lt;? super T, ? extends K&gt; keySelector, Func1&lt;? super T, ? extends V&gt; valueSelector, Func0&lt;? extends Map&lt;K, V&gt;&gt; mapFactory) {
<span class="fc" id="L9654">        return lift(new OperatorToMap&lt;T, K, V&gt;(keySelector, valueSelector, mapFactory));</span>
    }

    /**
     * Returns an Observable that emits a single HashMap that contains an ArrayList of items emitted by the
     * source Observable keyed by a specified {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as by intent it is requesting and buffering everything.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMultiMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            the function that extracts the key from the source items to be used as key in the HashMap
     * @return an Observable that emits a single item: a HashMap that contains an ArrayList of items mapped from
     *         the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final &lt;K&gt; Observable&lt;Map&lt;K, Collection&lt;T&gt;&gt;&gt; toMultimap(Func1&lt;? super T, ? extends K&gt; keySelector) {
<span class="fc" id="L9676">        return lift(new OperatorToMultimap&lt;T, K, T&gt;(keySelector, UtilityFunctions.&lt;T&gt;identity()));</span>
    }

    /**
     * Returns an Observable that emits a single HashMap that contains an ArrayList of values extracted by a
     * specified {@code valueSelector} function from items emitted by the source Observable, keyed by a
     * specified {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as by intent it is requesting and buffering everything.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMultiMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            the function that extracts a key from the source items to be used as key in the HashMap
     * @param valueSelector
     *            the function that extracts a value from the source items to be used as value in the HashMap
     * @return an Observable that emits a single item: a HashMap that contains an ArrayList of items mapped from
     *         the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final &lt;K, V&gt; Observable&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; toMultimap(Func1&lt;? super T, ? extends K&gt; keySelector, Func1&lt;? super T, ? extends V&gt; valueSelector) {
<span class="fc" id="L9701">        return lift(new OperatorToMultimap&lt;T, K, V&gt;(keySelector, valueSelector));</span>
    }

    /**
     * Returns an Observable that emits a single Map, returned by a specified {@code mapFactory} function, that
     * contains an ArrayList of values, extracted by a specified {@code valueSelector} function from items
     * emitted by the source Observable and keyed by the {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as by intent it is requesting and buffering everything.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMultiMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            the function that extracts a key from the source items to be used as the key in the Map
     * @param valueSelector
     *            the function that extracts a value from the source items to be used as the value in the Map
     * @param mapFactory
     *            the function that returns a Map instance to be used
     * @return an Observable that emits a single item: a Map that contains a list items mapped from the source
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final &lt;K, V&gt; Observable&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; toMultimap(Func1&lt;? super T, ? extends K&gt; keySelector, Func1&lt;? super T, ? extends V&gt; valueSelector, Func0&lt;? extends Map&lt;K, Collection&lt;V&gt;&gt;&gt; mapFactory) {
<span class="fc" id="L9728">        return lift(new OperatorToMultimap&lt;T, K, V&gt;(keySelector, valueSelector, mapFactory));</span>
    }

    /**
     * Returns an Observable that emits a single Map, returned by a specified {@code mapFactory} function, that
     * contains a custom collection of values, extracted by a specified {@code valueSelector} function from
     * items emitted by the source Observable, and keyed by the {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as by intent it is requesting and buffering everything.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMultiMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param keySelector
     *            the function that extracts a key from the source items to be used as the key in the Map
     * @param valueSelector
     *            the function that extracts a value from the source items to be used as the value in the Map
     * @param mapFactory
     *            the function that returns a Map instance to be used
     * @param collectionFactory
     *            the function that returns a Collection instance for a particular key to be used in the Map
     * @return an Observable that emits a single item: a Map that contains the collection of mapped items from
     *         the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final &lt;K, V&gt; Observable&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; toMultimap(Func1&lt;? super T, ? extends K&gt; keySelector, Func1&lt;? super T, ? extends V&gt; valueSelector, Func0&lt;? extends Map&lt;K, Collection&lt;V&gt;&gt;&gt; mapFactory, Func1&lt;? super K, ? extends Collection&lt;V&gt;&gt; collectionFactory) {
<span class="fc" id="L9757">        return lift(new OperatorToMultimap&lt;T, K, V&gt;(keySelector, valueSelector, mapFactory, collectionFactory));</span>
    }

    /**
     * Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
     * sorted order. Each item emitted by the Observable must implement {@link Comparable} with respect to all
     * other items in the sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator buffers everything from its upstream but it only emits the sorted list when the downstream requests at least one item.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSortedList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @throws ClassCastException
     *             if any item emitted by the Observable does not implement {@link Comparable} with respect to
     *             all other items emitted by the Observable
     * @return an Observable that emits a list that contains the items emitted by the source Observable in
     *         sorted order
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; toSortedList() {
<span class="fc" id="L9781">        return lift(new OperatorToObservableSortedList&lt;T&gt;(10));</span>
    }

    /**
     * Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
     * sorted order based on a specified comparison function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator buffers everything from its upstream but it only emits the sorted list when the downstream requests at least one item.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSortedList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param sortFunction
     *            a function that compares two items emitted by the source Observable and returns an Integer
     *            that indicates their sort order
     * @return an Observable that emits a list that contains the items emitted by the source Observable in
     *         sorted order
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    public final Observable&lt;List&lt;T&gt;&gt; toSortedList(Func2&lt;? super T, ? super T, Integer&gt; sortFunction) {
<span class="fc" id="L9804">        return lift(new OperatorToObservableSortedList&lt;T&gt;(sortFunction, 10));</span>
    }

    /**
     * Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
     * sorted order. Each item emitted by the Observable must implement {@link Comparable} with respect to all
     * other items in the sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator buffers everything from its upstream but it only emits the sorted list when the downstream requests at least one item.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSortedList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @throws ClassCastException
     *             if any item emitted by the Observable does not implement {@link Comparable} with respect to
     *             all other items emitted by the Observable
     * @param initialCapacity 
     *             the initial capacity of the ArrayList used to accumulate items before sorting
     * @return an Observable that emits a list that contains the items emitted by the source Observable in
     *         sorted order
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    public final Observable&lt;List&lt;T&gt;&gt; toSortedList(int initialCapacity) {
<span class="nc" id="L9832">        return lift(new OperatorToObservableSortedList&lt;T&gt;(initialCapacity));</span>
    }

    /**
     * Returns an Observable that emits a list that contains the items emitted by the source Observable, in a
     * sorted order based on a specified comparison function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator buffers everything from its upstream but it only emits the sorted list when the downstream requests at least one item.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSortedList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param sortFunction
     *            a function that compares two items emitted by the source Observable and returns an Integer
     *            that indicates their sort order
     * @param initialCapacity 
     *             the initial capacity of the ArrayList used to accumulate items before sorting
     * @return an Observable that emits a list that contains the items emitted by the source Observable in
     *         sorted order
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     */
    @Experimental
    public final Observable&lt;List&lt;T&gt;&gt; toSortedList(Func2&lt;? super T, ? super T, Integer&gt; sortFunction, int initialCapacity) {
<span class="nc" id="L9859">        return lift(new OperatorToObservableSortedList&lt;T&gt;(sortFunction, initialCapacity));</span>
    }

    /**
     * Modifies the source Observable so that subscribers will unsubscribe from it on a specified
     * {@link Scheduler}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param scheduler
     *            the {@link Scheduler} to perform unsubscription actions on
     * @return the source Observable modified so that its unsubscriptions happen on the specified
     *         {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribeon.html&quot;&gt;ReactiveX operators documentation: SubscribeOn&lt;/a&gt;
     */
    public final Observable&lt;T&gt; unsubscribeOn(Scheduler scheduler) {
<span class="fc" id="L9877">        return lift(new OperatorUnsubscribeOn&lt;T&gt;(scheduler));</span>
    }

    /**
     * Merges the specified Observable into this Observable sequence by using the {@code resultSelector}
     * function only when the source Observable (this instance) emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/withLatestFrom.png&quot; alt=&quot;&quot;&gt;
     *
     * @warn &quot;Backpressure Support&quot; section missing from javadoc
     * @warn &quot;Scheduler&quot; section missing from javadoc
     * @param other
     *            the other Observable
     * @param resultSelector
     *            the function to call when this Observable emits an item and the other Observable has already
     *            emitted an item, to generate the item to be emitted by the resulting Observable
     * @return an Observable that merges the specified Observable into this Observable by using the
     *         {@code resultSelector} function only when the source Observable sequence (this instance) emits an
     *         item
     * @Experimental The behavior of this can change at any time.
     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @Experimental
    public final &lt;U, R&gt; Observable&lt;R&gt; withLatestFrom(Observable&lt;? extends U&gt; other, Func2&lt;? super T, ? super U, ? extends R&gt; resultSelector) {
<span class="fc" id="L9902">        return lift(new OperatorWithLatestFrom&lt;T, U, R&gt;(other, resultSelector));</span>
    }
    
    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping windows. It emits the current window and opens a new one
     * whenever the Observable produced by the specified {@code closingSelector} emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;460&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window1.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses the {@code closingSelector} to control data
     *      flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param closingSelector
     *            a {@link Func0} that returns an {@code Observable} that governs the boundary between windows.
     *            When this {@code Observable} emits an item, {@code window} emits the current window and begins
     *            a new one.
     * @return an Observable that emits connected, non-overlapping windows of items from the source Observable
     *         whenever {@code closingSelector} emits an item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final &lt;TClosing&gt; Observable&lt;Observable&lt;T&gt;&gt; window(Func0&lt;? extends Observable&lt;? extends TClosing&gt;&gt; closingSelector) {
<span class="fc" id="L9928">        return lift(new OperatorWindowWithObservableFactory&lt;T, TClosing&gt;(closingSelector));</span>
    }

    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping windows, each containing {@code count} items. When the source
     * Observable completes or encounters an error, the resulting Observable emits the current window and
     * propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window3.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables 
     *  but each of them will emit at most {@code count} elements.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum size of each window before it should be emitted
     * @return an Observable that emits connected, non-overlapping windows, each containing at most
     *         {@code count} items from the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final Observable&lt;Observable&lt;T&gt;&gt; window(int count) {
<span class="fc" id="L9953">        return window(count, count);</span>
    }

    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable emits windows every {@code skip} items, each containing no more than {@code count} items. When
     * the source Observable completes or encounters an error, the resulting Observable emits the current window
     * and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;365&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window4.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure on its outer subscriber, ignores backpressure in its inner Observables 
     *  but each of them will emit at most {@code count} elements.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param count
     *            the maximum size of each window before it should be emitted
     * @param skip
     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and
     *            {@code count} are equal this is the same operation as {@link #window(int)}.
     * @return an Observable that emits windows every {@code skip} items containing at most {@code count} items
     *         from the source Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final Observable&lt;Observable&lt;T&gt;&gt; window(int count, int skip) {
<span class="fc" id="L9981">        return lift(new OperatorWindowWithSize&lt;T&gt;(count, skip));</span>
    }

    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable starts a new window periodically, as determined by the {@code timeshift} argument. It emits
     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source
     * Observable completes or Observable completes or encounters an error, the resulting Observable emits the
     * current window and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;335&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each window collects items before it should be emitted
     * @param timeshift
     *            the period of time after which a new window will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
     * @return an Observable that emits new windows periodically as a fixed timespan elapses
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final Observable&lt;Observable&lt;T&gt;&gt; window(long timespan, long timeshift, TimeUnit unit) {
<span class="nc" id="L10009">        return window(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable starts a new window periodically, as determined by the {@code timeshift} argument. It emits
     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source
     * Observable completes or Observable completes or encounters an error, the resulting Observable emits the
     * current window and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;335&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each window collects items before it should be emitted
     * @param timeshift
     *            the period of time after which a new window will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a window
     * @return an Observable that emits new windows periodically as a fixed timespan elapses
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final Observable&lt;Observable&lt;T&gt;&gt; window(long timespan, long timeshift, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L10039">        return window(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler);</span>
    }
    
    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable starts a new window periodically, as determined by the {@code timeshift} argument or a maximum
     * size as specified by the {@code count} argument (whichever is reached first). It emits
     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source
     * Observable completes or Observable completes or encounters an error, the resulting Observable emits the
     * current window and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;335&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each window collects items before it should be emitted
     * @param timeshift
     *            the period of time after which a new window will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
     * @param count
     *            the maximum size of each window before it should be emitted
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a window
     * @return an Observable that emits new windows periodically as a fixed timespan elapses
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final Observable&lt;Observable&lt;T&gt;&gt; window(long timespan, long timeshift, TimeUnit unit, int count, Scheduler scheduler) {
<span class="fc" id="L10072">        return lift(new OperatorWindowWithTime&lt;T&gt;(timespan, timeshift, unit, count, scheduler));</span>
    }

    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping windows, each of a fixed duration specified by the
     * {@code timespan} argument. When the source Observable completes or encounters an error, the resulting
     * Observable emits the current window and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;375&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window5.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time that applies to the {@code timespan} argument
     * @return an Observable that emits connected, non-overlapping windows represending items emitted by the
     *         source Observable during fixed, consecutive durations
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final Observable&lt;Observable&lt;T&gt;&gt; window(long timespan, TimeUnit unit) {
<span class="fc" id="L10099">        return window(timespan, timespan, unit, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping windows, each of a fixed duration as specified by the
     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is
     * reached first). When the source Observable completes or encounters an error, the resulting Observable
     * emits the current window and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time that applies to the {@code timespan} argument
     * @param count
     *            the maximum size of each window before it should be emitted
     * @return an Observable that emits connected, non-overlapping windows of items from the source Observable
     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity
     *         (whichever occurs first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final Observable&lt;Observable&lt;T&gt;&gt; window(long timespan, TimeUnit unit, int count) {
<span class="nc" id="L10130">        return window(timespan, unit, count, Schedulers.computation());</span>
    }

    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping windows, each of a fixed duration specified by the
     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached
     * first). When the source Observable completes or encounters an error, the resulting Observable emits the
     * current window and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param count
     *            the maximum size of each window before it should be emitted
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a window
     * @return an Observable that emits connected, non-overlapping windows of items from the source Observable
     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity
     *         (whichever occurs first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final Observable&lt;Observable&lt;T&gt;&gt; window(long timespan, TimeUnit unit, int count, Scheduler scheduler) {
<span class="fc" id="L10163">        return window(timespan, timespan, unit, count, scheduler);</span>
    }

    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable emits connected, non-overlapping windows, each of a fixed duration as specified by the
     * {@code timespan} argument. When the source Observable completes or encounters an error, the resulting
     * Observable emits the current window and propagates the notification from the source Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;375&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window5.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a window
     * @return an Observable that emits connected, non-overlapping windows containing items emitted by the
     *         source Observable within a fixed duration
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final Observable&lt;Observable&lt;T&gt;&gt; window(long timespan, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L10192">        return window(timespan, unit, Integer.MAX_VALUE, scheduler);</span>
    }

    /**
     * Returns an Observable that emits windows of items it collects from the source Observable. The resulting
     * Observable emits windows that contain those items emitted by the source Observable between the time when
     * the {@code windowOpenings} Observable emits an item and when the Observable returned by
     * {@code closingSelector} emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;550&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window2.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses Observables to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param windowOpenings
     *            an Observable that, when it emits an item, causes another window to be created
     * @param closingSelector
     *            a {@link Func1} that produces an Observable for every window created. When this Observable
     *            emits an item, the associated window is closed and emitted
     * @return an Observable that emits windows of items emitted by the source Observable that are governed by
     *         the specified window-governing Observables
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final &lt;TOpening, TClosing&gt; Observable&lt;Observable&lt;T&gt;&gt; window(Observable&lt;? extends TOpening&gt; windowOpenings, Func1&lt;? super TOpening, ? extends Observable&lt;? extends TClosing&gt;&gt; closingSelector) {
<span class="fc" id="L10219">        return lift(new OperatorWindowWithStartEndObservable&lt;T, TOpening, TClosing&gt;(windowOpenings, closingSelector));</span>
    }

    /**
     * Returns an Observable that emits non-overlapping windows of items it collects from the source Observable
     * where the boundary of each window is determined by the items emitted from a specified boundary-governing
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;475&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window8.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure Support:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses a {@code boundary} Observable to control data
     *      flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;U&gt;
     *            the window element type (ignored)
     * @param boundary
     *            an Observable whose emitted items close and open windows
     * @return an Observable that emits non-overlapping windows of items it collects from the source Observable
     *         where the boundary of each window is determined by the items emitted from the {@code boundary}
     *         Observable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    public final &lt;U&gt; Observable&lt;Observable&lt;T&gt;&gt; window(Observable&lt;U&gt; boundary) {
<span class="fc" id="L10246">        return lift(new OperatorWindowWithObservable&lt;T, U&gt;(boundary));</span>
    }

    /**
     * Returns an Observable that emits items that are the result of applying a specified function to pairs of
     * values, one each from the source Observable and a specified Iterable sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.i.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that the {@code other} Iterable is evaluated as items are observed from the source Observable; it is
     * not pre-consumed. This allows you to zip infinite streams on either side.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zipWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;T2&gt;
     *            the type of items in the {@code other} Iterable
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param other
     *            the Iterable sequence
     * @param zipFunction
     *            a function that combines the pairs of items from the Observable and the Iterable to generate
     *            the items to be emitted by the resulting Observable
     * @return an Observable that pairs up values from the source Observable and the {@code other} Iterable
     *         sequence and emits the results of {@code zipFunction} applied to these pairs
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public final &lt;T2, R&gt; Observable&lt;R&gt; zipWith(Iterable&lt;? extends T2&gt; other, Func2&lt;? super T, ? super T2, ? extends R&gt; zipFunction) {
<span class="fc" id="L10276">        return lift(new OperatorZipIterable&lt;T, T2, R&gt;(other, zipFunction));</span>
    }

    /**
     * Returns an Observable that emits items that are the result of applying a specified function to pairs of
     * values, one each from the source Observable and another specified Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zipWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * 
     * @param &lt;T2&gt;
     *            the type of items emitted by the {@code other} Observable
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Observable
     * @param other
     *            the other Observable
     * @param zipFunction
     *            a function that combines the pairs of items from the two Observables to generate the items to
     *            be emitted by the resulting Observable
     * @return an Observable that pairs up values from the source Observable and the {@code other} Observable
     *         and emits the results of {@code zipFunction} applied to these pairs
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    public final &lt;T2, R&gt; Observable&lt;R&gt; zipWith(Observable&lt;? extends T2&gt; other, Func2&lt;? super T, ? super T2, ? extends R&gt; zipFunction) {
<span class="fc" id="L10303">        return zip(this, other, zipFunction);</span>
    }

    /**
     * An Observable that never sends any information to an {@link Observer}.
     * This Observable is useful primarily for testing purposes.
     * 
     * @param &lt;T&gt;
     *            the type of item (not) emitted by the Observable
     */
    private static class NeverObservable&lt;T&gt; extends Observable&lt;T&gt; {
        
<span class="nc" id="L10315">        private static class Holder {</span>
<span class="fc" id="L10316">            static final NeverObservable&lt;?&gt; INSTANCE = new NeverObservable&lt;Object&gt;();</span>
        }
        
        /**
         * Returns a singleton instance of NeverObservble (cast to the generic type).
         * 
         * @return
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        static &lt;T&gt; NeverObservable&lt;T&gt; instance() {
<span class="fc" id="L10326">            return (NeverObservable&lt;T&gt;) Holder.INSTANCE;</span>
        }
        
        NeverObservable() {
<span class="fc" id="L10330">            super(new OnSubscribe&lt;T&gt;() {</span>

                @Override
                public void call(Subscriber&lt;? super T&gt; observer) {
                    // do nothing
<span class="fc" id="L10335">                }</span>

            });
<span class="fc" id="L10338">        }</span>
    }

    /**
     * An Observable that invokes {@link Observer#onError onError} when the {@link Observer} subscribes to it.
     * 
     * @param &lt;T&gt;
     *            the type of item (ostensibly) emitted by the Observable
     */
    private static class ThrowObservable&lt;T&gt; extends Observable&lt;T&gt; {

        public ThrowObservable(final Throwable exception) {
<span class="fc" id="L10350">            super(new OnSubscribe&lt;T&gt;() {</span>

                /**
                 * Accepts an {@link Observer} and calls its {@link Observer#onError onError} method.
                 * 
                 * @param observer
                 *            an {@link Observer} of this Observable
                 */
                @Override
                public void call(Subscriber&lt;? super T&gt; observer) {
<span class="fc" id="L10360">                    observer.onError(exception);</span>
<span class="fc" id="L10361">                }</span>

            });
<span class="fc" id="L10364">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>